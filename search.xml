<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用bat批处理文件创建命令行运行快捷命令</title>
    <url>/blog/2023/10/11/data/normal%20notes/%E4%BD%BF%E7%94%A8bat%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>When you run a batch file, it executes in a Command Prompt window. If
you're launching a program from the batch file and you want the Command
Prompt window to close after launching that program, you can use the
<code>start</code> command along with the <code>exit</code> command.</p>
<p>Here's a simple example:</p>
<ol type="1">
<li><p>Create a batch file, say <code>launchProgram.bat</code>.</p></li>
<li><p>Edit the batch file to have the following content:</p></li>
</ol>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">start</span> &quot;&quot; &quot;C:\<span class="built_in">Path</span>\To\Your\Program.exe&quot;</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>
<p>The <code>start</code> command launches the program in a new
window/process, and the batch file continues to the next line. The
<code>exit</code> command then closes the Command Prompt window.</p>
<p>If the program you're launching is a console-based program and you
still see the Command Prompt window, that means the program itself runs
in the Command Prompt. In this case, you might not be able to close the
window until the program completes its execution.</p>
<p>Also, make sure you replace
<code>"C:\Path\To\Your\Program.exe"</code> with the actual path to your
program.</p>
<p>Another way to avoid the Command Prompt window altogether is by
creating a shortcut to the batch file and then setting the shortcut to
run minimized:</p>
<ol type="1">
<li>Right-click on your <code>.bat</code> file and select
<code>Send to</code> &gt; <code>Desktop (create shortcut)</code>.<br />
</li>
<li>Right-click on the shortcut you just created on the desktop and
select <code>Properties</code>.<br />
</li>
<li>In the <code>Shortcut</code> tab, find the <code>Run</code> dropdown
and set it to <code>Minimized</code>.<br />
</li>
<li>Click <code>OK</code>.<br />
</li>
<li>Run your program using the shortcut.</li>
</ol>
<p>This will run the batch file minimized, so the Command Prompt window
is less intrusive.</p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>codecomp</title>
    <url>/blog/2023/10/06/codecomp/</url>
    <content><![CDATA[<table>
<tr>
<th>
Original Code
</th>
<th>
Optimized Code
</th>
</tr>
<tr>
<td>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxProfit</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = maxProfit;</span><br><span class="line">            <span class="type">int</span> maxProfitWithStock = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                maxProfitWithStock = <span class="built_in">max</span>( maxProfitWithStock, tmp[i<span class="number">-1</span>]-prices[i]);</span><br><span class="line">                maxProfit[i] = <span class="built_in">max</span>(maxProfit[i - <span class="number">1</span>], maxProfitWithStock + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</td>
<td>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxProfit</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = maxProfit[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> maxProfitWithStock = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                maxProfitWithStock = <span class="built_in">max</span>( maxProfitWithStock, tmp-prices[i]);</span><br><span class="line">                tmp =maxProfit[i];</span><br><span class="line">                maxProfit[i] = <span class="built_in">max</span>(maxProfit[i - <span class="number">1</span>], maxProfitWithStock + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[n - <span class="number">1</span>];<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</td>
</tr>
</table>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>comptest</tag>
      </tags>
  </entry>
  <entry>
    <title>华为0913秋招笔试真题解析</title>
    <url>/blog/2023/10/11/codetest/</url>
    <content><![CDATA[<h2 id="快递中转站">快递中转站</h2>
<p>快递公司有一个业务要求，所有当天下发到快递中转站的快递，最迟在第二天送达用户手中。</p>
<p>假设已经知道接下来n天每天下发到快递中转站的快递重量。快递中转站负责人需要使用快递运输车运输给用户，每一辆运输车最大只能装k重量的快递。</p>
<p>每天可以出车多次，也可以不出车，也不要求运输车装满。当天下发到快递中转站的快递，最晚留到第二天就要运输走送给用户。</p>
<p>快递中转站负责人希望出车次数最少，完成接下来n天的快递运输。</p>
<p><strong>解答要求</strong></p>
<p>时间限制: C/C++ 1000ms,其他语言: 2000ms内存限制: C/C++256MB其他语言:
512MB</p>
<p><strong>输入</strong></p>
<p>输入第一行包含两个整数n(1&lt;=
n&lt;=200000)，k(1&lt;=k&lt;=100000000)</p>
<p>第二行包含n个整数ai，表示第i天下发到快递中转站的快递重量。</p>
<p><strong>输出</strong></p>
<p>输出最少需要的出车次数。</p>
<p><strong>样例1</strong></p>
<p><strong>输入</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>第一天的快递出车一次送走2个重量，留1个重量到第二天</p>
<p>第二天送走第一天留下的1个重量和当前的1个重量，留1个重量到第三天送走。</p>
<p><strong>思路与代码</strong></p>
<p>打卡题。</p>
<p>直接模拟即可，注意如果第二天凑不满一车也还是得发一车。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, k;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        cin &gt;&gt; a[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> re = a[i] + left;  </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t1 = re / k;  </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t2 = re % k;  </span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="number">0</span> &amp;&amp; left != <span class="number">0</span>) &#123;  </span><br><span class="line">            t1++;  </span><br><span class="line">            t2 = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ans += t1;  </span><br><span class="line">        left = t2;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">0</span>) &#123;  </span><br><span class="line">        ans++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="互通设备集">互通设备集</h2>
<p>局一局域网内的设备可以相互发现，具备直连路由的两个设备可以互通。假定设备A和B互通，B和C互通，那么可以将B作为中心设备，通过多跳路由策略使设备A和C互通。这样，A、B、C三个设备就组成了一个互通设备集。其中，互通设备集包括以下几种情况:</p>
<ol type="1">
<li><p>直接互通的多个设备</p></li>
<li><p>通过多跳路由第略间接互通的多个设备</p></li>
<li><p>没有任何互通关系的单个设备现给出某一局域网内的设备总数以及具备直接互通关系的设备，请计算该局域网内的互通设备集有多少个?</p></li>
</ol>
<p><strong>输入</strong></p>
<p>第一行: 某一局域网内的设备总数M，32位有符号整数表示。1&lt;=
M&lt;=200</p>
<p>第二行:具备直接互通关系的数量N，32位有符号整数表示。0&lt;=
N&lt;200</p>
<p>第三行到第N+2行:
每行两个有符号32位整数，分别表示具备直接互通关系的两个设备的编号，用空格隔开。每个设备具有唯一的编号，0&lt;设备编号&lt;
M</p>
<p><strong>输出</strong></p>
<p>互通设备集的数量，32位有符号整数表示。</p>
<p><strong>样例1</strong></p>
<p><strong>输入</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3  </span><br><span class="line">2  </span><br><span class="line">0 1  </span><br><span class="line">0 2  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">**输出**  </span><br><span class="line"></span><br><span class="line">``` txt  </span><br><span class="line">1  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">**解释:**  </span><br><span class="line"></span><br><span class="line">编号0和1以及编号0和2的设备直接互通，编号1和2的设备可通过编号0的设备建立互通关系，互通设备集可合并为1个。  </span><br><span class="line"></span><br><span class="line">**思路与代码**  </span><br><span class="line"></span><br><span class="line">并查集。  </span><br><span class="line"></span><br><span class="line">类似LC的岛屿问题，可以直接使用并查集模板即可。  </span><br><span class="line"></span><br><span class="line">``` cpp  </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line">#include &lt;cstdio&gt;  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">#include &lt;vector&gt;  </span><br><span class="line">  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">vector&lt;int&gt; fa;  </span><br><span class="line">  </span><br><span class="line">void init(int n) &#123;  </span><br><span class="line">    fa.assign(n, 0);  </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;  </span><br><span class="line">        fa[i] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int find(int x) &#123;  </span><br><span class="line">    return x == fa[x] ? x : (fa[x] = find(fa[x]));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void Union(int x, int y) &#123;  </span><br><span class="line">    fa[find(x)] = find(y);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    int m, n;  </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;  </span><br><span class="line">    init(m);  </span><br><span class="line">    int u, v;  </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;  </span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;  </span><br><span class="line">        Union(u, v);  </span><br><span class="line">    &#125;  </span><br><span class="line">    int ans = 0;  </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;  </span><br><span class="line">        if (fa[i] == i) &#123;  </span><br><span class="line">            ans++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 基站建设  </span><br><span class="line"></span><br><span class="line">运营商建设基站时需要关注很多因素，其中: 基站的信号覆盖范围、建设成本就是要考虑的部分因素。  </span><br><span class="line"></span><br><span class="line">以一个二维数组(10000* 10000) 表示需要服务的有效地域范围，假设个基站坐标为(2,2)，可覆盖的范围为基站为中心的3*3的矩阵(若不在有效地域范围则无效)。  </span><br><span class="line"></span><br><span class="line">现有多个基站候选点，我们需要决策在哪些地点建设基站，要求:在尽可能多地覆盖服务地域的前提下尽可能少地建设基站  </span><br><span class="line"></span><br><span class="line">**输入**  </span><br><span class="line"></span><br><span class="line">第一行为候选基站的坐标点个数n (0&lt;n&lt;10000)，后面的每一行都表示候选基站的行列位置，格式为: 行位置+空格+列位置  </span><br><span class="line"></span><br><span class="line">**输出**  </span><br><span class="line"></span><br><span class="line">格式为:建造的基站个数+空格+覆盖的地域面积  </span><br><span class="line"></span><br><span class="line">**样例1**  </span><br><span class="line"></span><br><span class="line">**输入**  </span><br><span class="line"></span><br><span class="line">``` txt  </span><br><span class="line">4  </span><br><span class="line">2 2  </span><br><span class="line">5 5  </span><br><span class="line">5 4  </span><br><span class="line">5 3  </span><br><span class="line">1  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">**输出**  </span><br><span class="line"></span><br><span class="line">`3 24`  </span><br><span class="line"></span><br><span class="line">**解释:**  </span><br><span class="line"></span><br><span class="line">最佳的策略为选择(2,2)、(5,5)、(5,3)这三个基站候选点，他们的覆盖面积为24  </span><br><span class="line"></span><br><span class="line">**思路与代码**  </span><br><span class="line"></span><br><span class="line">模拟。  </span><br><span class="line"></span><br><span class="line">这是300分的题。。。。据说直接输出一些特殊值也能拿不少分数，不过可能像去年那样会重新增强样例......  </span><br><span class="line"></span><br><span class="line">总体是使用标记法，标后周围全部都&gt;1的就是被其他点覆盖的。  </span><br><span class="line"></span><br><span class="line">``` cpp  </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line">#include &lt;cstdio&gt;  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;map&gt;  </span><br><span class="line">#include &lt;set&gt;  </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">#include &lt;vector&gt;  </span><br><span class="line">  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    int n;  </span><br><span class="line">    cin &gt;&gt; n;  </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pos(n, vector&lt;int&gt;(2, 0));  </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;  </span><br><span class="line">        cin &gt;&gt; pos[i][0] &gt;&gt; pos[i][1];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    map&lt;int, int&gt; vis;  </span><br><span class="line">    int cnt = n;  </span><br><span class="line">    int square = 0;  </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;  </span><br><span class="line">        int x = pos[i][0], y = pos[i][1];  </span><br><span class="line">        for (int j = -1; j &lt;= 1; j++) &#123;  </span><br><span class="line">            for (int k = -1; k &lt;= 1; k++) &#123;  </span><br><span class="line">                int nx = x + j, ny = y + k;  </span><br><span class="line">                if (x + j &lt; -1 || x + j &gt;= 10001 || y + k &lt; -1 || y + k &gt;= 10001) &#123;  </span><br><span class="line">                    continue;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (vis.count(nx * 10001 + ny) == 0) &#123;  </span><br><span class="line">                    if (x + j &lt; 0 || x + j &gt;= 10000 || y + k &lt; 0 || y + k &gt;= 10000) &#123;  </span><br><span class="line">                        ;  </span><br><span class="line">                    &#125; else &#123;  </span><br><span class="line">                        square++;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                vis[nx * 10001 + ny]++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;  </span><br><span class="line">        int x = pos[i][0], y = pos[i][1];  </span><br><span class="line">        int flag = 0;  </span><br><span class="line">        int total = 0;  </span><br><span class="line">        for (int j = -1; j &lt;= 1; j++) &#123;  </span><br><span class="line">            for (int k = -1; k &lt;= 1; k++) &#123;  </span><br><span class="line">                int nx = x + j, ny = y + k;  </span><br><span class="line">                if (x + j &lt; -1 || x + j &gt;= 10001 || y + k &lt; -1 || y + k &gt;= 10001) &#123;  </span><br><span class="line">                    continue;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (vis[nx * 10001 + ny] &gt; 1) &#123;  </span><br><span class="line">                    flag++;  </span><br><span class="line">                &#125;  </span><br><span class="line">                total++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (flag == total) &#123;  </span><br><span class="line">            cnt--;  </span><br><span class="line">            for (int j = -1; j &lt;= 1; j++) &#123;  </span><br><span class="line">                for (int k = -1; k &lt;= 1; k++) &#123;  </span><br><span class="line">                    int nx = x + j, ny = y + k;  </span><br><span class="line">                    if (x + j &lt; -1 || x + j &gt;= 10001 || y + k &lt; -1 || y + k &gt;= 10001) &#123;  </span><br><span class="line">                        continue;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (vis[nx * 10001 + ny] &gt; 1) &#123;  </span><br><span class="line">                        vis[nx * 10001 + ny]--;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; square &lt;&lt; endl;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>coursesheet</title>
    <url>/blog/2023/09/24/coursesheet/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>这里有 <code>n</code> 门不同的在线课程，按从 <code>1</code> 到 <code>n</code> 编号。给你一个数组 <code>courses</code> ，其中 <code>courses[i] = [durationi, lastDayi]</code> 表示第 <code>i</code> 门课将会 <strong>持续</strong> 上 <code>durationi</code> 天课，并且必须在不晚于 <code>lastDayi</code> 的时候完成。</p>
<p>你的学期从第 <code>1</code> 天开始。且不能同时修读两门及两门以上的课程。</p>
<p>返回你最多可以修读的课程数目。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> courses = [[100, 200], [200, 1300], [1000,
1250], [2000, 3200]] <strong>输出：</strong> 3 <strong>解释：</strong>
这里一共有 4 门课程，但是你最多可以修 3 门： 首先，修第 1 门课，耗费 100
天，在第 100 天完成，在第 101 天开始下门课。 第二，修第 3 门课，耗费
1000 天，在第 1100 天完成，在第 1101 天开始下门课程。 第三，修第 2
门课，耗时 200 天，在第 1300 天完成。 第 4 门课现在不能修，因为将会在第
3300 天完成它，这已经超出了关闭日期。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> courses = [[1,2]] <strong>输出：</strong>
1</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> courses = [[3,2],[4,3]]
<strong>输出：</strong> 0</p>
<p>本题读完题之后大致可以猜到，需要对原数组进行排序，以及需要优先队列来维护某个性质的变量。但问题是给定数组的元素包含两个数字，到底需要以哪一个为排序标准暂时不得而知。另外优先队列需要如何使用也暂时不得而知。我们可以先假设最晚结束时间越早的课程应该需要先学习，也可以假设课程所需时间越短的课程先上课。到这里暂时就没有什么思路了。</p>
<p>官方题解的优先队列+贪心也需要一定的时间来理解。官方题解如下：</p>
<h2 id="思路">思路</h2>
<p>对于两门课程 <span class="math inline">\((t_1,d_1)\)</span> 和 <span
class="math inline">\((t_2,d_2)\)</span> ，如果后者的关闭时间较晚，即
<span class="math inline">\(d1 &lt; d2\)</span>
，那么我们先学习前者，再学习后者，总是最优的。这是因为：
设开始学习的时间点为 <span class="math inline">\(x\)</span>。 *
如果先学习前者，再学习后者，那么需要满足： <span class="math display">\[
\left\{
\begin{aligned}
x + t_1 &amp;\leq d_1 \\
x + t_1 + t_2 &amp;\leq d_2 \\
\end{aligned}
\right.
\]</span> * 如果先学习后者，再学习前者，那么需要满足： <span
class="math display">\[
\left\{
\begin{aligned}
x + t_2 &amp;\leq d_2 \\
x + t_2 + t_1 &amp;\leq d_1 \\
\end{aligned}
\right.
\]</span></p>
<p>如果 <span class="math inline">\(x + t_2 + t_1 \leq d_1\)</span>
成立，那么由于 <span class="math inline">\(d_1 \leq d_2\)</span> 则有
<span class="math inline">\(x + t_2 + t_1 \leq d_1 \leq d_2\)</span>
并且有 <span class="math inline">\(x + t_1 \leq d_1\)</span>
，也就是说如果先学后面的课程也能完成，那么先学前面的课程是一定能完成的。但是由先学习前面的课程的约束条件不能得出后面的课程也能在
<span class="math inline">\(d_2\)</span> 之前完成例如当 <span
class="math inline">\(x = 0\)</span>, <span class="math inline">\((t_1,
d_1) = (2, 3)\)</span>，<span class="math inline">\((t_2, d_2) = (5,
100)\)</span>
时，虽然能「先学习前者，再学习后者」，但不能「先学习后者，再学习前者」。</p>
<p>因此，我们可以讲所有的课程按照关闭时间 <span
class="math inline">\(d\)</span> 进行升序排序，再依次挑选课程并按照顺序进行学习。</p>
<p>在遍历的过程中，假设我们当前遍历到了第 <span
class="math inline">\(i\)</span> 门课 <span class="math inline">\((t_i,
d_i)\)</span>，而在前 <span class="math inline">\(i-1\)</span>
门课程中我们选择了 <span class="math inline">\(k\)</span> 门课 <span
class="math inline">\((t_{x1},d_{x1}),(t_{x2},d_{x2}),\dots
,(t_{xk},d_{xk})\)</span> ，且满足 <span class="math inline">\(x_1 &lt;
x_2 &lt; \dots &lt; x_k\)</span> ，那么有： <span
class="math display">\[
\left\{
\begin{aligned}
t_{x1} &amp;\leq d_{x1} \\
t_{x1} + t_{x2} &amp;\leq d_{x2} \\
\cdots \\
t_{x1} + t_{x2} + \dots + t_{xk} &amp;\leq d_{xk}
\end{aligned}
\right.
\]</span> 假定上述选择方案是前 <span class="math inline">\(i-1\)</span>
门课程的最优选择方案，即不存在能选择 <span
class="math inline">\(k+1\)</span>
门课程的方案（课程数量更多所以更优），也不存在能在选择 <span
class="math inline">\(k\)</span>
门课程时总时长比当前方案更短的方案（时间更短所以更优），那么我们可以根据前
<span class="math inline">\(i-1\)</span> 门课程的这个最优方案来构造前
<span class="math inline">\(i\)</span> 门课程的最优方案： * 如果 <span
class="math inline">\(t_{x1} + t_{x2} + \dots + t_{xk} \leq
d_{xk}\)</span> ，那么我们可以直接将第 <span
class="math inline">\(i\)</span>
门课程加入到已选课程列表当中，此时的方案就是前 <span
class="math inline">\(i\)</span>
门课程的最优方案了，可以通过如下的反证法来证明： * 假设我们在遍历到第
<span class="math inline">\(i\)</span>
门课程的时候，把它加入到课程列表的方案并不能成为最优方案，那么一定还存在着一个更优的方案，那个方案不需要第
<span class="math inline">\(i\)</span>
门课程就能达到更多的课程数量，既然有无第 <span
class="math inline">\(i\)</span>
门课程都不影响这个最优方案的存在，那么其实这个方案也就是前 <span
class="math inline">\(i-1\)</span>
门课程的最优方案了，这与我们的假设已经矛盾了。 *
假设最优方案也是需要加入第 <span class="math inline">\(i\)</span>
门课程的，根据我们之前的推论：<strong>「先学习前者，再学习后者，总是最优的」</strong>，我们可以把前
<span class="math inline">\(i-1\)</span>
门课程看作是一门大课程，然后是第 <span class="math inline">\(i\)</span>
门课程，如果当前方案和那个假设的最优方案都暂时不学习第 <span
class="math inline">\(i\)</span>
门课程了，那么那个假设存在的最优方案不就是前 <span
class="math inline">\(i-1\)</span>
门课程的最优方案了吗？这同样也与我们的假设矛盾了。</p>
<ul>
<li>如果 <span class="math inline">\(t_{x1} + t_{x2} + \dots + t_{xk}
&gt; d_{xk}\)</span> ，那么现在第 <span class="math inline">\(i\)</span>
门课程的学习时间超过了最晚结课时间，我们无法将这门课程加入到已选课程列表中，因为题目没有限制每门课程的学习开始时间，因此我们可以考虑第
<span class="math inline">\(i\)</span>
门课程能不能用于替换掉前面的某个课程来使得当前的课程列表中所有课程的学习时间更短，为后续的课程腾出更多的时间来获得更多选择的可能性。如果
<span class="math inline">\(t_{x1}, t_{x2}, \dots, t_{xk}\)</span>
都小于等于 <span
class="math inline">\(t_i\)</span>，那么显然我们并不能通过替换课程来使得学习所有课程的时间减少。但如果其中学习时间最长的那门课程的学习时间
<span class="math inline">\(t_{xj}\)</span> 大于 <span
class="math inline">\(t_i\)</span>
的话，则我们可以替换掉这门课程来获得更短的总学习时间了，这样的替换会使得总学习时间减少
<span class="math inline">\(t_{xj} -
t_i\)</span>。替换课程之后学习时间是否还满足在结课时间之前的要求呢？
<ul>
<li>对于课程 <span class="math inline">\(x_1, x_2, \dots,
x_{j-1}\)</span>，这显然是满足的，因为替换的课程是 <span
class="math inline">\(x_j\)</span>，这并不会影响到前面课程</li>
<li>对于 <span class="math inline">\(x_{j+1}, \dots, x_{k}\)</span>
的课程，由于缺少了课程 <span
class="math inline">\(x_j\)</span>，由于原先本就是符合要求的，现在少上一门课，预留的可调整时间变多了，自然可以提前学习课程，那么也不会超过这些课程的原本的结课时间</li>
<li>总的来说，因为原不等式 <span class="math inline">\(t_1 + t_2 +
\cdots + t_{xk} &lt; d_{xk}\)</span> 且 <span
class="math inline">\(t_{xj} &lt; t_i\)</span>，则将 <span
class="math inline">\(t_{xj}\)</span> 替换为 <span
class="math inline">\(t_i\)</span> 时，原不等式也一定满足</li>
</ul></li>
</ul>
<p>有了上述的贪心方案之后，我们在遍历完所有课程时就可以确定我们的选课列表了。</p>
<h2 id="算法">算法</h2>
<p>我们需要一个数据结构能够支持直接取出当前课程列表中所需学习时间最长的那门课程的学习时间，因此可以使用大根堆来维护课程列表中课程的学习时间。我们一次遍历每一门课程，当遍历到<span
class="math inline">\((t_i, d_i)\)</span> 时： *
如果当前优先队列中的学习时间总时间 + <span
class="math inline">\(t_i\)</span> 小于等于 <span
class="math inline">\(d_i\)</span>，那么直接将第 <span
class="math inline">\(i\)</span> 门课程的学习时间 <span
class="math inline">\(ti\)</span>，加入到优先队列中进行维护 *
如果当前优先队列中的学习时间总时间 + <span
class="math inline">\(t_i\)</span> 大于 <span
class="math inline">\(d_i\)</span>，那么我们尝试进行课程替换，检测优先队列的堆顶（也就是最长的学习时间）<span
class="math inline">\(t_{xj}\)</span> 是否大于当前课程的学习时间 <span
class="math inline">\(t_i\)</span>，如果 <span
class="math inline">\(t_{xj} &gt; t_i\)</span>，那么将 <span
class="math inline">\(t_{xj}\)</span> 弹出堆顶，并将 <span
class="math inline">\(t_i\)</span> 加入到优先队列中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scheduleCourse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(</span><br><span class="line">            courses.<span class="built_in">begin</span>(),</span><br><span class="line">            courses.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; p0, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; p1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// return true if you want p0 ahead of p1</span></span><br><span class="line">                <span class="keyword">return</span> p0[<span class="number">1</span>] &lt; p1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;uint, vector&lt;uint&gt;, less&lt;uint&gt;&gt; pq;</span><br><span class="line">        uint time_cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; course : courses)</span><br><span class="line">        &#123;</span><br><span class="line">            uint ti = course[<span class="number">0</span>];</span><br><span class="line">            uint di = course[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (time_cost + ti &lt;= di)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// try to maximize course amount</span></span><br><span class="line">                time_cost += ti;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>() &gt; ti)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// try to minimize course time cost</span></span><br><span class="line">                time_cost -= (pq.<span class="built_in">top</span>() - ti);</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                pq.<span class="built_in">emplace</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkIfPrerequisite</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>, queries [][]<span class="type">int</span>)</span></span> []<span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// try Floyd-Warshall algorithm</span></span><br><span class="line">    adjcentMatrix := <span class="built_in">make</span>([][]<span class="type">bool</span>, numCourses);</span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> adjcentMatrix &#123;</span><br><span class="line">        adjcentMatrix[idx] = <span class="built_in">make</span>([]<span class="type">bool</span>, numCourses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, prep := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        adjcentMatrix[prep[<span class="number">0</span>]][prep[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; numCourses; k++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; numCourses; j++ &#123;</span><br><span class="line">                adjcentMatrix[i][j] = adjcentMatrix[i][j] || (adjcentMatrix[i][k] &amp;&amp; adjcentMatrix[k][j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(queries))</span><br><span class="line">    <span class="keyword">for</span> idx, query := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        <span class="keyword">if</span> adjcentMatrix[query[<span class="number">0</span>]][query[<span class="number">1</span>]] &#123;</span><br><span class="line">            ans[idx] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2023/10/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>买卖股票总结</title>
    <url>/blog/2020/10/06/stocking/</url>
    <content><![CDATA[<h1 id="stocking">Stocking</h1>
<h2 id="dp-for-stocking-i">dp for stocking I</h2>
<p>To solve this, calculate profit until we find a smaller stock.
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_price = prices[<span class="number">0</span>]</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; min_price:</span><br><span class="line">                min_price = prices[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_profit = <span class="built_in">max</span>(max_profit, prices[i] - min_price)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure></p>
<h2 id="dp-for-stocking-ii">dp for stocking II</h2>
<p>Use greedy approach. Initialize a profit to be 0. loop through the
prices array, if the current price is larger than the previous one, add
the difference to the profit.</p>
<p>This method works because for the case that <strong>stock continues
to climb up for several days</strong>, we add up the profit for each
day. And it sum up to the same as the difference between <strong>the
last day and the first day</strong>.</p>
<p>The total profit can be expressed as the sum of the differences of
prices on subsequent days:</p>
<p><span class="math display">\[
\text{profit} = \sum_{i=1}^{n} (p_i - p_{i-1})
\]</span></p>
<p>Expanding the summation gives:</p>
<p><span class="math display">\[
\text{profit} = p_n - p_{n-1} + p_{n-1} - p_{n-2} + ... + p_1 - p_0
\]</span></p>
<p>Now, notice that each price ( p_i ) for ( i ) from 1 to ( n-1 )
appears twice, once as a positive term and once as a negative term, and
they cancel each other out. Hence, we get:</p>
<p><span class="math display">\[
\text{profit} = p_n - p_0
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="dp-for-stocking-iii">dp for stocking III</h2>
<p>Subproblem for stocking IV with k = 2.</p>
<h2 id="dp-for-stocking-iv">dp for stocking IV</h2>
<p>Problem is to find the maximum profit with at most k
transactions.</p>
<p>we can keep track of two states for each day: the maximum profit with
stock in hand and the maximum profit without stock in hand.index i
represents the i-th day.</p>
<p><span class="math display">\[
\begin{aligned}
maxProfitWithStock[j][i] &amp;= \max(maxProfitWithStock[j][i-1],
maxProfit[j-1][i-1] - prices[i]) \\
maxProfit[j][i] &amp;= \max(maxProfit[j][i-1], maxProfitWithStock[j][i]
+ prices[i])
\end{aligned}
\]</span></p>
<p>We can view more in depth for each part of these equation.</p>
<p><span class="math display">\[
\begin{aligned}
maxProfitWithStock[j][i] &amp;= \max(maxProfitWithStock[j][i-1],
maxProfit[j-1][i-1] - prices[i]) \\
\end{aligned}
\]</span></p>
<ul>
<li>maxProfitWithStock[j][i-1] means we do not sell the stock at day
i.</li>
<li>maxProfitWithStock[j-1][i-1] - prices[i] means we buy the stock at
day i with the max profit of j-1 transactions at day
i-1(maxProfit[j-1][i-1]).</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
maxProfit[j][i] &amp;= \max(maxProfit[j][i-1], maxProfitWithStock[j][i]
+ prices[i])
\end{aligned}
\]</span></p>
<ul>
<li>maxProfit[j][i-1] means we can make more money if we don't sell the
stock on day i.</li>
<li>maxProfitWithStock[j][i] + prices[i] means we sell the stock on day
i. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">maxProfitWithStock</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">maxProfit</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            maxProfitWithStock[j][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                maxProfitWithStock[j][i] = <span class="built_in">max</span>(maxProfitWithStock[j][i - <span class="number">1</span>], maxProfit[j - <span class="number">1</span>][i - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                maxProfit[j][i] = <span class="built_in">max</span>(maxProfit[j][i - <span class="number">1</span>], maxProfitWithStock[j][i] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[k][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="optimization">Optimization</h3>
<p>We can see that the maxProfitWithStock[j][i] only depends on the
previous day. So we can use a integer to store it.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">maxProfit</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="type">int</span> maxProfitWithStock = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                maxProfitWithStock = <span class="built_in">max</span>( maxProfitWithStock, maxProfit[j<span class="number">-1</span>][i<span class="number">-1</span>]-prices[i]);</span><br><span class="line">                maxProfit[j][i] = <span class="built_in">max</span>(maxProfit[j][i - <span class="number">1</span>], maxProfitWithStock + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[k][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>then We can see that the maxProfit[j][i] only depends on the previous
row. So we can use a vector to store it.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxProfit</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = maxProfit;</span><br><span class="line">            <span class="type">int</span> maxProfitWithStock = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                maxProfitWithStock = <span class="built_in">max</span>( maxProfitWithStock, tmp[i<span class="number">-1</span>]-prices[i]);</span><br><span class="line">                maxProfit[i] = <span class="built_in">max</span>(maxProfit[i - <span class="number">1</span>], maxProfitWithStock + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Now we can see that the tmp Only depends on the previous element. So
we can use a integer to store it.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxProfit</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = maxProfit[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> maxProfitWithStock = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                maxProfitWithStock = <span class="built_in">max</span>( maxProfitWithStock, tmp-prices[i]);</span><br><span class="line">                tmp =maxProfit[i];</span><br><span class="line">                maxProfit[i] = <span class="built_in">max</span>(maxProfit[i - <span class="number">1</span>], maxProfitWithStock + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<table>
<tr>
<th>
Original Code
</th>
<th>
Optimized Code
</th>
</tr>
<tr>
<td>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxProfit</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = maxProfit;</span><br><span class="line">            <span class="type">int</span> maxProfitWithStock = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                maxProfitWithStock = <span class="built_in">max</span>( maxProfitWithStock, tmp[i<span class="number">-1</span>]-prices[i]);</span><br><span class="line">                maxProfit[i] = <span class="built_in">max</span>(maxProfit[i - <span class="number">1</span>], maxProfitWithStock + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</td>
<td>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxProfit</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = maxProfit[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> maxProfitWithStock = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                maxProfitWithStock = <span class="built_in">max</span>( maxProfitWithStock, tmp-prices[i]);</span><br><span class="line">                tmp =maxProfit[i];</span><br><span class="line">                maxProfit[i] = <span class="built_in">max</span>(maxProfit[i - <span class="number">1</span>], maxProfitWithStock + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[n - <span class="number">1</span>];<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</td>
</tr>
</table>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>研一上 代办项目清单</title>
    <url>/blog/2023/10/11/data/%E7%A0%94%E4%B8%80%E4%B8%8A%20%E4%BB%A3%E5%8A%9E%E9%A1%B9%E7%9B%AE%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<h2 id="课程">课程</h2>
<ol type="1">
<li>InfluxDB + Grafana + docker，系统资源监控看板服务<br />
</li>
<li>ElasticSearch + LogStach + Kibana + docker，日志系统<br />
</li>
<li>CMU15445 关系型数据库实现Lab<br />
</li>
<li>TCP/IP socket 编程</li>
</ol>
<h2 id="项目学习">项目学习</h2>
<ol type="1">
<li>acwj - C语言编译器简单教程<br />
</li>
<li>TinyHttpd - C http服务后端<br />
</li>
<li>TinyWebServer - C++ Web服务后端<br />
</li>
<li>这是一条测试语句</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>常见算法总览</title>
    <url>/blog/2023/10/11/data/algorithmn/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<p>顺序表：<br />
&gt; * 线性枚举<br />
&gt; * 前缀和<br />
&gt; * 双指针<br />
&gt; * 二分枚举<br />
&gt; * 三分枚举<br />
&gt; * 离散化<br />
&gt; * 冒泡排序<br />
&gt; * 选择排序<br />
&gt; * 插入排序<br />
&gt; * 快速排序<br />
&gt; * 希尔排序<br />
&gt; * 归并排序<br />
&gt; * 堆排序<br />
&gt; * 基数排序<br />
&gt; * 计数排序<br />
&gt; * 模拟<br />
&gt; * 贪心</p>
<p>链表：<br />
&gt; * 单向链表<br />
&gt; * 双向链表<br />
&gt; * 循环链表<br />
&gt; * 链表反转<br />
&gt; * 链表合并</p>
<p>栈：<br />
&gt; * LIFO（后进先出）<br />
&gt; * 单调队列<br />
&gt; * FIFO（先进先出）<br />
&gt; * 双端队列</p>
<p>字符串：<br />
&gt; * KMP子串查找<br />
&gt; * 字典树Trie<br />
&gt; * 马拉车子串查找<br />
&gt; * AC自动机<br />
&gt; * 后缀数组<br />
&gt; * BM</p>
<p>树：<br />
&gt; * 二叉树<br />
&gt; * 二叉搜索树<br />
&gt; * AVL树<br />
&gt; * 线段树<br />
&gt; * 霍夫曼压缩<br />
&gt; * 堆<br />
&gt; * 红黑树<br />
&gt; * 伸展树<br />
&gt; * 左偏树<br />
&gt; * Treap<br />
&gt; * B+树<br />
&gt; * 树链剖分</p>
<p>图：<br />
&gt; * 二分图<br />
&gt; * 单源最短路径<br />
&gt; * 多源最短路径<br />
&gt; * 最小生成树<br />
&gt; * 最近公共祖先<br />
&gt; * 深度优先搜索<br />
&gt; * 广度优先搜索<br />
&gt; * 强连通分量<br />
&gt; * 双连通分量<br />
&gt; * 2-set<br />
&gt; * 欧拉回路<br />
&gt; * 哈密尔顿回路<br />
&gt; * 迭代加深<br />
&gt; * 拓扑排序<br />
&gt; * A-star自动寻路<br />
&gt; * 稳定婚姻<br />
&gt; * 双向广搜<br />
&gt; * 差分约束<br />
&gt; * 并查集<br />
&gt; * 哈希表<br />
&gt; * 跳跃表<br />
&gt; * 树状数组<br />
&gt; * 最大网络流</p>
<p>动态规划：<br />
&gt; * 递推<br />
&gt; * 线性规划<br />
&gt; * 记忆化搜索<br />
&gt; * 背包问题<br />
&gt; * 树形规划<br />
&gt; * 区间规划<br />
&gt; * 数位规划<br />
&gt; * 状态压缩</p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法的稳定性</title>
    <url>/blog/2023/10/11/data/algorithmn/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
    <content><![CDATA[<h2 id="一排序算法的稳定性">一、排序算法的稳定性</h2>
<p>稳定性定义：稳定性是指样本在排序之后不会改变相对顺序。</p>
<p>对于基础类型来说，稳定性毫无意义</p>
<p>对非基础类型来说，稳定性有重要意义</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<tbody>
<tr class="odd">
<td>排序算法</td>
<td>时间复杂度</td>
<td>额外空间复杂度</td>
<td>稳定性</td>
</tr>
<tr class="even">
<td>选择排序</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>无（选择最小的数和第一个位置的数交换时改变了相对顺序）</td>
</tr>
<tr class="odd">
<td>冒泡排序</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>有（相等时不往后交换即可）</td>
</tr>
<tr class="even">
<td>插入排序</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>有（相等时不前移即可）</td>
</tr>
<tr class="odd">
<td>归并排序</td>
<td>O(N*logN)</td>
<td>O(N)</td>
<td>有（相等时拷贝左组的即可）</td>
</tr>
<tr class="even">
<td>快速排序</td>
<td>O(N*logN)</td>
<td>O(logN)</td>
<td>无（小于区右扩，交换当前数和小于区最右侧的数时改变了相对顺序）</td>
</tr>
<tr class="odd">
<td>堆排序</td>
<td>O(N*logN)</td>
<td>O(1)</td>
<td>无（调整为大根堆或小根堆时就改变了相对顺序）</td>
</tr>
</tbody>
</table>
<h2 id="二排序算法总结">二、排序算法总结</h2>
<p>1、不基于比较的排序，对样本数据有严格要求，不易改写</p>
<p>2、基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用</p>
<p>3、基于比较的排序，时间复杂度的极限是O(N*logN)</p>
<p>4、时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。</p>
<p>5、为了绝对的速度选快排（时间复杂度的常数时间小）、为了省空间选堆排、为了稳定性选归并</p>
<h2 id="三排序算法常见的坑">三、排序算法常见的坑</h2>
<p>在网上见到以下相关的文章，如果不是做学术研究的，可以直接忽略，不然对于你而言只是浪费时间，最后发现毫无用处。</p>
<p>1、归并排序的额外空间复杂度可以变成O(1)，采用“归并排序
内部缓存法”，但是将变得不再稳定。</p>
<p>2、”原地归并排序”是垃圾贴，会让时间复杂度变成O(N^2)</p>
<p>3、快速排序稳定性改进， “01 stable sort"
，但是会对样本数据要求更多。</p>
<p>4、在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。时间复杂度做到O(N)，额外空间复杂度做到O(1)。</p>
<p>这是不可能的。</p>
<p>这就是快排的partition分成小于、等于、大于区的过程，在此过程的标准和分奇偶一样是01标准，而快排的时间复杂度是O(N*logN)，额外空间复杂是O(logN)，所以是不可能的，不然快排早就改进了。</p>
<h2 id="四工程上对排序的改进">四、工程上对排序的改进</h2>
<p>1、稳定性的考虑</p>
<p>例如：Java中Arrays.sort()方法，如果传入的是基础类型，系统是采用快排进行排序的（因为此时的稳定性是无意义的，而快排比堆排更快）；如果传入的是非基础类型，系统是采用归并排序进行排序的（因为此时可能是需要稳定性的）。</p>
<p>2、充分利用O(N*logN)和O(N^2)排序算法各自的优势</p>
<p>插入排序O(N^2)，但是常数项小</p>
<p>快速排序O(N * logN)，但是常数项高</p>
<p>也就是N很大的时候，采用快排；当N比较小（小于60，实验得出）的时候，采用插排。</p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
      </tags>
  </entry>
  <entry>
    <title>commonly used key short cut</title>
    <url>/blog/2023/10/11/data/blender/commonly%20used%20key%20short%20cut/</url>
    <content><![CDATA[<p><img
src="https://pic3.zhimg.com/80/v2-ab63fe22a0dbb8be20ef686565d86912_720w.webp" /></p>
<h2 id="一对象操作">一、对象操作</h2>
<h3 id="物体相关操作">【1.1】物体相关操作</h3>
<ol type="1">
<li>全选物体——A<br />
</li>
<li>框选物体——B<br />
</li>
<li>反选物体——Ctrl+I<br />
</li>
<li>删除物体——X（可以直接单手操作好嘛，左手键盘，右手鼠标，不至于一直放开右手去按Delete）<br />
</li>
<li>相机范围——N-&gt;View-&gt;Clip
Start（如果旋转视角的时候，模型乱乱的，就设置这个参数，一般为最小，0.001)<br />
</li>
<li>选择物体——鼠标左键/W(切换W有不同的选择模式)</li>
</ol>
<ul>
<li>对象选择<br />
</li>
<li>框选<br />
</li>
<li>点选<br />
</li>
<li>套索选</li>
</ul>
<h3 id="控制物体坐标z轴向上">【1.2】控制物体坐标（Z轴向上)</h3>
<p>相对于Transform（Translate、Rotate、Scale来说)，RGB三种颜色分别对应XYZ轴。</p>
<p><img
src="https://pic4.zhimg.com/80/v2-054c63c485855480bc547ed48745b1cf_720w.webp" /></p>
<ol type="1">
<li>调出ToolBar——T（另：下方画笔和测量为辅助工具，都是长按调用不同的模式)<br />
</li>
<li>调出属性栏Properties——N<br />
</li>
<li>使用快捷键G、R、S分别来控制模型的Translate、Rotate、Scale</li>
</ol>
<p><strong>【1.2.1】移动物体：</strong></p>
<ol type="1">
<li><p>快捷键——G，然后跟着鼠标移动</p></li>
<li><p>顺着X轴移动——X<br />
</p></li>
<li><p>顺着Y轴移动——Y<br />
</p></li>
<li><p>顺着Z轴移动——Z</p></li>
<li><p>使用当前位置——鼠标左键<br />
</p></li>
<li><p>取消编辑——鼠标右键</p></li>
</ol>
<p><strong>【1.2.2】旋转物体：</strong></p>
<ol type="1">
<li><p>快捷键——R，然后跟着鼠标旋转</p></li>
<li><p>顺着X轴旋转——X<br />
</p></li>
<li><p>顺着Y轴旋转——Y<br />
</p></li>
<li><p>顺着Z轴旋转——Z</p></li>
<li><p>使用当前位置——鼠标左键<br />
</p></li>
<li><p>取消编辑——鼠标右键</p></li>
</ol>
<p><strong>【1.2.3】缩放物体：</strong></p>
<ol type="1">
<li>快捷键——S，然后跟着鼠标缩放<br />
</li>
<li>顺着X轴缩放——X<br />
</li>
<li>顺着Y轴缩放——Y<br />
</li>
<li>顺着Z轴缩放——Z<br />
</li>
<li>使用当前位置——鼠标左键<br />
</li>
<li>取消编辑——鼠标右键</li>
</ol>
<p>在进行坐标相关操作的时候，可以按Numberpad上面的数字——指定变化多少。Enter确定。</p>
<h3 id="坐标轴小技巧">【1.2.4】坐标轴小技巧：</h3>
<ol type="1">
<li>移动/旋转/缩放的时候 ，按住鼠标中键可以随时切换轴进行操作。<br />
</li>
<li>Shift+X/Y/Z（可以去掉这个轴，只在另外两个轴构成的平面上移动）</li>
</ol>
<h3 id="切换坐标中心">【1.2.5】切换坐标中心</h3>
<ol type="1">
<li>设置方向（坐标空间)—— &lt;</li>
</ol>
<p><img
src="https://pic2.zhimg.com/80/v2-b5eb67daaee3ac007913f727111577dd_720w.webp" /></p>
<p>2.设置枢轴点位置—— &gt;</p>
<p><img
src="https://pic1.zhimg.com/80/v2-5686bfbc79420ae7c8b93183003a68a0_720w.webp" /></p>
<h3 id="视角转换"><strong>【1.3】视角转换</strong></h3>
<p><strong>【1.3.1】常规操作：</strong></p>
<ol type="1">
<li>如果有摄像机（没有可以Ctrl+N
General新建一个场景），<strong>切换摄像机视角</strong>——0（注意是Numberpad的“0”，键盘最右边的），<strong>Shift+~（自由控制相机），像玩游戏一样</strong><br />
</li>
<li><strong>居中物体</strong>——“."(0 右边的)<br />
</li>
<li><strong>旋转视角</strong>——鼠标中键（不太习惯，我定义为了Maya
的快捷键，Alt+左键）<br />
</li>
<li><strong>移动视</strong>角——（Alt+中键）<br />
</li>
<li><strong>缩放视角</strong>——（Alt+右键/Ctrl+ +/- ）<br />
</li>
<li><strong>分屏操作</strong>——鼠标放在下图红色处，会出现一个十字加号，往左移动就好了（取消分屏同样移动按照箭头的方向进行取消）<br />
</li>
<li><strong>窗口最大化</strong>——Ctrl+空格<br />
</li>
<li><strong>切换不同的Panel</strong>（Shift+F5/F6）那些（当窗口过小时，可用<strong>鼠标滚轮</strong>在Panel栏滑动来切换不同的模式（如雕刻，材质，视频，3D等等）</li>
</ol>
<p><img
src="https://pic3.zhimg.com/80/v2-562c15d48e5037f6b4f655cdc1ed6bf2_720w.webp" /></p>
<p><img
src="https://pic1.zhimg.com/80/v2-986461a44a14143d50ca58c667b6ca48_720w.webp" /></p>
<p><strong>【1.3.2】三视图切换：</strong></p>
<p><img
src="https://pic3.zhimg.com/80/v2-16d0dd51748b6c07da9ac195c04f8fa2_720w.webp" /></p>
<ol type="1">
<li><p><strong>雷达圆盘</strong>——Semicolon（ESC下面的那个波浪线，我更喜欢这种切换模式，因为比较集中，另外就是还是可以单手操作的原因；选取好后松开鼠标就好了）<br />
</p></li>
<li><p><strong>快捷键</strong>——Numberpad</p></li>
<li><p>三视图（奇数）</p></li>
<li><p>前视图——1<br />
</p></li>
<li><p>右视图——3<br />
</p></li>
<li><p>顶视图——7<br />
</p></li>
<li><p>后视图——Ctrl+1<br />
</p></li>
<li><p>左视图——Ctrl+3<br />
</p></li>
<li><p>顶视图——Ctrl+7<br />
</p></li>
<li><p>切换正交/透视图——5</p></li>
<li><p>其他轴旋转（偶数）</p></li>
<li><p>顺着X轴顺时针旋转——2<br />
</p></li>
<li><p>顺着X轴逆时针旋转——8<br />
</p></li>
<li><p>顺着Z轴顺时针旋转——4<br />
</p></li>
<li><p>顺着Z轴逆时针旋转——6<br />
</p></li>
<li><p>Z轴旋转180度——9<br />
</p></li>
<li><p>视图向上下左右方移动——Ctrl+2/4/6/8</p></li>
<li><p>相机运动</p></li>
<li><p>【Shift+`】 FPS游戏自由控制视角<br />
</p></li>
<li><p>【Q】相机上升<br />
</p></li>
<li><p>【E】相机下降<br />
</p></li>
<li><p>【WASD】前后左右<br />
</p></li>
<li><p>【鼠标滑轮滚动】相机运动速度<br />
</p></li>
<li><p>【鼠标右键】取消选定当前位置<br />
</p></li>
<li><p>【鼠标左键/Enter】选定当前相机位置<br />
</p></li>
<li><p>【鼠标中键】旋转相机视角<br />
</p></li>
<li><p>【Shift+鼠标中键】平移相机视角</p></li>
</ol>
<p><img
src="https://pic3.zhimg.com/80/v2-0f833d294f203eec4d771668a6e5e4ce_720w.webp" /></p>
<h2 id="二模型操作"><strong>二、模型操作：</strong></h2>
<h3 id="普通操作"><strong>【2.1】普通操作：</strong></h3>
<ol type="1">
<li><p><strong>创建物体——Shift+A</strong><br />
</p></li>
<li><p><strong>复制物体——Shift+D（XYZ同理）</strong><br />
</p></li>
<li><p><strong>切换模式——Tab 切换Object/Edit
Mode【Object是物体模型，Edit编辑点线面（可在Edit
Mode中再创建模型，即使它们没有衔接在一块，但它们还是作为一个Object是一个整体）】（另外注意Edit
Mode不可以框选另外的模型哦)</strong><br />
</p></li>
<li><p><strong>重命名模型——右边Scene Collection
选中模型的名字双击或者F2</strong><br />
</p></li>
<li><p><strong>隐藏模型</strong></p></li>
<li><p>X-Ray模型，可以选中模型后面的点。(可以自己测试一下，1切换到前视图，然后选取前面的点)——Alt+Z<br />
</p></li>
<li><p>隐藏模型——H<br />
</p></li>
<li><p>恢复隐藏——Alt+H</p></li>
<li><p><strong>切换渲染模式——快捷键Z调取</strong></p></li>
<li><p>固态<br />
</p></li>
<li><p>网格<br />
</p></li>
<li><p>调试<br />
</p></li>
<li><p>渲染</p></li>
</ol>
<p><img
src="https://pic1.zhimg.com/80/v2-4cacdd8a7c833e7ffdbfd9bb722da31c_720w.webp" /></p>
<p>7.<strong>切换3D坐标显示——Ctrl+Semicolon（~)</strong></p>
<p><img
src="https://pic1.zhimg.com/80/v2-ed2ac81903fdf21853b7dc539695b680_720w.webp" /></p>
<p>8.切换不同的Mode（如Edit Mode,Object Mode等等）——Ctrl+Tab</p>
<p>9.切换Snapping功能（移动每格一米/自由移动这样子的）——Shift+Tab</p>
<h3 id="设置3d指针"><strong>【2.2】设置3D指针：</strong></h3>
<p><strong>切换3D指针（世界原点，用于在此产生物体）</strong></p>
<p><img
src="https://pic2.zhimg.com/80/v2-fd7009ff9be86ff32764f9d369c4bd1d_720w.webp" /></p>
<p>调取3D指针切换方法——Shift+S</p>
<p><img
src="https://pic1.zhimg.com/80/v2-fbf0c2461e93c92ce31879eb1708db64_720w.webp" /></p>
<ol type="1">
<li>自由设置——Shift+右键<br />
</li>
<li>归零（又回到最初的起点，记忆中你3D的脸，哈哈）——Cursor to World
Origin/Shift+C<br />
</li>
<li>将在外游玩的模型回家（归零）——先选中模型，然后Selection to
Cursor<br />
</li>
<li>将3DCursor设为模型的中心点——先选中模型，然后Cursor to
Selection<br />
</li>
<li>其他不常用。</li>
</ol>
<h3 id="父子关系">【2.3】父子关系</h3>
<ol type="1">
<li>Edit
Mode下分离模型（就好比母亲怀孕，孩子跟妈妈原先是一个整体，现在孩子出生了，自己也是一个角色了)——P</li>
</ol>
<p><img
src="https://pic2.zhimg.com/80/v2-6b374acdd3f2f24c3f05db2649f383ad_720w.webp" /></p>
<p>2.Object Mode下父子关系——Ctrl+P(先选中儿子，再Shift加选爹)</p>
<p><img
src="https://pic4.zhimg.com/80/v2-37e6293a907850f82779d01ce292f3b7_720w.webp" /></p>
<p>3.新建一个文件夹——M(Collection)</p>
<h3 id="设置枢轴坐标中心点">【2.4】设置枢轴坐标中心点</h3>
<ul>
<li>3D Cursor为世界坐标中心原点<br />
</li>
<li>Individual Origins为单个面的中心枢轴<br />
</li>
<li>Median Point为模型中心</li>
</ul>
<p><img
src="https://pic4.zhimg.com/80/v2-4a340ab3ec2f9b4437cf52d484f3bccb_720w.webp" /></p>
<h2 id="三建模操作">三、建模操作：</h2>
<h3 id="loop-cut-循环切线">【3.1】Loop Cut 循环切线</h3>
<p>Emulate(键盘左边的)1、2、3切换不同的点、线、面模式</p>
<p><img
src="https://pic2.zhimg.com/80/v2-33e1d9cacb0577bf5ccf52b66506225d_720w.webp" /></p>
<ol type="1">
<li>添加Loop Cut，循环切线——Ctrl+R(滚轮上下滑控制切线个数)</li>
</ol>
<p><img
src="https://pic3.zhimg.com/80/v2-1e492073941043f295909c7e2ac1b322_720w.webp" /></p>
<p>在切割的过程中，(注意小红点的移动)</p>
<ul>
<li>正常中轴线切割/按照左边的线切割——E<br />
</li>
<li>按照右边的线来切割——F</li>
</ul>
<p><img
src="https://pic4.zhimg.com/80/v2-2baffb47f94881051965826f4c5799b7_720w.webp" /></p>
<h3 id="propotional成比例缩放">【3.2】Propotional成比例缩放</h3>
<p>之后对点进行成比例缩放的时候，可以用O打开Propotional，定义一个编辑点的范围（我们给人物骨骼刷蒙皮或者是制作人物的表情动画Blendshape/Morph
target当中非常常用）。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-62ed4b3cbf4ef959de6d422601545662_720w.webp" /></p>
<p><strong>以下为不同的成比例结果，合计8种：</strong></p>
<p><img
src="https://pic4.zhimg.com/80/v2-e96de10847275ccca72e3b53dbb3b0c7_720w.webp" /></p>
<p>Smooth</p>
<p><img
src="https://pic1.zhimg.com/80/v2-0f96b25e081bcb557cf1507c6f743870_720w.webp" /></p>
<p>Sphere</p>
<p><img
src="https://pic4.zhimg.com/80/v2-2d2d1c65f1f7634129967c30ef8e087f_720w.webp" /></p>
<p>Root</p>
<p><img
src="https://pic3.zhimg.com/80/v2-c602263b5c07b8066be767aa10edfd06_720w.webp" /></p>
<p>Inverse Square</p>
<p><img
src="https://pic4.zhimg.com/80/v2-68b7c97b63d7501be697c6d249844c2b_720w.webp" /></p>
<p>Sharp</p>
<p><img
src="https://pic4.zhimg.com/80/v2-f6dbe6a28a71cc62bc82cd0b3f05ba83_720w.webp" /></p>
<p>Linear</p>
<p><img
src="https://pic2.zhimg.com/80/v2-e78e61329d8ab87d308d718d9ee08c95_720w.webp" /></p>
<p>Constant</p>
<p><img
src="https://pic2.zhimg.com/80/v2-5235705c17a527c7cc1196787513558d_720w.webp" /></p>
<p>Random</p>
<h3 id="选取循环边">【3.3】选取循环边</h3>
<ol type="1">
<li>选中所有连接起来的顶点——L<br />
</li>
<li>选中一部分连接起来的顶点——Shift+Alt+LeftClick<br />
</li>
<li>选中一部分连续便后，可以Ctrl+E-&gt;Mark Seam
即可高亮所选的连续边（橙色线）</li>
</ol>
<h3 id="挤出extrude">【3.4】挤出Extrude</h3>
<p>E 一般对于面操作</p>
<p><img
src="https://pic2.zhimg.com/80/v2-1141714a2ec3e020f040358a8c83539d_720w.webp" /></p>
<p>单个挤出面，右键Extrude Individual Faces</p>
<p><img
src="https://pic1.zhimg.com/80/v2-684b1b2aa2d2bb0339af8594cbad8560_720w.webp" /></p>
<h3
id="连接两个顶点成线四点成面f鼠标右键bridge-edge-loops">【3.5】连接两个顶点成线，四点成面——F/鼠标右键Bridge
Edge Loops</h3>
<p><img
src="https://pic2.zhimg.com/80/v2-0559aede7e631435e8f70135a09d5edd_720w.webp" /></p>
<h3 id="将点聚拢">【3.6】将点聚拢</h3>
<p>如上图，选中顶面的点，然后——S(Scale)
(Shift+X/Y/Z除了这个轴进行操作)</p>
<h3 id="创建斜面">【3.7】创建斜面</h3>
<p>Ctrl+B(Bevel) (滑到最大侧面变成三角形)</p>
<p><img
src="https://pic1.zhimg.com/80/v2-0e17af47dd650dc7f002f8de5cf7694c_720w.webp" /></p>
<h3 id="顶点混合">【3.8】顶点混合</h3>
<p>Double G(G按两次，这是沿着边在移动),之后在X-Ray模式下Alt+M(Merge At
Center将重叠的两个点删除掉)</p>
<p><img
src="https://pic4.zhimg.com/80/v2-150311f469be219702a9d18cb147798b_720w.webp" /></p>
<h3 id="小刀切割">【3.9】小刀切割</h3>
<p>K（切割完Enter；相当于在一个四边面上添加一些线而已)</p>
<p>删除这个切割线，可以切换到边的编辑模式，然后选中这个刚切割出来的边——2</p>
<p>然后——X，删除，Dissolve only edges</p>
<h3 id="关于点的两个小技巧">【3.10】关于点的两个小技巧</h3>
<p>如果想让两个点合并：</p>
<ul>
<li>选中两个点，将Scale的值改为0<br />
</li>
<li>Alt+M-&gt;Merge At Center</li>
</ul>
<p>如果想让两个线平行</p>
<ul>
<li>选中要平行的两个点按一次G进行移动（Z只在Z轴移动)<br />
</li>
<li>选中要平行的两条线(四个点)，S，Z(只在Z轴缩放)，0——这样就会将两个点平行到中间部分了。</li>
</ul>
<h3
id="提高模型分辨率的基础上让模型变得更加得圆润">【3.11】提高模型分辨率的基础上让模型变得更加得圆润</h3>
<p>——Shift+E(Create Crease)</p>
<h3 id="分离面">【3.12】分离面</h3>
<p>‘Y'/Ctrl+E-&gt;Edge Split（在环切面的时候非常常用）</p>
<h3 id="空格spacebar调用脚本">【3.13】空格Spacebar调用脚本</h3>
<p><code>Select Random</code>随机选择面</p>
<h3 id="模型归一化">【3.14】模型归一化</h3>
<p>Ctrl+A-&gt; Apply
Scale(**模型宽度尺寸Dimensions=Scale*Size**），归一化就是将Scale设为1.</p>
<p><img
src="https://pic4.zhimg.com/80/v2-4ca6f1627dcb4c56df8a21a182d56f1b_720w.webp" /></p>
<h2 id="四雕刻模式">四、雕刻模式</h2>
<ul>
<li>F来切换笔刷大小<br />
</li>
<li>Shift+F:来调节笔刷的力度<br />
</li>
<li>鼠标左键：刷上来<br />
</li>
<li>Ctrl+鼠标左键：刷下去</li>
</ul>
]]></content>
      <categories>
        <category>blender</category>
      </categories>
      <tags>
        <tag>blender</tag>
      </tags>
  </entry>
  <entry>
    <title>部署InfluxDB，docker容器运行</title>
    <url>/blog/2023/10/11/data/deployment/%E9%83%A8%E7%BD%B2InfluxDB%EF%BC%8Cdocker%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p><img
src="https://miro.medium.com/v2/resize:fit:875/0*L4rlJyor6EKcqgcX.png" /></p>
<p>InfluxDB 2.0, the image belongs to InfluxData.</p>
<p>InfluxDB 2.0 is generally available. This version of InfluxDB
provides the time-series database and a set of tools to create beautiful
dashboards using either the query builder or writing the Flux query
manually. You can also schedule tasks and configure alerts when a
measurement exceeds a certain threshold.</p>
<p>Months ago, I always deploy InfluxDB along with Grafana or Chronograf
for visualization. Now I only need to deploy InfluxDB 2.0 image
alongside the applications that I developed.</p>
<p>Let’s get started!</p>
<p>First of all, InfluxData provides a comprehensive guide for deploying
InfluxDB 2.0 using docker. So, I’m not going to describe everything in
detail. Instead, I’m going to describe how the configuration or setup
process can be automated using a bash script.</p>
<p>You will need to pull the image from the docker hub using the
following command:</p>
<p>docker pull influxdb:2.0.7</p>
<p>If you want to customize the configuration, you will need to create
the config.yml file and mount it as a volume to the docker container</p>
<p>docker run --rm influxdb:2.0.7 influxd print-config &gt;
config.yml</p>
<p>A config.yml file will be created inside your working directory.</p>
<p>Now, if you want to persist the database on your host machine, you
can create a directory and mount it to /var/lib/influxdb2 on the
container.</p>
<p>So, let’s create the container</p>
<p>docker run --name influxdb -d   -p 8086:8086   --volume
<code>pwd</code>/influxdb2:/var/lib/influxdb2   --volume
<code>pwd</code>/config.yml:/etc/influxdb2/config.yml  
influxdb:2.0.7</p>
<p>The command above will create a container
named <code>influxdb</code> and mount the config.yml file and influxdb2
directory inside your working directory. It also binds the 8086 port of
your host machine to the port 8086 of the container, assuming that you
don’t have any software running and using that port on your host
machine.</p>
<p>Remember that our goal is to create a bash script that can automate
the configuration process. But we’ll walk through every process
manually.</p>
<p>Next, we’re going to set up an account that we can use to access the
dashboard, writing, and querying data from the database. To do this, we
need to use the <code>setup</code> command
of <code>influx</code> command-line interface tool.</p>
<p>You can see the complete flags for that command <a
href="https://docs.influxdata.com/influxdb/v2.0/reference/cli/influx/setup/#flags">here</a>.
But we’re going to use some of the flags as shown in the following
command:</p>
<p>docker exec influxdb influx setup   --bucket BUCKET_NAME   --org
ORG_NAME   --password PASSWORD   --username USERNAME   --force</p>
<p>A bucket is a group of measurements. You can think of a bucket as a
database in a relational database and measurements as the tables. You
need to provide the name of the bucket and replace
the <code>BUCKET_NAME</code>.</p>
<p>Next, you have to input the name of your organization and replace
the <code>ORG_NAME</code>.</p>
<p>Then, you need to provide the username and password of the owner of
the organization. This username and password will be used as your log-in
to the dashboard.</p>
<p>If you are going to explore the features of InfluxDB 2.0 without
coding any software to write or query the data from the database, then
you are done. You can visit http://localhost:8086, log in, and then
explore the features.</p>
<p>But, if you already have an application that can write and/or query
data, and you need to get the access token programmatically then you can
continue reading.</p>
<p>The token that I mentioned is used to authenticate and authorize a
client that is going to write and/or query data. It is available on the
dashboard, but we’re not gonna open the dashboard just for that
purpose.</p>
<p>You can use the <code>influx</code> CLI to retrieve the token using
the following command:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec influxdb influx auth list</span><br></pre></td></tr></table></figure></p>
<p>The command will produce the following output:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID   Description Token            User Name User ID   Permissions07ec335d5c118000 admin&#x27;s Token TOKEN_REDACTED admin  07ec335d32118000 [read:authorizations write:authorizations read:buckets write:buckets read:dashboards write:dashboards read:orgs write:orgs read:sources write:sources read:tasks write:tasks read:telegrafs write:telegrafs read:users write:users read:variables write:variables read:scrapers write:scrapers read:secrets write:secrets read:labels write:labels read:views write:views read:documents write:documents read:notificationRules write:notificationRules read:notificationEndpoints write:notificationEndpoints read:checks write:checks read:dbrp write:dbrp]</span><br></pre></td></tr></table></figure></p>
<p>As you can see, there’s a lot of information from the output. For
example, we have an account with <code>admin</code> as the username.
This account is assigned as the owner of an organization, that’s why
there’s a lot of permissions assigned to that account.</p>
<p>But, we’re here for the token, right? Yes, you can see the token from
that output. But you might need to narrow your vision to look for the
token.</p>
<p>You may have already noticed that the output is formatted like a
table. If we split each line of the output by using space into an
array-like type by using <code>awk</code>, then the token is stored as
the 4th entry. But this isn’t always true.</p>
<p>The index of the token depends on the content of the description. By
default, the description of the token follows the following format:</p>
<p>USERNAME's Token</p>
<p>In this case, it’s <code>admin’s Token</code>. If we try visualizing
the array, here how it will look like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;07ec335d5c118000&quot;, &quot;admin&#x27;s&quot;, &quot;Token&quot;, &quot;REDACTED_TOKEN&quot;, &quot;admin&quot;, ...]</span><br></pre></td></tr></table></figure>
<p>You can confirm this by using <code>awk</code></p>
<p>docker exec influxdb influx auth list | awk '/admin/ {print $4 "
"}'</p>
<p>The command above will print the token in a line of text that
has <code>admin</code> in it. We have the token now.</p>
<p>Are we done? No, not yet.</p>
<p>At this point, we’ve done everything we need to do (excluding putting
all of the commands into a single bash script file), though. But there’s
one last thing that I want to highlight by asking this question: What if
the username is not <code>admin</code> ?</p>
<p>Of course, you can change the <code>admin</code> in the command line
with something else. But once everything is in a bash script file, you
will need to change the file for different users. You don’t want to do
this, trust me.</p>
<p>No need to panic, there’s an easy way for this.</p>
<p>You can use an environment variable to provide the username and
assign it to <code>awk</code> variable and use it as a pattern to match
the lines in the output of<code>influx auth list</code>.</p>
<p>For example, we’re going to
use <code>INFLUXDB_USERNAME</code> environment variable to store the
username, and pass the value to <code>username</code> variable
in <code>awk</code>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export INFLUXDB_USERNAME=otheruser  </span><br><span class="line">docker exec influxdb influx auth list | awk -v username=$INFLUXDB_USERNAME &#x27;$5 ~ username &#123;print $4 &quot; &quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>Note that we’re testing the <code>username</code> variable against
the 5th element in the array which contains the username listed in the
output of influx CLI as shown below:<br />
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="variable">$5</span> ~ username</span><br></pre></td></tr></table></figure></p>
<p>So, now you don’t need to change the command line every time you are
using a different username. You just need to change the value of
the <code>INFLUXDB_USERNAME</code> environment variable.</p>
<p>Let’s put everything into a bash script file.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create config file</span></span><br><span class="line">docker run --rm influxdb:2.0.7 influxd print-config &gt; config.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create the container</span></span><br><span class="line">docker run --name influxdb -d \  </span><br><span class="line">  -p 8086:8086 \  </span><br><span class="line">  --volume `pwd`/influxdb2:/var/lib/influxdb2 \  </span><br><span class="line">  --volume `pwd`/config.yml:/etc/influxdb2/config.yml \  </span><br><span class="line">  influxdb:2.0.7</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">configure influxdb</span></span><br><span class="line">docker exec influxdb influx setup \  </span><br><span class="line">  --bucket $INFLUXDB_BUCKET \  </span><br><span class="line">  --org $INFLUXDB_ORG \  </span><br><span class="line">  --password $INFLUXDB_PASSWORD \  </span><br><span class="line">  --username $INFLUXDB_USERNAME \  </span><br><span class="line"><span class="meta prompt_">  --force# </span><span class="language-bash">get the tokendocker <span class="built_in">exec</span> influxdb influx auth list | \ </span> </span><br><span class="line">awk -v username=$INFLUXDB_USERNAME &#x27;$5 ~ username &#123;print $4 &quot; &quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>Note that we use environment variables to provide the information
for <code>influx setup</code> command.</p>
<p>We’re done! But I think we might miss something here.<br />
What if the database server is not ready when we run the setup
command?</p>
<p>How can we handle this case?</p>
<p>Relax, we can use the <code>influx ping</code> command to check the
server status.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until docker exec influxdb influx ping  </span><br><span class="line">do  </span><br><span class="line">  echo &quot;Retrying...&quot;  </span><br><span class="line">  sleep 5  </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>If the server is not ready yet or experiencing a fatal error,
the <code>docker exec influxdb influx ping</code> command will fail, and
the commands inside the <code>until</code> block will be executed. This
way, we can try something like waiting for five seconds before
retrying.</p>
<p>Let’s put everything together</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create config file</span></span><br><span class="line">docker run --rm influxdb:2.0.7 influxd print-config &gt; config.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create the container</span></span><br><span class="line">docker run --name influxdb -d \  </span><br><span class="line">  -p 8086:8086 \  </span><br><span class="line">  --volume `pwd`/influxdb2:/var/lib/influxdb2 \  </span><br><span class="line">  --volume `pwd`/config.yml:/etc/influxdb2/config.yml \  </span><br><span class="line">  influxdb:2.0.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">wait</span> <span class="keyword">until</span> the database server is ready</span></span><br><span class="line">until docker exec influxdb influx ping  </span><br><span class="line">do  </span><br><span class="line">  echo &quot;Retrying...&quot;  </span><br><span class="line">  sleep 5  </span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">configure influxdb</span></span><br><span class="line">docker exec influxdb influx setup \  </span><br><span class="line">  --bucket $INFLUXDB_BUCKET \  </span><br><span class="line">  --org $INFLUXDB_ORG \  </span><br><span class="line">  --password $INFLUXDB_PASSWORD \  </span><br><span class="line">  --username $INFLUXDB_USERNAME \  </span><br><span class="line">  --force</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get the tokendocker <span class="built_in">exec</span> influxdb influx auth list | \ </span> </span><br><span class="line">awk -v username=$INFLUXDB_USERNAME &#x27;$5 ~ username &#123;print $4 &quot; &quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>We’re finally done!</p>
<p>Thank you for reading! Stay safe and healthy!</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>部署参考</title>
    <url>/blog/2023/10/11/data/deployment/%E9%83%A8%E7%BD%B2%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h2 id="一般部署">一般部署</h2>
<p>获取项目目录：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -L 2 .</span></span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── mainservice</span><br><span class="line">├── conf</span><br><span class="line">│   ├── config.go</span><br><span class="line">│   ├── dbconn.json</span><br><span class="line">│   └── server.json</span><br><span class="line">├── dal</span><br><span class="line">│   ├── dbconn.go</span><br><span class="line">│   ├── level_color_map.go</span><br><span class="line">│   └── ndival_data.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── handlers</span><br><span class="line">│   ├── ndival_seg1.go</span><br><span class="line">│   ├── ndival_seg2.go</span><br><span class="line">│   ├── ndival_seg3.go</span><br><span class="line">│   └── ndival_utils.go</span><br><span class="line">├── launch.sh</span><br><span class="line">├── log</span><br><span class="line">│   ├── gin</span><br><span class="line">│   └── service</span><br><span class="line">├── main.go</span><br><span class="line">├── misc</span><br><span class="line">│   ├── concepts_color_map.json</span><br><span class="line">│   ├── concepts_level_map.json</span><br><span class="line">│   ├── industries_color_map.json</span><br><span class="line">│   ├── industries_level_map.json</span><br><span class="line">│   ├── seg3_samples</span><br><span class="line">│   └── termsEN2CN.json</span><br><span class="line">├── models</span><br><span class="line">│   ├── compact</span><br><span class="line">│   ├── dal</span><br><span class="line">│   ├── seg2.go</span><br><span class="line">│   └── seg3.go</span><br><span class="line">├── ndival.dockerfile</span><br><span class="line">├── nohup.out</span><br><span class="line">├── routers</span><br><span class="line">│   └── router.go</span><br><span class="line">├── service</span><br><span class="line">│   ├── ndival_seg1.go</span><br><span class="line">│   ├── ndival_seg2.go</span><br><span class="line">│   ├── ndival_seg3.go</span><br><span class="line">│   └── ndival_utils.go</span><br><span class="line">├── test</span><br><span class="line">│   └── dal_ndival_data_test.go</span><br><span class="line">└── utils</span><br><span class="line">    ├── const_var.go</span><br><span class="line">    ├── log.go</span><br><span class="line">    └── tools.go</span><br><span class="line"></span><br><span class="line">16 directories, 33 files</span><br></pre></td></tr></table></figure></p>
<p>各个目录含义：<br />
* bin：存放编译后的可执行二进制文件<br />
*
conf：服务启动时有关的配置项json文件以及配置代码（如数据库名称和密码，读写超时时间设置）<br />
*
handlers：一级处理句柄函数，此目录下的函数负责对接入的请求解析参数，验证参数是否合法以及对service核心处理函数返回的结果做清洗和拼接，还有一些适当的数据格式转换等<br />
* main.go：服务启动入口源文件<br />
* misc：一些不适合存放在数据库而适合直接读取的键值<br />
* models：用于golang的sql库读取数据库对应表的解析结构体定义<br />
* routers：所有接口的路由路径配置<br />
* service：服务处理核心逻辑<br />
* test：一些简单的单元测试，连通性测试<br />
*
log：存放golang的http服务框架gin的一些运行日志，以及本服务的一些运行日志<br />
* utils：存放自定义日志工具以及其他一些数据格式转换等工具函数</p>
<p>获取项目目录后，在项目目录（go.mod和go.sum所在目录）执行命令：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure>
来获取代码所需的依赖项。前提是主机已安装Go运行时环境，如未安装，参考<a
href="%5BDownload%20and%20install%20-%20The%20Go%20Programming%20Language%5D(https://go.dev/doc/install)">Golang官网Install小节</a>来安装Golang运行时，本服务最后更新于Go版本1.20.4。</p>
<p>在项目目录下执行以下命令编译源文件为二进制可执行文件：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go build .</span><br></pre></td></tr></table></figure></p>
<p>将可执行二进制文件移动到bin目录下存放，启动服务直接运行二进制文件即可。请在服务器防火墙设置中将服务配置的监听端口放行（默认配置tcp:9190端口）。</p>
<h2 id="添加为系统服务">添加为系统服务</h2>
<p>在以下目录创建服务配置文件：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/systemd/system</span><br></pre></td></tr></table></figure> 文件模板：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=ndival nvision backend service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/path/to/your/ndival_service/bin/mainservice</span><br><span class="line">WorkingDirectory=/path/to/your/ndival_service</span><br><span class="line">Restart=always</span><br><span class="line">User=fredom</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure></p>
<p>使用<code>sudo systemctl start &lt;service-name&gt;</code>来启动服务，使用<code>systemctl status &lt;service-name&gt;</code>查看服务stdout日志输出（同时也会在配置的<code>WorkingDirectory</code>下生成log目录存放日志文件）。</p>
<p>![[Pasted image 20230813134806.png]]</p>
<h2 id="接口路由">接口路由</h2>
<h3 id="主要数据接口路由">主要数据接口路由</h3>
<table>
<colgroup>
<col style="width: 54%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">功能释意</th>
<th>接口路由</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">一次数据（单家企业）</td>
<td><code>http://ndival.com:9190/ndival_seg1?code=&lt;企业代码&gt;&amp;num=&lt;历史记录数量&gt;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">一次数据（页面列表）</td>
<td><code>http://ndival.com:9190/ndival_seg1/page_list?page_num=&lt;页码&gt;&amp;list_num=&lt;每页记录数量&gt;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">二次数据（单家企业）</td>
<td><code>http://ndival.com:9190/ndival_seg2?code=&lt;企业代码&gt;&amp;num=&lt;历史记录数量&gt;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">二次数据（页面列表）</td>
<td><code>http://ndival.com:9190/ndival_seg2/page_list?page_num=&lt;页码&gt;&amp;list_num=&lt;每页记录数量&gt;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">三次数据（单家企业）</td>
<td><code>http://ndival.com:9190/ndival_seg3?code=&lt;企业代码&gt;&amp;num=&lt;历史记录数量&gt;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">三次数据（页面列表）</td>
<td><code>http://ndival.com:9190/ndival_seg3/page_list?page_num=&lt;页码&gt;&amp;list_num=&lt;每页记录数量&gt;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">价值榜单排序</td>
<td><code>http://ndival.com:9190/ndival_seg2/rank_list</code></td>
</tr>
</tbody>
</table>
<h3 id="其他数据接口路由">其他数据接口路由</h3>
<table>
<colgroup>
<col style="width: 54%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">功能释意</th>
<th>接口路由</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">行业概念统计</td>
<td><code>http://ndival.com:9190/concept_industries?batch_size=&lt;单线程获取的记录数量&gt;&amp;num_workers=&lt;线程数量&gt;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">数据库已注册企业数量</td>
<td><code>http://ndival.com:9190/ndival_utils/all_codes_num</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">数据库已注册企业代码</td>
<td><code>http://ndival.com:9190/ndival_utils/all_codes</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">数据库已注册企业代码名称映射</td>
<td><code>http://ndival.com:9190/ndival_utils/all_codename</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">单家企业代码名称映射</td>
<td><code>http://ndival.com:9190/ndival_utils/one_codename?code=&lt;企业代码&gt;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">N维图数据表字段术语参考</td>
<td><code>http://ndival.com:9190/ndival_utils/terms_dict</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">一二三次数据汇总</td>
<td><code>http://ndival.com:9190/ndival_utils/overviewlist</code></td>
</tr>
</tbody>
</table>
<p>接口路由源代码参考：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/ndival_seg1&quot;</span>, handlers.GetSeg1)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_seg1/page_list&quot;</span>, handlers.GetSegment1PageList)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_seg2&quot;</span>, handlers.GetSeg2)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_seg2/page_list&quot;</span>, handlers.GetSegment2PageList)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_seg2/rank_list&quot;</span>, handlers.GetSegment2RankList)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_seg3&quot;</span>, handlers.GetSeg3)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_seg3/page_list&quot;</span>, handlers.GetSegment3PageList)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/ndival_utils/concept_industries&quot;</span>, handlers.GetConceptIndustriesCounts)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_utils/all_codes_num&quot;</span>, handlers.GetAllCodesNum)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_utils/all_codes&quot;</span>, handlers.GetAllCodes)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_utils/all_codename&quot;</span>, handlers.GetAllCodeNameMap)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_utils/one_codename&quot;</span>, handlers.GetOneCodeNameMap)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_utils/terms_dict&quot;</span>, handlers.GetTermsEN2CN)</span><br><span class="line">r.GET(<span class="string">&quot;/ndival_utils/overviewlist&quot;</span>, handlers.GetSegmentOverviewPageList)</span><br></pre></td></tr></table></figure></p>
<p>已允许前端跨域访问。</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>输电线路背景知识</title>
    <url>/blog/2023/10/11/data/lab/%E8%BE%93%E7%94%B5%E7%BA%BF%E8%B7%AF%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>各种各样的电线，抬头不见低头见，但你还真不一定认识它们！电压是多少，直流还是交流……</p>
<p>这也不怪大家，实话说，即便是学电的、在电力系统工作的人都不一定认识输电线路……今天，合伙人教大家几个认输电线路的妙招。</p>
<p>![][https://pic2.zhimg.com/80/v2-5270259ee74b541614fd9c04dea89d79_720w.webp]</p>
<p>（这是啥输电线路）先说说输电杆塔的概念，输电导线是由输电杆塔一段一段撑起来的，高电压等级的用“铁塔”，低电压等级的比如居民区里见的一般用“木头杆”或“水泥杆”，合起来统称“杆塔”。高电压等级的线路需要有更大的安全距离，所以要架得很高，只有铁塔才能有能力负担数十吨的线路，一根电线杆架不了这么高、也没这么大支撑力，所以电线杆都是较低电压等级的。至于多高电压算高，多低算低，这个回头细说。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-9bc1ff6acb2a50fa8e38bd4378dec63e_720w.webp" /></p>
<p>（皖电东送1000千伏特高压交流线路）电压等级都是说线电压，ABC三相中任意两相之间的电压。家里用的220伏是相电压，是三相中任意一相对大地的电压。实际家里用电是380伏线电压的（220伏的根号3倍），只是到了楼门口了，才三相分开，比如ABC三相各入一栋楼的三个单元。380伏电压等级在电力系统也叫0.4千伏电压等级，对比下目前的1000千伏特高压输电线路，差2500倍。</p>
<p>我们在旅行沿途看到的一般都是输电铁塔，至于塔型什么的没啥意思就不说了，<strong>猫头塔、酒杯塔、门型塔、V字塔都是“象形”的</strong>，看样子就知道。输电线路也分直流和交流（DC和AC），直流好认但不是很常见，国内的线路就那么几条，碰上不容易。</p>
<p>±800千伏哈密南—郑州特高压直流输电线路铁塔是<strong>T型</strong>的，下面吊着两回输电线路，一边正极，一边负极，至于为啥正极和负极要分这么多股线，咱们等到讲交流线路的分裂导线时再说。仔细看铁塔上面还伸出来了两个小“角”，一边也各一条“细线”，这不是输电用的，而是避雷用的<strong>避雷线</strong>，也叫地线。接下来说说我们常见的交流线路。</p>
<p>交流的一回线路有A、B、C三相，输电铁塔最顶端顶着的是避雷线。雷暴多地区或电压等级高的线路是两根避雷线，雷暴不严重或电压等级低的线路可以减少到一根避雷线，这个是从工程实际和省钱的角度选择的，反正大家看到最顶端细细的一或两根线就知道是避雷线了。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-f6cdf81a11befdfdbf8c0f03074ca926_720w.webp" /></p>
<p>避雷线都是跟铁塔相连的，为的是把雷击时的电流能顺着铁塔引到地里面去。不过在接的时候，避雷线和杆塔中间是有段绝缘体或绝缘子的，仔细看，能看到跳线。这样的目的是可以在雷击时方便击穿泄流，同时在平时减少输电损耗。如果避雷线直接连着铁塔，则线中对导线的感应电流会直接流入大地，导致输电损耗。避雷线一般都高电压等级的空旷地区的输电铁塔用，咱们看到的电线杆上一般很少有避雷线：一是电线杆一般是在城市内，有其他更高的建筑可以被雷劈；二是本来低电压等级的电线杆就送不了多少电，还要架根避雷线的成本就高了。</p>
<p>避雷线下面就是输电线路了，根数都是<strong>3的倍数</strong>，3根线的叫一回线，6根线的叫两回线，12根的就叫四回线了，每一回里都有ABC三相的三根线。开头的那张图我们就叫“同塔四回”线路。之所以一个塔上有多回线路，主要是考虑输送容量和占地面积，所以也衍生出了“线路长度”和“回路长度”的概念，对同塔双回而言，回路长度是线路长度的2倍，以此类推。下图也是两个同塔四回的线路，如果是不同电压等级的，则上面导线的电压要高于下面导线的电压，电压越高对地的安全距离要求越高。</p>
<p><img
src="https://pic1.zhimg.com/80/v2-d396a767c9554275e8cfd8210d073158_720w.webp" /></p>
<p>两种不同布置的同塔四回线路</p>
<p><img
src="https://pic2.zhimg.com/80/v2-fa3da64e973a391b6950a16d30bf0dd9_720w.webp" /></p>
<p>避雷线和输电导线其实也很好区分，一个是直接顶在杆塔上的，一个是需要用绝缘子串悬挂在杆塔上的。杆塔上是地电位，没有绝缘子串的绝缘，导线就直接对杆塔短路了。看输电线路，能分清电压等级是首位的，这决定了是哪条线，大概输送多少功率，输送多远距离。怎么一眼看出输电线路的电压呢？秘诀是“三看”：看<strong>导线分裂数、看绝缘子串长度、看杆塔高度</strong>。</p>
<h2 id="看导线是几分裂的">1<strong>看导线是几分裂的</strong></h2>
<p>先说分裂数，正如下面这张图片显示的，对于ABC三相中的每一相导线，都是分成好几股的，比如下面这个1000千伏特高压输电线路就分了8股，叫“<strong>八分裂</strong>”导线。之所以一相导线要分裂成好几股，是要把导线的“等效直径”扩大，相当于用几股较细的导线（相对较细，其实也有女生的手腕子粗），围成一个近似圆形，相当于把整相的导线直径“等效”扩大了。</p>
<p><img
src="https://pic2.zhimg.com/80/v2-c26793b83acc8f27d67c796c0eb737f9_720w.webp" /></p>
<p>扩大“导线直径”有这么几个原因：一、交流电有“趋肤效应”，因为自感的原因，电流大部分都在导线表面流动，导体中间几乎没有电流，把导体弄成管状可以简约材料减轻重量，既然是管状，不如弄成分裂导线代替管状线；二、高压输电线电流很大，要求导线的电阻低，电阻与导线的面积成反比，因此本来要用很粗管状导线代替，现在就用分裂导线了（在变电站里还是用管母线）；三、导线越粗，导线表面电场强度就越低，电晕就越小。电晕是对电能的损耗，我们当然希望把导线弄粗些，降低表面场强及电晕。<strong>电晕</strong>是一种放电现象，雨天在输电线周围可能会听到“兹兹”的声音，那就是电晕的声音，夜里也能看到导线在发微弱的光，当然电晕也不是只有坏处，以后可以细说。由电晕的“兹兹”声，也会带来无线电干扰，这也是为什么直流导线也要分裂的原因，都是为了降低电晕。</p>
<p>在1000千伏以下还有750千伏的超高压输电线路，这个电压等级只在我国的西北电网使用，欧洲倒也有765千伏这个电压等级的线路。750千伏电压等级一般用<strong>六分裂</strong>的导线。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-39f24548898a8e8958c9f8fddff1c406_720w.webp" /></p>
<p>500千伏的是按规程是<strong>四分裂</strong>导线，不过据观察，现在<strong>六分裂</strong>导线居多了，尤其在大城市周边，可能是输送功率大了。</p>
<p><img
src="https://pic2.zhimg.com/80/v2-7fd158c7f22c865441764fabbe6a26fd_720w.webp" /></p>
<p>220千伏的一般是<strong>两分裂</strong>，110千伏及再往下的电压等级就不用分裂导线了，单根就行，电晕已经不严重了。</p>
<p><img
src="https://pic4.zhimg.com/80/v2-23e39703a3770b203e9c888477420c33_720w.webp" /></p>
<p>不过可能因送电功率大的原因，某些地方也能见到220千伏四分裂，110千伏两分裂。三分裂的导线理论上有，但还真没怎么见过。</p>
<h2 id="看绝缘子片数">2<strong>看绝缘子片数</strong></h2>
<p><img
src="https://pic1.zhimg.com/80/v2-c87167abf9db2439e6759fd524832358_720w.webp" /></p>
<p>绝缘子是一种特殊的绝缘控件，通常有玻璃或陶瓷制成，是为了增加爬电距离的。其形状是飞碟状的，一个飞碟算一片绝缘子，绝缘子串是把若干飞碟串起来，隔离导线与杆塔用的。下图是玻璃钢绝缘子的一片的形状。再说绝缘子片数。导线分裂数比较好数，数清楚几根线就知道是多高电压等级的了。除了看分裂数，也可以数绝缘子的片数，不过比较费眼，熟了的话扫一眼就知道。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-22fa576a570b3ac747d0b40458f08786_720w.webp" /></p>
<p>常用的绝缘子还有陶瓷绝缘子，下图就是是陶瓷绝缘子</p>
<p><img
src="https://pic4.zhimg.com/80/v2-30980a2a3de5d39bc5fe96c4df220017_720w.webp" /></p>
<p>还有合成绝缘子</p>
<p><img
src="https://pic4.zhimg.com/80/v2-65c1e3958dbac2fcd223d7072c833b13_720w.webp" /></p>
<p>一片绝缘子大概的厚度是15厘米，串7片差不多一米。一般情况下：750千伏，32个500千伏，23-25个330千伏，17个220千伏，13个110千伏，7个66千伏，5个35千伏，3个</p>
<p>如果高海拔、污秽重的地区或者重要的塔，片数还要增加几片。基本可以看出<strong>1片绝缘子可以承受1-1.5万伏特的电压</strong>，但随着电压等级的升高，承压的非线性越强。实际上，不同地区不同环境，绝缘子片数可能差别很大。当然不同类型的绝缘子，要求的片数也不同。</p>
<p><img
src="https://pic2.zhimg.com/80/v2-1c80fccafb5748ded9740525d295c3a5_720w.webp" /></p>
<p>1000千伏交流特高压线路绝缘子</p>
<p><img
src="https://pic3.zhimg.com/80/v2-c0865463fbd52e7995ee1c5d0d3be2c2_720w.webp" /></p>
<p>±800千伏特高压直流线路绝缘子。</p>
<h2 id="看杆塔的高度">3<strong>看杆塔的高度</strong></h2>
<p>除了数分裂数和绝缘子片数，还可以看看杆塔的高度，虽然设计规程上没有规定杆塔要多高，但非常详细地规定了输电导线距离其他物体的最小距离。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-cb7945d858dd05d9a9bada67c5d48ac2_720w.webp" /></p>
<p>（500千伏线路铁塔）输电线路一档大约500米，导线是要下垂的，尤其是天气热和用电负荷大的时候，导线热胀冷缩，会下垂的更厉害。所以规定中明确写了各电压等级的输电线路的导线对各种物体的最小距离。例如，在居民区导线对地面最小距离分别为：35~110千伏是7米，220千伏是7.5米，330千伏是8.5米，500千伏是14米，</p>
<p>750千伏为19.5米。</p>
<p><img
src="https://pic1.zhimg.com/80/v2-552831caad3c270b1ca7c863c36510b0_720w.webp" /></p>
<p>（750千伏线路铁塔）</p>
<p>如果考虑导线弧垂和绝缘子长度，则：110千伏大概离地面十几米，220千伏和330千伏是二十几米，500千伏是三四十米，750千伏是五十几米，</p>
<p>1000千伏是七八十米。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-c78b869d5960740056de11e7a285f4c2_720w.webp" /></p>
<p>（1000千伏特高压线路铁塔）</p>
<p>换算成楼房高度，那分别是5层楼、8层楼、12层楼、18层楼和25层楼，有点印象了吧。不过这都很粗略，根据气候和地形不同，高度是要调整很大的。总体来说，<strong>区分电压等级最容易看的是导线分裂数，最准确能判断的是绝缘子片数，最有震撼力的是杆塔的高度</strong>。我们能看到的输电线路，都是地形地貌比较好的地区，要知道崇山峻岭中、大川大河上也都有输电线路，尤其是给偏远地区送电，铁塔和电线材料都是人拉肩扛上去的，相当辛苦！可以说连公路都没有的地方，可能会有输电线路，真的要向送变电工作人员们致敬！最后说说输电杆塔上的小玩意儿。大家猜猜这个刺儿和橘黄色的小风车是干嘛的？</p>
<p><img
src="https://pic1.zhimg.com/80/v2-db290ea781fb12b03f904ad476473610_720w.webp" /></p>
<p>防鸟刺</p>
<p><img
src="https://pic3.zhimg.com/80/v2-cbcbd2cece1b77e2372996bb0ae52326_720w.webp" /></p>
<p>答案揭晓：都是防鸟的！倒刺是防止鸟筑巢，用在铁塔上；小风车是驱赶鸟的，一般用在电线杆上。下次可以留意下哈！</p>
<p><img
src="https://pic2.zhimg.com/80/v2-9ff93999f6df090e822c7bccbe441701_720w.webp" /></p>
<p>为啥输电杆塔跟鸟过不去呢？因为鸟粪是导致输电线路短路故障的重要原因。鸟粪是导电的，排放到绝缘子串上时，很会构成导线的对地短路通道，所以输电线路都很怕“愤怒的小鸟”……除了鸟，蛇、鼠、黄鼠狼、或者翼展太长的大鸟都可能导致输电线路的对地或相间短路。大树也会，所以也要定期修剪树木。由此可见，高压塔的日常运维工作也是不可怠慢的呢~</p>
]]></content>
      <categories>
        <category>lab</category>
      </categories>
      <tags>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>latex test</title>
    <url>/blog/2023/10/11/data/math/latex%20test/</url>
    <content><![CDATA[<p><span class="math inline">\(\sqrt{a}\)</span> <span
class="math inline">\(\sum_{i=1}^{k}\)</span> <span
class="math inline">\(\sum\limits_{i=1}^{k}\)</span><br />
<span
class="math inline">\(f(x)=\sum_{i=1}^{k}a_{i}\chi_{A_i}(x)\)</span><br />
<span class="math inline">\(\int_{1}^{\frac{pi}{2}}\)</span><br />
<span class="math inline">\(\int_{1}^{\infty}\)</span><br />
<span class="math inline">\(\lim_{n \to \infty}\)</span><br />
<span class="math inline">\(\lim\limits_{n\to \infty}\int_{E}f_n dx \geq
\int_{E}gdx\)</span><br />
<span class="math display">\[  
\begin{bmatrix}  
a &amp; b \\  
c &amp; d  
\end{bmatrix}  
\]</span><br />
<span class="math display">\[  
H_x=\frac{1}{3}\times{  
\left[ \begin{array}{ccc}  
1 &amp; 0 &amp; -1\\  
1 &amp; 0 &amp; -1\\  
1 &amp; 0 &amp; -1  
\end{array}
\right ]},  
H_y=\frac{1}{3}\times{  
\left[ \begin{array}{ccc}  
1 &amp; 1 &amp; 1\\  
0&amp; 0 &amp; 0\\  
1 &amp; 1 &amp; 1  
\end{array}  
\right ]}  
\]</span></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian没有ifconfig？</title>
    <url>/blog/2023/10/11/data/linux/Debian%E6%B2%A1%E6%9C%89ifconfig%EF%BC%9F/</url>
    <content><![CDATA[<p>晚上在虚拟机里安装了最新的 Debian
9，然后想查看ip地址的时候报错了：</p>
<p>zhang@debian:~$ ifconfig</p>
<p>-bash: ifconfig: command not found</p>
<p>出现这个问题的原因是新版本的Debian 默认不带
ifconfig，官方推荐使用ip命令查看ip：</p>
<p>zhang@debian:~$ ip addr</p>
<p>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state
UNKNOWN group default qlen 1</p>
<p>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</p>
<p>    inet 127.0.0.1/8 scope host lo</p>
<p>       valid_lft forever preferred_lft forever</p>
<p>    inet6 ::1/128 scope host</p>
<p>       valid_lft forever preferred_lft forever</p>
<p>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc
pfifo_fast state UP group default qlen 1000</p>
<p>    link/ether 00:0c:29:2b:61:d3 brd ff:ff:ff:ff:ff:ff</p>
<p>    inet 192.168.32.155/24 brd 192.168.32.255 scope global ens33</p>
<p>       valid_lft forever preferred_lft forever</p>
<p>    inet6 fe80::20c:29ff:fe2b:61d3/64 scope link</p>
<p>       valid_lft forever preferred_lft forever</p>
<p>如果还想使用ifconfig命令，需要安装包：</p>
<p>sudo apt-get install net-tools</p>
<p>1</p>
<p>然后ifconfig会被安装：</p>
<p>root@debian:/home/zhang# whereis ifconfig</p>
<p>ifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz</p>
<p>1</p>
<p>2</p>
<p>你可以给ifconfig起个别名：</p>
<p>zhang@debian:~$ alias ifconfig='/sbin/ifconfig'</p>
<p>zhang@debian:~$ ifconfig</p>
<p>ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</p>
<p>        inet 192.168.32.155  netmask 255.255.255.0  broadcast
192.168.32.255</p>
<p>        inet6 fe80::20c:29ff:fe2b:61d3  prefixlen 64  scopeid
0x20<link></p>
<p>        ether 00:0c:29:2b:61:d3  txqueuelen 1000  (Ethernet)</p>
<p>        RX packets 527  bytes 44816 (43.7 KiB)</p>
<p>        RX errors 0  dropped 0  overruns 0  frame 0</p>
<p>        TX packets 394  bytes 55245 (53.9 KiB)</p>
<p>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions
0</p>
<p>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</p>
<p>        inet 127.0.0.1  netmask 255.0.0.0</p>
<p>        inet6 ::1  prefixlen 128  scopeid 0x10<host></p>
<p>        loop  txqueuelen 1  (Local Loopback)</p>
<p>        RX packets 2  bytes 78 (78.0 B)</p>
<p>        RX errors 0  dropped 0  overruns 0  frame 0</p>
<p>        TX packets 2  bytes 78 (78.0 B)</p>
<p>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions
0</p>
<p>————————————————</p>
<p>版权声明：本文为CSDN博主「zhangpeterx」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：https://blog.csdn.net/zhangpeterx/article/details/92718001</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP的主动模式与被动模式下20、21端口</title>
    <url>/blog/2023/10/11/data/linux/FTP%E7%9A%84%E4%B8%BB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8B20%E3%80%8121%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>FTP端口详解</p>
<p>FTP服务端口是21号端口，默认情况下FTP协会使用TCP端口中的20和21这两个端口，作用如下：</p>
<ul>
<li>21端口：FTP传输控制信息端口，用于连接；<br />
</li>
<li>20端口：FTP传输数据端口，是否会用到20端口与FTP传输模式有关，主动模式使用20端口传输，被动模式下服务器端和客户端协商决定端口。</li>
</ul>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td>FTP端口</td>
<td>作用</td>
</tr>
<tr class="even">
<td>21端口</td>
<td>用于FTP传输控制信息，用于连接</td>
</tr>
<tr class="odd">
<td>20端口</td>
<td>用于FTP传输数据端口，非必须开放端口，只有当FTP客户端传输模式设置为主动主动传输时才会使用20端口；如果传输模式为被动模式，则由服务器端和客户端协商决定使用哪个端口</td>
</tr>
</tbody>
</table>
<p>FTP主动模式和被动模式</p>
<p>端口号上面已经说了20端口是否使用与FTP客户端的传输模式有关，那么什么是主动传输什么是被动传输？</p>
<ul>
<li>主动模式：客户端向FTP服务器发送端口信息，由服务器主动连接该端口；<br />
</li>
<li>被动模式：FTP服务器开启并发送端口信息给客户端，由客户端连接该端口，服务器被动接受连接。</li>
</ul>
<p>来自 &lt;<a
href="http://www.duankouhao.com/ftp21-20.html">http://www.duankouhao.com/ftp21-20.html</a>&gt;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TTY到底是什么？</title>
    <url>/blog/2023/10/11/data/linux/TTY%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>谈到 Linux 和 UNIX 时，你一定听说过 “TTY”
这个术语，但是，这玩意是什么？</p>
<p>作为一个桌面用户，它对你有用吗？你需要它吗？你能用它做什么？</p>
<p>在本文中，让我向你介绍这些，帮助你熟悉 Linux 中的 TTY。</p>
<p>注意：这个问题没有明确的答案，但它与过去的输入/输出设备的交互方式有关。因此，你必须了解一些历史，才能清楚地了解情况。</p>
<p>“TTY” 背后的历史</p>
<p>一切始于 19 世纪 30 年代的电传打印机Teleprinter。</p>
<p>电传打印机可以让你通过电线发送或接受消息，它取代了摩尔斯电码通信，那是一种需要两个操作员才能有效地相互通信的方式。</p>
<p>一台电传打印机只需要一个操作员就可以轻松地传递消息。虽然它没有现代布局的键盘，但它的系统后来由
Donald Murray 在 1901 年进行了改良，包括了一个类似打字机的键盘。</p>
<p>Murray 电码减少了操作员发送消息的工作量。这才使得电传打印机在 1908
年有了发展成为商业电传打字机Teletypewriter的可能。TTY
即是电传打字机的缩写。</p>
<p>![[Pasted image 20231011170756.png]]</p>
<p>二战期间在伦敦实际使用的电传打字机 | 图片来源于维基百科</p>
<p>电传打字机和普通打字机typewriter的区别在于，电传打字机连接到通信设备，直接发送输入的消息。</p>
<p><a
href="https://en.wikipedia.org/wiki/Teletype_Corporation#/media/File:What-is-teletype.jpg">电传打字机使人类在没有计算机的情况下通过电线进行更快的通信成为可能</a>。</p>
<p>从这时起，“TTY” 一词就存在了。</p>
<p>（相对）现代的概念</p>
<p>现在，你一定想知道，它是如何进入现代计算机和 Linux 的？</p>
<p>最初是当电传打字机进入了市场，几年后半导体晶体管发展起来，然后演变成微处理器，为计算机的出现做好了准备。</p>
<p>最初的计算机没有键盘的概念，打孔卡Punch card就是输入的方法。</p>
<p>![[Pasted image 20231011170820.png]]</p>
<p>一种插入计算机而不是通过键盘（TTY）输入的打孔卡计算机程序 |
图片来源于维基百科</p>
<p>随着计算机的发展，批量输入的打孔卡最终被电传打字机取代，成为一种方便的输入/输出设备。</p>
<p>![[Pasted image 20231011170834.png]]</p>
<p>1956 年的 LGP-30 计算机，附带 TTY</p>
<p>随着技术的进步，电传打字机被电子技术“虚拟化”了。因此，你不需要一个物理的、机械的
TTY，而是一个虚拟的电子 TTY。</p>
<p>早期的计算机甚至没有视频屏幕。字符被打印在纸上而不是显示在屏幕上。因此，你会看到“打印print”这个术语而不是“显示display”。随着技术的进步，视频显示后来被添加到终端中。</p>
<p>换句话说，你可能听说过把它们称为“视频终端”。或者，你可以称它们为“物理”终端。</p>
<p>后来，它们演变成具有更强的能力和功能的软件仿真的终端。</p>
<p>这就是所谓的“终端仿真器terminal emulator”，如 GNOME 终端或
Konsole，或者其他 <a
href="https://itsfoss.com/linux-terminal-emulators/">你在 Linux
上找到的各种终端仿真器</a>。</p>
<p>所以，Linux 中的 TTY 到底是什么？</p>
<p>在 Linux 或 UNIX 中，TTY
变为了一个抽象设备。有时它指的是一个物理输入设备，例如串口，有时它指的是一个允许用户和系统交互的虚拟
TTY（<a
href="https://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con">参考此处</a>）。</p>
<p>TTY 是 Linux 或 UNIX 的一个子系统，它通过 TTY
驱动程序在内核级别实现进程管理、行编辑和会话管理。</p>
<p>在编程的场景下，你还需要深入研究。但是考虑到本文的范围，这可能是一个容易理解的定义。</p>
<p>如果你好奇的话，你可以查看一个有点旧的资源（<a
href="https://www.linusakesson.net/programming/tty/index.php">TTY
揭秘</a>），它尽可能的澄清了 Linux 和 UNIX 系统中的 TTY
的各种技术细节。</p>
<p>事实上，每当你在系统中启动一个终端仿真器或使用任何类型的 shell
时，它都会与虚拟 TTY（也被称为伪 TTYpseudo-TTY，即 PTY）进行交互。</p>
<p>你可以在终端仿真器中输入 tty 来找到相关联的 PTY。</p>
<p>如何在 Linux 中访问 TTY？</p>
<p>在 Linux 中很容易访问
TTY。事实上，当我不知道它是什么时，我不小心打开了它，于是对要做什么、如何摆脱它感到恐慌。</p>
<p>在大多数 发行版 中，你可以使用以下键盘快捷键来得到 TTY 屏幕：</p>
<ul>
<li>CTRL + ALT + F1 – 锁屏<br />
</li>
<li>CTRL + ALT + F2 – 桌面环境<br />
</li>
<li>CTRL + ALT + F3 – TTY3<br />
</li>
<li>CTRL + ALT + F4 – TTY4<br />
</li>
<li>CTRL + ALT + F5 – TTY5<br />
</li>
<li>CTRL + ALT + F6 – TTY6</li>
</ul>
<p>你最多可以访问六个
TTY。但是，前两个快捷方式指向发行版的锁定屏幕和桌面环境。</p>
<p>而其他快捷方式将会让你进入一个命令行界面。</p>
<p>什么时候应该使用 TTY？</p>
<p>TTY
不仅是一个技术宝藏，即使像我这样不是开发人员的用户，它也很有用。</p>
<p>在图形桌面环境冻结的情况下，它应该可以派上用场。在某些情况下，从 TTY
重建桌面环境能帮助解决程序问题。</p>
<p>或者，你也可以选择在 TTY 中执行任务，例如更新 Linux
系统等。在这些情况下，你不希望显示问题中断你的进程。</p>
<p>最坏的情况是，如果图形用户界面失去响应，你可以进入 TTY
并重新启动计算机。</p>
<p>有些用户还喜欢在 TTY 的帮助下传输大文件（我不是其中之一）。</p>
<p>Linux 中的 TTY 命令</p>
<p>当你在终端模拟器中输入 tty 时，它将打印连接到标准输入的终端文件名，就像手册页描述的一样。</p>
<p>换句话说，要知道你连接的 TTY
编号，只需输入 tty。并且，如果有多个用户远程连接到 Linux
机器，你可以使用 who 命令来检查其他用户连接到的是哪个 TTY。</p>
<p>来自 &lt;<a
href="https://linux.cn/article-14093-1.html">https://linux.cn/article-14093-1.html</a>&gt;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab定时任务</title>
    <url>/blog/2023/10/11/data/linux/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>Linux crontab 是用来定期执行程序的命令。</p>
<p>当安装完成操作系统之后，默认便会启动此任务调度命令。</p>
<p>crond
命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p>
<p>注意：新创建的 cron 任务，不会马上执行，至少要过 2
分钟后才可以，当然你可以重启 cron 来马上执行。</p>
<p>而 linux 任务调度的工作主要分为以下两类：</p>
<ul>
<li>1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存<br />
</li>
<li>2、个人执行的工作：某个用户定期要做的工作，例如每隔 10
分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</li>
</ul>
<h3 id="语法">语法</h3>
<p>crontab [ -u user ] file</p>
<p>或</p>
<p>crontab [ -u user ] { -l | -r | -e }</p>
<p>说明：</p>
<p>crontab
是用来让使用者在固定时间或固定间隔执行程序之用，换句话说，也就是类似使用者的时程表。</p>
<p>-u user 是指设定指定 user
的时程表，这个前提是你必须要有其权限(比如说是
root)才能够指定他人的时程表。如果不使用 -u user
的话，就是表示设定自己的时程表。</p>
<p>参数说明：</p>
<ul>
<li>-e : 执行文字编辑器来设定时程表，内定的文字编辑器是
VI，如果你想用别的文字编辑器，则请先设定 VISUAL
环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)<br />
</li>
<li>-r : 删除目前的时程表<br />
</li>
<li>-l : 列出目前的时程表</li>
</ul>
<p>时间格式如下：</p>
<p>f1 f2 f3 f4 f5 program</p>
<ul>
<li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4
表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。<br />
</li>
<li>当 f1 为 * 时表示每分钟都要执行 program，f2 为 *
时表示每小时都要执行程序，其馀类推<br />
</li>
<li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b
时表示从第 a 到第 b 小时都要执行，其馀类推<br />
</li>
<li>当 f1 为 <em>/n 时表示每 n 分钟个时间间隔执行一次，f2 为 </em>/n
表示每 n 小时个时间间隔执行一次，其馀类推<br />
</li>
<li>当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b,
c,... 时表示第 a, b, c...个小时要执行，其馀类推<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12)</span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)  </span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用者也可以将所有的设定先存放在文件中，用 crontab file
的方式来设定执行时间。</p>
<table>
<tbody>
<tr class="odd">
<td>执行时间</td>
<td>格式</td>
</tr>
<tr class="even">
<td>每分钟定时执行一次</td>
<td>* * * * *</td>
</tr>
<tr class="odd">
<td>每小时定时执行一次</td>
<td>0 * * * *</td>
</tr>
<tr class="even">
<td>每天定时执行一次</td>
<td>0 0 * * *</td>
</tr>
<tr class="odd">
<td>每周定时执行一次</td>
<td>0 0 * * 0</td>
</tr>
<tr class="even">
<td>每月定时执行一次</td>
<td>0 0 1 * *</td>
</tr>
<tr class="odd">
<td>每月最后一天定时执行一次</td>
<td>0 0 L * *</td>
</tr>
<tr class="even">
<td>每年定时执行一次</td>
<td>0 0 1 1 *</td>
</tr>
</tbody>
</table>
<h3 id="实例">实例</h3>
<p>每一分钟执行一次 /bin/ls：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * * * * /bin/ls</span><br></pre></td></tr></table></figure></p>
<p>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次
<code>/usr/bin/backup</code>：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 6-12/3 * 12 * /usr/bin/backup</span><br></pre></td></tr></table></figure></p>
<p>周一到周五每天下午 5:00 寄一封信给 <a
href="mailto:alex@domain.name">alex@domain.name</a>：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 17 * * 1-5 mail -s &quot;hi&quot; [alex@domain.name](mailto:alex@domain.name) &lt; /tmp/maildata</span><br></pre></td></tr></table></figure></p>
<p>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分....执行 echo
"haha"：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">20 0-23/2 * * * echo &quot;haha&quot;</span><br></pre></td></tr></table></figure></p>
<p>下面再看看几个具体的例子：</p>
<ul>
<li><code>0 */2 * * * /sbin/service httpd restart</code> 
意思是每两个小时重启一次apache<br />
</li>
<li><code>*/5 * * * * date &gt;&gt; file.txt</code> 意思是每5分钟将时间打印到file.txt中<br />
</li>
<li><code>50 7 * * * /sbin/service sshd start</code> 意思是每天7：50开启ssh服务<br />
</li>
<li><code>50 22 * * * /sbin/service sshd stop</code> 意思是每天22：50关闭ssh服务<br />
</li>
<li><code>0 0 1,15 * * fsck /home</code> 每月1号和15号检查/home
磁盘<br />
</li>
<li><code>1 * * * * /home/bruce/backup</code> 每小时的第一分执行
/home/bruce/backup这个文件<br />
</li>
<li><code>00 03 * * 1-5 find /home "*.xxx" -mtime +4 -exec rm &#123;&#125; \;</code> 每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。<br />
</li>
<li><code>30 6 */10 * * ls</code> 意思是每月的1、11、21、31日是的6：30执行一次ls命令</li>
</ul>
<p>注意：当程序在你所指定的时间执行后，系统会发一封邮件给当前的用户，显示该程序执行的内容，若是你不希望收到这样的邮件，请在每一行空一格之后加上
&gt; /dev/null 2&gt;&amp;1 即可，如：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">20 03 * * * . /etc/profile;/bin/sh /var/www/runoob/test.sh &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<h3 id="脚本无法执行问题">脚本无法执行问题</h3>
<p>如果我们使用 crontab
来定时执行脚本，无法执行，但是如果直接通过命令（如：./test.sh)又可以正常执行，这主要是因为无法读取环境变量的原因。</p>
<p>解决方法：</p>
<ul>
<li><p>1、所有命令需要写成绝对路径形式，如:
/usr/local/bin/docker。<br />
</p></li>
<li><p>2、在 shell 脚本开头使用以下代码：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span>  </span><br><span class="line">  </span><br><span class="line">. /etc/profile  </span><br><span class="line">. ~/.bash_profile</span><br></pre></td></tr></table></figure></p></li>
<li><p>3、在 /etc/crontab 中添加环境变量，在可执行命令之前添加命令 .
/etc/profile;/bin/sh，使得环境变量生效，例如：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 03 * * * . /etc/profile;/bin/sh /var/www/runoob/test.sh</span><br></pre></td></tr></table></figure></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Edit this file to introduce tasks to be run by cron.</span><br><span class="line">#</span><br><span class="line"># Each task to run has to be defined through a single line</span><br><span class="line"># indicating with different fields when the task will be run</span><br><span class="line"># and what command to run for the task</span><br><span class="line">#</span><br><span class="line"># To define the time you can provide concrete values for</span><br><span class="line"># minute (m), hour (h), day of month (dom), month (mon),</span><br><span class="line"># and day of week (dow) or use &#x27;*&#x27; in these fields (for &#x27;any&#x27;).</span><br><span class="line">#</span><br><span class="line"># Notice that tasks will be started based on the cron&#x27;s system</span><br><span class="line"># daemon&#x27;s notion of time and timezones.</span><br><span class="line">#</span><br><span class="line"># Output of the crontab jobs (including errors) is sent through</span><br><span class="line"># email to the user the crontab file belongs to (unless redirected).</span><br><span class="line">#</span><br><span class="line"># For example, you can run a backup of all your user accounts</span><br><span class="line"># at 5 a.m every week with:</span><br><span class="line"># 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/</span><br><span class="line">#</span><br><span class="line"># For more information see the manual pages of crontab(5) and cron(8)</span><br><span class="line">#</span><br><span class="line"># m  h d m w command</span><br><span class="line">*/30 * * * * date &gt;&gt; /home/fredom/log/memclean.log</span><br><span class="line">*/30 * * * * /bin/sh /home/fredom/scripts/memclean_crond.sh &gt;&gt; /home/fredom/log/memclean.log</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>htop各字段含义</title>
    <url>/blog/2023/10/11/data/linux/htop%E5%90%84%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<p>Now, let’s see what each field means, starting at the top:</p>
<h3 id="uptime">Uptime</h3>
<p>This parameter indicates how long the system has been running. The
same information can be seen by running the uptime command. It reads the
information from the /proc/uptime file.</p>
<h3 id="load-average">Load Average</h3>
<p>In addition to uptime, three numbers represent the load average. They
are taken from the /proc/loadavg file. If you take another look at the
strace output, you'll see that this file was also opened.</p>
<h3 id="pid-process-id">PID (Process ID)</h3>
<p>Every time a new process is started, it is assigned an identification
number (ID) called process ID or PID for short.</p>
<p>If you run a program in the background (&amp;) from bash, you will
see the job number in square brackets and the PID.</p>
<h3 id="process-tree">Process Tree</h3>
<p>When you launch a new process, the process that launches the new
process is called the parent process. The new process is now a child
process for the parent process. These relationships form a tree
structure. If you hit F5 in htop, you can see the process hierarchy. You
can also use the f switch with ps or pstree.</p>
<h3 id="process-user">Process User</h3>
<p>A user owns each process. Users are represented with a numeric ID.
The id command can be used to find out the name of the user. This
command gets the information from the /etc/passwd and /etc/group
files.</p>
<h3 id="process-state-s">Process State (S)</h3>
<p>While within htop it is denoted as only an “S”, it stands for process
state. Here are the values you might encounter within it:</p>
<ul>
<li>R: the process is currently running or on a run queue waiting to
run.<br />
</li>
<li>S: the process is in interruptible sleep (waiting for an event or
condition to happen).<br />
</li>
<li>D: the process is in uninterruptible sleep (cannot be woken up from
sleep).<br />
</li>
<li>Z: the process is defunct (a.k.a. “zombie”). Terminated but not
repeated by its parent.<br />
</li>
<li>T: the process is stopped by the job control signal.<br />
</li>
<li>t: the process is stopped by the debugger during the tracing.<br />
</li>
<li>X: the process is dead. You will probably never see this one.</li>
</ul>
<h3 id="process-time">Process Time</h3>
<p>Linux is a multitasking operating system which means that even when
you have a single CPU, you can run several processes simultaneously. You
can connect to your server via SSH and look at the output of htop while
your web server delivers your blog's content to your readers over the
internet.</p>
<p>How is that possible when a single CPU can only execute one
instruction at a time? The answer is time-sharing. One process runs for
a bit. Then it is suspended while the other processes waiting to run
take turns running for a while. The bit of time a process runs is called
the time slice.</p>
<p>The time slice is usually a few milliseconds, so you don't really
notice it that much when your system is not under a high load. (It'd be
really interesting to find out how long time slices usually are in
Linux.)</p>
<p>This should help explain why the load average is the average number
of running processes. If you have just one core and the load average is
1.0, the CPU has been utilized at 100%. If the load average is higher
than 1.0, it means that the number of processes wanting to run is higher
than the CPU can run so you may experience slowdowns or delays. If the
load is lower than 1.0, it means the CPU is sometimes idling and not
doing anything.</p>
<p>This should also give you a clue why sometimes the running time of a
process that's been running for 10 seconds is higher or lower than
exactly 10 seconds.</p>
<h3 id="process-niceness-and-priority">Process Niceness and
Priority</h3>
<p>When you have more tasks to run than the number of available CPU
cores, you somehow have to decide which tasks to run next and which ones
to keep waiting. This is what the task scheduler is responsible for.</p>
<p>The scheduler in the Linux kernel is responsible for choosing which
process on a run queue to pick next, and it depends on the scheduler
algorithm used in the kernel.</p>
<p>You can't generally influence the scheduler, but you can let it know
which processes are more important to you, and the scheduler may
consider it.</p>
<p>Niceness (NI) is a user-space priority to processes, ranging from
-20, the highest priority, to 19, the lowest priority. It can be
confusing, but you can think that a nice process yields a less nice
process. So the nicer a process is, the more it yields.</p>
<h3 id="memory-usage">Memory Usage</h3>
<p>A process has the illusion of being the only one in memory. This is
accomplished by using virtual memory.</p>
<p>A process does not have direct access to physical memory. Instead, it
has its own virtual address space, and the kernel translates the virtual
memory addresses to physical memory or can map some of it to disk. This
is why it can look like processes use more memory than you have
installed on your computer.</p>
<p>The point I want to make here is that it is not very straightforward
to figure out how much memory a process takes up. Do you also want to
count the shared libraries or disk-mapped memory? But the kernel
provides, and htop shows some information that can help you estimate
memory usage.</p>
<p>Here is what the memory usage colors mean:</p>
<ul>
<li>Green: Used memory<br />
</li>
<li>Blue: Buffers<br />
</li>
<li>Orange: Cache</li>
</ul>
<h2 id="options">Options</h2>
<ul>
<li>-d –delay : Used to show the delay between updates in tenths of
seconds.<br />
</li>
<li>-C –no-color –no-colour : Start htop in monochrome mode.<br />
</li>
<li>-h –help : Used to display the help message and exit.<br />
</li>
<li>-u –user=USERNAME : Used to show only the processes of a given
user.<br />
</li>
<li>-p –pid=PID, PID… : Used to show only the given PIDs.<br />
</li>
<li>-s –sort-key COLUMN : Sort by this column (use –sort-key help for a
column list).<br />
</li>
<li>-v –version : Output version information and exit</li>
</ul>
<h2 id="interactive-commands">Interactive Commands</h2>
<ul>
<li>Arrows, Page Up, Page Down, Home, End: Scroll the process
list.<br />
</li>
<li>Space: Tag or untag a process.<br />
</li>
<li>U – Untag all processes (remove all tags added with the Space
key).<br />
</li>
<li>s – Trace process system calls.<br />
</li>
<li>F1 – Help<br />
</li>
<li>F2 – setup<br />
</li>
<li>F3 – search<br />
</li>
<li>F4 – filtering: type in part of a process command line, and only
processes whose names match will be shown.<br />
</li>
<li>F5 – Tree view.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>We hope that with the help of this detailed blog, you were able to
better understand htop and learn how to use the program. If you have any
questions or suggestions, please leave them in the comment section
below.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>known hosts 文件有什么用？</title>
    <url>/blog/2023/10/11/data/linux/known%20hosts%20%E6%96%87%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>known host 的作用是什么呢？</p>
<p>ChatGPT</p>
<p><code>known_hosts</code> 文件是 SSH (Secure Shell)
协议的一部分，用于远程控制和文件传输。该文件存储了用户已知和信任的远程服务器的公钥信息。当你尝试通过
SSH 连接到一个远程服务器时，系统会检查 <code>known_hosts</code>
文件，以验证你是否曾经连接过这个服务器，以及这个服务器是否可信。</p>
<p>这里是一个简化的流程说明：</p>
<ol type="1">
<li><strong>首次连接</strong>：
<ul>
<li>当你第一次尝试连接到一个远程服务器时，该服务器的公钥会被添加到你的
<code>known_hosts</code> 文件中。<br />
</li>
<li>在这个过程中，系统通常会显示一条消息，提示你验证并接受这个新的公钥。<br />
</li>
<li></li>
</ul></li>
<li><strong>再次连接</strong>：
<ul>
<li>当你再次尝试连接到同一台服务器时，SSH
客户端会检查该服务器的公钥是否与 <code>known_hosts</code>
文件中的公钥匹配。<br />
</li>
<li>如果匹配，连接将继续。<br />
</li>
<li>如果不匹配，你会收到警告，通知你服务器的公钥已更改，这可能意味着连接受到了中间人攻击（Man-in-the-Middle
Attack）。</li>
</ul></li>
</ol>
<p><code>known_hosts</code>
文件的主要目的是增加安全性，通过验证服务器的身份来防止中间人攻击。在这种攻击中，攻击者会试图拦截和修改在客户端和服务器之间传输的数据。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>man 手册高亮</title>
    <url>/blog/2023/10/11/data/linux/man%20%E6%89%8B%E5%86%8C%E9%AB%98%E4%BA%AE/</url>
    <content><![CDATA[<p>因为man其实是一个按照固定格式生成帮助文档和使用说明的程序，它本身并不负责显示，man显示手册页的时候都是调用其他分页器比如
<strong>less</strong> 或者 <strong>most</strong>
等程序，甚至可以用vim。</p>
<p>因此我们只需要写一个脚本，让对应的分页器具有高亮关键字的功能即可，这样man调用这些分类器的时候就具有颜色显示了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cman</span></span>() &#123;</span><br><span class="line">        LESS_TERMCAP_mb=$<span class="string">&#x27;\e[01;31m&#x27;</span> \</span><br><span class="line">        LESS_TERMCAP_md=$<span class="string">&#x27;\e[01;31m&#x27;</span> \</span><br><span class="line">        LESS_TERMCAP_me=$<span class="string">&#x27;\e[0m&#x27;</span> \</span><br><span class="line">        LESS_TERMCAP_se=$<span class="string">&#x27;\e[0m&#x27;</span> \</span><br><span class="line">        LESS_TERMCAP_so=$<span class="string">&#x27;\e[45;93m&#x27;</span> \</span><br><span class="line">        LESS_TERMCAP_ue=$<span class="string">&#x27;\e[0m&#x27;</span> \</span><br><span class="line">        LESS_TERMCAP_us=$<span class="string">&#x27;\e[4;93m&#x27;</span> \</span><br><span class="line">        <span class="built_in">command</span> man <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们 source
一下这个脚本，让shell知道这个函数的存在，之后使用cman来查看手册的时候就是有一些简单语法高亮的手册页面了（以下截图因为是使用windows的cmd和ssh登录的，所以有些字符显示不全，不过颜色倒是正确了）。<br />
![[Pasted image 20231007113119.png]]</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mask一个systemd服务</title>
    <url>/blog/2023/10/11/data/linux/mask%E4%B8%80%E4%B8%AAsystemd%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>因为每天晚上睡一觉之后，第二天NUC的SSH又连接不上了，但是重启了就立刻可以连接上，看了日志发现内存也是非常充足的，没有高CPU占用进程存在，所以怀疑是休眠了导致的。</p>
<p>上CSDN搜了一下，Debian11禁止休眠，发现sleep等服务光是状态inactive还不行，必须使用更加绝对的禁止服务方式
- mask。</p>
<blockquote>
<p>GPT4:<br />
When a systemd target or service is in an "inactive" state, it simply
means it's currently not running or triggered. However, being "loaded"
means systemd is aware of its existence and it could be started or
triggered by certain events or conditions.</p>
<p>In the context of <code>sleep.target</code> in Debian 11 (or other
distributions using systemd), this target might get triggered by
specific system conditions or other services, for example, due to
inactivity or low battery on laptops. When the system goes to sleep, all
running services and connections, including SSH, are interrupted. Once
the system wakes up, you'd have to re-establish the connection.</p>
</blockquote>
<blockquote>
<p>If you simply stop the <code>sleep.target</code>, you're making it
inactive for the moment, but it could be triggered again in the future
by certain events or conditions. Masking a target or service is a
stronger measure in systemd. When you mask a service or target, you're
effectively creating a symbolic link to <code>/dev/null</code>, which
means that systemd can't start it manually or automatically,
irrespective of any event or condition.</p>
</blockquote>
<p>![[Pasted image 20230821175242.png]]</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>poweroff 计算机完全断电</title>
    <url>/blog/2023/10/11/data/linux/poweroff%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%8C%E5%85%A8%E6%96%AD%E7%94%B5/</url>
    <content><![CDATA[<p>如果使用<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo shutdown</span><br></pre></td></tr></table></figure>
命令来关闭计算机的话，似乎电源指示灯还是亮着的，这就有点奇怪。</p>
<p>询问ChatGPT之后，尝试使用了 <code>poweroff</code>
命令，这下电源指示灯确实熄灭了，但是 <code>poweroff</code> 和
<code>shutdown</code> 的区别到底是什么？</p>
<p>以下是GPT的回答</p>
<p>When you use <code>shutdown</code> without the <code>-h</code> (halt)
or <code>-r</code> (reboot) options, the system goes through the
shutdown procedure and then essentially stops, without turning off the
power. In this "halted" state, some systems might still have their power
LED on.</p>
<p>Using <code>shutdown -h now</code> tells the system to halt
<em>and</em> power off. On most systems, this should behave the same as
<code>poweroff</code>.</p>
<p>If you notice that using <code>shutdown -h now</code> still doesn't
turn off the power LED, but <code>sudo poweroff</code> does, then it
might be a quirk specific to your hardware or system configuration. In
such a case, it would be best to use <code>sudo poweroff</code> to
ensure the system powers off completely.</p>
<p>For a system where you're using it often or in scripts, you'd want
the behavior to be consistent and known, so stick with what works best
for your specific setup.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sudo的时候显示密码长度</title>
    <url>/blog/2023/10/11/data/linux/sudo%E7%9A%84%E6%97%B6%E5%80%99%E6%98%BE%E7%A4%BA%E5%AF%86%E7%A0%81%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p>By default, password prompts (like those in <code>sudo</code>) do not
display any feedback as you type in a Unix/Linux terminal for security
reasons. This is to avoid giving any hints about the password, such as
its length. However, it is possible to enable password feedback for
<code>sudo</code> by editing its configuration file.</p>
<h3
id="step-by-step-guide-to-enable-password-feedback-in-sudo">Step-By-Step
Guide to Enable Password Feedback in <code>sudo</code>:</h3>
<ol type="1">
<li><p><strong>Open the sudoers file</strong>:</p>
<p>You'll want to edit the <code>sudoers</code> file in a safe way. Use
<code>visudo</code> to do this:</p>
<p><code>sudo visudo</code></p>
<p><code>visudo</code> will check the syntax of the <code>sudoers</code>
file before saving, reducing the risk of locking yourself out due to a
syntax error.</p></li>
<li><p><strong>Change the Defaults</strong>:</p>
<p>Look for a line starting with <code>Defaults</code>. To enable
password feedback using asterisks (<code>*</code>), add the
<code>pwfeedback</code> directive to the <code>Defaults</code> line:</p>
<p><code>Defaults pwfeedback</code></p>
<p>If you want to add it as a new line instead, just enter the above
line in a new line of the file.</p></li>
<li><p><strong>Save and Exit</strong>:</p>
<ul>
<li>If <code>visudo</code> is using the <code>vi</code> editor, press
<code>Esc</code>, then type <code>:wq</code>, and hit
<code>Enter</code>.<br />
</li>
<li>If it's using the <code>nano</code> editor, press <code>Ctrl</code>
+ <code>X</code>, then <code>Y</code> to confirm changes, and
<code>Enter</code> to exit.<br />
</li>
</ul></li>
<li><p><strong>Test the Configuration</strong>:</p>
<p>Try using <code>sudo</code> and entering a password to see if
feedback is displayed.</p></li>
</ol>
<h3 id="note">Note:</h3>
<ul>
<li>Be cautious with enabling password feedback in security-sensitive
environments or public terminals, as it does reveal the length of your
password.<br />
</li>
<li>Always use <code>visudo</code> to edit the <code>sudoers</code> file
to prevent accidentally locking yourself out of the system due to syntax
errors.<br />
</li>
<li>Making changes to system security settings could violate policies in
managed environments. Ensure you have the appropriate permissions and
are in compliance with your IT policy before making such changes.</li>
</ul>
<p>This should give you a visual feedback (in the form of asterisks) for
each character you type into the password prompt of
<code>sudo</code>.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd服务的Wants和Requires小节</title>
    <url>/blog/2023/10/11/data/linux/systemd%E6%9C%8D%E5%8A%A1%E7%9A%84Wants%E5%92%8CRequires%E5%B0%8F%E8%8A%82/</url>
    <content><![CDATA[<p>Wants和Requires到底是如何工作的？今天在设置服务器的一些服务为开机自启动的时候，突然想到这个问题，因此问了一下ChatGPT，感觉回答和实际的运行结果是有点道理的。</p>
<p>After enabling the service, it says it created a symbolic link in
/etc/systemd/system/default.target.wants, so any service file in this
dir will be automatically loaded after system boot?</p>
<p>ChatGPT</p>
<p>Yes, that's correct. The
<code>/etc/systemd/system/default.target.wants/</code> directory
contains symbolic links to service files that are enabled to start on
boot under the <code>default.target</code>. When systemd starts up, it
uses the "wants" and "requires" directories associated with the current
target to determine which services to start.</p>
<p>The exact target (e.g., <code>default.target</code>,
<code>multi-user.target</code>, etc.) determines the operational state
the system is transitioning into. <code>default.target</code> is usually
a symbolic link pointing to the default target for the system, which is
typically <code>multi-user.target</code> for server systems and
<code>graphical.target</code> for systems with a GUI.</p>
<p>So, when you enable a service and systemd tells you it has created a
symbolic link in <code>/etc/systemd/system/default.target.wants/</code>,
it's indicating that the service will be started the next time the
system enters the state defined by <code>default.target</code>.</p>
<p>By placing symbolic links in these directories, systemd provides a
flexible mechanism to manage dependencies and ensure services are
started in the appropriate system state.</p>
<p>so, the <code>wants</code> and <code>requires</code> are actually
just a folder?</p>
<p>ChatGPT</p>
<p>Yes, <code>wants</code> and <code>requires</code> are directories (or
folders) used by systemd to manage dependencies and to determine which
units (services, mounts, sockets, etc.) should be activated when a
particular target is activated.</p>
<p>Here's a breakdown:</p>
<ol type="1">
<li><strong>Wants vs. Requires</strong>:
<ul>
<li><strong>Wants</strong>: If a unit is specified in a "wants"
directory, systemd will try to start it along with the target, but if
the unit fails to start, it won't stop the target from activating. It's
a softer dependency.<br />
</li>
<li><strong>Requires</strong>: If a unit is listed under a "requires"
directory and fails to start, the target will also fail to start. It's a
stronger dependency.<br />
</li>
<li></li>
</ul></li>
<li><strong>How They Work</strong>:
<ul>
<li>When a target is activated, systemd looks into its associated
<code>wants</code> and <code>requires</code> directories.<br />
</li>
<li>For each symbolic link it finds there (which points to a unit file
elsewhere on the system), systemd will attempt to start the unit.<br />
</li>
<li></li>
</ul></li>
<li><strong>Directory Structure</strong>:
<ul>
<li>Directories corresponding to <code>wants</code> and
<code>requires</code> are usually located in
<code>/etc/systemd/system/</code> or
<code>/lib/systemd/system/</code>.<br />
</li>
<li>For example, for the <code>multi-user.target</code>, you might find
directories like:
<ul>
<li><code>/etc/systemd/system/multi-user.target.wants/</code><br />
</li>
<li><code>/etc/systemd/system/multi-user.target.requires/</code> (though
the <code>requires</code> directory is less commonly used in default
configurations).<br />
</li>
</ul></li>
<li>When you enable a service with <code>systemctl enable</code>,
systemd creates a symbolic link in the appropriate <code>wants</code>
directory for the target specified in the <code>[Install]</code> section
of the service file (via the <code>WantedBy=</code> directive).</li>
</ul></li>
</ol>
<p>This directory-based approach allows for a flexible mechanism to
manage and organize dependencies and startup behavior for different
system states or "targets".</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd服务项文件各小节</title>
    <url>/blog/2023/10/11/data/linux/systemd%E6%9C%8D%E5%8A%A1%E9%A1%B9%E6%96%87%E4%BB%B6%E5%90%84%E5%B0%8F%E8%8A%82/</url>
    <content><![CDATA[<p>.service文件通常包含哪些section？</p>
<p>一个 .service 文件通常包含以下几个 section（节）：</p>
<ol type="1">
<li>[Unit]</li>
</ol>
<p>这个
section（节）是必须的，用于指定服务的元数据和依赖关系。常用的关键字有：</p>
<ul>
<li>Description：服务的描述信息。<br />
</li>
<li>Requires：服务启动所依赖的其他服务。<br />
</li>
<li>After：服务启动需要在其他服务之后启动。<br />
</li>
<li>Before：服务启动需要在其他服务之前启动。<br />
</li>
<li>Conflicts：服务与其他服务的冲突关系。</li>
</ul>
<ol type="1">
<li>[Service]</li>
</ol>
<p>这个
section（节）指定了服务的主要配置，包括启动命令、运行用户、环境变量等。常用的关键字有：</p>
<ul>
<li>Type：指定服务的类型，如 simple、forking、oneshot、dbus 等。<br />
</li>
<li>ExecStart：服务启动命令。<br />
</li>
<li>User：指定服务运行的用户。<br />
</li>
<li>Group：指定服务运行的组。<br />
</li>
<li>Environment：指定服务运行时的环境变量。<br />
</li>
<li>WorkingDirectory：指定服务的工作目录。</li>
</ul>
<ol type="1">
<li>[Install]</li>
</ol>
<p>这个
section（节）主要用于指定服务的安装和启动配置，包括服务安装的目标和别名等。常用的关键字有：</p>
<ul>
<li>WantedBy：服务要启动的目标。<br />
</li>
<li>RequiredBy：其他服务依赖该服务。<br />
</li>
<li>Alias：为服务指定别名。</li>
</ul>
<p>除了上述三个 section，.service 文件还可以包含其他 section，如
[Timer]、[Path]、[Socket] 等，这些 section
用于配置服务的定时器、文件监控、套接字等。</p>
<p>来自 &lt;<a
href="https://chenxinxu.eu.org/label/43056150-52dd-4b80-b2fe-be1eb7cf082a">https://chenxinxu.eu.org/label/43056150-52dd-4b80-b2fe-be1eb7cf082a</a>&gt;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux分屏</title>
    <url>/blog/2023/10/11/data/linux/tmux%E5%88%86%E5%B1%8F/</url>
    <content><![CDATA[<p>使用 <code>tmux</code>
工具可以在终端中进行分屏和多窗格管理。下面是一些常用的 <code>tmux</code>
命令，用于对终端进行分屏操作：</p>
<ol type="1">
<li><p>启动 <code>tmux</code>：<br />
<code>tmux</code></p></li>
<li><p>创建水平分割窗格：<br />
<code>Ctrl + b, " （按下 Ctrl 和 b 键后，松开后再按下 " 键）</code></p></li>
<li><p>创建垂直分割窗格：<br />
<code>Ctrl + b, % （按下 Ctrl 和 b 键后，松开后再按下 % 键）</code></p></li>
<li><p>在窗格间切换焦点：<br />
<code>Ctrl + b, 方向键（上/下/左/右）</code></p></li>
<li><p>关闭当前窗格：<br />
<code>Ctrl + b, x （按下 Ctrl 和 b 键后，松开后再按下 x 键）</code></p></li>
<li><p>重新调整窗格大小：<br />
<code>Ctrl + b, 方向键（上/下/左/右）+ 按住 Alt 键</code></p></li>
<li><p>分离 <code>tmux</code> 会话（在后台运行）：<br />
<code>Ctrl + b, d （按下 Ctrl 和 b 键后，松开后再按下 d 键）</code></p></li>
<li><p>重新连接到已分离的 <code>tmux</code> 会话：<br />
<code>tmux attach</code></p></li>
</ol>
<p>这只是一些常见的命令示例，<code>tmux</code>
还提供了更多的功能和命令，可以按需使用。你可以通过 <code>man tmux</code>
命令查看完整的 <code>tmux</code> 帮助文档来获取更多信息。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux分屏调整窗格大小</title>
    <url>/blog/2023/10/11/data/linux/tmux%E5%88%86%E5%B1%8F%E8%B0%83%E6%95%B4%E7%AA%97%E6%A0%BC%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>在摘抄这篇文章笔记之后，自己无意间发现，按着Ctrl+b后再按方向键就可以调整当前所在窗格的大小了，只不过如果按下Ctrl+b之后没有及时按下方向键的话，就不会判定为调整大小</p>
<p>sudo apt install tmux</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Install-Tmux.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x540/rscb4/ng:webp/ngcb4"
alt="install tmux" />
<figcaption aria-hidden="true">install tmux</figcaption>
</figure>
<p>Install Tmux</p>
<p>Alternatively, you can install it using the Ubuntu Software Center.
Launch the Ubuntu Software Center application, search for tmux and click
the ‘Install’ button.</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Install-Tmux-via-software-center.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:890x510/rscb4/ng:webp/ngcb4"
alt="install tmux via software center" />
<figcaption aria-hidden="true">install tmux via software
center</figcaption>
</figure>
<p>Install Tmux via software center</p>
<p>Once Tmux has been installed, you will need to invoke it via the
terminal since Tmux does not come with an application associated with
it, nor does it come with an icon. Therefore, to launch the installed
Tmux application, open your terminal or use the already existing window
to execute the following line of code:</p>
<p>tmux</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Tmux-new-screen.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x540/rscb4/ng:webp/ngcb4"
alt="tmux new screen" />
<figcaption aria-hidden="true">tmux new screen</figcaption>
</figure>
<p>Tmux new screen</p>
<h2 id="how-to-use-tmux">How to use Tmux</h2>
<p>Tmux uses notions like sessions, windows, panes, and hotkeys. As a
result, newcomers typically find it intimidating at first. However,
you’ll feel much more productive after you’ve mastered it. A Tmux
session denotes the scope of the job at hand. Windows allows users to do
a range of tasks inside a single session.</p>
<p><img
src="https://nc.pubpowerplatform.io/assets/pubpower-black-100x18.png" /></p>
<p>On the other hand, Panes will allow you to deal with many viewpoints
in a single window. Tmux hotkeys, which consist of the Tmux prefix
followed by a key, may be used to control all of them. The default
prefix is “Ctrl + B.”</p>
<h3 id="how-to-resize-tmux-panes">How to resize Tmux panes</h3>
<p>Resizing panes in Tmux is quite complex when using the default
keybinding. However, don’t worry since, in this tutorial guide, I will
be illustrating how to configure the tmux.conf file to aid in easily
resizing the panes.</p>
<p>By default, when you create a pane/s in Tmux, it splits the window
into 50% splits.</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Pane-resizing-using-arrow-keys.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x503/rscb4/ng:webp/ngcb4"
alt="pane resizing using arrow keys" />
<figcaption aria-hidden="true">pane resizing using arrow
keys</figcaption>
</figure>
<p>Pane resizing</p>
<p>However, the major question is, what do you do when you want some
panes to contain more space than others? That is where pane resizing
comes in. To resize a pane, you always use the default prefix ‘Ctrl + b’
followed by the colon (:) key. When you invoke these key combinations,
it will prompt at the bottom of your screen. To resize the pane, you
will need to use the prompt to resize the desired pane.</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Input-command-to-resize-pane.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x522/rscb4/ng:webp/ngcb4"
alt="input command to resize pane" />
<figcaption aria-hidden="true">input command to resize pane</figcaption>
</figure>
<p>Input command to resize the pane</p>
<p>For example, to resize a pane, you must type in the ‘resize-pane’
command followed by a hyphen (-) and either one of these options (D, U,
R, L). These options are down, up, right, and left, respectively. Its
work is to resize the pane in the direction provided.</p>
<p>:resize-pane -D 10</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Resized-pane-using-resize-pane-command.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x522/rscb4/ng:webp/ngcb4"
alt="resized pane using resize pane command" />
<figcaption aria-hidden="true">resized pane using resize pane
command</figcaption>
</figure>
<p>Resized pane using the resize-pane command</p>
<p><strong>Note:</strong> While using the resize-pane command, the
resize option triggered will be applied to the last pane you were
in.</p>
<p>Below is a syntax that can help you quickly grasp the resizing
concept:</p>
<p>:resize-pane -D (Resizes the current pane down by one cell)</p>
<p>:resize-pane -R (Resizes the current pane right by one cell)</p>
<p>:resize-pane -U (Resizes the current pane upward by one cell)</p>
<p>:resize-pane -L (Resizes the current pane left by one cell)</p>
<p>:resize-pane -U 10 (Resizes the current pane upward by ten cells)</p>
<p>:resize-pane -R 10 (Resizes the current pane right by ten cells)</p>
<p>:resize-pane -D 10 (Resizes the current pane down by ten cells)</p>
<p>:resize-pane -L 10 (Resizes the current pane left by ten cells)</p>
<p>If you wish to configure your keybindings, then open the tmux.conf
file and append the following lines of code:</p>
<p>bind -n M-H resize-pane -L 2</p>
<p>bind -n M-L resize-pane -R 2</p>
<p>bind -n M-K resize-pane -U 2</p>
<p>bind -n M-J resize-pane -D 2</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Configure-keybindings.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x503/rscb4/ng:webp/ngcb4"
alt="configure keybindings" />
<figcaption aria-hidden="true">configure keybindings</figcaption>
</figure>
<p>Configure keybindings</p>
<p>The above codes will help you use the ‘Usual’ (H, J, K, L) to resize
the panes. If you have your own default keys you intend to use, then you
can bind them into tmux.conf file. Once you are done, remember to exit
the current session and start a new session or execute the reload
command to reload the tmux.conf file.</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Resized-panes.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x522/rscb4/ng:webp/ngcb4"
alt="resized panes" />
<figcaption aria-hidden="true">resized panes</figcaption>
</figure>
<p>Resized panes</p>
<h4 id="using-the-mouse-mode">Using the mouse mode</h4>
<p>This is one of the easiest alternatives to resize panes on Tmux.
Using the mouse is much more convenient as it does not require any
commands. This method is usually preferred since it provides more
control over the pane size than the first method, which involves using
the resize-pane command. Open the tmux.conf file and append the
following line of code:</p>
<p>set -g mouse on</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Set-mouse-mode.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x430/rscb4/ng:webp/ngcb4"
alt="set mouse mode" />
<figcaption aria-hidden="true">set mouse mode</figcaption>
</figure>
<p>Set mouse mode</p>
<p>Once you are done, reload the tmux.conf file by executing the
following line of code:</p>
<p>tmux source-file ~/.tmux.conf</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Reload-Tmux-config-file.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x339/rscb4/ng:webp/ngcb4"
alt="reload tmux config file" />
<figcaption aria-hidden="true">reload tmux config file</figcaption>
</figure>
<p>Reload Tmux config file</p>
<p><strong>Note:</strong> It is always vital to reload the tmux.conf
file to effect the changes made.</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Resized-panes.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x522/rscb4/ng:webp/ngcb4"
alt="resized panes" />
<figcaption aria-hidden="true">resized panes</figcaption>
</figure>
<p>Resized panes using mouse mode</p>
<h4 id="using-the-arrow-keys-plus-the-default-prefix">Using the Arrow
keys plus the default prefix</h4>
<p>This is another technique that can be used to resize Tmux panes. You
can resize the panes by using the default ‘Prefix’ (Ctrl + b) plus the
arrow keys.</p>
<p>Also Read</p>
<ul>
<li><a
href="https://www.fosslinux.com/35735/5-ways-to-send-emails-using-the-command-line-in-linux.htm">5
ways to send emails using the command-line in Linux</a><br />
</li>
<li><a
href="https://www.fosslinux.com/4383/how-to-update-solus-using-commands-from-the-terminal.htm">How
to update Solus using commands from the Terminal</a><br />
</li>
<li><a
href="https://www.fosslinux.com/3766/how-to-search-wikipedia-by-command-line-on-ubuntu.htm">How
to search Wikipedia by command-line on Ubuntu</a></li>
</ul>
<p>For example, to resize a pane to the right, use the default prefix
followed by the right arrow key. This applies to all other directions,
such as up, down, left, and right.</p>
<figure>
<img
src="https://www.fosslinux.com/ezoimgfmt/b1490832.smushcdn.com/1490832/wp-content/uploads/2022/10/Pane-resizing-using-arrow-keys.png?lossy=1&amp;strip=1&amp;webp=1&amp;ezimgfmt=rs:796x503/rscb4/ng:webp/ngcb4"
alt="pane resizing using arrow keys" />
<figcaption aria-hidden="true">pane resizing using arrow
keys</figcaption>
</figure>
<p>Pane resizing using arrow keys</p>
<p>That’s how to resize panes on Tmux.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This guide illustrated how to resize Tmux panes on your Linux OS. All
the methods provided are effective and have been tested. Therefore,
don’t shy away from trying them. If you encounter a challenge, don’t
hesitate to let us know via the message board below.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>不要在.bashrc及其索引的脚本中使用 exit</title>
    <url>/blog/2023/10/11/data/linux/%E4%B8%8D%E8%A6%81%E5%9C%A8.bashrc%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8%20exit/</url>
    <content><![CDATA[<p>这可能会导致意料之外的行为，比如当机器的环境发生了某些变动之后，你的.bashrc脚本很有可能会进入到触发
<code>exit &lt;code&gt;</code>
的分支，从而导致这个bash进程退出，而更糟糕的是，.bashrc是shell进程启动时source的配置脚本，如果在这里面使用了
<code>exit &lt;code&gt;</code>
，那么整个shell进程都会随之退出，从而导致你刚连接到主机就会关闭连接，因为维持ssh连接的最后一个进程是shell，而shell退出了自然ssh连接也就结束了。</p>
<p>以下是来自GPT4的建议：<br />
当脚本需要被直接执行的时候，exit是合适的提前结束脚本的方法；当脚本是被source读取的时候，则可以使用return来安全的退出脚本，但return在直接执行的脚本中是不可用的。</p>
<p>In a shell script, using <code>exit</code> is a common way to
terminate the script early if certain conditions are met or not
satisfied. However, when writing scripts that are meant to be sourced
(like <code>.bashrc</code>, <code>.bash_profile</code>, etc.), using
<code>exit</code> can indeed close the entire shell session, which might
be undesirable in many cases.</p>
<p>In the context of scripts that are intended to be sourced, you might
prefer to use <code>return</code> instead of <code>exit</code> to end
the script early without closing the shell session.</p>
<h3 id="example-using-return-in-.bashrc">Example using
<code>return</code> in <code>.bashrc</code>:</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$TERM</span>&quot;</span> = <span class="string">&quot;dumb&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;This terminal type is not supported.&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remaining .bashrc configurations...</span></span><br></pre></td></tr></table></figure>
<p>In the above snippet:</p>
<ul>
<li>If <code>$TERM</code> is equal to "dumb", a message is printed, and
<code>.bashrc</code> is exited early with a status of <code>1</code>
using <code>return</code>.<br />
</li>
<li>If <code>$TERM</code> is not "dumb", the script continues executing
the remaining configurations.</li>
</ul>
<p>Using <code>return</code> instead of <code>exit</code> in files that
are meant to be sourced is essential to avoid accidentally terminating
the session. Here's a breakdown of their general use:</p>
<h3 id="in-shell-scripts">In Shell Scripts:</h3>
<ul>
<li><p><code>exit</code>: Terminates the script and sets a status
code.</p>
<p>Example Shell Script (<code>script.sh</code>):<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;No argument supplied&quot;</span></span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remaining script...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>Usage: <code>./script.sh</code></p>
<h3 id="in-sourced-files-like-.bashrc">In Sourced Files (like
<code>.bashrc</code>):</h3>
<ul>
<li><p><code>return</code>: Stops sourcing the file and returns to the
calling script/shell, with an optional status code.</p>
<p>Example Sourced Script Section (<code>source_script.sh</code>):<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;No argument supplied&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remaining script...</span></span><br></pre></td></tr></table></figure></p>
<p>Usage: <code>source source_script.sh</code> or
<code>. source_script.sh</code></p></li>
</ul>
<p>Ensure to use <code>return</code> in scenarios where you are using
<code>source</code> or <code>.</code> to load a script, and
<code>exit</code> when running scripts directly to manage script and
session termination appropriately. Always ensure to handle script
termination carefully to avoid unexpected behavior, particularly when
configuring startup files like <code>.bashrc</code> or
<code>.bash_profile</code>.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码编译git并使用</title>
    <url>/blog/2023/10/11/data/linux/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91git%E5%B9%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>有些Linux发行版的包管理器中，git的版本并不经常更新，但是有时候我们需要新的git特性，这个时候就只能下载git的源码从头编译了。但前提是这个发行版必须携带了GNU
make以及GCC套件用来编译git源码。</p>
<p>首先查看git官方文档的安装指南，包括了Debian系列发行版和RHEL系列发行版的系统使用包管理器安装git的步骤。最后是使用源码安装的步骤。https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</p>
<p>Installing from Source</p>
<p>Some people may instead find it useful to install Git from source,
because you’ll get the most recent version. The binary installers tend
to be a bit behind, though as Git has matured in recent years, this has
made less of a difference.</p>
<p>If you do want to install Git from source, you need to have the
following libraries that Git depends on: autotools, curl, zlib, openssl,
expat, and libiconv. For example, if you’re on a system that
has dnf (such as Fedora) or apt-get (such as a Debian-based system), you
can use one of these commands to install the minimal dependencies for
compiling and installing the Git binaries:</p>
<p>$ sudo dnf install dh-autoreconf curl-devel expat-devel gettext-devel
    openssl-devel perl-devel zlib-devel<br />
$ sudo apt-get install dh-autoreconf libcurl4-gnutls-dev libexpat1-dev  
  gettext libz-dev libssl-dev</p>
<p>In order to be able to add the documentation in various formats (doc,
html, info), these additional dependencies are required:</p>
<p>$ sudo dnf install asciidoc xmlto docbook2X<br />
$ sudo apt-get install asciidoc xmlto docbook2x</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Note</td>
<td>Users of RHEL and RHEL-derivatives like CentOS and Scientific Linux
will have to <a
href="https://docs.fedoraproject.org/en-US/epel/#how_can_i_use_these_extra_packages">enable
the EPEL repository</a> to download the docbook2X package.</td>
</tr>
</tbody>
</table>
<p>If you’re using a Debian-based distribution
(Debian/Ubuntu/Ubuntu-derivatives), you also need
the install-info package:</p>
<p>$ sudo apt-get install install-info</p>
<p>If you’re using a RPM-based distribution
(Fedora/RHEL/RHEL-derivatives), you also need the getopt package (which
is already installed on a Debian-based distro):</p>
<p>$ sudo dnf install getopt</p>
<p>Additionally, if you’re using Fedora/RHEL/RHEL-derivatives, you need
to do this:</p>
<p>$ sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi</p>
<p>due to binary name differences.</p>
<p>When you have all the necessary dependencies, you can go ahead and
grab the latest tagged release tarball from several places. You can get
it via the kernel.org site, at  <a
href="https://www.kernel.org/pub/software/scm/git">https://www.kernel.org/pub/software/scm/git</a>,
or the mirror on the GitHub website, at  <a
href="https://github.com/git/git/tags">https://github.com/git/git/tags</a>.
It’s generally a little clearer what the latest version is on the GitHub
page, but the kernel.org page also has release signatures if you want to
verify your download.</p>
<p>Then, compile and install:</p>
<p>$ tar -zxf git-2.8.0.tar.gz<br />
$ cd git-2.8.0<br />
$ make configure<br />
$ ./configure --prefix=/usr<br />
$ make all doc info<br />
$ sudo make install install-doc install-html install-info</p>
<p>After this is done, you can also get Git via Git itself for
updates:</p>
<p>$ git clone <a
href="https://git.kernel.org/pub/scm/git/git.git">https://git.kernel.org/pub/scm/git/git.git</a></p>
<p>来自 &lt;<a
href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a>&gt;</p>
<p>按照上面的指示应该是能正常安装的，不过推荐prefix换成自定义的目录，不要放在/usr这种只有root才有权限读写的目录。而且git一般也是给自己安装，不清楚这台机器的其他用户是否需要。我的安装前缀prefix是$PWD/build/install，也就是在git的源码目录下新建了
build/install目录用于存放make自动化构建产物，最后再把这个目录下的可执行文件所在目录软连接到系统路径下也是可以的。</p>
<p>[fredom@AliyunECS 14:45:01]
~/programFiles/git-2.40.1/build/install</p>
<p>$ tree -L 2</p>
<p>.</p>
<p>├── bin</p>
<p>│   ├── git</p>
<p>│   ├── git-cvsserver</p>
<p>│   ├── gitk</p>
<p>│   ├── git-receive-pack</p>
<p>│   ├── git-shell</p>
<p>│   ├── git-upload-archive</p>
<p>│   ├── git-upload-pack</p>
<p>│   └── scalar</p>
<p>├── libexec</p>
<p>│   └── git-core</p>
<p>└── share</p>
<p>    ├── doc</p>
<p>    ├── git-core</p>
<p>    ├── git-gui</p>
<p>    ├── gitk</p>
<p>    ├── gitweb</p>
<p>    ├── info</p>
<p>    ├── locale</p>
<p>    ├── man</p>
<p>    └── perl5</p>
<p>13 directories, 8 files</p>
<p>记住，软链接目录时，目录的路径必须是绝对路径不能用相对路径。这里，我把install/bin这个目录链接到了家目录下的.local/bin/git，并且把这个.local/bin/git添加到了系统路径。这样就能在其他地方也使用git了。</p>
<p>注意：</p>
<p>1、目录只能建软连接</p>
<p>2、建立的时候参数都要绝对路径</p>
<p>3、示例：ln -s /var/www/HDP-UTILS /home/data/<a
href="https://so.csdn.net/so/search?q=package&amp;spm=1001.2101.3001.7020">package</a>/HDP-UTILS</p>
<p>4、 ln -s 有文件的原目录 需要建立软连接的目录</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PM2来管理自己的进程</title>
    <url>/blog/2023/10/11/data/linux/%E4%BD%BF%E7%94%A8PM2%E6%9D%A5%E7%AE%A1%E7%90%86%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>pm2 是一款基于 nodejs
运行在服务器上的进程管理工具，它允许用户可视化地管理自己的进程。</p>
<p>当服务器是多用户环境时，也许你不想自己的进程夹杂在一堆系统进程和其他人的进程中，并且希望能只关注自己启动的进程的相关信息比如资源使用率等等。</p>
<h2 id="managing-applications-states">Managing applications states</h2>
<p>With PM2 you can easily start/restart/reload/stop/list applications
in background.</p>
<h3 id="start">Start</h3>
<p>To start an application:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ pm2 start api.js</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://user-images.githubusercontent.com/757747/123512784-b0341900-d689-11eb-93d4-69510ee2be27.png"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>You can also start any kind of application like bash commands,
script, binaries:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ pm2 start <span class="string">&quot;npm run start&quot;</span></span><br><span class="line">$ pm2 start <span class="string">&quot;ls -la&quot;</span></span><br><span class="line">$ pm2 start app.py</span><br></pre></td></tr></table></figure>
<h4 id="start-and-display-log-stream">Start and display log stream</h4>
<p>To start an app and check logs stream use
the <code>--attach</code> option:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ pm2 start api.js --attach</span><br></pre></td></tr></table></figure>
<p>When quitting via Ctrl-C, the app will still run in background.</p>
<h4 id="passing-arguments">Passing arguments</h4>
<p>All option passed after <code>--</code> will be passed as argument to
the app:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ pm2 start api.js -- arg1 arg2</span><br></pre></td></tr></table></figure>
<h4 id="configuration-file">Configuration File</h4>
<p>When managing multiple application at the same time or having to
specify multiple options, you can use a configuration file. Example with
this ecosystem.config.js file:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">module.exports = <span class="punctuation">&#123;</span></span><br><span class="line">  apps <span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    name   <span class="punctuation">:</span> <span class="string">&quot;limit worker&quot;</span><span class="punctuation">,</span></span><br><span class="line">    script <span class="punctuation">:</span> <span class="string">&quot;./worker.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    args   <span class="punctuation">:</span> <span class="string">&quot;limit&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">    name   <span class="punctuation">:</span> <span class="string">&quot;rotate worker&quot;</span><span class="punctuation">,</span></span><br><span class="line">    script <span class="punctuation">:</span> <span class="string">&quot;./worker.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    args   <span class="punctuation">:</span> <span class="string">&quot;rotate&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Then to start both apps:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 start ecosystem.config.js</span><br></pre></td></tr></table></figure>
<p>Read more about <a
href="https://pm2.keymetrics.io/docs/usage/application-declaration/">configuration
file</a>.</p>
<h3 id="restart">Restart</h3>
<p>To restart an application:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 restart api</span><br></pre></td></tr></table></figure>
<p>To restart all applications:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 restart all</span><br></pre></td></tr></table></figure>
<p>To restart multiple apps at once:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 restart app1 app3 app4</span><br></pre></td></tr></table></figure>
<h4 id="updating-environment-variables-and-options">Updating environment
variables and options</h4>
<p>To update environment variables or PM2 options, specify
the <code>--update-env</code> CLI option:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ NODE_ENV=production pm2 restart web-interface --update-env</span><br></pre></td></tr></table></figure>
<h3 id="stop">Stop</h3>
<p>To stop a specified application:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 stop api</span><br><span class="line">$ pm2 stop [process_id]</span><br></pre></td></tr></table></figure>
<p>To stop them all:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 stop all</span><br></pre></td></tr></table></figure>
<p>To stop multiple apps at once:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 stop app1 app3 app4</span><br></pre></td></tr></table></figure>
<p>Note: this will not delete the application from PM2 application list.
See next section to delete an application.</p>
<h3 id="delete">Delete</h3>
<p>To stop and delete an application:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 delete api</span><br></pre></td></tr></table></figure>
<p>To delete them all:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 delete all</span><br></pre></td></tr></table></figure>
<h2 id="listing-applications">Listing Applications</h2>
<p>To list all running applications:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 list</span><br><span class="line"># Or</span><br><span class="line">$ pm2 [list|ls|l|status]</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://user-images.githubusercontent.com/757747/123511260-a3f78e00-d680-11eb-8907-3f1017ef7dc8.png"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>To specify which order you want the application to be listed:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ pm2 list --<span class="built_in">sort</span> name:desc</span><br><span class="line"><span class="comment"># Or</span></span><br><span class="line">$ pm2 list --<span class="built_in">sort</span> [name|<span class="built_in">id</span>|pid|memory|cpu|status|<span class="built_in">uptime</span>][:asc|desc]</span><br></pre></td></tr></table></figure>
<h3 id="terminal-dashboard">Terminal Dashboard</h3>
<p>PM2 gives you a simple way to monitor the resource usage of your
application. You can monitor memory and CPU easily and straight from
your terminal with:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm2 monit</span><br></pre></td></tr></table></figure>
<p><img src="https://pm2.keymetrics.io/images/pm2-monit.png"
title="PM2 Monit" /></p>
<h3 id="showing-application-metadata">Showing application metadata</h3>
<p>To display metadata about an application:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ pm2 show api</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://user-images.githubusercontent.com/757747/123510635-fafb6400-d67c-11eb-8534-0ce6106979b2.png"
alt="drawing" />
<figcaption aria-hidden="true">drawing</figcaption>
</figure>
<h3 id="reset-restart-count">Reset restart count</h3>
<p>To reset the restart counter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pm2 reset all</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用XRDP服务在局域网完成远程桌面连接</title>
    <url>/blog/2023/10/11/data/linux/%E4%BD%BF%E7%94%A8XRDP%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E5%AE%8C%E6%88%90%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>In this article, we want to teach you how to <strong>Install and
Configure XRDP on Debian 11</strong>.</p>
<p><strong>XRDP</strong> is an open-source implementation of the
Microsoft RDP (Remote Desktop Protocol) server. It provides bridging
between the RDP client and the X windows system. The XRDP server allows
remote users to graphical login to the remote machines using the
Microsoft RDP client.</p>
<p>what you read in this post?</p>
<ul>
<li><a
href="https://orcacore.com/install-and-configure-xrdp-on-debian-11/#steps-to-install-and-configure-xrdp-on-debian-11">Steps
To Install and Configure XRDP on Debian 11</a><br />
</li>
<li><a
href="https://orcacore.com/install-and-configure-xrdp-on-debian-11/#install-the-desktop-environment-on-debian-11">Install
the Desktop Environment on Debian 11</a><br />
</li>
<li><a
href="https://orcacore.com/install-and-configure-xrdp-on-debian-11/#install-xrdp-on-debian-11">Install
XRDP on Debian 11</a><br />
</li>
<li><a
href="https://orcacore.com/install-and-configure-xrdp-on-debian-11/#configure-xrdp-service-on-debian-11">Configure
XRDP service on Debian 11</a><br />
</li>
<li><a
href="https://orcacore.com/install-and-configure-xrdp-on-debian-11/#access-debian-remote-desktop">Access
Debian Remote Desktop</a><br />
</li>
<li><a
href="https://orcacore.com/install-and-configure-xrdp-on-debian-11/#conclusion">Conclusion</a></li>
</ul>
<h3 id="steps-to-install-and-configure-xrdp-on-debian-11">Steps To
Install and Configure XRDP on Debian 11</h3>
<p>Before you start to install XRDP on Debian 11, you need to log in to
your server as a non-root user with sudo privileges and set up a basic
firewall. To do these, you can check our article about the <a
href="https://orcacore.com/initial-server-setup-with-debian-11/">Initial
Server Setup with Debian 11</a>.</p>
<p>Now you can start to install the Desktop environment on Debian
11.</p>
<h3 id="install-the-desktop-environment-on-debian-11">Install the
Desktop Environment on Debian 11</h3>
<p>There are several desktop environments (DE) available in Debian
repositories. We’ll be installing <a
href="https://xfce.org/">Xfce</a>.</p>
<p>First, update the local package index with the following command:</p>
<p>sudo apt update</p>
<p>Then, install the Xfce packages with the following command:</p>
<p>sudo apt install xfce4 xfce4-goodies xorg dbus-x11
x11-xserver-utils</p>
<p>This may take some time to install.</p>
<p>Now you can install XRDP on your server.</p>
<h3 id="install-xrdp-on-debian-11">Install XRDP on Debian 11</h3>
<p>The XRDP packages are available on the default Debian repository. You
can install it with the following command:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install xrdp -y </span><br></pre></td></tr></table></figure>
<p>Verify that the XRDP is active and running on Debian 11 with the
following command:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl status xrdp </span><br></pre></td></tr></table></figure>
<p><strong>Output</strong><br />
xrdp.service - xrdp daemon<br />
Loaded: loaded (/lib/systemd/system/xrdp.service; enabled; vendor
preset: &gt;<br />
Active: active (running) since Tue 2021-11-09 08:10:53 EST; 46s
ago<br />
Docs: man:xrdp(8)<br />
man:xrdp.ini(5)<br />
Process: 1363 ExecStartPre=/bin/sh /usr/share/xrdp/socksetup
(code=exited, &gt;<br />
Process: 1371 ExecStart=/usr/sbin/xrdp $XRDP_OPTIONS (code=exited,
status=0&gt;<br />
Main PID: 1372 (xrdp)<br />
Tasks: 1 (limit: 2325)<br />
Memory: 760.0K<br />
CPU: 59ms<br />
CGroup: /system.slice/xrdp.service<br />
└─1372 /usr/sbin/xrdp</p>
<p>The installation process creates a user named xrdp in your system.
The XRDP sessions use a certificate key file
“/etc/ssl/private/ssl-cert-snakeoil.key”. This key file is owned by root
and the group owner is “ssl-cert”</p>
<p>So you need to allow xrdp users to access this key file. To do this,
add the xrdp user to the “ssl-cert” group with the following
command:</p>
<p>sudo adduser xrdp ssl-cert</p>
<p><strong>Output</strong><br />
Adding user <code>xrdp' to group</code>ssl-cert' ...<br />
Adding user xrdp to group ssl-cert<br />
Done.</p>
<p>When you have XRDP active and running on Debian 11, let’s start to
configure it.</p>
<h3 id="configure-xrdp-service-on-debian-11">Configure XRDP service on
Debian 11</h3>
<p>For basic Xrdp connections, you do not need to make any changes to
the configuration files. Xrdp will use the default X Window desktop,
which in this case, is XFCE.</p>
<p>The main configuration file is named <code>xrdp.ini</code> . This
file allows you to set global configuration settings such as security
and listening addresses and create different xrdp login sessions.</p>
<p>Whenever you make any changes to the configuration file you need to
restart the Xrdp service on Debian 11:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart xrdp</span><br></pre></td></tr></table></figure>
<p>Xrdp uses <code>startwm.sh</code> file to launch the X session. To
use another X Window desktop, edit this file.</p>
<p>Now you need to adjust the firewall to access the XRDP on Debian
11.</p>
<p>The Xrdp listens on port 3389.</p>
<p>You can use the following command to open port 3389 for the LAN
network:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 192.168.1.0/24 to any port 3389 </span><br></pre></td></tr></table></figure>
<p><em><strong>Note</strong></em>: If you want to allow access from
anywhere you can use the following command:</p>
<p>sudo ufw allow 3389</p>
<p>To apply the new rules reload the firewall with the following
command:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw reload </span><br></pre></td></tr></table></figure>
<p>Now you can access the xrdp on Debian 11.</p>
<h3 id="access-debian-remote-desktop">Access Debian Remote Desktop</h3>
<p>On your Windows client, open the RDP client and enter the IP address
of the Debian system.</p>
<p>You can launch the RDP client by typing the “mstsc” in the Run window
or command line.</p>
<figure>
<img
src="https://orcacore.com/wp-content/uploads/2021/11/remote-desktop-connection.webp"
alt="XRP on Debian11-remote desktop connection" />
<figcaption aria-hidden="true">XRP on Debian11-remote desktop
connection</figcaption>
</figure>
<p>It will ask for a warning message that the remote system is unknown
to your system.</p>
<p>Click the “Don’t ask me again for connection to this computer” and
click Yes to continue.</p>
<figure>
<img
src="https://orcacore.com/wp-content/uploads/2021/11/remote-warning.webp"
alt="Remote desktop connection warning" />
<figcaption aria-hidden="true">Remote desktop connection
warning</figcaption>
</figure>
<p>Now enter the login credentials of the remote Debian system to get
remote desktop access:</p>
<figure>
<img
src="https://orcacore.com/wp-content/uploads/2021/11/Ubuntu-credentials.webp"
alt="Debian 11 login credentials" />
<figcaption aria-hidden="true">Debian 11 login credentials</figcaption>
</figure>
<p>When you have logged in you will see:</p>
<p><a
href="https://orcacore.com/wp-content/uploads/2021/11/desktop-env-debian11.webp"><img
src="https://orcacore.com/wp-content/uploads/2021/11/desktop-env-debian11.webp"
alt="Debian 11 desktop environment with Xrdp" /></a></p>
<p>You can now start interacting with the remote XFCE desktop from your
local machine using your keyboard and mouse.</p>
<p>If you are using macOS, you can install the Microsoft Remote Desktop
application from the Mac App Store. Linux users can use an RDP client
such as Remmina or Vinagre.</p>
<h3 id="conclusion">Conclusion</h3>
<p>At this point, you learn to set up a desktop environment
and <strong>install</strong> <strong>XRDP on Debian 11</strong>. Now you
can manage your server from the local desktop machine in a graphical
interface.</p>
<p>Hope you enjoy this part of the <a
href="https://orcacore.com/category/linux/">Linux Tutorials</a> on
the <a href="https://orcacore.com/">orcacore</a> website.</p>
<p>You may be like these articles:</p>
<p><a
href="https://orcacore.com/install-configure-xrdp-almalinux-9/">Install
and Configure XRDP on AlmaLinux 9</a></p>
<p><a
href="https://orcacore.com/install-configure-xrdp-ubuntu-22-04/">Install
and Configure XRDP on Ubuntu 22.04</a></p>
<p><a href="https://orcacore.com/install-xrdp-centos-7/">How To Install
XRDP on Centos 7</a></p>
<p>以下是实验结果，自己安装的是Debian 11 + KDE
桌面环境，其中KDE也是基于X11
图形界面库开发的，所以可以使用XRDP系列的服务。XRDP就是X Remote Desktop
Protocol远程桌面协议，也是Windows的远程桌面连接兼容的桌面协议。</p>
<p>首先开启Debian的图形界面会话管理服务sddm，因为我默认情况下这台Debian是日志服务器，只是用SSH连接，但是这次我需要在上面做操作系统的实验，涉及到Bochs的可视化调试界面，不得不上图形界面了。<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌[fredom@NUC 09:59:10] ~</span><br><span class="line">└$ stl status sddm</span><br><span class="line">● sddm.service - Simple Desktop Display Manager</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/sddm.service; disabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Thu 2023-08-17 09:59:01 HKT; 6min ago</span><br><span class="line">       Docs: man:sddm(1)</span><br><span class="line">             man:sddm.conf(5)</span><br><span class="line">   Main PID: 3326 (sddm)</span><br><span class="line">      Tasks: 12 (limit: 9312)</span><br><span class="line">     Memory: 83.5M</span><br><span class="line">        CPU: 817ms</span><br><span class="line">     CGroup: /system.slice/sddm.service</span><br><span class="line">             ├─3326 /usr/bin/sddm</span><br><span class="line">             └─3338 /usr/lib/xorg/Xorg -nolisten tcp -auth /var/run/sddm/&#123;73f81b5d-fecb-4&gt;</span><br><span class="line"></span><br><span class="line">Aug 17 09:59:01 NUC sddm[3326]: Socket server starting...</span><br><span class="line">Aug 17 09:59:01 NUC sddm[3326]: Socket server started.</span><br><span class="line">Aug 17 09:59:01 NUC sddm[3326]: Loading theme configuration from &quot;/usr/share/sddm/themes/&gt;&quot;</span><br><span class="line">Aug 17 09:59:01 NUC sddm[3326]: Greeter starting...</span><br><span class="line">Aug 17 09:59:01 NUC sddm-helper[3357]: [PAM] Starting...</span><br><span class="line">Aug 17 09:59:01 NUC sddm-helper[3357]: [PAM] Authenticating...</span><br><span class="line">Aug 17 09:59:01 NUC sddm-helper[3357]: [PAM] returning.</span><br><span class="line">Aug 17 09:59:01 NUC sddm-helper[3357]: pam_unix(sddm-greeter:session): session opened for&gt;</span><br><span class="line">Aug 17 09:59:01 NUC sddm[3326]: Greeter session started successfully</span><br><span class="line">Aug 17 09:59:01 NUC sddm[3326]: Message received from greeter: Connect</span><br></pre></td></tr></table></figure></p>
<p>检查sddm桌面环境管理服务没有问题之后，开启xrdp服务，并且根据上面的文章要注意，xrdp服务应该被加入ssl-cert组别来访问本计算机的密钥。<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">● xrdp.service - xrdp daemon</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/xrdp.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Thu 2023-08-17 09:59:07 HKT; 8min ago</span><br><span class="line">       Docs: man:xrdp(8)</span><br><span class="line">             man:xrdp.ini(5)</span><br><span class="line">    Process: 3406 ExecStartPre=/bin/sh /usr/share/xrdp/socksetup (code=exited, status=0/SUCCESS)</span><br><span class="line">    Process: 3414 ExecStart=/usr/sbin/xrdp $XRDP_OPTIONS (code=exited, status=0/SUCCESS)</span><br><span class="line">   Main PID: 3415 (xrdp)</span><br><span class="line">      Tasks: 1 (limit: 9312)</span><br><span class="line">     Memory: 924.0K</span><br><span class="line">        CPU: 5.318s</span><br><span class="line">     CGroup: /system.slice/xrdp.service</span><br><span class="line">             └─3415 /usr/sbin/xrdp</span><br><span class="line"></span><br><span class="line">Aug 17 09:59:31 NUC xrdp[3432]: (3432)(140331499132736)[INFO ] xrdp_wm_log_msg: login successful for display 10</span><br><span class="line">Aug 17 09:59:31 NUC xrdp[3432]: (3432)(140331499132736)[DEBUG] xrdp_wm_log_msg: started connecting</span><br><span class="line">Aug 17 09:59:31 NUC xrdp[3432]: (3432)(140331499132736)[INFO ] lib_mod_log_peer: xrdp_pid=3432 connected to X11rdp_pid=3435 X11rdp_uid=1000 X11rdp_gid=1000 client_ip=::ffff:192.168.8.157 c&gt;</span><br><span class="line">Aug 17 09:59:31 NUC xrdp[3432]: (3432)(140331499132736)[DEBUG] xrdp_wm_log_msg: connected ok</span><br><span class="line">Aug 17 09:59:31 NUC xrdp[3432]: (3432)(140331499132736)[DEBUG] xrdp_mm_connect_chansrv: chansrv connect successful</span><br><span class="line">Aug 17 09:59:31 NUC xrdp[3432]: (3432)(140331499132736)[DEBUG] Closed socket 18 (AF_INET6 ::1 port 39472)</span><br><span class="line">Aug 17 10:00:35 NUC xrdp[3432]: (3432)(140331499132736)[DEBUG] Closed socket 12 (AF_INET6 ::ffff:192.168.8.73 port 3389)</span><br><span class="line">Aug 17 10:00:35 NUC xrdp[3432]: (3432)(140331499132736)[DEBUG] xrdp_mm_module_cleanup</span><br><span class="line">Aug 17 10:00:35 NUC xrdp[3432]: (3432)(140331499132736)[DEBUG] Closed socket 19 (AF_UNIX)</span><br><span class="line">Aug 17 10:00:35 NUC xrdp[3432]: (3432)(140331499132736)[DEBUG] Closed socket 20 (AF_UNIX)</span><br></pre></td></tr></table></figure></p>
<p>确定xrdp服务也开启了之后，再检查防火墙有没有阻拦xrdp服务监听的3389端口。然后在Windows下（一般需要Windows专业版才有远程桌面连接服务，这里白嫖了学校的Win10
专业版许可证）打开远程桌面连接，无需配置端口，只需要指定Debian主机在当前路由器下的局域网地址即可连接，虽然连接上之后画面传输比较卡，不过还是能凑合着用，可能因为两台主机都是通过路由器的无线传输吧，或者可以在Windows的远程桌面连接中把画质调低一些。<br />
![[Pasted image 20230817101048.png]]<br />
![[Pasted image 20230817101534.png]]</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用fuzzy finder增强查找</title>
    <url>/blog/2023/10/11/data/linux/%E4%BD%BF%E7%94%A8fuzzy%20finder%E5%A2%9E%E5%BC%BA%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><a
href="%5BFuzzy%20finder(fzf+vim)%20使用全指南%20(keelii.com)%5D(https://keelii.com/2018/08/12/fuzzy-finder-full-guide)">文章来源</a></p>
<h2 id="简介">简介</h2>
<p><a href="https://github.com/junegunn/fzf">Fuzzy finder</a> 是一款使用
GO 语言编写的交互式的 Unix
命令行工具。可以用来查找任何 <strong>列表</strong> 内容，文件、Git
分支、进程等。所有的命令行工具可以生成列表输出的都可以再通过管道 pipe 到
fzf 上进行搜索和查找</p>
<h2 id="优点">优点</h2>
<ul>
<li>GO 语言编写，编译完生成可执行文件没有任何依赖<br />
</li>
<li>搜索/查找速度飞快<br />
</li>
<li>功能全面/可视化界面体验很棒<br />
</li>
<li>周边插件丰富 (vim, tmux, fuzzy auto-completion)</li>
</ul>
<h2 id="安装">安装</h2>
<p>参考<strong>FZF</strong>的<a
href="%5Bjunegunn/fzf:%20:cherry_blossom:%20A%20command-line%20fuzzy%20finder%20(github.com)%5D(https://github.com/junegunn/fzf/tree/master)">github仓库地址</a>中，给出的安装指示</p>
<h2 id="使用">使用</h2>
<p>命令行下执行 <code>fzf</code> 即可展示当前目录下所有文件列表，可以用键盘上下键或者鼠标点出来选择 <img
src="https://img10.360buyimg.com/devfe/jfs/t26002/277/432949068/59208/9725245b/5b6fc71fN03036763.png"
alt="fzf-normal" /><br />
或许你会觉得这个查找提示看起来挺漂亮的，但是并没有什么卵用，因为查找出来就没有然后了。其实这也是
Fuzzy finder
最核心的地方，他只是一个通用的下拉查找功能，自己本身并不关心你用它来做什么，通常我们需要组合使用才会有很好的效果</p>
<p>或许你会觉得这个查找提示看起来挺漂亮的，但是并没有什么卵用，因为查找出来就没有然后了。其实这也是
Fuzzy finder
最核心的地方，他只是一个通用的下拉查找功能，自己本身并不关心你用它来做什么，通常我们需要组合使用才会有很好的效果</p>
<h3 id="用-vim-打开文件">用 vim 打开文件</h3>
<p>比如我们用 vim 组合 fzf 来查找并打开目录下的文件：<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim $(fzf)</span><br></pre></td></tr></table></figure></p>
<figure>
<img
src="https://img30.360buyimg.com/devfe/jfs/t25372/5/461999989/83158/3ce44a5/5b6fc7f2Nd6432499.gif"
alt="fzf-vim" />
<figcaption aria-hidden="true">fzf-vim</figcaption>
</figure>
<h3 id="切换当前工作目录">切换当前工作目录</h3>
<p>再比如进入到某个文件夹下面，使用 fzf 的过滤选择真是太方便了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> $(find * -<span class="built_in">type</span> d | fzf)</span><br></pre></td></tr></table></figure>
<p>这是个组合 (cd+find+fzf)
命令，完成切换到任意子目录的功能。可以看出来当 fzf
和其它命令组合使用时就能使得一些操作更方便：</p>
<ol type="1">
<li>使用 find 命令找出所有的子目录<br />
</li>
<li>把子目录列表 pipe 到 fzf 上进行选择<br />
</li>
<li>再把结果以子命令的形式传给 cd<br />
<img
src="https://img13.360buyimg.com/devfe/jfs/t23848/96/1951894215/50884/20a513d7/5b6fcabbNb77c46d5.gif"
alt="fzf-find-cd" /></li>
</ol>
<h3 id="切换-git-分支">切换 git 分支</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout $(git branch -r | fzf)</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://img10.360buyimg.com/devfe/jfs/t23242/262/2000817850/127859/c0955478/5b6fce70N3c3573ae.gif"
alt="fzf-git-branch" />
<figcaption aria-hidden="true">fzf-git-branch</figcaption>
</figure>
<p>不过这样组合使用命令的实在太长了，如果你不使用自动补全的话巧起来很累的。建议把常用的
alias 放在 .zshrc 中管理嘛</p>
<h3 id="shell-命令行补全">shell 命令行补全</h3>
<p>fzf 默认使用 <code>**</code> 来补全 shell 命令，比起默认的 tab
补全，fzf 补全不知道高到哪里去了。cd, vim, kill, ssh, export...
统统都能补全，好用哭了 🤣</p>
<figure>
<img
src="https://img10.360buyimg.com/devfe/jfs/t24820/280/435378103/490486/3777afba/5b6fedc6N59529380.gif"
alt="fzf-completion" />
<figcaption aria-hidden="true">fzf-completion</figcaption>
</figure>
<h2 id="配置">配置</h2>
<p>fzf 提供了两个 <em>环境变量</em> 配置参数，来分别设置默认的调用命令和
fzf 默认配置参数</p>
<h3 id="核心命令-fzf_default_command">核心命令 FZF_DEFAULT_COMMAND</h3>
<p>对于使用 fzf 来查找文件的情况，fzf 其实底层是调用的 Unix
系统 <code>find</code> 命令，如果你觉得 find
不好用也可以使用其它查找文件的命令行工具「我使用 <a
href="https://github.com/sharkdp/fd">fd</a>」。注意：对原始命令添加一些参数应该在这个环境变量里面添加</p>
<p>比如说我们一般都会查找文件 <code>-type f</code>，通常会忽略一些文件夹/目录 <code>--exclude=...</code>，下面是我的变量值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FZF_DEFAULT_COMMAND=<span class="string">&quot;fd --exclude=&#123;.git,.idea,.vscode,.sass-cache,node_modules,build&#125; --type f&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="界面展示-fzf_default_opts">界面展示 FZF_DEFAULT_OPTS</h3>
<p>界面展示这些参数在 <code>fzf --help</code> 中都有，按需配置即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FZF_DEFAULT_OPTS=<span class="string">&quot;--height 40% --layout=reverse --preview &#x27;(highlight -O ansi &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<p>界面配置参数加上后就漂亮多了 <a
href="https://img11.360buyimg.com/devfe/jfs/t24178/228/1983729650/93496/412c5c52/5b6fd697N0d686b66.png"><img
src="https://img11.360buyimg.com/devfe/jfs/t24178/228/1983729650/93496/412c5c52/5b6fd697N0d686b66.png"
alt="fzf-with-preview" /></a></p>
<p><code>--preview</code> 表示在右侧显示文件的预览界面，语法高亮的设置使用了 <a
href="http://www.andre-simon.de/doku/highlight/en/highlight.php">highlight</a> 如果
highlight 失败则使用最常见的 <code>cat</code> 命令来查看文件内容</p>
<p>highlight 安装可能会有个小插曲。highlight
需要手动编译安装，默认安装目录在 <code>/usr/bin</code>, <code>/usr/share</code> 下面。然而在
macOS 中由于 SIP 保护，用户安装的程序不能在这几个目录下面「即使有 sudo
权限也不行」。我们可以手动更改下 highlight 源代码中 makefile
中的参数即可</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PREFIX = /usr</span></span><br><span class="line">PREFIX = /usr/local</span><br></pre></td></tr></table></figure>
<p>将 <code>PREFIX = /usr</code> 改成 <code>PREFIX = /usr/local</code>，然后 <code>make</code>，<code>sudo make install</code> 就可以了</p>
<h3 id="触发命令行补全-fzf_completion_trigger">触发命令行补全
FZF_COMPLETION_TRIGGER</h3>
<p>默认是 <code>**</code>，一般不用修改</p>
<h2 id="vim-fzf-插件">VIM fzf 插件</h2>
<p>如果你使用 vim，那么官方提供的插件会让你的 vim 使用更加流畅</p>
<h3 id="安装插件">安装插件</h3>
<p>如果你本地安装过 fzf 命令行工具了，只需要在 .vimrc
里面添加下面两个插件配置即可</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">&#x27;/usr/local/opt/fzf&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;junegunn/fzf.vim&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意：使用了 <a
href="https://github.com/junegunn/vim-plug">vim-plug</a> 插件管理</p>
<p>插件主要对 fzf 集成绑定了一些和 vim 相关的功能，比如：查找当前
Buffer、Tag、Marks。甚至切换 window 更换 vim 主题配色等</p>
<p>命令模式下敲 <code>Files</code> 即可选择当前目录下所有文件，<code>Buffers</code> 可以过滤当前所有
vim buffer 内容</p>
<figure>
<img
src="https://img10.360buyimg.com/devfe/jfs/t25240/349/434572567/558564/433c151a/5b6fdfadNfd6ea407.gif"
alt="fzf-vim-plugin" />
<figcaption aria-hidden="true">fzf-vim-plugin</figcaption>
</figure>
<p>再配置几个常用快捷键就可以直接取代 CtrlP 插件了 🤔</p>
<ul>
<li>Ctrl + p 查看文件列表<br />
</li>
<li>Ctrl + e 查看当前 Buffer，两次 Ctrl + e 快速切换上次打开的
Buffer</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-p&gt;</span> :Files<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-e&gt;</span> :Buffers<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:fzf_action</span> = &#123; <span class="string">&#x27;ctrl-e&#x27;</span>: <span class="string">&#x27;edit&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="结语">结语</h3>
<p>当然 fzf
还可以在很多其它场景下用来。如果你想使用可视化的列表选择而不是咣咣敲命令，那就自己搭配一些组合来使用吧</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nmtui可视化命令行界面连接WIFI</title>
    <url>/blog/2023/10/11/data/linux/%E4%BD%BF%E7%94%A8nmtui%E5%8F%AF%E8%A7%86%E5%8C%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5WIFI/</url>
    <content><![CDATA[<p>使用该命令可以以字符界面环境可视化网络配置，十分便捷。但是使用时一般是要通过sudo提权使用，这样配置才能在每次重启之后都能生效。</p>
<p>可以配置已经连接的网络，比如以太网和无线网<br />
![[Pasted image 20230814224740.png]]</p>
<p>可以连接其他网络，比如能检测到的以太网和无线网<br />
![[Pasted image 20230814224833.png]]</p>
<p>需要注意的是，在命令行（虚拟终端，virtual
terminal，也称作VT）环境下登录用户账户，是无法使用在桌面环境下登录用户时创建的密钥环的。也就是说，桌面环境下连接的WIFI默认是不对其他用户开放此链接，所以在命令行下，无法自动复用桌面环境下的WIFI连接，因为WIFI连接一般需要密码，而密钥环又是不可用的。</p>
<p>所以我们可以在 nmtui 中选择 Edit
修改当前已检测到网络连接，删除已有的WIFI连接，然后在命令行环境下，使用
<code>sudo nmtui</code> ，<code>activate</code>
去连接检测到的网络，此时就是默认勾选了允许所有用户检测到此链接并复用了。<br />
![[Pasted image 20230814231306.png]]</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tmux分离会话和窗口</title>
    <url>/blog/2023/10/11/data/linux/%E4%BD%BF%E7%94%A8tmux%E5%88%86%E7%A6%BB%E4%BC%9A%E8%AF%9D%E5%92%8C%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="tmux是什么">tmux是什么</h2>
<p>tmux是一个 terminal
multiplexer（终端复用器），它可以启动一系列终端会话。</p>
<p>我们使用命令行时，打开一个终端窗口，,会话开始，执行某些命令如npm run
dev，关闭此终端窗口，会话结束，npm run
dev服务会话随之被关闭。有时我们希望我们运行的服务如npm run dev
或者一些cd命令等，被保留，而不是关闭窗口再打开后，重新手动执行。tmux的主要用途就在于此。</p>
<p>它解绑了会话和终端窗口。关闭终端窗口再打开，会话并不终止，而是继续运行在执行。将会话与终端窗后彻底分离。</p>
<h2 id="用法">用法</h2>
<h3 id="安装">安装</h3>
<p>tmux使用c语言实现的，<a
href="https://link.zhihu.com/?target=https%3A//github.com/tmux/tmux.git">https://github.com/tmux/tmux.git</a>可运行在OpenBSD，FreeBSD,NetBSD,Linux,OS
X,Solaris上。</p>
<h3 id="安装方法一">安装方法一</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tmux/tmux.git</span><br><span class="line">cd tmux</span><br><span class="line">sh autogen.sh</span><br><span class="line">./configure &amp;&amp; make</span><br></pre></td></tr></table></figure>
<h3 id="安装方法二">安装方法二</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Ubuntu 或 Debian</span><br><span class="line">$ sudo apt-get install tmux</span><br><span class="line"></span><br><span class="line"># CentOS 或 Fedora</span><br><span class="line">$ sudo yum install tmux</span><br><span class="line"></span><br><span class="line"># Mac</span><br><span class="line">$ brew install tmux</span><br></pre></td></tr></table></figure>
<h3 id="启动与退出">启动与退出</h3>
<p>讲解使用之前，我们需要先搞清楚窗口与会话的概念。</p>
<p>所谓窗口，其实就是我们终端打开的一个tab，如终端里面所操作的命令、启动的服务，为会话，如下图所示：</p>
<p><img
src="https://pic1.zhimg.com/80/v2-62e1282f8bccee854c455c9a3e289538_720w.webp" /></p>
<p>在理解了窗口和会话的观念上，我们介绍下tmux使用。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 启动tmux</span><br><span class="line">$ tmux</span><br><span class="line"></span><br><span class="line"># 退出</span><br><span class="line">$ exit 或 Ctrl+D</span><br></pre></td></tr></table></figure>
<p>在终端窗口上，运行tmux，其实就打开了一个终端与tmux服务的会话。只不过我们可以在tmux会话上层，再次输入’会话‘命令，使tmux上层运行的'会话'与终端窗口进行分离。这里面tmux其实可以称之为伪窗口（它其实是会话）。</p>
<p>启动tmux后，底部[0]
表示第0个tmux伪窗口，再启动一个tmux伪窗口，则为[1],依次递增。</p>
<p><img
src="https://pic2.zhimg.com/80/v2-98d5263e542fdb45bf543b5fa5e78f41_720w.webp" /></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 启动命名tmux</span><br><span class="line">$ tmux new -s &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>底部不再是数字，而是命名的名字，如下图</p>
<p><img
src="https://pic4.zhimg.com/80/v2-0ce6aedcf3812612f17d302ab1016d9b_720w.webp" /></p>
<h3 id="分离会话">分离会话</h3>
<p>在会话窗口上，执行<code>cd demo</code>操作后，再执行<code>tmux detach</code>，可见退出了tmux伪窗口</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 分离会话</span><br><span class="line">$ tmux detach</span><br></pre></td></tr></table></figure>
<p>执行<code>tmux ls</code>可看到当前所有的tmux伪窗口。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-695c424b8638dc60c1f8e09c709be89e_720w.webp" /></p>
<h3 id="重接会话">重接会话</h3>
<p>我们通过<code>tmux detach</code>关闭tmux伪窗口后，希望能再次进入某一个会话窗口，怎么操做？</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 重接会话 使用伪窗口编号</span><br><span class="line">$ tmux attach -t 0</span><br><span class="line"></span><br><span class="line"># 重接会话 使用伪窗口名称</span><br><span class="line">$ tmux attach -t xiaoqi</span><br></pre></td></tr></table></figure>
<h3 id="杀死会话">杀死会话</h3>
<p>有时候我们想彻底关闭某个会话，不想让其再执行，怎么操作?</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 使用会话编号</span><br><span class="line">$ tmux kill-session -t 0</span><br><span class="line"></span><br><span class="line"># 使用会话名称</span><br><span class="line">$ tmux kill-session -t &lt;name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="切换会话">切换会话</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 使用会话编号</span><br><span class="line">$ tmux switch -t 0</span><br><span class="line"></span><br><span class="line"># 使用会话名称</span><br><span class="line">$ tmux switch -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="重命名会话">重命名会话</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux rename-session -t 0 &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="其他命令">其他命令</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 列出所有快捷键，及其对应的 Tmux 命令</span><br><span class="line">$ tmux list-keys</span><br><span class="line"></span><br><span class="line"># 列出所有 Tmux 命令及其参数</span><br><span class="line">$ tmux list-commands</span><br><span class="line"></span><br><span class="line"># 列出当前所有 Tmux 会话的信息</span><br><span class="line">$ tmux info</span><br><span class="line"></span><br><span class="line"># 重新加载当前的 Tmux 配置</span><br><span class="line">$ tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>
<p>好了，到这里，tmux的基本用法已经全部掌握了，可以愉快的使用了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>修改主机名</title>
    <url>/blog/2023/10/11/data/linux/%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
    <content><![CDATA[<p>这篇指南讲解如何在 Ubuntu 20.04
上设置或者改变主机名，而不需要重新启动系统。</p>
<h2 id="一理解主机名">一、理解主机名</h2>
<p>一个主机名就是在网络上标记一个设备的标签名称。在同一个网络中，你不应该有两台或者更多机器拥有同样的主机名。</p>
<p>在 Ubuntu
中，你可以使用hostnamectl命令编辑系统主机名以及相关设置。这个工具识别三种不同的主机名：</p>
<p>static -
传统主机名。它存储在/etc/hostname文件中，并且可以被用户设置</p>
<p>pretty - 一个自由形态的 UTF8 主机名，用来代表用户。例如： Linuxize's
desktop。</p>
<p>transient - 由 kernel 维护的动态主机名。 在运行过程中，DHCP 或者 mDNS
<a
href="https://cloud.tencent.com/product/cvm?from=20065&amp;from_column=20065">服务器</a>可以改变
transient 主机名。默认情况下，它和 static 主机名一模一样。</p>
<p>我们强烈推荐使用完整<a
href="https://cloud.tencent.com/act/pro/domain-sales?from=20065&amp;from_column=20065">域名</a>(<a
href="https://kb.iu.edu/d/aiuv">FQDN</a>)来设置static和transient名称，例如host.example.com。</p>
<p>仅仅 root 或者有 sudo 权限的用户可以修改系统主机名。</p>
<h2 id="二显示当前主机名">二、显示当前主机名</h2>
<p>想要查看当前主机名，运行hostnamectl命令，不带任何参数：</p>
<p>hostnamectl复制</p>
<figure>
<img
src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAl0AAACuCAIAAACDeS/iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAVkSURBVHhe7d3tThN5GMbhtlBQCGQFFV3Z4omgxw6eSdWgri8IAkKhLNsZubGilNpp2nhdacIzD/1KfmT6H6g/3WjVAICeRvkVANBFALgq91G3tl8UAwD8mZ4/2/yui62WzxoB+EO12+2LLrqPCgChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABC6CAChiwAQuggAoYsAELoIAKGLABD1pxutYtraftFqlTMwpK97Hw9Py3lcZhdWlu+UMzC0drv9/NmmLsJIfdpp73fKeVyaS63H98oZGJouQgV6Xaw37y7Oz5SbKp0dHxx1znURRkIXoQK9Ljburq4/WCw3VTr499WHo64uwkgUXXTuBgBCFwEgdBGmwMnum9cv2xdevtr5cHheboEK6CJMvM6HD3snZ70annc7B7vvj3proAq6CONzvv/+zdvdk/JqYCfds3LqOT39Wk7A6OkijMlFFHc+H54c7727bRrnGt898zE76yF+qI4uwjgUUTztNhqNWve2aWyuri7NNeq9uTG7sHT/bm8EqqCLULnLKDYXV548/Gt+5tZpnLv3aH398dra43/W/76/VBQSqIQuQrWuRvHR6kJ9bnntwTBprNWb8/NNSYSq6SJUqD+KxXboNALV00WoyvVRLEgjTCpdhEr8KoqFQdN4svv2zft9z/LDmOgiVOD0yw1RLNycxosovts7Pjn8vCONMB66CKPX7RzfHMXCr9JYRLFbazQa3VNphPHQRajCYFEsXJ/Gb1Gcmf/r4ZOVxaY0wnjoIoxefX550CgW+tN4JYoP1pbn6gurj6QRxkMXYfTqjZlbRLFwNY2vr0ax+LY0wpjoIkyMyzSedWv1uaVEsSCNMA66CJPkWxpr5ycHn348oSqNUDldhAlz/TGcS9+l8ctpuQVGRRdh8gycxuNOt9wBI6KLMJEGTGN5CYyMHyuYVAOkcXn+1udegV/TRZhgN6VxpvxvxcDI1J9utIppa/tFq1XOwJA+7bT3O/Xm3cWLmo1Kt3N0dHx2XmvMLSzMffe77NnxwVHnvLnUenyv3ABDa7fbz59t6iKMVK+L5TwuuggjoYtQga97Hw/H/fDE7MLK8p1yBoamiwAQRRedu4GpVa////rRz/bAAHQRptNl+foS+LM9MBhdhOl0fuWPo17bwqtvAAamizC1+tIoijAKugjT7Nr+iSL8Bl2EKddXQVGE36OLMOX6ztf0XQK3pIswza6toDTCb9BFmFp9B22u3kGVRhiWLsJ06oti33BBGmEougjT6doWXvjZHhiMLsLUuijftfH72R4YgC4CQOgiAIQuAkDoIgCELgJA6CIAhC4CQOgiAIQuAkDoIgCELgJA6CIAhC4CQOgiAIQuAkDoIgCELgJA6CIAhC4CQOgiAIQuAkDoIgCELgJA6CIAhC4CQOgiAIQuAkDoIgCELgJA6CIAhC4CQOgiAIQuAkDoIgCELgJA6CIAhC4CQOgiAIQuAkDoIgCELgJA6CIAhC4CQOgiAIQuAkDoIgCELgJA6CIAhC4CQOgiAIQuAkDoIgCELgJA6CIAhC4CQOgiAET96UarmLa2XxQDAPyZnj/bTBcBAPdRAeCbWu0/wNL4ES5cYh8AAAAASUVORK5CYII="
alt="danny@ubuntuaøøg : static hostname: Icon name: Chassis: Machine ID: Boot ID: Virtualization : operating system: Kernel : Architecture: hostnamectl ubuntu2004. local host computer-vm aeoe3543f3da4692914926b7c!41e87aed aa51b274703440dfb622ef2bd80cncb oracle Ubuntu 20.04 L TS Linux 5. 4.0-26-generic X86-614" />
<figcaption aria-hidden="true">danny@ubuntuaøøg : static hostname: Icon
name: Chassis: Machine ID: Boot ID: Virtualization : operating system:
Kernel : Architecture: hostnamectl ubuntu2004. local host computer-vm
aeoe3543f3da4692914926b7c!41e87aed aa51b274703440dfb622ef2bd80cncb
oracle Ubuntu 20.04 L TS Linux 5. 4.0-26-generic X86-614</figcaption>
</figure>
<p>在这个例子中，当前主机名被设置为：ubuntu2004.localdomain。</p>
<h2 id="三修改系统主机名">三、修改系统主机名</h2>
<p>修改系统主机名是一个简单的过程，语法如下：</p>
<p>sudo hostnamectl set-hostname host.example.com<br />
sudo hostnamectl set-hostname "Your Pretty HostName" --pretty<br />
sudo hostnamectl set-hostname host.example.com --static<br />
sudo hostnamectl set-hostname host.example.com --transient</p>
<p>例如，想要修改系统今天主机名到neptune.linuxize.com,你可以使用下面的命令：</p>
<p>sudo hostnamectl set-hostname neptune.linuxize.com</p>
<p>你也可以设置 pretty 主机名：</p>
<p>sudo hostnamectl set-hostname "Linuxize's laptop" --pretty</p>
<p>hostnamectl不产生任何输出。如果成功，返回0，否则，返回一个非0错误码。</p>
<p>静态主机名被存储在/etc/hostname,并且 pretty
主机名被存储在/etc/machine-info文件。</p>
<p>你不应该在同样的网络不同的机器上使用相同的主机名。</p>
<p>在大多数系统中，主机名在/etc/hosts中被映射到127.0.0.1。打开文件，并且修改旧的主机名到新的主机名。</p>
<p>127.0.0.1   localhost127.0.0.1   neptune.linuxize.com</p>
<h1
id="the-following-lines-are-desirable-for-ipv6-capable-hosts1-localhost-ip6-localhost-ip6-loopback">The
following lines are desirable for IPv6 capable hosts::1     localhost
ip6-localhost ip6-loopback</h1>
<p>ff02::1 ip6-allnodes<br />
ff02::2 ip6-allrouters复制</p>
<p>如果你在一个云实例上运行
Ubuntu，并且安装了cloud-init软件包，你也可以编辑/etc/cloud/cloud.cfg文件。这个软件包由<a
href="https://cloud.tencent.com/product/cvm?from=20065&amp;from_column=20065">云服务器</a>厂商提供，通常默认被安装，并且它可以被用来处理云服务器实例的初始化。</p>
<p>如果文件存在于你的系统上，打开它：</p>
<p>sudo nano /etc/cloud/cloud.cfg复制</p>
<p>搜索"preserve_hostname”,并且将值从false修改到true。</p>
<h1
id="this-will-cause-the-setupdate-hostname-module-to-not-operate-if-true">This
will cause the set+update hostname module to not operate (if true)</h1>
<p>preserve_hostname: true复制</p>
<p>保存文件，并且关闭编辑器。</p>
<h2 id="四验证修改">四、验证修改</h2>
<p>想要验证主机名是否被完全修改，输入hostnamectl命令：</p>
<p>hostnamectl复制</p>
<p>你的新主机名将会在终端上被打印出来。</p>
<p>  Static hostname: neptune.linuxize.com<br />
   Pretty hostname: Linuxize's desktop<br />
         Icon name: computer-vm           Chassis: vm<br />
        Machine ID: a04e3543f3da460294926b7c41e87a0d<br />
           Boot ID: aa31b274703440dfb622ef2bd84c52cb    Virtualization:
oracle<br />
  Operating System: Ubuntu 20.04 LTS            Kernel: Linux
5.4.0-26-generic      Architecture: x86-64复制</p>
<h2 id="五总结">五、总结</h2>
<p>我们已经向你展示如何很简单地在 Ubuntu 20.04
上修改主机名，并且不需要重启机器。</p>
<p>还有很多理由你需要修改主机名。最普遍的理由就是，主机名需要在实例创建的时候进行自动设置。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>修改了主机名后每次sudo都有unable to resolve警告？</title>
    <url>/blog/2023/10/11/data/linux/%E4%BF%AE%E6%94%B9%E4%BA%86%E4%B8%BB%E6%9C%BA%E5%90%8D%E5%90%8E%E6%AF%8F%E6%AC%A1sudo%E9%83%BD%E6%9C%89unable%20to%20resolve%E8%AD%A6%E5%91%8A%EF%BC%9F/</url>
    <content><![CDATA[<p>[fredom@ECS-Tencentyun 16:34:24] ~</p>
<p>$ sudo echo "hello"</p>
<p>sudo: unable to resolve host ECS-Tencentyun: Name or service not
known</p>
<p>hello</p>
<p>这是因为hostnamectl
set-hostname设置了/etc/hostname中主机名的内容，但是却并没有同步更新/etc/hosts的解析，原本/etc/hosts的解析是这样的：</p>
<p>[fredom@ECS-Tencentyun 16:40:58] ~</p>
<p>$ cat /etc/hosts</p>
<h1 id="section"></h1>
<p>127.0.1.1 localhost.localdomain VM-20-16-debian</p>
<p>127.0.0.1 localhost</p>
<p>::1 ip6-localhost ip6-loopback</p>
<p>fe00::0 ip6-localnet</p>
<p>ff00::0 ip6-mcastprefix</p>
<p>ff02::1 ip6-allnodes</p>
<p>ff02::2 ip6-allrouters</p>
<p>ff02::3 ip6-allhosts</p>
<p>可以看到原主机名是可以解析到127.0.0.1这个回环本地地址的，但是更新了主机名为自定义主机名后，这里的主机名并没有同步更新，于是就会发生无法解析该host的错误。把/etc/hosts里127.0.0.1地址对应的主机名更新为当前/etc/hostname的内容即可。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>修改默认终端为bash</title>
    <url>/blog/2023/10/11/data/linux/%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BB%88%E7%AB%AF%E4%B8%BAbash/</url>
    <content><![CDATA[<p>要将默认 shell 设置为 <code>bash</code>，请按照以下步骤操作：</p>
<h3 id="打开终端">1. 打开终端。</h3>
<h3 id="运行以下命令以修改默认-shell">2. 运行以下命令以修改默认
shell：</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure dash</span><br></pre></td></tr></table></figure>
<h3 id="在弹出的对话框中选择-no-以将-binsh-设置为-bash">3.
在弹出的对话框中，选择 "No"
以将 <code>/bin/sh</code> 设置为 <code>bash</code>。</h3>
<h3 id="再次运行以下命令以更改当前用户的默认-shell">4.
再次运行以下命令以更改当前用户的默认 shell：</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="输入您的用户密码以确认更改">5. 输入您的用户密码以确认更改。</h3>
<h3 id="关闭终端并重新打开一个新的终端窗口">6.
关闭终端并重新打开一个新的终端窗口。</h3>
<p>现在，您的默认 shell
已更改为 <code>bash</code>。每次打开终端时，都会使用 <code>bash</code> 作为默认
shell。请注意，对于其他用户，您需要使用相同的步骤进行更改，因为每个用户可以具有自己的默认
shell 设置。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>删除已停止容器，清理未使用的数据卷</title>
    <url>/blog/2023/10/11/data/linux/%E5%88%A0%E9%99%A4%E5%B7%B2%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8%EF%BC%8C%E6%B8%85%E7%90%86%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
    <content><![CDATA[<p>杀死所有正在运行的容器<br />
docker kill $(docker ps -a -q)</p>
<p>删除所有已经停止的容器<br />
docker rm $(docker ps -a -q)</p>
<p>删除所有未打 dangling 标签的镜像<br />
docker rmi $(docker images -q -f dangling=true)</p>
<p>删除所有镜像<br />
docker rmi $(docker images -q)</p>
<p>强制删除镜像名称中包含“doss-api”的镜像<br />
docker rmi --force $(docker images | grep doss-api | awk '{print
$3}')</p>
<p>删除所有未使用数据<br />
docker system prune</p>
<p>只删除未使用的volumes<br />
docker volume prune</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>压缩和解压缩</title>
    <url>/blog/2023/10/11/data/linux/%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>Linux 系统中，最常用的归档（打包）命令就是
tar，该命令可以将许多文件一起保存到一个单独的磁带或磁盘中进行归档。不仅如此，该命令还可以从归档文件中还原所需文件，也就是打包的反过程，称为解打包。</p>
<p>使用 tar 命令归档的包通常称为 tar 包（tar
包文件都是以“.tar”结尾的）。</p>
<p>tar命令做打包操作</p>
<p>当 tar 命令用于打包操作时，该命令的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 源文件或目录</span><br></pre></td></tr></table></figure>
<p>此命令常用的选项及各自的含义如表 1 所示。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td>选项</td>
<td>含义</td>
</tr>
<tr class="even">
<td>-c</td>
<td>将多个文件或目录进行打包。</td>
</tr>
<tr class="odd">
<td>-A</td>
<td>追加 tar 文件到归档文件。</td>
</tr>
<tr class="even">
<td>-f 包名</td>
<td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td>
</tr>
<tr class="odd">
<td>-v</td>
<td>显示打包文件过程；</td>
</tr>
</tbody>
</table>
<p>表 1 tar 打包命令常用选项及含义</p>
<p>需要注意的是，在使用 tar
命令指定选项时可以不在选项前面输入“-”。例如，使用“cvf”选项和
“-cvf”起到的作用一样。</p>
<p>下面给大家举几个例子，一起看看如何使用 tar 命令打包文件和目录。</p>
<p>【例 1】打包文件和目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把anacondehks.cfg打包为 anacondehks.cfg.tar文件</span></span><br></pre></td></tr></table></figure>
<p>选项 "-cvf"
一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 ".tar"
作为扩展名。打包目录也是如此：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll -d test/</span><br><span class="line"></span><br><span class="line">drwxr-xr-x 2 root root 4096 6月 17 21:09 test/</span><br></pre></td></tr></table></figure>
<p>#test是我们之前的测试目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -cvf test.tar test/</span><br><span class="line"></span><br><span class="line">test/</span><br><span class="line"></span><br><span class="line">test/test3</span><br><span class="line"></span><br><span class="line">test/test2</span><br><span class="line"></span><br><span class="line">test/test1</span><br></pre></td></tr></table></figure>
<p>#把目录打包为test.tar文件</p>
<p>tar命令也可以打包多个文件或目录，只要用空格分开即可。例如:</p>
<p>[root@localhost ~]# tar -cvf ana.tar anaconda-ks.cfg /tmp/</p>
<p>#把anaconda-ks.cfg文件和/tmp目录打包成ana.tar文件包</p>
<p>【例 2】打包并压缩目录。</p>
<p>首先声明一点，压缩命令不能直接压缩目录，必须先用 tar
命令将目录打包，然后才能用 gzip 命令或 bzip2
命令对打包文件进行压缩。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#ll -d test test.tar</span><br><span class="line"></span><br><span class="line">drwxr-xr-x 2 root root 4096 6月 17 21:09 test</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root 10240 6月 18 01:06 test.tar</span><br></pre></td></tr></table></figure>
<p>#我们之前已经把test目录打包成test.tar文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# gzip test.tar</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll test.tar.gz</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root 176 6月 18 01:06 test.tar.gz</span><br></pre></td></tr></table></figure>
<p>#gzip命令会把test.tar压缩成test.tar.gz</p>
<p>tar命令做解打包操作</p>
<p>当 tar 命令用于对 tar 包做解打包操作时，该命令的基本格式如下：</p>
<p>[root@localhost ~]#tar [选项] 压缩包</p>
<p>当用于解打包时，常用的选项与含义如表 2 所示。</p>
<table>
<tbody>
<tr class="odd">
<td>选项</td>
<td>含义</td>
</tr>
<tr class="even">
<td>-x</td>
<td>对 tar 包做解打包操作。</td>
</tr>
<tr class="odd">
<td>-f</td>
<td>指定要解压的 tar 包的包名。</td>
</tr>
<tr class="even">
<td>-t</td>
<td>只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td>
</tr>
<tr class="odd">
<td>-C 目录</td>
<td>指定解打包位置。</td>
</tr>
<tr class="even">
<td>-v</td>
<td>显示解打包的具体过程。</td>
</tr>
</tbody>
</table>
<p>表 2 tar 解打包常用选项及含义</p>
<p>其实解打包和打包相比，只是把打包选项 "-cvf" 更换为
"-xvf"。我们来试试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -xvf anaconda-ks.cfg. tar</span><br></pre></td></tr></table></figure>
<p>#解打包到当前目录下</p>
<p>如果使用 "-xvf"
选项，则会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用
"-C(大写)" 选项。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -xvf test.tar -C /tmp</span><br></pre></td></tr></table></figure>
<p>#把文件包test.tar解打包到/tmp/目录下</p>
<p>如果只想查看文件包中有哪些文件，则可以把解打包选项 "-x"
更换为测试选项 "-t"。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -tvf test.tar</span><br><span class="line"></span><br><span class="line">drwxr-xr-x root/root 0 2016-06-17 21:09 test/</span><br><span class="line"></span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test3</span><br><span class="line"></span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test2</span><br><span class="line"></span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test1</span><br></pre></td></tr></table></figure>
<p>#会用长格式显示test.tar文件包中文件的详细信息</p>
<p>tar命令做打包压缩（解压缩解打包）操作</p>
<p>你可能会觉得 Linux 实在太不智能了，一个打包压缩，居然还要先打包成
".tar" 格式，再压缩成 ".tar.gz" 或 ".tar.bz2" 格式。其实 tar
命令是可以同时打包压缩的，前面的讲解之所打包和压缩分开，是为了让大家了解在
Linux 中打包和压缩的不同。</p>
<p>当 tar 命令同时做打包压缩的操作时，其基本格式如下：</p>
<p>[root@localhost ~]#tar [选项] 压缩包 源文件或目录</p>
<p>此处常用的选项有以下 2 个，分别是：</p>
<ul>
<li>-z：压缩和解压缩 ".tar.gz" 格式；<br />
</li>
<li>-j：压缩和解压缩 ".tar.bz2"格式。</li>
</ul>
<p>【例 1】压缩与解压缩 ".tar.gz"格式。</p>
<p>[root@localhost ~]# tar -zcvf tmp.tar.gz /tmp/</p>
<p>#把/temp/目录直接打包压缩为".tar.gz"格式，通过"-z"来识别格式，"-cvf"和打包选项一致</p>
<p>解压缩也只是在解打包选项 "-xvf" 前面加了一个 "-z" 选项。</p>
<p>[root@localhost ~]# tar -zxvf tmp.tar.gz</p>
<p>#解压缩与解打包".tar.gz"格式</p>
<p>前面讲的选项 "-C" 用于指定解压位置、"-t"
用于查看压缩包内容，在这里同样适用。</p>
<p>【例 2】压缩与解压缩 ".tar.bz2" 格式。</p>
<p>和".tar.gz"格式唯一的不同就是"-zcvf"选项换成了
"-jcvf"，如下所示：</p>
<p>[root@localhost ~]# tar -jcvf tmp.tar.bz2 /tmp/</p>
<p>#打包压缩为".tar.bz2"格式，注意压缩包文件名</p>
<p>[root@localhost ~]# tar -jxvf tmp.tar.bz2</p>
<p>#解压缩与解打包".tar.bz2"格式</p>
<p>把文件直接压缩成".tar.gz"和".tar.bz2"格式，才是 Linux
中最常用的压缩方式，这是大家一定要掌握的压缩和解压缩方法。</p>
<p>tar
命令最初被用来在磁带上创建备份，现在可以在任何设备上创建备份。利用 tar
命令可以把一大堆的文件和目录打包成一个文件，这对于备份文件或是将几个文件组合成为一个文件进行网络传输是非常有用的。</p>
<p>压缩命令</p>
<p>tar -zcvf 文件名.tar.gz 要压缩的文件/文件夹</p>
<p>例如，把webfile目录（包括里面的文件）压缩为webfile.tar.gz，命令：tar
-zcvf webfile.tar.gz webfile</p>
<p>解压</p>
<p>tar –xvf file.tar //解压 tar包</p>
<p>tar -xzvf file.tar.gz //解压tar.gz</p>
<p>tar -xjvf file.tar.bz2   //解压 tar.bz2</p>
<p>tar –xZvf file.tar.Z   //解压tar.Z</p>
<p>unrar e file.rar //解压rar</p>
<p>unzip file.zip //解压zip</p>
<p>总结</p>
<p>1、*.tar 用 tar –xvf 解压</p>
<p>2、*.gz 用 gzip -d或者gunzip 解压</p>
<p>3、<em>.tar.gz和</em>.tgz 用 tar –xzf 解压</p>
<p>4、*.bz2 用 bzip2 -d或者用bunzip2 解压</p>
<p>5、*.tar.bz2用tar –xjf 解压</p>
<p>6、*.Z 用 uncompress 解压</p>
<p>7、*.tar.Z 用tar –xZf 解压</p>
<p>8、*.rar 用 unrar e解压</p>
<p>9、*.zip 用 unzip 解压</p>
<p>chown用来更改某个目录或文件的用户名和用户组</p>
<p>chown 用户名:组名 文件路径（可以是绝对路径也可以是相对路径）</p>
<p>例如：</p>
<p>chown root:root /var/lib/nginx</p>
<p>就是把/var/lib下的nginx的用户组改成root用户组下面的root用户(只修改了nginx的属于的用户名)</p>
<p>chown -R root:root /var/lib/nginx</p>
<p>就是把/var/lib下的nginx所有文件的用户组改成root用户组下面的root用户</p>
<p>chmod用来修改某个目录或文件的访问权限</p>
<p>语法：</p>
<p>chmod [-cfvR] [—help] [—version] [who] [+|-|==] [model]文件名</p>
<p>例如：</p>
<p>chmod -R 777 /var/lib/nginx</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>后台运行hexo</title>
    <url>/blog/2023/10/11/data/linux/%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8Chexo/</url>
    <content><![CDATA[<p>折腾了大半天的 systemd
service，修改了好多地方参考了好多其他人的服务文件，始终是无法启动，总是进程退出，实在没办法只能找其他方法了，好在在中文社区找到了这篇博客，并且这个方法能用，在这里记录下来</p>
<p>hexo是一个非常高效的博客，但由于其设计特点，目的是为了转换为静态页面，因此不必要一直在后台运行，但是我想随时随地写博客同步到github，使用hexo
admin编辑器，这就需要hexo一直在后台运行，于是在网上找到了pm2托管的方式。</p>
<p>首先安装pm2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ npm  install -g pm2</span><br></pre></td></tr></table></figure>
<p>第二步，写一个运行脚本，在博客根目录下面创建一个<strong>hexo_run.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//run</span></span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="title function_">exec</span>(<span class="string">&#x27;hexo server&#x27;</span>,<span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(error)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exec error: $&#123;error&#125;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stdout: $&#123;stdout&#125;&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stderr: $&#123;stderr&#125;&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第三步，cd到博客根目录下运行脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># pm2 start hexo_run.<span class="property">js</span></span><br></pre></td></tr></table></figure>
<p>但是不知道为什么，我安装pm2这个包 <code>npm install</code>
了两次，但好在是能用这种方法把hexo博客挂在后台了，唉......<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌[fredom@hcss-ecs-1c01 00:26:50] ~/workspace/web/html</span><br><span class="line">└&gt; pm2 start nohup_hexo.js </span><br><span class="line">[PM2] Spawning PM2 daemon with pm2_home=/home/fredom/.pm2</span><br><span class="line">[PM2] PM2 Successfully daemonized</span><br><span class="line">[PM2] Starting /home/fredom/workspace/web/html/nohup_hexo.js in fork_mode (1 instance)</span><br><span class="line">[PM2] Done.</span><br><span class="line">┌────┬───────────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐</span><br><span class="line">│ id │ name          │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │</span><br><span class="line">├────┼───────────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤</span><br><span class="line">│ 0  │ nohup_hexo    │ default     │ 0.0.0   │ fork    │ 168176   │ 0s     │ 0    │ online    │ 0%       │ 37.1mb   │ fredom   │ disabled │</span><br><span class="line">└────┴───────────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴─────────</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>在bash脚本中使用带颜色的输出前缀</title>
    <url>/blog/2023/10/11/data/linux/%E5%9C%A8bash%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%B8%A6%E9%A2%9C%E8%89%B2%E7%9A%84%E8%BE%93%E5%87%BA%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define color codes</span></span><br><span class="line">RED=<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">GREEN=<span class="string">&#x27;\033[0;32m&#x27;</span></span><br><span class="line">YELLOW=<span class="string">&#x27;\033[1;33m&#x27;</span></span><br><span class="line">NC=<span class="string">&#x27;\033[0m&#x27;</span> <span class="comment"># No Color</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to print INFO logs</span></span><br><span class="line"><span class="function"><span class="title">info</span></span>() &#123;</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>[INFO]<span class="variable">$&#123;NC&#125;</span> <span class="variable">$1</span>\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to print WARNING logs</span></span><br><span class="line"><span class="function"><span class="title">warn</span></span>() &#123;</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&quot;<span class="variable">$&#123;YELLOW&#125;</span>[WARN]<span class="variable">$&#123;NC&#125;</span> <span class="variable">$1</span>\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to print ERROR logs</span></span><br><span class="line"><span class="function"><span class="title">error</span></span>() &#123;</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&quot;<span class="variable">$&#123;RED&#125;</span>[ERROR]<span class="variable">$&#123;NC&#125;</span> <span class="variable">$1</span>\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example usage</span></span><br><span class="line">info <span class="string">&quot;This is an information message.&quot;</span></span><br><span class="line">warn <span class="string">&quot;This is a warning message.&quot;</span></span><br><span class="line">error <span class="string">&quot;This is an error message.&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样，我们可以提供更加人性化的信息输出。<br />
![[Pasted image 20230930123311.png]]</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在crontab定时任务中使用sudo</title>
    <url>/blog/2023/10/11/data/linux/%E5%A6%82%E4%BD%95%E5%9C%A8crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8sudo/</url>
    <content><![CDATA[<p>实际上这是不现实的，对于需要sudo权限的命令，都必须手动输入密码，但是crontab没有交互式消息弹出。最好的办法是使用root用户设置crontab任务，而不是普通用户设置crontab任务</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>将FRP穿透作为系统服务</title>
    <url>/blog/2023/10/11/data/linux/%E5%B0%86FRP%E7%A9%BF%E9%80%8F%E4%BD%9C%E4%B8%BA%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>这个示例将会演示在 Linux 系统下使用 systemd 控制 frps
及配置开机自启。</p>
<p>在 Linux 系统下，使用<code>systemd</code> 可以方便地控制 frp
服务端 <code>frps</code> 的启动和停止、配置后台运行和开启自启。</p>
<p>要使用 <code>systemd</code> 来控制 <code>frps</code>，需要先安装 <code>systemd</code>，然后在 <code>/etc/systemd/system</code> 目录下创建一个
frps.service 文件。</p>
<ol type="1">
<li><p>如Linux服务端上没有安装 <code>systemd</code>，可以使用 <code>yum</code> 或 <code>apt</code> 等命令安装 <code>systemd</code>。<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum</span></span><br><span class="line">yum install systemd</span><br><span class="line"><span class="comment"># apt</span></span><br><span class="line">apt install systemd</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用文本编辑器，如 <code>vim</code> 创建并编辑 <code>frps.service</code> 文件。<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/systemd/system/frps.service</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>写入内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"># 服务名称，可自定义</span><br><span class="line">Description = frp server</span><br><span class="line">After = network.target syslog.target</span><br><span class="line">Wants = network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = simple</span><br><span class="line"># 启动frps的命令，需修改为您的frps的安装路径</span><br><span class="line">ExecStart = /path/to/frps -c /path/to/frps.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p>使用 <code>systemd</code> 命令，管理 frps。<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动frp</span></span><br><span class="line">systemctl start frps</span><br><span class="line"><span class="comment"># 停止frp</span></span><br><span class="line">systemctl stop frps</span><br><span class="line"><span class="comment"># 重启frp</span></span><br><span class="line">systemctl restart frps</span><br><span class="line"><span class="comment"># 查看frp状态</span></span><br><span class="line">systemctl status frps</span><br></pre></td></tr></table></figure></p></li>
<li><p>配置 frps 开机自启。<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> frps</span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>将二进制文件添加为服务启动项</title>
    <url>/blog/2023/10/11/data/linux/%E5%B0%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E9%A1%B9/</url>
    <content><![CDATA[<p>要将自己的二进制文件添加为 systemd
的一个服务，你需要完成以下步骤：</p>
<ol type="1">
<li><p>创建一个新的服务文件：在 <code>/etc/systemd/system/</code>
目录下创建一个以 <code>.service</code> 结尾的服务文件，比如
<code>your_service.service</code>。<br />
<code>sudo nano /etc/systemd/system/your_service.service</code></p></li>
<li><p>在服务文件中添加以下内容（根据你的需求进行相应修改）：<br />
<code>[Unit] Description=Your Service Description After=network.target  [Service] ExecStart=/path/to/your/binary WorkingDirectory=/path/to/your/working/directory Restart=always User=your_username  [Install] WantedBy=default.target</code></p>
<ul>
<li><code>Description</code>：服务描述，用于说明该服务的作用。<br />
</li>
<li><code>ExecStart</code>：指定要运行的二进制文件的路径。<br />
</li>
<li><code>WorkingDirectory</code>：指定二进制文件的工作目录（如果需要）。<br />
</li>
<li><code>Restart</code>：设置服务在崩溃或退出后是否自动重启。<br />
</li>
<li><code>User</code>：指定服务运行时所使用的用户。<br />
</li>
<li><code>WantedBy</code>：指定服务在哪个
target（比如 <code>default.target</code>）下启动。<br />
</li>
</ul></li>
<li><p>保存并关闭文件。</p></li>
<li><p>重新加载 systemd 配置：<br />
<code>sudo systemctl daemon-reload</code></p></li>
<li><p>启动服务：<br />
<code>sudo systemctl start your_service</code></p>
<p>如果一切正常，你的二进制文件将会被作为一个服务在后台运行。</p></li>
<li><p>(可选) 设置开机自启动：<br />
<code>sudo systemctl enable your_service</code></p>
<p>这样，当系统启动时，你的服务将自动启动。</p></li>
</ol>
<p>你可以通过以下命令来控制你的服务：</p>
<ul>
<li>启动服务：<code>sudo systemctl start your_service</code><br />
</li>
<li>停止服务：<code>sudo systemctl stop your_service</code><br />
</li>
<li>重启服务：<code>sudo systemctl restart your_service</code><br />
</li>
<li>查看服务状态：<code>sudo systemctl status your_service</code></li>
</ul>
<p>这就是将自己的二进制文件添加为 systemd
的一个服务的基本步骤。根据你的具体需求，你可能还需要进行其他配置或修改。如果你需要更多的帮助，可以参考
systemd
的官方文档或者提供更多关于你的服务的详细信息，我将尽力提供帮助！</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底删除某用户</title>
    <url>/blog/2023/10/11/data/linux/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<p>userdel 命令功能很简单，就是删除用户的相关数据。此命令只有 root
用户才能使用。</p>
<p>通过前面的学习我们知道，用户的相关数据包含如下几项：</p>
<ul>
<li>用户基本信息：存储在 /etc/passwd 文件中；<br />
</li>
<li>用户密码信息：存储在 /etc/shadow 文件中；<br />
</li>
<li>用户群组基本信息：存储在 /etc/group 文件中；<br />
</li>
<li>用户群组信息信息：存储在 /etc/gshadow 文件中；<br />
</li>
<li>用户个人文件：主目录默认位于 /home/用户名，邮箱位于
/var/spool/mail/用户名。</li>
</ul>
<p>其实，userdel
命令的作用就是从以上文件中，删除与指定用户有关的数据信息。</p>
<p>userdel 命令的语法很简单，基本格式如下：</p>
<p>[root@localhost ~]# userdel -r 用户名</p>
<p>-r 选项表示在删除用户的同时删除用户的家目录。</p>
<p>注意，在删除用户的同时如果不删除用户的家目录，那么家目录就会变成没有属主和属组的目录，也就是垃圾文件。</p>
<p>例如，删除前面章节中创建的 lamp 用户，只需执行如下命令：</p>
<p>[root@localhost ~]# userdel -r lamp</p>
<p>除了使用 userdel
命令删除用户，还可以手动方式删除，毕竟通过前面的学习，我们已经知道与用户相关信息的存储位置。虽然这样做没有实际意义，但对于初学者来说，可以加深对
userdel 命令的理解。</p>
<p>手动删除指定用户的具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#建立新 lamp 用户</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# useradd lamp</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# passwd lamp</span><br><span class="line"></span><br><span class="line">#为 lamp 用户设置密码，由此 lamp 用户才算是创建成功</span><br><span class="line"></span><br><span class="line">#下面开始手动删除 lamp</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# vi /etc/passwd</span><br><span class="line"></span><br><span class="line">lamp:x:501:501::/home/lamp:/bin/bash   &lt;--删除此行</span><br><span class="line"></span><br><span class="line">#修改用户信息文件，删除lamp用户行</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#vi /etc/shadow</span><br><span class="line"></span><br><span class="line">lamp:$6$KoOYtcOJ $56Xk9vp3D2vMRBxibNOn.21cVJ9onbW8IHx4WrOx6qBqfGa9U3mjMsGjqYnj L/4t3zt3YxElce2X8rbb12x4a0:15716:0:99999:7:::   &lt;--删除此行</span><br><span class="line"></span><br><span class="line">#修改影子文件，删除lamp用户密码行，注意，这个文件的权限是000，所以要强制保存</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#vi /etc/group</span><br><span class="line"></span><br><span class="line">lamp:x:501:  &lt;--删除此行</span><br><span class="line"></span><br><span class="line">#修改组信息文件，删除lamp群组信息</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#vi /etc/gshadow</span><br><span class="line"></span><br><span class="line">lamp:!::  &lt;--删除此行</span><br><span class="line"></span><br><span class="line">#修改组影子文件，删除lamp群组密码信息。同样注意需要强制保存</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# rm -rf /var/spod/mail/lamp  #删除用户邮箱</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# rm -rf/home/lamp/  #删除用户的家目录</span><br><span class="line"></span><br><span class="line">#至此，用户彻底删除，再新建用户lamp。如果可以正常建立，则说明我们手工删除干净了</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# useradd lamp</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# passwd lamp</span><br><span class="line"></span><br><span class="line">#重新建立同名用户，没有报错，说明前面的手工删除是可以完全删除用户的</span><br></pre></td></tr></table></figure>
<p>手动删除用户，仅是为了让读者对 userdel
命令理解地更透彻，实际使用中，使用 userdel 删除用户更方便。</p>
<p>最后需要大家注意的是，如果要删除的用户已经使用过系统一段时间，那么此用户可能在系统中留有其他文件，因此，如果我们想要从系统中彻底的删除某个用户，最好在使用
userdel 命令之前，先通过 find -user
用户名 命令查出系统中属于该用户的文件，然后在加以删除。</p>
<p>来自 &lt;<a
href="http://c.biancheng.net/view/851.html">http://c.biancheng.net/view/851.html</a>&gt;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>查看kernel版本和glibc版本</title>
    <url>/blog/2023/10/11/data/linux/%E6%9F%A5%E7%9C%8Bkernel%E7%89%88%E6%9C%AC%E5%92%8Cglibc%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>怎么查看Linux系统的kernel版本和glic版本？</p>
<p>ChatGPT</p>
<p>在 Linux 系统中，可以通过以下命令来查看内核版本和 glibc 版本：</p>
<ol type="1">
<li><strong>查看内核版本</strong>： 打开终端，使用 <code>uname</code>
命令，带上 <code>-r</code> 或 <code>-a</code> 参数：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure> 或者<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这会显示当前运行的 Linux 内核版本号。</p>
<ol start="2" type="1">
<li><p><strong>查看 glibc 版本</strong>： 要查看 glibc（GNU C
库）的版本，可以使用 <code>ldd</code>（List Dynamic
Dependencies）命令，带上 <code>--version</code> 参数：</p>
<p><code>ldd --version</code></p>
<p>这会显示 glibc 的版本信息，版本号通常位于输出的第一行。</p></li>
</ol>
<p>这两个命令通常在大多数 Linux
发行版中都可用，可以帮助您快速了解系统的内核版本和 glibc 版本。</p>
<p>glibc是动态库吗？ldd为什么可以直接输出glibc的版本而不是其他什么库的版本？</p>
<p>ChatGPT</p>
<p>是的，glibc（GNU C Library）是一种动态库，它为 Linux
系统上的应用程序提供了系统级别的基本功能和服务。glibc 包含了 C
语言运行时环境所需的基础函数，如内存分配、文件操作、进程控制等，是 Linux
系统中非常核心的一部分。</p>
<p><code>ldd</code>
命令用于列出一个可执行程序或者动态库的动态依赖，它会显示出程序运行时需要加载的动态库文件。而
<code>ldd --version</code> 命令则是用于显示 <code>ldd</code>
命令自身依赖的 glibc 的版本信息，而不是显示其他库的版本。</p>
<p>之所以 <code>ldd</code> 命令可以直接输出 glibc 的版本信息，是因为
<code>ldd</code> 是一个依赖于 glibc 的工具。<code>ldd</code>
命令在执行时会加载 glibc 动态库，因此，通过 <code>ldd --version</code>
命令可以方便地查询到 glibc 的版本信息。这并不意味着 <code>ldd</code>
不能显示其他库的版本，而是说 <code>ldd --version</code>
这个特定命令是设计用来输出 glibc
版本的。要查看其他库的版本，通常需要使用其他方法，例如，直接查阅库文件的信息，或者使用库提供的查询版本的工具和函数。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>检查你的终端支持多少颜色</title>
    <url>/blog/2023/10/11/data/linux/%E6%A3%80%E6%9F%A5%E4%BD%A0%E7%9A%84%E7%BB%88%E7%AB%AF%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>使用以下的perl脚本并对其添加可执行权限直接执行来测试终端支持多少种颜色：<br />
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"><span class="comment">#Author: Todd Larason &lt;jtl@molehill.org&gt;</span></span><br><span class="line"><span class="comment">#$XFree86: xc/programs/xterm/vttests/256colors2.pl,v 1.2 2002/03/26 01:46:43 dickey Exp $</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#use the resources for colors 0-15 - usually more-or-less a</span></span><br><span class="line"><span class="comment">#reproduction of the standard ANSI colors, but possibly more</span></span><br><span class="line"><span class="comment">#pleasing shades</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#colors 16-231 are a 6x6x6 color cube</span></span><br><span class="line"><span class="keyword">for</span>($red= <span class="number">0</span>; $red&lt; <span class="number">6</span>; $red++) &#123;</span><br><span class="line">    <span class="keyword">for</span>($green= <span class="number">0</span>; $green&lt; <span class="number">6</span>; $green++) &#123;</span><br><span class="line">	<span class="keyword">for</span>($blue= <span class="number">0</span>; $blue&lt; <span class="number">6</span>; $blue++) &#123;</span><br><span class="line">	    <span class="keyword">printf</span>(<span class="string">&quot;\x1b]4;%d;rgb:%2.2x/%2.2x/%2.2x\x1b\\&quot;</span>,</span><br><span class="line">		   <span class="number">16</span> + ($red* <span class="number">36</span>) + ($green* <span class="number">6</span>) + $blue,</span><br><span class="line">		   ($red? ($red* <span class="number">40</span> + <span class="number">55</span>) : <span class="number">0</span>),</span><br><span class="line">		   ($green? ($green* <span class="number">40</span> + <span class="number">55</span>) : <span class="number">0</span>),</span><br><span class="line">		   ($blue? ($blue* <span class="number">40</span> + <span class="number">55</span>) : <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#colors 232-255 are a grayscale ramp, intentionally leaving out</span></span><br><span class="line"><span class="comment">#black and white</span></span><br><span class="line"><span class="keyword">for</span>($gray= <span class="number">0</span>; $gray&lt; <span class="number">24</span>; $gray++) &#123;</span><br><span class="line">    $level= ($gray* <span class="number">10</span>) + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;\x1b]4;%d;rgb:%2.2x/%2.2x/%2.2x\x1b\\&quot;</span>,</span><br><span class="line">	   <span class="number">232</span> + $gray, $level, $level, $level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#display the colors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#first the system ones:</span></span><br><span class="line"><span class="keyword">print</span><span class="string">&quot;System colors:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>($color= <span class="number">0</span>; $color&lt; <span class="number">8</span>; $color++) &#123;</span><br><span class="line">    <span class="keyword">print</span><span class="string">&quot;\x1b[48;5;<span class="subst">$&#123;color&#125;</span>m  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span><span class="string">&quot;\x1b[0m\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>($color= <span class="number">8</span>; $color&lt; <span class="number">16</span>; $color++) &#123;</span><br><span class="line">    <span class="keyword">print</span><span class="string">&quot;\x1b[48;5;<span class="subst">$&#123;color&#125;</span>m  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span><span class="string">&quot;\x1b[0m\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#now the color cube</span></span><br><span class="line"><span class="keyword">print</span><span class="string">&quot;Color cube, 6x6x6:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>($green= <span class="number">0</span>; $green&lt; <span class="number">6</span>; $green++) &#123;</span><br><span class="line">    <span class="keyword">for</span>($red= <span class="number">0</span>; $red&lt; <span class="number">6</span>; $red++) &#123;</span><br><span class="line">	<span class="keyword">for</span>($blue= <span class="number">0</span>; $blue&lt; <span class="number">6</span>; $blue++) &#123;</span><br><span class="line">	    $color= <span class="number">16</span> + ($red* <span class="number">36</span>) + ($green* <span class="number">6</span>) + $blue;</span><br><span class="line">	    <span class="keyword">print</span><span class="string">&quot;\x1b[48;5;<span class="subst">$&#123;color&#125;</span>m  &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">print</span><span class="string">&quot;\x1b[0m &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">print</span><span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#now the grayscale ramp</span></span><br><span class="line"><span class="keyword">print</span><span class="string">&quot;Grayscale ramp:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>($color= <span class="number">232</span>; $color&lt; <span class="number">256</span>; $color++) &#123;</span><br><span class="line">    <span class="keyword">print</span><span class="string">&quot;\x1b[48;5;<span class="subst">$&#123;color&#125;</span>m  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span><span class="string">&quot;\x1b[0m\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>添加了SSH public key到authorized_keys却无法免密连接？</title>
    <url>/blog/2023/10/11/data/linux/%E6%B7%BB%E5%8A%A0%E4%BA%86SSH%20public%20key%E5%88%B0authorized_keys%E5%8D%B4%E6%97%A0%E6%B3%95%E5%85%8D%E5%AF%86%E8%BF%9E%E6%8E%A5%EF%BC%9F/</url>
    <content><![CDATA[<p>在使用ssh-keygen生成了本机本用户的.ssh目录后，把其他机器的public
key放到.ssh目录下的authorized_keys，却仍然无法免密连接？很有可能是.ssh目录的权限和authorized_keys文件的权限设置的不对。一个目录必须对其他用户具有可执行权限才能进入目录内，而authorized_keys文件对于ssh远端服务进程来说，只有当其安全性得到保障时，sshd才会认可这个公钥认证文件，也就是说，authorized_keys的权限最多为600（本用户可读写，同组内其他用户，和其他普通用户无法读写），sshd才会认为这份认证文件是有效的。</p>
<ul>
<li><p>The ssh client software (ssh/sftp/scp/etc) is concerned about the
permissions and ownership of the private key file (~/.ssh/id_rsa, for
example). Because it's your "private" key, the permissions are expected
to reflect that no other user besides the owner can read or write the
file - therefore, the ~/.ssh/id_rsa file must be permission mode 00600
(or better). If it was mode 00640, then your group could possibly read
your private key, and that would be enough for the ssh client software
to reject it's use. Note also that every individual directory leading to
this file is also validated.</p></li>
<li><p>The ssh server software (sshd) is concerned about the permissions
and ownership of the public key file (~/.ssh/authorized_keys). Because
it's your public key, the ssh server software is less concerned about
keeping it private, but more concerned about ensuring it cannot be
tampered with (read: written to). Therefore, sshd will reject use of a
public key if it's permissions and ownership allow write access to a
user other than the owner. Usually, mode 00644 works fine, thought many
confuse the permissions on id_rsa with authorized_keys. Mode 00664 is
too permissive for a public key file, since it implies any other users
in your group could change your public key and impersonate you by
injecting their own public key to or ~/.ssh/authorized_keys (for
example). Note also that every individual directory leading to this file
is also validated.</p></li>
</ul>
<p>来自 &lt;<a
href="https://security.stackexchange.com/questions/256116/how-does-chmod-600-to-private-ssh-keys-make-them-secure-what-is-the-minimum-a">https://security.stackexchange.com/questions/256116/how-does-chmod-600-to-private-ssh-keys-make-them-secure-what-is-the-minimum-a</a>&gt;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>相对路径的软链接</title>
    <url>/blog/2023/10/11/data/linux/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>我在nodejs的目录下的bin目录中看到了这样的软链接： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -&gt; ../lib/node_modules/npm/bin/npm-cli.js</span><br></pre></td></tr></table></figure></p>
<p>原来软连接不一定必须是绝对路径的？</p>
<p>ChatGPT</p>
<p>是的，软链接（符号链接）可以是相对路径，也可以是绝对路径。上述的例子中，<code>npm</code>
是一个相对路径的软链接，它指向的是与 <code>bin</code> 目录同级的
<code>lib/node_modules/npm/bin/npm-cli.js</code> 文件。</p>
<p>当你在 <code>bin</code> 目录下使用 <code>npm</code>
命令时，系统会根据这个软链接找到并执行
<code>../lib/node_modules/npm/bin/npm-cli.js</code> 文件。</p>
<p>软链接可以指向任何类型的文件，并且可以跨文件系统。相对路径的软链接通常更加灵活和便携，因为当整个目录树被移动到另一个位置时，相对路径的软链接仍然有效，而绝对路径的软链接可能会失效。</p>
<p>在 Linux 或 Unix 系统中，你可以使用 <code>ln -s</code>
命令创建软链接，例如：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s target link_name</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>target</code>
是你要链接到的文件或目录，<code>link_name</code> 是链接的名称。这里的
<code>target</code> 可以是相对路径，也可以是绝对路径。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲与缓存的区别</title>
    <url>/blog/2023/10/11/data/linux/%E7%BC%93%E5%86%B2%E4%B8%8E%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>什么是缓存、缓存区？</p>
<p>        Cache（缓存）是“读”数据时在内存的一种优化技术。</p>
<p>        缓存区就是占用内存中的一块区域来做进程的数据缓存，比如WEB服务，当用户第一次请求时，进程会从磁盘（硬盘）中拿数据（结果），将结果存储到缓存区，当第二次该用户发起同样的请求时，则进程会在缓存区中匹配已经缓存的结果，直接返回数据。内存的读写效率是磁盘的10倍以上。所以该技术增加了进程处理数据的效率，并降低了磁盘IO的使用。</p>
<p>什么是缓冲、缓冲区？</p>
<p>        Buffer（缓冲）是“写”数据时在内存的一种优化技术。</p>
<p>        缓冲区就是占用内存中的一块区域来做进程的数据缓冲，比如上传一个数据（文件），数据由进程处理，进程调用内存持续性的将数据写入磁盘，数据在内存中会被分成大小不均匀的信息数据块持续性的写入磁盘，这种写入磁盘的方式执行效率比较慢，而且因为大小不均会导致磁盘碎片。而Buffer则是对这些大小不均匀的信息数据块流量整形的一项技术，这些数据块首先会存入缓冲区，等待积累的多个数据块占满整个缓冲区大小时，然后从缓冲区写入到磁盘中。所以一般情况下一个缓冲区大小等于系统的分页大小。</p>
<p>        系统的分页大小则就是磁盘的文件系统的存储块大小。如果是Windows系统一般我们在格式化的时候可以看到，即“分配单元大小”。如果是Linux则可以通过“ getconf
PAGE_SIZE”命令查看。</p>
<p>来自 &lt;<a
href="https://developer.aliyun.com/article/536892">https://developer.aliyun.com/article/536892</a>&gt;</p>
<p>在软件系统中谈到数据复用，首先想到的就是缓冲和缓存，两者意义完全不同。</p>
<p>缓冲（Buffer）：常见于对数据的暂存，然后批量传输或者写入，
多使用顺序的方式，用来缓解不同设备之间频繁地、缓慢地随机写。</p>
<p>缓存（Cache）：常见于对已读数据的复用，通过将它们缓存在相对高速的区域，缓存主要针对的是读操作。</p>
<p><a
href="https://link.zhihu.com/?target=http%3A//www.fangbangxin.com/photo/show-109.html">参考《Java性能优化与面试21讲》</a></p>
<p>缓冲区是解决速度差异的唯一工具。但是，在极端情况下，比如断电时，这些缓冲区容易丢。</p>
<p>直观上来讲，
缓冲可以说是一种机制，一种思路或者一种技术。但是缓存所指的Cache和缓冲区在计算机组成中都可以找到对应的硬件支持。</p>
<p>在百度百科中可以看到对缓冲技术有这样一种说明，如下图：</p>
<p>另外，还有以下两种形象的比喻可以用来进行辅助理解：</p>
<p>可以把缓冲区想象成一个蓄水池，放水的水龙头一直开着，如果池子里有水，它就以恒定的速度流淌，不需要暂停。而供水的水龙头，速度却不确定，有时候会快一点，有时候会特别慢。通过判断水池里水的状态，就可以自由控制进水的速度。<br />
​<br />
也可以比作包饺子，擀饺皮的把饺皮擀出来给包饺子的，这样一进一出，就慢。如果在中间放一个盆。擀饺皮的把饺子皮放到盆里。包饺子的人只管从盆里取。这样效率就会快很多。</p>
<p>缓冲区的目的：</p>
<ul>
<li>缓冲双方各自保持自己的操作节奏，操作处理顺序也不会打乱，可以one by
one顺序进行<br />
</li>
<li>以批量的方式处理，减少网络交互和繁重的I/O操作，从而减少性能损耗<br />
</li>
<li>优化用户体验，比如常见的音频/视频缓冲加载，通过提前缓冲数据，达到流畅的播放效果</li>
</ul>
<p>从软件的角度，</p>
<p>宏观上讲，JVM的堆就是一个大的缓冲区，代码不停地在堆空间中生产对象，而垃圾回收期进程则在背后默默地进行垃圾回。</p>
<p>缓冲在java中被广泛应用，在idea中搜索
buffer可以看到常常的类列表，其中最典型的就是文件读取和写入字符流。</p>
<p>从硬件的角度看，</p>
<p>为了屏蔽设备之间的差异，每个设备都有一个叫设备控制器（Device
Control）的组件，比如硬盘有硬盘控制器、显示器有视频控制器等。</p>
<p>因为这些控制器都很清楚的知道对应设备的用法和功能，所以CPU是通过设备控制器和设备打交道的。设备控制器里有芯片，它可执行自己的逻辑，也有自己的寄存器，用来与CPU进行通信，比如：</p>
<ul>
<li>通过写入这些寄存器，操作系统可以命令设备发送数据、接受数据、开启或关闭，或者执行某些其他操作<br />
</li>
<li>通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。</li>
</ul>
<p>输入输出设备分为两大类：块设备（Block Device）和字符设备（Character
Device）</p>
<p>块设备通常传输的数据量会非常大，于是控制器设立了一个可读写的数据缓冲区。</p>
<ul>
<li>CPU写入数据到控制器的缓冲区时，当缓冲区的数据囤够了一部分，才会发给设备。<br />
</li>
<li>CPU从控制器的缓冲区读取数据时，也需要缓冲区囤够了一部分，才拷贝到内存。</li>
</ul>
<p>这就结合实际的I/O设备中对于缓冲的应用进一步加深对于缓冲的理解。</p>
<p>（注：我会尽量的渗透关于硬件知识的补充，来更深入理解软件运行的原理）</p>
<p>微型机的主要组成部件：</p>
<ul>
<li>主板<br />
</li>
<li>CPU<br />
</li>
<li>运算部件（ALU）<br />
</li>
<li>寄存器组（用来保存从存储单元中读取的指令或数据，也保存来自其他各部件的状态信息）<br />
</li>
<li>通用寄存器<br />
</li>
<li>专用寄存器<br />
</li>
<li>数据缓冲寄存器（这里的数据缓冲寄存器（MDR），用来暂时存放由主存中读出的指令或数据或者写入主存的指令或数据，即CPU要写入主存单元的数据先送入MDR中，再从MDR送入主存响应的单元中；同样，从主存单元中读出数据时，先送入MDR中，再送入CPU指定的寄存器。所以MDR可作为CPU和内存，外部设备之间信息传送的中转站。）<br />
</li>
<li>指令寄存器<br />
</li>
<li>程序计数器<br />
</li>
<li>地址寄存器<br />
</li>
<li>状态字寄存器<br />
</li>
<li>控制器（EU）<br />
</li>
<li>存储器<br />
</li>
<li>主存（主存储器，简称主存，因为主存一般在主机之内，所以又称内存）<br />
</li>
<li>高速缓存（高速缓冲存储器）</li>
</ul>
<p><img
src="data:image/png;base64,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" /></p>
<ul>
<li>辅存（辅助存储器）</li>
</ul>
<p>上述的内容，主要描述的是对于缓冲技术和缓冲寄存器这种硬件在计算机中的应用的理解？</p>
<p>到这儿如果面试官继续问一个问题，缓存是什么，高速缓存中的缓存和Redis这种我们平时用的分布式缓存有什么区别和联系？</p>
<p>来自 &lt;<a
href="https://zhuanlan.zhihu.com/p/376380293">https://zhuanlan.zhihu.com/p/376380293</a>&gt;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>行缓冲、全缓冲、无缓冲</title>
    <url>/blog/2023/10/11/data/linux/%E8%A1%8C%E7%BC%93%E5%86%B2%E3%80%81%E5%85%A8%E7%BC%93%E5%86%B2%E3%80%81%E6%97%A0%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<p>给出下面这一段C程序，它在命令行的输出和使用管道符重定向到文件的输出是不同的：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var_glb = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;a message to stdout\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(STDOUT_FILENO, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>) != <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">error_exit</span>(<span class="string">&quot;fail to write properly\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> var_lcl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fork\n&quot;</span>);</span><br><span class="line">    <span class="comment">// fflush(stdout);</span></span><br><span class="line">    <span class="type">pid_t</span> pid_subprocess = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid_subprocess &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">error_exit</span>(<span class="string">&quot;fail to fork sub-process&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid_subprocess == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// child process</span></span><br><span class="line">        var_glb++;</span><br><span class="line">        var_lcl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid_subprocess &gt;  <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// main process</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid#%d, glb: %d, lcl: %d\n&quot;</span>, <span class="built_in">getpid</span>(), var_glb, var_lcl);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在命令行直接运行编译好的二进制可执行文件得到输出：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a message to stdout</span><br><span class="line">before fork</span><br><span class="line">pid<span class="comment">#682287, glb: 1, lcl: 1</span></span><br><span class="line">pid<span class="comment">#682282, glb: 0, lcl: 0</span></span><br></pre></td></tr></table></figure></p>
<p>重定向标准输出到文件中：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a message to stdout</span><br><span class="line">before fork</span><br><span class="line">pid<span class="comment">#683185, glb: 1, lcl: 1</span></span><br><span class="line">before fork</span><br><span class="line">pid<span class="comment">#683184, glb: 0, lcl: 0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，文件中 <code>"before fork"</code>
重复输出了两次。这种结果不一致的行为其实是子进程复制了父进程的进程空间的数据，以及输出的缓存决策行为。</p>
<p>首先，每个进程有自己的用户态缓存，一般程序输出到标准输出<code>stdout</code>使用的是行缓冲，也就是在Linux系统下，每次遇到<code>\n</code>就会把缓冲区中的内容输送到终端上。而如果重定向输出到文件中，则使用的是全缓冲，也就是减少了IO次数，减少用户态到内核态缓冲拷贝的开销。当子进程被
fork
出来后，子进程也拥有自己的用户态缓存，并且这份缓存中的数据与父进程是一模一样的，毕竟是赋值进程空间得来的。因此，现在运行的这个程序包含了两个进程，每个进程的用户态缓存中都有
<code>"before fork\n"</code>
字符串内容，当进程结束的时候，缓存会被刷新以保证用户设计的程序写入的内容能被正确保存，因此这两个进程的用户态缓存中的字符串都重定向到了输出文件中。要解决这个问题只需要保证在执行
<code>fork</code> 克隆出子进程之前把用户态缓存中的内容
<code>flush</code>
输出出去即可，这样子进程就不会复制到父进程的用户态缓存内容而是复制了一片空缓存。</p>
<p>将缓存刷新输出到指定的文件句柄可以使用
<code>fflush(FILE&amp; fp)</code> 函数。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode CMake Make配套构建任务tasks.json</title>
    <url>/blog/2023/10/11/data/normal%20notes/VScode%20CMake%20Make%E9%85%8D%E5%A5%97%E6%9E%84%E5%BB%BA%E4%BB%BB%E5%8A%A1tasks.json/</url>
    <content><![CDATA[<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;configure&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmake&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;configure&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMake template configure task&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;-C&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span></span><br><span class="line">			<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;configure&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     &quot;label&quot;: &quot;install targets&quot;,</span></span><br><span class="line">        <span class="comment">//     &quot;type&quot;: &quot;shell&quot;,</span></span><br><span class="line">        <span class="comment">//     &quot;command&quot;: &quot;make&quot;,</span></span><br><span class="line">        <span class="comment">//     &quot;args&quot;: [</span></span><br><span class="line">        <span class="comment">//         &quot;-C&quot;, &quot;$&#123;workspaceFolder&#125;/build&quot;,</span></span><br><span class="line">        <span class="comment">//         &quot;install&quot;</span></span><br><span class="line">        <span class="comment">//     ],</span></span><br><span class="line">        <span class="comment">//     &quot;dependsOn&quot;: [</span></span><br><span class="line">        <span class="comment">//         &quot;generate Makefiles&quot;</span></span><br><span class="line">        <span class="comment">//     ]</span></span><br><span class="line">        <span class="comment">// &#125;,</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build workspace&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;dependsOn&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;configure&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;generate&quot;</span></span><br><span class="line">			<span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode插件清单备份</title>
    <url>/blog/2023/10/11/data/normal%20notes/VScode%E6%8F%92%E4%BB%B6%E6%B8%85%E5%8D%95%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<p>在终端使用下述命令输出VScode已安装插件为列表到文本文件中：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code --list-extensions &gt; extensions.txt</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaron-bond.better-comments</span><br><span class="line">christian-kohler.path-intellisense</span><br><span class="line">eamodio.gitlens</span><br><span class="line">kevinkyang.auto-comment-blocks</span><br><span class="line">ms-azuretools.vscode-docker</span><br><span class="line">MS-CEINTL.vscode-language-pack-zh-hans</span><br><span class="line">ms-dotnettools.csdevkit</span><br><span class="line">ms-dotnettools.csharp</span><br><span class="line">ms-dotnettools.vscode-dotnet-runtime</span><br><span class="line">ms-dotnettools.vscodeintellicode-csharp</span><br><span class="line">ms-python.python</span><br><span class="line">ms-python.vscode-pylance</span><br><span class="line">ms-toolsai.jupyter</span><br><span class="line">ms-toolsai.jupyter-keymap</span><br><span class="line">ms-toolsai.jupyter-renderers</span><br><span class="line">ms-toolsai.vscode-jupyter-cell-tags</span><br><span class="line">ms-toolsai.vscode-jupyter-slideshow</span><br><span class="line">ms-vscode-remote.remote-containers</span><br><span class="line">ms-vscode-remote.remote-ssh</span><br><span class="line">ms-vscode-remote.remote-ssh-edit</span><br><span class="line">ms-vscode-remote.remote-wsl</span><br><span class="line">ms-vscode-remote.vscode-remote-extensionpack</span><br><span class="line">ms-vscode.cmake-tools</span><br><span class="line">ms-vscode.cpptools</span><br><span class="line">ms-vscode.remote-explorer</span><br><span class="line">ms-vscode.remote-server</span><br><span class="line">njpwerner.autodocstring</span><br><span class="line">oderwat.indent-rainbow</span><br><span class="line">twxs.cmake</span><br><span class="line">vscode-icons-team.vscode-icons</span><br></pre></td></tr></table></figure>
<p>有了插件清单之后，如何在其他计算机上导入VScode插件呢？可以执行VScode提供的命令参数
--install-extension &lt;extension-name&gt;</p>
<p>对于Windows系统来说，如果要批量安装插件清单列表中的插件，可以使用如下批处理命令（请在PowerShell中使用该命令，cmd不支持<code>get-content</code>命令）：<br />
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">get-content extensions.txt | forEach-object &#123; code --install-extension $_ &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>get-content</code>命令就类似于Linux下的cat打印文件内容命令，然后使用管道符重定向输出给VScode的命令行工具code。</p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode更改插件目录位置</title>
    <url>/blog/2023/10/11/data/normal%20notes/VScode%E6%9B%B4%E6%94%B9%E6%8F%92%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>以前一直把Windows的快捷方式理解为Linux下的软链接。直到最近VScode使用快捷方式转移插件安装文件夹无法生效时才发现问题。</p>
<p>如果使用右键-&gt;创建快捷方式来创建指向其他插件存储位置的链接的话，文件类型会显示快捷方式而非文件夹，这样VScode在启动的时候仍然检测不到默认位置的插件目录，所以显示一安装插件为空。<br />
![[Pasted image 20230802152727.png]]</p>
<p>但是如果用cmd（可能需要管理员权限运行）的mklink命令创建目录类型的符号链接（symbol
link），显示的类型就是文件夹，并且VScode启动的时候也能检测到这个目标是一个目录类型。<br />
<img src="symlink_cmd.png" alt="cmdsymlink" /></p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode高亮悬停匹配工作区设置</title>
    <url>/blog/2023/10/11/data/normal%20notes/VScode%E9%AB%98%E4%BA%AE%E6%82%AC%E5%81%9C%E5%8C%B9%E9%85%8D%E5%B7%A5%E4%BD%9C%E5%8C%BA%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>在当前工作区的.vscode目录下新建.settings文件来添加新的自定义项以覆盖默认配置项，普通的深色主题光标悬停高亮时只有背景有一层浅浅的高亮，看代码看久了不是很容易发现，通过设置边框颜色来让高亮更显眼。<br />
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;workbench.colorCustomizations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;editor.selectionHighlightBorder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f4f4f456&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;editor.wordHighlightBorder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f4f4f456&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;editor.lineHighlightBorder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f4f4f456&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;editor.findMatchHighlightBorder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f4f4f456&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>第一项设置鼠标选中的部分在其他位置检测到时的边框颜色<br />
![[Pasted image 20230802155234.png]]</p>
<p>第二项设置当前语言后端语义分析能检测出的关键字高亮边框颜色，并同时高亮当前文件中其他出现该关键字的位置<br />
![[Pasted image 20230802155242.png]]</p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下查找特定进程</title>
    <url>/blog/2023/10/11/data/normal%20notes/Windows%E4%B8%8B%E6%9F%A5%E6%89%BE%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>cmd有没有列出当前进程并像Linux用grep一样关键字过滤的命令</p>
<p>2023/8/17 18:23:41</p>
<p>在 Windows 的命令提示符 (cmd) 中，可以使用 <code>tasklist</code>
命令列出当前运行的进程。然而，cmd 默认不提供类似于 Linux 中的
<code>grep</code> 命令的过滤功能。</p>
<p>但是，您可以结合 <code>tasklist</code> 命令和其他 cmd
命令来实现类似的效果。以下是一种可能的方法：</p>
<p><code>tasklist | findstr "keyword"</code></p>
<p>上述命令将使用 <code>tasklist</code>
列出所有的进程，并将输出通过管道传递给 <code>findstr</code>
命令来过滤包含指定关键字的行。您只需将 "keyword"
替换为您想要过滤的关键字即可。</p>
<p>请注意，<code>findstr</code>
命令会对关键字进行区分大小写的匹配，如果要进行不区分大小写的匹配，可以使用
<code>/i</code> 参数。例如：</p>
<p><code>tasklist | findstr /i "keyword"</code></p>
<p>这样将会忽略关键字的大小写。</p>
<p>另外，如果您经常需要在 Windows 系统中进行类似的操作，建议考虑使用
PowerShell，它是一种功能更强大且灵活的命令行工具，可以提供与 Linux
中类似的过滤和查找功能。</p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>bat脚本如何后台运行？</title>
    <url>/blog/2023/10/11/data/normal%20notes/bat%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%EF%BC%9F/</url>
    <content><![CDATA[<p>需求:</p>
<p>当运行 批处理文件bat 时 , 会有一个黑窗口显示 , 对于不懂的人来说,
还是很吓人的;<br />
有两种办法,可以让bat后台运行,不出现黑窗口</p>
<p>第一种解决办法(推荐) :<br />
在你写的批处理文件,开头加上以下三行代码即可</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &quot;%<span class="number">1</span>&quot;==&quot;hide&quot; <span class="keyword">goto</span> CmdBegin</span><br><span class="line"><span class="built_in">start</span> mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~<span class="number">0</span>&quot;&quot; hide&quot;,<span class="number">0</span>)(window.close)&amp;&amp;<span class="keyword">exit</span></span><br><span class="line">:CmdBegin</span><br></pre></td></tr></table></figure>
<p>第二种解决办法:</p>
<p>比如你的批处理文件, 名字为 test.bat<br />
再创建一个txt文件 , 比如叫 backrun.txt<br />
再该文件中写入以下代码<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">createobject(&quot;wscript.shell&quot;).run &quot;test.bat&quot;,0</span><br></pre></td></tr></table></figure></p>
<p>此时再把该txt文件的后缀名改为.vbs ; </p>
<p>backrun.vbs</p>
<p>此时双击该该vbs文件, 我们的批处理文件,就已经进入后台运行模式了; </p>
<p>可以打开资源管理器, 会发现有一个
叫cmd的进程在运行,就是我们批处理文件的进程了;<br />
结束进程的话,直接再资源管理器上,结束该cmd进程即可</p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo分目录存放待发布文章</title>
    <url>/blog/2023/10/11/data/normal%20notes/hexo%E5%88%86%E7%9B%AE%E5%BD%95%E5%AD%98%E6%94%BE%E5%BE%85%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>我想问一下，我用的是hexo博客生成框架，按照一般步骤是通过<code>hexo new &lt;name&gt;</code>
来在_post目录下生成待发表的文章，但是所有文章都直接放在一起太混乱了，我可以在_post分不同目录存放不同类别的markdown笔记吗？会影响hexo的生成吗？</p>
<p>是的，你可以在 Hexo 的 <code>_posts</code>
目录下创建子目录来组织你的文章，并且这不会影响 Hexo
生成你的博客。实际上，这是一种常见的做法，用于组织和分类文章。</p>
<p>例如，你的目录结构可以是这样的：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>/</span><br><span class="line">    _posts/</span><br><span class="line">        technology/</span><br><span class="line">            post1.md</span><br><span class="line">            post2.md</span><br><span class="line">        lifestyle/</span><br><span class="line">            post3.md</span><br><span class="line">            post4.md</span><br></pre></td></tr></table></figure></p>
<p>在这个结构中，<code>technology</code> 和 <code>lifestyle</code> 是
<code>_posts</code>
目录下的子目录。你可以在这些子目录中放置相关的文章。</p>
<p>当你运行 <code>hexo generate</code> 或 <code>hexo server</code>
时，Hexo 会递归地搜索 <code>_posts</code> 目录（包括所有子目录）中的
Markdown
文件，并生成对应的博客文章。在生成的博客中，目录名称通常会被用作分类的名称。</p>
<p>你也可以使用 <code>hexo new</code>
命令来在特定的子目录中创建新文章。例如：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;technology/My New Tech Post&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>这将在 <code>source/_posts/technology/</code> 目录下创建一个新的
Markdown 文件。</p>
<p>请注意，你可能需要在你的 Hexo
配置文件或主题配置中正确设置分类和标签的路径，以确保它们在生成的站点中正确链接。你可以在
Hexo 文档中找到更多关于<a
href="https://hexo.io/docs/configuration">配置</a>和<a
href="https://hexo.io/docs/writing">写作</a>的信息。</p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter notebook 网页中不显示conda虚拟环境</title>
    <url>/blog/2023/10/11/data/normal%20notes/jupyter%20notebook%20%E7%BD%91%E9%A1%B5%E4%B8%AD%E4%B8%8D%E6%98%BE%E7%A4%BAconda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="一jupyter-notebook切换运行环境步骤如下">一、Jupyter
notebook切换运行环境步骤如下</h2>
<p>1.1 打开jupyter
，点击new，会有你现在存在的运行环境，但如果你是第一次打开，很有可能会发现无法找到你以前创建的虚拟环境。那么进入下一步。点击terminal进入终端</p>
<p>1.2 激活你要加到jupyter里面的本地环境（本文示例的是tensorflow）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate tensorflow</span><br></pre></td></tr></table></figure></p>
<p>1.3 然后安装ipykernel（用下面指令可以直接安装）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install ipykernel</span><br></pre></td></tr></table></figure></p>
<p>1.3 最后就是把本地环境注入jupyter<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m ipykernel install --user --name 本地环境名称 --display-name &quot;在jupyter上显示的环境名称&quot;</span><br></pre></td></tr></table></figure> 切回到第一步就能看见自己刚注入的环境了</p>
<h2 id="二使用环境">二、使用环境</h2>
<p>2.1 使用环境<br />
<img
src="https://img-blog.csdnimg.cn/0a03f8e5c39c439e95220e8194cb973c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATElVTElVMzQyOQ==,size_20,color_FFFFFF,t_70,g_se,x_16" /></p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用RD Client 从iPad远程连接Windows PC</title>
    <url>/blog/2023/10/11/data/normal%20notes/%E4%BD%BF%E7%94%A8RD%20Client%20%E4%BB%8EiPad%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Windows%20PC/</url>
    <content><![CDATA[<h2 id="起因">起因</h2>
<p>因为上课的时候，只有iPad的话只能刷题或者看看笔记，但是比较复杂的代码工作没有办法完成，这是十分浪费时间的，因此询问室友得知iPad上可以使用RD
Client作为WindowsPC的远程桌面客户端，但是如果不进行配置和准备的话只能在局域网使用，并不能在公网使用。</p>
<h2 id="前置要求">前置要求</h2>
<p>使用 RD Client 作为连接终端有两个前提要求：<br />
1.
你的Windows系统是专业版系统，似乎家庭版系统是没有安装远程桌面的（当然也可以后期通过其他方法安装就是了）<br />
2.
购买了一台具有公网ip的云服务器（华为云、腾讯云、阿里云均可），我们要使用这台具有公网ip的服务器做frp穿透来提供内网机器的3389端口，转发rdp服务</p>
<h2 id="frp下载与启动配置和服务注册">frp下载与启动配置和服务注册</h2>
<p>首先下载frp穿透的Windows平台客户端，可以在这个开源项目的<a
href="%5BReleases%20·%20fatedier/frp%20(github.com)%5D(https://github.com/fatedier/frp/releases)">github发行记录页面</a>找到最新的对应系统的发行版本。<br />
![[Pasted image 20230926233225.png]]</p>
<p>在下载frp程序之前，你也许需要去Windows的安全设置中心将病毒威胁实时防护暂时关闭，因为Windows出于某种原因似乎认为frp是病毒并且在完成下载的时候会自动删除该压缩包，就算解压了，如果frpc和frps没有被加入到白名单的话，一样会在短时间内被Windows的病毒防护扫描到并删除。</p>
<p>在Windows设置-&gt;更新和安全-&gt;Windows安全中心-&gt;病毒和威胁防护-&gt;病毒和威胁防护设置的管理设置-&gt;排除项-&gt;添加或删除排除项，来将fprc和fprs添加到白名单，然后再开启Windows的病毒威胁实时防护即可。<br />
![[Pasted image 20230926233656.png]]</p>
<p>然后公网ip的云服务器同样也需要下载对应操作系统和CPU架构平台的frp预编译二进制包。在服务器端可以把frp注册为系统服务也就是system
service，只需要写一个service文件即可，具体可以参考笔记<a
href="obsidian://open?vault=testrepo&amp;file=linux%2F%E5%B0%86FRP%E7%A9%BF%E9%80%8F%E4%BD%9C%E4%B8%BA%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1">将FRP注册为系统服务</a>，然后记得去云服务器厂商的防火墙/安全组中将3389端口开放。配置完成之后，应该可以在系统服务的状态日志中看到frp
server的连接状态：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">┌[fredom@hcss-ecs-1c01 09:00:54] ~</span><br><span class="line">└&gt; <span class="built_in">cat</span> frps.lo </span><br><span class="line">● frps.service - frp server</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/frps.service; disabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Tue 2023-09-26 21:20:35 CST; 11h ago</span><br><span class="line">   Main PID: 245004 (frps)</span><br><span class="line">      Tasks: 5 (<span class="built_in">limit</span>: 1988)</span><br><span class="line">     Memory: 22.2M</span><br><span class="line">        CPU: 10.141s</span><br><span class="line">     CGroup: /system.slice/frps.service</span><br><span class="line">             └─245004 /home/fredom/programfiles/frp/frps -c /home/fredom/programfiles/frp/frps.ini</span><br><span class="line"></span><br><span class="line">Sep 26 22:43:45 hcss-ecs-1c01 frps[245004]: 2023/09/26 22:43:45 [I] [control.go:332] [eb172ce2539a3213] control writer is closing</span><br><span class="line">Sep 26 22:43:45 hcss-ecs-1c01 frps[245004]: 2023/09/26 22:43:45 [I] [proxy.go:110] [eb172ce2539a3213] [ssh] proxy closing</span><br><span class="line">Sep 26 22:43:45 hcss-ecs-1c01 frps[245004]: 2023/09/26 22:43:45 [W] [proxy.go:196] [eb172ce2539a3213] [ssh] listener is closed: accept tcp [::]:3389: use of closed network connection</span><br><span class="line">Sep 26 22:43:45 hcss-ecs-1c01 frps[245004]: 2023/09/26 22:43:45 [I] [control.go:421] [eb172ce2539a3213] client <span class="built_in">exit</span> success</span><br><span class="line">Sep 27 08:26:45 hcss-ecs-1c01 frps[245004]: 2023/09/27 08:26:45 [I] [service.go:539] [3bdfab421c086b9b] client login info: ip [222.201.155.130:18858] version [0.51.3] hostname [] os [windows] <span class="built_in">arch</span> [amd64]</span><br><span class="line">Sep 27 08:26:45 hcss-ecs-1c01 frps[245004]: 2023/09/27 08:26:45 [I] [tcp.go:81] [3bdfab421c086b9b] [ssh] tcp proxy listen port [3389]</span><br><span class="line">Sep 27 08:26:45 hcss-ecs-1c01 frps[245004]: 2023/09/27 08:26:45 [I] [control.go:497] [3bdfab421c086b9b] new proxy [ssh] <span class="built_in">type</span> [tcp] success</span><br><span class="line">Sep 27 08:46:27 hcss-ecs-1c01 frps[245004]: 2023/09/27 08:46:27 [I] [proxy.go:199] [3bdfab421c086b9b] [ssh] get a user connection [120.238.248.51:7554]</span><br><span class="line">Sep 27 08:59:21 hcss-ecs-1c01 frps[245004]: 2023/09/27 08:59:21 [I] [proxy.go:199] [3bdfab421c086b9b] [ssh] get a user connection [95.216.66.209:64546]</span><br><span class="line">Sep 27 09:00:12 hcss-ecs-1c01 frps[245004]: 2023/09/27 09:00:12 [I] [proxy.go:199] [3bdfab421c086b9b] [ssh] get a user connection [95.216.66.209:55287]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="配置远程桌面发现和连接">配置远程桌面发现和连接</h2>
<p>在 <strong>Windows设置-&gt;系统-&gt;远程桌面</strong>
中进行设置，打开远程桌面发现已接受来自外面的连接：<br />
<img
src="https://pic2.zhimg.com/80/v2-86d4b4f39d65516b78c714b81056eccd_720w.webp" /></p>
<p>然后在iPad上的RD
Client上，配置frp服务器的ip地址，以及Windows系统中实际用于登陆的用户名和密码（虽然不设置也可以，在链接了之后再手动输入要登陆的账户和密码）。<br />
<img
src="https://pic3.zhimg.com/80/v2-88bf926c63b57a31b842124de47c4c32_720w.webp" /></p>
<h2 id="windows后台驻留fpr客户端监听">Windows后台驻留fpr客户端监听</h2>
<p>网上大部分使用fprc的教程是直接使用cmd或者powershell来运行frpc的，可是这样运行的话，fprc就成为了一个前台进程，只要进程窗口关闭，那么进程也会随之退出。我们可以写一个bat脚本并让这个脚本运行的时候不弹出窗口。<br />
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &quot;%<span class="number">1</span>&quot;==&quot;hide&quot; <span class="keyword">goto</span> CmdBegin</span><br><span class="line"><span class="built_in">start</span> mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~<span class="number">0</span>&quot;&quot; hide&quot;,<span class="number">0</span>)(window.close)&amp;&amp;<span class="keyword">exit</span></span><br><span class="line">:CmdBegin</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span> /b E:\frp_0.<span class="number">51</span>.<span class="number">3</span>_windows_amd64\frpc.exe -c E:\frp_0.<span class="number">51</span>.<span class="number">3</span>_windows_amd64\frpc.ini</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>删除QQ的Q盾进程和服务 - 知乎回答</title>
    <url>/blog/2023/10/11/data/normal%20notes/%E5%88%A0%E9%99%A4QQ%E7%9A%84Q%E7%9B%BE%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%9C%8D%E5%8A%A1%20-%20%E7%9F%A5%E4%B9%8E%E5%9B%9E%E7%AD%94/</url>
    <content><![CDATA[<p>157 人赞同了该回答</p>
<p>经过验证，从 QQ 9.6.0 版本开始（以及它的后续版本 9.6.x, 9.7.x
等版本依旧可用）已经不再依赖 QQProtect（<a
href="https://www.zhihu.com/search?q=Q%E7%9B%BE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">Q盾</a>、QPCore）进程了，<strong>但是“安装和升级”的时候还会安装上，每次升级都要手动进行删除</strong>。</p>
<p><strong>Q盾残留内容可以进行手动删除，不再影响 QQ
的正常使用。</strong></p>
<p><img
src="https://picx.zhimg.com/80/v2-962221dc6037dec41cc638150e3ff45e_720w.webp?source=1940ef5c" /></p>
<p>QQ 9.6.0 版本</p>
<h2 id="qq-win32-版下载">QQ Win32 版下载</h2>
<p><a
href="https://www.zhihu.com/search?q=%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">直接访问</a> QQ
官网下载即可：</p>
<blockquote>
<p><em>QQ Windows Electron 版暂未验证。</em></p>
</blockquote>
<p><a
href="https://link.zhihu.com/?target=https%3A//im.qq.com/index/%23downloadAnchor">QQ官网​im.qq.com/index/#downloadAnchor</a></p>
<h2 id="删除所有q盾组件">删除所有Q盾组件</h2>
<h3 id="结束q盾进程">1.结束Q盾进程</h3>
<p>首先
QQ <strong>不能</strong>在运行/打开状态，在任务管理器中找到 <strong>“<a
href="https://www.zhihu.com/search?q=Q%E7%9B%BE%E8%BF%9B%E7%A8%8B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">Q盾进程</a>”</strong>，<strong>右键并结束进程</strong>：</p>
<p><img
src="https://pica.zhimg.com/80/v2-a5a1c58284043b1773c69ab7ec5fbd6e_720w.webp?source=1940ef5c" /></p>
<h3 id="停止-qpcore-服务">2.停止 QPCore 服务</h3>
<p>右键 <strong>“<a
href="https://www.zhihu.com/search?q=%E6%AD%A4%E7%94%B5%E8%84%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">此电脑</a>”</strong>，选择 <strong>“管理
- 服务和<a
href="https://www.zhihu.com/search?q=%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">应用程序</a> -
服务”</strong>，找到 <strong>“QPCore Service”</strong>：</p>
<p><img
src="https://picx.zhimg.com/80/v2-7002db103b96d1b5b6d9b297bc81a68e_720w.webp?source=1940ef5c" /></p>
<blockquote>
<p>注意：必须先在<a
href="https://www.zhihu.com/search?q=%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">任务管理器</a>中结束
“结束Q盾进程”，才能够停止 QPCore 服务</p>
</blockquote>
<p><strong>“右键 - 属性”</strong>，检查 <strong>“QPCore
Service”</strong> 服务是否已停止。（一般来说，当你完成步骤1时，结束Q盾进程的时候，QPCore
Service 就已经停止了）</p>
<h3 id="删除-qpcore-服务">3.删除 QPCore 服务</h3>
<p>以 <strong>“管理员身份”</strong> 打开 <strong><a
href="https://www.zhihu.com/search?q=%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8F%90%E7%A4%BA%E7%AC%A6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">命令与提示符</a> CMD（Powershell
并不支持）</strong></p>
<p><img
src="https://pic1.zhimg.com/80/v2-46556137296ad89167acf997e059124d_720w.webp?source=1940ef5c" /></p>
<p>输入以下命令，即可<strong>删除Q盾进程</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sc delete QPCore</span><br></pre></td></tr></table></figure>
<p><img
src="https://picx.zhimg.com/80/v2-c0d792e45581c2de0b382d5f4a4624af_720w.webp?source=1940ef5c" /></p>
<p>删除后刷新下，你可以在 <strong>“管理 - 服务和应用程序 -
服务”</strong> 检查 <strong>“QPCore Service”
受否还存在？</strong>正常情况下不会有这个服务了。</p>
<h3 id="删除所有-qqprotect-文件">4.删除所有 QQProtect 文件</h3>
<p>总共有两处<strong>（QQ 9.7.x 版本之后只有一个 QQProtect <a
href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E5%A4%B9%E8%B7%AF%E5%BE%84&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">文件夹路径</a>）</strong>，删除这两个<strong>（或这一个）</strong> QQProtect
文件夹：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Common Files\Tencent\QQProtect</span><br><span class="line"></span><br><span class="line">C:\Users\yourname\AppData\Roaming\Tencent\QQ\QQProtect</span><br></pre></td></tr></table></figure>
<h2 id="启动-qq">5.启动 QQ</h2>
<p>此时你的 QQ 应该还能<strong>正常启动、登陆和使用。</strong></p>
<p>但是根据知友评论反馈，在 Windows SandBox（<a
href="https://www.zhihu.com/search?q=%E6%B2%99%E7%9B%92&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">沙盒</a>）环境中安装的
QQ 可能会导致无法启动。</p>
<h2 id="qqguild-卸载可选不得不删了">6.QQGuild
卸载（可选×，不得不删了√）</h2>
<p>之前一直是存在这个玩意，最近在QQ标签卡突然冒出来了，<strong>很生气！必须要给它删除！</strong></p>
<p>QQ Guild 模块（这是一个QQ<a
href="https://www.zhihu.com/search?q=%E9%A2%91%E9%81%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">频道</a>的组件），目录如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">C:\Users\yourname\AppData\Local\Tencent\QQGuild</span><br></pre></td></tr></table></figure>
<p>在这个路径下，可以看见一个版本文件夹（例如：<a
href="https://www.zhihu.com/search?q=1.3.24-213&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">1.3.24-213</a>），进入这个文件夹，然后运行<a
href="https://www.zhihu.com/search?q=%E5%8D%B8%E8%BD%BD%E7%A8%8B%E5%BA%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2492603110%7D">卸载程序</a>即可：</p>
<p><img
src="https://pic1.zhimg.com/80/v2-cbdbb7544fcd26c08c0dc670ff9c1b03_720w.webp?source=1940ef5c" /></p>
<p><strong>卸载完成后，请将 QQGuild 文件夹，右键属性，把 Users
的写入权限拒绝掉就行了</strong></p>
<p><img
src="https://pica.zhimg.com/80/v2-3d52f3a1e249cd001bb60ba7b36aeba2_720w.webp?source=1940ef5c" /></p>
<h2 id="windows-tim">7.Windows Tim</h2>
<p>根据评论区知友反馈 Tim 3.4.6 版本也支持。</p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>可用的ChatGPT国内代理站</title>
    <url>/blog/2023/10/11/data/normal%20notes/%E5%8F%AF%E7%94%A8%E7%9A%84ChatGPT%E5%9B%BD%E5%86%85%E4%BB%A3%E7%90%86%E7%AB%99/</url>
    <content><![CDATA[<p>除了官方网站，国内也有一些免费的 ChatGPT
代理网站可以使用。这些网站不仅可以让用户免费使用 ChatGPT
生成自然语言文本，还可以免去翻墙的麻烦。</p>
<p>以下为大家分享几个免费的 ChatGPT 代理网站：</p>
<ol type="1">
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jaGF0MjMueXFjbG91ZC50b3A=">https://chat23.yqcloud.top</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9ncHQucWluZ3Rpbmcud29yay8=">https://gpt.qingting.work/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly93d3cuYWl0aWFuaHUuY29tLw==">https://www.aitianhu.com/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jaGF0LmFpZHV0dS5jbi8=">https://chat.aidutu.cn/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jaGF0LndvYmN3LmNvbS8=">https://chat.wobcw.com/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9ncHQuYWllYXN5Lm9uZS8=">https://gpt.aieasy.one/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jaGF0MTQueGVhc3kubWUv">https://chat14.xeasy.me/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jaGF0LnpodWxlaXh4LnRvcC8=">https://chat.zhuleixx.top/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jaGF0LjY4Njg2Lmx0ZC8=">https://chat.68686.ltd/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jaGF0Lm9odG9haS5jb20v">https://chat.ohtoai.com/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9vcGVuLXByb2R1Y3Rpb24udXAucmFpbHdheS5hcHAv">https://open-production.up.railway.app/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9hLm15ZG9nLmJ1enov">https://a.mydog.buzz/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jaGF0LmJudTEyMC5zcGFjZS8=">https://chat.bnu120.space/</a><br />
</li>
<li><a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jb29sLWpzLmNvbS8=">https://cool-js.com/</a><br />
</li>
<li>支持GPT4:<a
href="https://www.chengzz.com/?golink=aHR0cHM6Ly9jaGF0LmNoYXRib3Quc2V4Lw==">https://chat.chatbot.sex/</a></li>
</ol>
<p>这些代理网站提供了多种语言版本的 ChatGPT
接口，包括英文、中文、日文等等。用户可以根据自己的需求选择合适的接口进行使用。</p>
<p>其中第一个代理网站的效果不错，免费用爱发电，站长自己购买代理服务器和API
Key，可以捐赠以维持服务器的运行。<a
href="%5Bchatgpt-web/README.md%20at%20main%20·%20binjie09/chatgpt-web%20(github.com)%5D(https://github.com/binjie09/chatgpt-web/blob/main/README.md)">Github链接</a></p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>学生交了保险就会失去应届生身份吗？</title>
    <url>/blog/2023/10/11/data/normal%20notes/%E5%AD%A6%E7%94%9F%E4%BA%A4%E4%BA%86%E4%BF%9D%E9%99%A9%E5%B0%B1%E4%BC%9A%E5%A4%B1%E5%8E%BB%E5%BA%94%E5%B1%8A%E7%94%9F%E8%BA%AB%E4%BB%BD%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p><a
href="https://www.zhihu.com/search?q=%E7%A4%BE%E4%BF%9D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">社保</a>身份分为两类，一是职工，二是居民。</p>
<p>⭐职工社保简单说，就是去单位上班交的五险（五险包括：养老，医疗，失业，工伤，生育）。有些人没工作单位，也可以去交<a
href="https://www.zhihu.com/search?q=%E7%81%B5%E6%B4%BB%E5%B0%B1%E4%B8%9A&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">灵活就业</a>社保（一般是养老和医疗两险，也有地方是养老医疗失业三险）灵活就业交的社保也是职工社保的范畴。</p>
<hr />
<p>⭐<a
href="https://www.zhihu.com/search?q=%E5%B1%85%E6%B0%91%E7%A4%BE%E4%BF%9D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">居民社保</a>简单说就是没工作单位也没交灵活就业的，都可以去交居民社保，只要你有中国国国籍即可。当然现在港澳台居民也能在大陆交居民社保。</p>
<p>居民社保分为养老和医疗。</p>
<p>⭐居民医疗没有<a
href="https://www.zhihu.com/search?q=%E5%B9%B4%E9%BE%84%E9%99%90%E5%88%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">年龄限制</a>，从新生儿，到学生儿童，到大学生，到16周岁以上的<a
href="https://www.zhihu.com/search?q=%E5%8A%B3%E5%8A%A8%E5%B9%B4%E9%BE%84&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">劳动年龄</a>内居民，到超了劳动年龄却没有退休的老年人，都可以交居民医保。不知你听说过<a
href="https://www.zhihu.com/search?q=%E6%96%B0%E5%86%9C%E5%90%88&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">新农合</a>吗？新农合就是一种居民<a
href="https://www.zhihu.com/search?q=%E5%8C%BB%E7%96%97%E4%BF%9D%E9%99%A9&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">医疗保险</a>。现在统一称为城乡居民医疗保险，以前在农村交的叫新农合，在城市交的叫城镇居民医保也叫“<a
href="https://www.zhihu.com/search?q=%E4%B8%80%E8%80%81%E4%B8%80%E5%B0%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">一老一小</a>”，在大学里交的叫<a
href="https://www.zhihu.com/search?q=%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%8C%BB%E4%BF%9D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">大学生医保</a>。所以，你同学在上大学之前，在家里交了居民医保⭐并且领取了<a
href="https://www.zhihu.com/search?q=%E7%A4%BE%E4%BF%9D%E5%8D%A1&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">社保卡</a>，这是很正常的现象。你为什么没有社保卡？也许家里没给你交居民医保，也可能交了没去办社保卡。无论哪种原因，这都不重要了。居民医保一年一交，一年一保，你以前一直身体健康，没去过医院，没用过医保，更不需要去补缴什么的。过去的就让他过去吧！现在你有大学生医保，等你毕业了，参加工作，还会有职工医保继续对接的，继续保障，不用担心。</p>
<p>⭐居民养老是个什么鬼？这个险种比较小众，交的人比较少。如果毕业之后，没在单位上班，除了自己去交个<a
href="https://www.zhihu.com/search?q=%E5%B1%85%E6%B0%91%E5%8C%BB%E7%96%97&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">居民医疗</a>，原则上是可以再去交个<a
href="https://www.zhihu.com/search?q=%E5%B1%85%E6%B0%91%E5%85%BB%E8%80%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">居民养老</a>。但真的，很少人这么干。大学毕业，二十多岁，上个班交个职工社保，单位出大部分的费用，个人出小部分的费用，多合适啊。何必要自己花钱去交居民社保，不光居民医疗看病报销的少，而且居民养老<a
href="https://www.zhihu.com/search?q=%E9%80%80%E4%BC%91%E9%87%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">退休金</a>也拿的少。目前，只有一些<a
href="https://www.zhihu.com/search?q=%E5%86%9C%E6%9D%91%E6%88%B7%E7%B1%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">农村户籍</a>没出去打工的，或者城市里有些特殊原因无法正常上班交职工社保的，为了有个最低保障才去交。经常有人说⭐农民没有<a
href="https://www.zhihu.com/search?q=%E5%85%BB%E8%80%81%E9%87%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">养老金</a>之类的，实际上不是这样。农民进城务工了，就可以交职工社保，按职工退休领养老金。农民不进城务工的，就可以交这个居民养老保险，一年几百或几千块钱，最少交15年，60岁后按月领居民<a
href="https://www.zhihu.com/search?q=%E5%85%BB%E8%80%81%E4%BF%9D%E9%99%A9%E9%87%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">养老保险金</a>。</p>
<hr />
<p>再说最重要的一点，上班交社保，是法定强制缴纳义务。有⭐劳动关系就必须交<a
href="https://www.zhihu.com/search?q=%E8%81%8C%E5%B7%A5%E7%A4%BE%E4%BF%9D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">职工社保</a>。所以，如果你在上大学期间，在某个单位交了职工社保，那就代表着你与这个单位存在劳动关系。而在毕业时，如果要考公考编进<a
href="https://www.zhihu.com/search?q=%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">事业单位</a>，或者在<a
href="https://www.zhihu.com/search?q=%E5%A4%A7%E5%9F%8E%E5%B8%82&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">大城市</a>申请毕业生落户，一般都有一个要求：<a
href="https://www.zhihu.com/search?q=%E5%9C%A8%E6%A0%A1%E6%9C%9F%E9%97%B4&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">在校期间</a>不能与任何单位有劳动关系。他怎么知道你有没有劳动关系呢？查社保记录。所以，在校期间，尽量不要去什么亲戚朋友公司挂靠社保之类的。寒暑假打工的话，也要跟单位说明，不交社保。</p>
<p>注意，这个社保记录是，职工社保。而你在学校交的大学生医保，你同学以前在家交的新农合，一老一小，居民医保这些都不会有任何影响的。</p>
<p>⭐<a
href="https://www.zhihu.com/search?q=%E5%BA%94%E5%B1%8A%E7%94%9F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">应届生</a>身份，当年毕业的都叫应届生。有些地方招考要求，会放宽至两年<a
href="https://www.zhihu.com/search?q=%E6%8B%A9%E4%B8%9A%E6%9C%9F%E5%86%85&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">择业期内</a>，也就是两年内没落实工作的毕业生。具体看招考单位的要求。</p>
<p>⭐至于有没有社保卡，不是很重要的事情。你若没有，就去申请办一个。社保卡号等于身份证号，将来社保身份改变了，例如毕业之后上班交职工社保了，而你社保卡里的身份信息可能还是大学生身份，交给单位的人事去做数据信息同步即可。当然，也有很多地方自动<a
href="https://www.zhihu.com/search?q=%E5%90%8C%E6%AD%A5%E4%BF%A1%E6%81%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">同步信息</a>，不用特意去变卡里的信息。<a
href="https://www.zhihu.com/search?q=%E8%BF%99%E4%BA%9B%E9%83%BD%E6%98%AF%E5%B0%8F%E4%BA%8B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2326031703%7D">这些都是小事</a>，不重要。</p>
]]></content>
      <categories>
        <category>normal notes</category>
      </categories>
      <tags>
        <tag>normal notes</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake生成的编译命令</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/CMake%E7%94%9F%E6%88%90%E7%9A%84%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>今天在更新自己的CMake项目模板的时候，好奇build构建目录下CMake生成的一大堆文件里到底都有什么，除了对每个<code>add_sub_directory</code>建立的管理目录，还有一个makefile，一个install_manifest.txt，一个compile_command.json，一直没有看过这个json文件到底是什么，查看了一下。原来是CMake根据CMakeLists文件构建的对象最终生成的帮用户调用g++和gcc的命令：<br />
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++ -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu++17 -o CMakeFiles/insrc.dir/dummy/dummy.cpp.o -c /home/fredom/workspace/temp2/src/dummy/dummy.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/dummy/dummy.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/insrc.dir/dummy/dummy.cpp.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++ -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu++17 -o CMakeFiles/insrc.dir/mathnipet.cpp.o -c /home/fredom/workspace/temp2/src/mathnipet.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/mathnipet.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/insrc.dir/mathnipet.cpp.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu17 -o CMakeFiles/insrc.dir/utils/clog.c.o -c /home/fredom/workspace/temp2/src/utils/clog.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/utils/clog.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/insrc.dir/utils/clog.c.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu17 -o CMakeFiles/insrc.dir/utils/ctest1.c.o -c /home/fredom/workspace/temp2/src/utils/ctest1.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/utils/ctest1.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/insrc.dir/utils/ctest1.c.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu17 -o CMakeFiles/insrc.dir/utils/ctest2.c.o -c /home/fredom/workspace/temp2/src/utils/ctest2.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/utils/ctest2.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/insrc.dir/utils/ctest2.c.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++ -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu++17 -o CMakeFiles/insrc.dir/utils/log.cpp.o -c /home/fredom/workspace/temp2/src/utils/log.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/utils/log.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/insrc.dir/utils/log.cpp.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++ -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu++17 -o CMakeFiles/dummy.dir/dummy/dummy.cpp.o -c /home/fredom/workspace/temp2/src/dummy/dummy.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/dummy/dummy.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/dummy.dir/dummy/dummy.cpp.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu17 -o CMakeFiles/utils.dir/utils/clog.c.o -c /home/fredom/workspace/temp2/src/utils/clog.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/utils/clog.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/utils.dir/utils/clog.c.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu17 -o CMakeFiles/utils.dir/utils/ctest1.c.o -c /home/fredom/workspace/temp2/src/utils/ctest1.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/utils/ctest1.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/utils.dir/utils/ctest1.c.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu17 -o CMakeFiles/utils.dir/utils/ctest2.c.o -c /home/fredom/workspace/temp2/src/utils/ctest2.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/utils/ctest2.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/utils.dir/utils/ctest2.c.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++ -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu++17 -o CMakeFiles/utils.dir/utils/log.cpp.o -c /home/fredom/workspace/temp2/src/utils/log.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/src/utils/log.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/utils.dir/utils/log.cpp.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/app&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu17 -o CMakeFiles/ctest.dir/ctest.c.o -c /home/fredom/workspace/temp2/app/ctest.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/app/ctest.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;app/CMakeFiles/ctest.dir/ctest.c.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/build/app&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++ -DDEBUG -I/home/fredom/workspace/temp2/include/dummy -I/home/fredom/workspace/temp2/include -I/home/fredom/workspace/temp2/include/utils -g -std=gnu++17 -o CMakeFiles/main.dir/main.cpp.o -c /home/fredom/workspace/temp2/app/main.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/fredom/workspace/temp2/app/main.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;app/CMakeFiles/main.dir/main.cpp.o&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，实际生成的g++、gcc编译命令，里面的参数，包括-I指示的头文件目录和
-L指示的库文件链接目录，-l指示的待尝试链接的库文件，都是CMakeLists中写好的，一一对应的。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC、G++自动链接libstdc++.so动态库的原理</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/GCC%E3%80%81G++%E8%87%AA%E5%8A%A8%E9%93%BE%E6%8E%A5libstdc++.so%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>基本的C/C++程序一般都会使用到&lt;stdio.h&gt;或者&lt;iostream&gt;这样的标准库，这些标准库的头文件提供了声明，它们是C/C++标准委员会制定的标准头文件（一般存放在GCC或者MinGW的目录下的include），那么这些标准库的函数实现在哪里？没错，就是libstdc++.so（Unix类系统）和libstdc++.dll（Win32系统），gcc/g++在编译我们的项目文件时，除了我们自己指定的第三方库，这个标准库是自动链接的，一般是链接动态库，听说链接静态库有问题（https://stackoverflow.com/questions/13636513/linking-libstdc-statically-any-gotchas）</p>
<h2 id="什么是c-abi">什么是C++ ABI？</h2>
<p>C++ ABI 指的是 C++ 应用程序二进制接口，是一组由 C++
编译器和标准库实现的规则，用于指定在不同编译器和系统上编译的 C++
应用程序之间的二进制兼容性。C++ ABI 包括如何表示 C++
类、虚函数表、异常处理、名称重载、模板实例化等方面的规定。采用 C++ ABI
可以使得不同编译器和系统之间的 C++
应用程序可以在二进制级别上相互兼容，从而使得不同的代码模块可以在运行时动态链接和使用。</p>
<h2 id="abi-是什么的缩写">ABI 是什么的缩写</h2>
<p>ABI 是 Application Binary Interface
的缩写，意为应用程序二进制接口。</p>
<p>由gcc编译的C++ 程序都会自动地动态链接
系统环境变量下的libstdc++.so吗？如果我将libstdc++.so所在的目录路径从环境变量中去除，gcc还能正常编译C++程序吗</p>
<p>是的，由 GCC 编译的 C++ 程序默认会自动地动态链接系统环境变量下的
libstdc++.so 库。如果将 libstdc++.so 所在的目录路径从环境变量中去除，GCC
仍然可以正常编译 C++ 程序，但是在链接时会提示找不到 libstdc++.so
库，程序无法运行。如果需要在没有系统环境变量的情况下编译和链接 C++
程序，可以使用静态链接方式，将 libstdc++.a 静态库链接到程序中。</p>
<p>你知道编译C/C++程序时
指定的RPATH是什么作用吗？好像是指定可执行文件在执行时需要加载动态链接库的话，可能的库搜索目录？</p>
<p>是的，RPATH 是 Runtime PATH
的缩写，指的是程序运行时搜索动态链接库的路径。在编译 C/C++
程序时，可以使用 -rpath 选项来指定 RPATH，例如
-Wl,-rpath=/path/to/lib。指定 RPATH
的作用是允许可执行文件在执行时自动搜索指定路径下的动态链接库。如果程序调用了某个动态链接库，但是系统默认的动态链接库搜索路径中没有该库，程序会无法运行。通过指定
RPATH，程序就可以在指定路径下搜索动态链接库，避免了这个问题。</p>
<p>需要注意的是，指定 RPATH
会使程序在运行时依赖指定路径下的动态链接库，如果该路径下的库发生变化或不存在，程序就无法运行。因此，使用
RPATH 时需要谨慎，确保库的版本和路径的正确性。</p>
<h2 id="那么-wl参数有什么用">那么-Wl参数有什么用？</h2>
<p>-Wl 是 GCC 的一个编译选项，表示将后面的参数传递给链接器 ld。在 C/C++
编译过程中，编译器会将源代码编译成目标文件，然后链接器会将多个目标文件合并成一个可执行文件或者共享库。-Wl
选项可以将选项传递给链接器，以控制链接器的行为。</p>
<p>例如，-Wl,-rpath=/path/to/lib 就是将 -rpath=/path/to/lib
选项传递给链接器。这个选项会告诉链接器在链接可执行文件或共享库时添加
RPATH，以便程序在运行时可以正确地搜索动态链接库。类似地，-Wl,-Bstatic
选项可以告诉链接器静态链接库，-Wl,-Bdynamic
选项可以告诉链接器动态链接库。这些选项都是通过 -Wl
选项传递给链接器的。</p>
<p>总之，-Wl 选项可以将链接器的选项传递给
GCC，以便控制链接器的行为。</p>
<p>这么说RPATH这个参数的值是被嵌入到可执行文件中了吗？还是说这个参数的值只对链接器起作用，会告诉它去哪里找库文件？</p>
<p>RPATH
这个参数的值是被嵌入到可执行文件中的，它会告诉操作系统在运行可执行文件时去哪里找动态链接库。在
Linux 系统中，可执行文件会包含一个 ELF 格式的头部，其中有一个名为
DT_RPATH 的动态链接器标志。这个标志指定了程序运行时需要搜索的
RPATH，以便找到程序所依赖的动态链接库。RPATH
可以被设置为绝对路径或相对路径，如果是相对路径，那么相对路径是相对于可执行文件的路径。在编译
C/C++ 程序时，可以使用 -rpath 选项来指定
RPATH。这个选项会告诉链接器在生成可执行文件时将 RPATH
嵌入到可执行文件中。因此，RPATH
的值是被嵌入到可执行文件中的，它会影响程序在运行时搜索动态链接库的路径。</p>
<p>需要注意的是，RPATH
会使程序在运行时依赖指定路径下的动态链接库，如果该路径下的库发生变化或不存在，程序就无法运行。因此，使用
RPATH 时需要谨慎，确保库的版本和路径的正确性。</p>
<p>RPATH默认值是可执行文件所在的目录吗？</p>
<p>不是的，RPATH 的默认值是空值（即没有设置 RPATH）。</p>
<p>如果没有设置 RPATH，操作系统会按照以下顺序搜索动态链接库：</p>
<ol type="1">
<li>在默认路径 /lib 和 /usr/lib 中查找系统库。<br />
</li>
<li>在环境变量 LD_LIBRARY_PATH 指定的路径中查找动态链接库。<br />
</li>
<li>在运行时可执行文件所在目录中查找动态链接库。</li>
</ol>
<p>因此，如果可执行文件和动态链接库在同一目录下，操作系统会在运行时可执行文件所在目录中查找动态链接库。</p>
<p>但是，为了避免程序依赖于环境变量和默认路径，建议在编译可执行文件时设置
RPATH，以确保程序可以正确地找到所依赖的动态链接库。</p>
<p>gcc为什么知道要自动链接libstdc++.so动态库而无需人为地指定链接参数？编译器制作人员在设计之初就把这个自动链接行为编码在了gcc中吗？</p>
<p>是的，gcc 的编译器制作人员在设计之初就将自动链接 libstdc++.so
动态库的行为编码在了 gcc 中。</p>
<p>在编译 C++ 程序时，gcc 会默认链接 libstdc++.so 动态库。这是因为 gcc
的 C++ 标准库是以动态库的形式提供的，而且 gcc 内部已经将链接
libstdc++.so 的选项</p>
<p>-lstdc++ 编码进了编译器中。</p>
<p>具体来说，gcc 会在链接阶段自动查找 C++ 标准库，包括 libstdc++.so
和其他依赖的动态库，并将这些库链接到程序中。如果找不到这些库，编译器会报错。</p>
<p>因此，在编译 C++ 程序时，我们不需要显式地指定 -lstdc++ 参数来链接
libstdc++.so 动态库，gcc 会自动完成这个工作。</p>
<p>-Wl 参数是什么指令的缩写？</p>
<p>-Wl 是 gcc/g++ 编译器的一个参数，用于将选项传递给链接器
ld。具体来说，-Wl
参数后面可以跟随多个用逗号分隔的选项，这些选项会被传递给链接器
ld。例如：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -o myapp myapp.cpp -Wl,-rpath,/usr/local/lib Copy</span><br></pre></td></tr></table></figure></p>
<p>上述命令中，-Wl,-rpath,/usr/local/lib 会将 -rpath,/usr/local/lib
这个选项传递给链接器 ld，告诉 ld 在运行时动态链接库搜索路径中添加
/usr/local/lib。因此，可以将 -Wl
看作是一个将编译器选项传递给链接器的缩写指令。如果我有多个链接选项要传递给链接器呢？如果你有多个链接选项要传递给链接器，可以使用多个-Wl
参数来分别传递这些选项。例如，假设你要传递-L/usr/local/lib 和 -lfoo
这两个链接选项给链接器，可以使用如下命令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -o myapp myapp.cpp -Wl,-L/usr/local/lib -Wl,-lfoo Copy</span><br></pre></td></tr></table></figure></p>
<p>上述命令中，-Wl,-L/usr/local/lib 会将 -L/usr/local/lib
这个选项传递给链接器 ld，告诉 ld 在搜索库文件时添加 /usr/local/lib
这个路径。-Wl,-lfoo 则会将 -lfoo 这个选项传递给链接器 ld，告诉 ld
链接名为 libfoo.so 或 libfoo.a
的库文件。需要注意的是，不同的链接选项之间应该使用多个 -Wl
参数进行分隔，否则可能会被 gcc/g++
解析成其他的编译选项，导致编译错误。</p>
<p>比如在调试一个基本的C++
helloworld程序时，gdb在加载了符号后会弹出以下信息：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Loaded &#x27;/lib64/ld-linux-x86-64.so.2&#x27;. Symbols loaded.</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdb38) at /home/fredom/workspace/cpp-playground/temp/app/main.cpp:5</span><br><span class="line">5 print_msg(&quot;hello world&quot;);</span><br><span class="line">Loaded &#x27;/home/fredom/workspace/cpp-playground/temp/runtimelib/Debug/SHARED/libruntime.so&#x27;. Symbols loaded.</span><br><span class="line">Loaded &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;. Symbols loaded.</span><br><span class="line">Loaded &#x27;/lib/x86_64-linux-gnu/libstdc++.so.6&#x27;. Symbols loaded.</span><br><span class="line">Loaded &#x27;/lib/x86_64-linux-gnu/libm.so.6&#x27;. Symbols loaded.</span><br><span class="line">Loaded &#x27;/lib/x86_64-linux-gnu/libgcc_s.so.1&#x27;. Symbols loaded.</span><br><span class="line">[Inferior 1 (process 13434) exited normally]</span><br><span class="line"></span><br><span class="line">The program &#x27;/home/fredom/workspace/cpp-playground/temp/bin/Debug/main&#x27; has exited with code 0 (0x00000000).</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>找不到动态库文件？试试手动指定查找目录</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E5%BA%93%E6%96%87%E4%BB%B6%EF%BC%9F%E8%AF%95%E8%AF%95%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A%E6%9F%A5%E6%89%BE%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>我在另一台Linux机器上编译了所有可执行文件，使用的是动态链接库的方式把src目录下的定义生成为一个库，在运行时动态链接。然后我将这些可执行文件和动态库打包为.tar.gz文件使用nc发送给另一台Linux机器，可是当我在另一台Linux机器上准备运行的时候，发现提示无法找到动态链接库。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[fredom@ECS-Tencentyun 15:16:55] ~/workspace/bin/Debug</span><br><span class="line">$ ./main</span><br><span class="line">./main: error while loading shared libraries: libmysrc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>当时的目录下有这些文件：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[fredom@ECS-Tencentyun 15:21:08] ~/workspace/bin/Debug</span><br><span class="line">$ ls</span><br><span class="line">total 448K</span><br><span class="line">-rwxr-xr-x 1 fredom fredom  27K Jul 21 14:06 ctest*</span><br><span class="line">-rwxr-xr-x 1 fredom fredom  27K Jul 21 14:06 file_clnt*</span><br><span class="line">-rwxr-xr-x 1 fredom fredom  31K Jul 21 14:06 file_serv*</span><br><span class="line">-rw-r--r-- 1 fredom fredom 166K Jul 21 14:06 libmysrc.so</span><br><span class="line">-rwxr-xr-x 1 fredom fredom 127K Jul 21 14:06 main*</span><br><span class="line">-rwxr-xr-x 1 fredom fredom  30K Jul 21 14:06 uecho_client*</span><br><span class="line">-rwxr-xr-x 1 fredom fredom  29K Jul 21 14:06 uecho_server*</span><br></pre></td></tr></table></figure>
可以看到.so动态库文件就和可执行文件在同一个目录，但是却无法被可执行文件找到，此时我意识到，原来可执行文件封装的动态库查找信息是绝对路径，因为我换了一台机器，所以原来的绝对路径是不存在了，因此又会去系统指定的库目录下查找，但是我发现这台Linux机器的
<strong>LD_LIBRARY_PATH</strong>
环境变量是空的。。。怪不得没有找到可链接动态库</p>
<p>解决办法也很简单，在运行当前指令前，给环境变量增加
<strong>LD_LIBRARY_PATH</strong> 变量的值为动态库所在目录即可。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[fredom@ECS-Tencentyun 15:20:11] ~/workspace/bin/Debug</span><br><span class="line">$ LD_LIBRARY_PATH=$&#123;PWD&#125; ./main</span><br><span class="line">msg - Hello, world!</span><br><span class="line">2023-07-21 15:21:08 [DBUG] Hello, world!</span><br><span class="line">    /home/fredom/workspace/tcpipstudy/src/dummy/dummy.cpp 9</span><br><span class="line">2023-07-21 15:21:08 [DBUG]</span><br><span class="line">    /home/fredom/workspace/tcpipstudy/src/dummy/dummy.cpp 10</span><br><span class="line">2023-07-21 15:21:08 [DBUG] Hello , world!</span><br><span class="line">    /home/fredom/workspace/tcpipstudy/app/main.cpp 7</span><br><span class="line">2023-07-21 15:21:08 [DBUG]</span><br><span class="line">    /home/fredom/workspace/tcpipstudy/app/main.cpp 8</span><br></pre></td></tr></table></figure></p>
<p>![[Pasted image 20230721153308.png]]</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器如何找到默认头文件位置？</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E9%BB%98%E8%AE%A4%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE%EF%BC%9F/</url>
    <content><![CDATA[<p>Partly by convention and partly by design, C programs are split into
source files that describe the functionality of the program itself and
header files that describe how to invoke that functionality from other
source files. Technically speaking, you can write a complete and useful
C program without ever creating or referring to a header file — this is
actually feasible when writing embedded apps — but practically, you're
going to probably need to at least import a few. You can't even read a
file or write to the console without importing &lt;stdio.h&gt;, for
example.</p>
<p>include-ing a header file in a C program actually means copying the
contents of another file in the current one. The strange-looking
construct in listings 1 and 2 compile and work correctly:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, i );</span><br><span class="line"></span><br><span class="line">Listing <span class="number">1</span>: increment.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span> &#123;  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;increment.c&quot;</span>  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 2: count.c</p>
<p>Nobody ever codes this way (I hope...) but since the C
preprocessor's #include directive just means "copy the contents of the
named file into this one before compiling", you could.</p>
<p>In practical use, though, #include is used to copy in header files
that describe other modules which will be linked and referred to within
the current source file. C includes dozens of standard header files for
I/O, math, concurrency, string manipulation, etc. If you refer to one,
its contents must be copied into the current source file before it can
be processed. So, where does the compiler look to find these files? The
earliest description of the C programming language, Kernighan and
Ritchie's book "The C Programming Language" (AKA K&amp;R), talks about
the preprocessor in chapter 4:</p>
<p>File inclusion makes it easy to handle collections of #defines and
declarations (among other things). Any source line of the form</p>
<p>#include "filename"</p>
<p>or</p>
<p>#include &lt;filename&gt;</p>
<p>is replaced by the contents of the file filename. If the filename is
quoted, searching for the file typically begins where the source program
was found; if it is not found there, or if the name is enclosed in &lt;
and &gt;, seaching follows an implementation-defined rule to find the
file.</p>
<p>While not an official standard, K&amp;R suggested two different ways
to indicate to the compiler where to look for a header file. The first
was to enclose the name of the header file in double quotes,
e.g. "header.h". In this case, the compiler should (typically) look for
the header in the same directory as the source file. Otherwise, the
search should be "implementation-defined". Well, that's not very
informative. K&amp;R was published in 1978, but C was standardized by
ANSI in 1983. So what does the standard say about header file
inclusion?</p>
<p>The <a
href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf">official
C standard</a> in section 6.10.2, "Source file inclusion", states:</p>
<p>A preprocessing directive of the form</p>
<p>#include "q-char-sequence" new-line</p>
<p>causes the replacement of that directive by the entire contents of
the source file identified by the specified sequence between the "
delimiters. The named source file is searched for in an
implementation-defined manner.</p>
<p>The standard actually says less about where to look for header files
than K&amp;R does! Technically speaking, it's impossible to write a
portable C program consisting of less than one source file, since the
compiler can be standards compliant while searching for header files
anywhere it cares to.</p>
<p>Although Apple seems to have nudged the world in the direction of
LLVM, for decades, GCC was the de facto standard for C compilation until
very recently. Sometimes you had to use a vendor-specific compiler like
Microsoft's, but GCC mostly blazed the trail for standardizing the
non-standard parts of the C progamming language. So what is the
"implementation-defined" GCC manner for header file incluion? As it
turns out, although it mostly does what you want it to in most cases, it
can be pretty complex and compiler flags can make radical changes to
it.</p>
<p>In the simplest (theoretical) case, you have a single source file and
a single header file, both in the same directory. In this case, GCC's
job seems easy; it just looks in the current directory, finds the header
file, and compiles. But actually, there's even a bit of a twist here.
This complexity arises because the behavior differs when you use quotes
vs. angle brackets. If you use quotes, the current directory is searched
first. If the header file isn't found, then the angle-bracket search
path is used. You can verify this by actually "overriding" stdio.h</p>
<p>#define SEEK_SET  12</p>
<p>Listing 3: overridden stdio.h</p>
<p>If you include this file in the same directory as source.c:</p>
<p>#include &lt;stdio.h&gt;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;SEEK_SET = %d\n&quot;</span> );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 4: system search path</p>
<p>And compile and run this, you'll see:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./a.out  </span><br><span class="line">SEEK_SET = 0</span><br></pre></td></tr></table></figure>
<p>The compiler found the system copy of stdio.h instead of my
"override". However, if I change the #include to use single quotes:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;SEEK_SET = %d\n&quot;</span> );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 5: system search path</p>
<p>The output becomes:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./a.out  </span><br><span class="line">SEEK_SET = 12</span><br></pre></td></tr></table></figure>
<p>I also got a compiler warning about an incompatible implicit
declaration of built-in function 'printf' — my new stdio.h didn't
declare it, but of course the linker still found it.</p>
<p>So, if a header file is not found in the current directory, where
does it look? The <a
href="http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html">GCC
documentation</a> states:</p>
<p>GCC looks in several different places for headers. On a normal Unix
system, if you do not instruct it otherwise, it will look for headers
requested with #include &lt;file&gt; in:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /usr/local/include  </span><br><span class="line">  libdir/gcc/target/version/include  </span><br><span class="line">  /usr/target/include  </span><br><span class="line">  /usr/include</span><br></pre></td></tr></table></figure>
<p>but that's sort of a wishy-washy answer (and also incomplete). Surely
there must be a way to get GCC to tell you exactly where it's going to
end up looking for its header files? Well, although it's convenient to
think of GCC as a single monolithic application that takes in source
code files and spits out working programs, it's technically a collection
of other programs which chain together to produce the final compiled
object file. The first of these is CPP, short for C Pre-Processor, whose
job is to look for compiler directives like #include and modify the
source code as specified by them; in the case of include, by copying the
contents of another file into the current one. You can see where it
looks for these files by passing it the -v flag:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cpp -v</span>  </span><br><span class="line">...  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include <span class="string">&quot;...&quot;</span> search starts here:</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;...&gt; search starts here:</span>  </span><br><span class="line"> /usr/local/include  </span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include  </span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed  </span><br><span class="line"> /usr/include/x86_64-linux-gnu  </span><br><span class="line"> /usr/include</span><br></pre></td></tr></table></figure>
<p>this path is actually built into CPP (which is part of GCC) at
compile time; if for whatever reason you end up deleting one of those
directories, it will still be checked for on each compile. Each
directory is searched in the order it's listed here; if a file is found
in /usr/local/include, the next three directories won't be checked. This
behavior is important — notice the include-fixed directory in the search
path? On my system, it includes two files: limits.h and syslimits.h.
Both of these files also appear in /usr/include; however, GCC will not
operate correctly if it finds the copies from the /usr/include directory
later in its search path.</p>
<p>There are a couple of ways you can manipulate this directory
structure. The simplest is by providing the compiler flag -I. -I is
followed by an absolute or relative (to the current directory) path,
with no spaces, and inserts the named directory at the beginning of the
"angle-bracket" search path. Thus, if you create a directory headers,
copy the "overridden" stdio.h from listing 3 into it, and
invoke gcc with:</p>
<p>gcc -Iheaders source.c</p>
<p>the output will show SEEK_SET as 12 even if you #include stdio.h with
angle brackets as in listing 4. cpp -v verifies that the -I'ed directory
is first in the search path:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cpp -Iheaders -v</span>  </span><br><span class="line">...  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include <span class="string">&quot;...&quot;</span> search starts here:</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;...&gt; search starts here:</span>  </span><br><span class="line"> headers  </span><br><span class="line"> /usr/local/include  </span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include  </span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed  </span><br><span class="line"> /usr/include/x86_64-linux-gnu  </span><br><span class="line"> /usr/include</span><br></pre></td></tr></table></figure>
<p>But wait — earlier I said that GCC will not compile correctly if it
picks up limits.h from /usr/include. So what happens if I try to
force /usr/include to be the first directory in the list via:</p>
<p>$ cpp -I/usr/include</p>
<p>? As it turns out, GCC will ignore me in this case:</p>
<p>$ cpp -I/usr/include -v<br />
...<br />
ignoring duplicate directory "/usr/include"<br />
  as it is a non-system directory that duplicates a system
directory<br />
#include "..." search starts here:<br />
#include &lt;...&gt; search starts here:<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> /usr/local/include  </span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include  </span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed  </span><br><span class="line"> /usr/include/x86_64-linux-gnu  </span><br><span class="line"> /usr/include</span><br></pre></td></tr></table></figure></p>
<p>There is no way to change this search order other than to recompile
GCC itself. You can pass in the -nostdinc option which will remove all
of these directories from the search path:</p>
<p>$ cpp -I/usr/include -v<br />
...<br />
#include "..." search starts here:<br />
#include &lt;...&gt; search starts here:</p>
<p>But there are only a few good reasons why you'd want to do that
(compiling the Linux kernel is one example). Other than -nostdinc, GCC
does not give you a way to remove a directory from the search path once
it's been added.</p>
<p>If you want to add multiple directories to the search path, you
specify the -I directory multiples times. These new directories are
added to the beginning of the search path, in the order that they're
presented on the command line. If you have a lot of paths that you need
to specify repeatedly, GCC looks for an environment variable
called CPATH that has the same effect as include -I multiple times, once
for each colon- separated path in the declaration:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ EXPORT CPATH=hdr1:hdr2  </span><br><span class="line">$ cpp -v  </span><br><span class="line">...  </span><br><span class="line">\#include &lt;...&gt; search starts here:  </span><br><span class="line"> hdr1  </span><br><span class="line"> hdr2  </span><br><span class="line"> /usr/local/include  </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>If you combine CPATH with -I flags, -I takes precedence:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ EXPORT CPATH=hdr1:hdr2  </span><br><span class="line">$ cpp -Ihdr3 -v  </span><br><span class="line">...  </span><br><span class="line">#include &lt;...&gt; search starts here:  </span><br><span class="line"> hdr3  </span><br><span class="line"> hdr1  </span><br><span class="line"> hdr2  </span><br><span class="line"> /usr/local/include  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>In general, though, you should probably never use
the CPATH environment variable, since you'll end up creating
non-portable source code; specify a Makefile instead.</p>
<p>If you look at all of the CPP search directory examples here, you'll
notice that they always start with:</p>
<p>#include "..." search starts here:</p>
<p>And immediately jumping down to the angle-bracket search path,
implying that nothing is searched for quoted includes. As we know from
experimentation, however, this search does include the current
directory; GCC actually does allow you to modify this search path as
well, with the -iquote compiler flag.</p>
<p>$ cpp -iquote hdr1 -v<br />
...<br />
#include "..." search starts here:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> hdr1  </span><br></pre></td></tr></table></figure> #include &lt;...&gt; search starts here:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /usr/local/include  </span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include  </span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed  </span><br><span class="line"> /usr/include/x86_64-linux-gnu  </span><br><span class="line"> /usr/include</span><br></pre></td></tr></table></figure></p>
<p>Here's an edge case that bit me last week. Consider this directory
structure:</p>
<p>base/Makefile<br />
base/shared.c<br />
base/core.h<br />
base/core.c<br />
override/Makefile<br />
override/core.c<br />
override/core.h</p>
<p>What I'm trying to do here is to generate two different executables
- base and override. I want a different version of core.h in each, but I
want to reuse shared.c in each. So my Makefile in override looks like
this:</p>
<p>override: ../base/shared.c core.c core.h<br />
  gcc -o override ../base/shared.c core.c</p>
<p>The top of shared.c looks like this:</p>
<p>#include "core.h"</p>
<p>Naively, I assumed that shared.c would compile with the version
of core.h from the override directory, since that's the "current working
directory". As it turns out, no — GCC considers ../base the current
working directory for that compilation unit because that's where it was
found. I spent a lot of time banging my head against the keyboard trying
to figure out what was going on here, since the problem manifested
itself as a memory corruption quite a ways into the execution of the
application. One solution would be the -iquote compiler directive...
although I think if you find yourself manipulating the quote search path
this way, it's time to rethink your application structure (and, in my
case, I did).</p>
<p>来自 &lt;<a
href="https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art026">https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art026</a>&gt;</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树Trie</title>
    <url>/blog/2023/10/11/data/CSAPP/data%20structure/%E5%AD%97%E5%85%B8%E6%A0%91Trie/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> End;</span><br><span class="line">    vector&lt;TrieNode*&gt; alphabet;</span><br><span class="line">    <span class="built_in">TrieNode</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        End = <span class="literal">false</span>;</span><br><span class="line">        alphabet.<span class="built_in">resize</span>(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = word.<span class="built_in">length</span>();</span><br><span class="line">        TrieNode* temp = root;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            index = word[i] - <span class="number">97</span>;</span><br><span class="line">            <span class="keyword">if</span> (!temp-&gt;alphabet[index])</span><br><span class="line">                temp-&gt;alphabet[index] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            temp = temp-&gt;alphabet[index];</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;End = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Match</span>(root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Match</span><span class="params">(TrieNode* root, <span class="type">const</span> string&amp; word, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == word.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> root-&gt;End;</span><br><span class="line">        <span class="type">int</span> ch = word[index];</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;alphabet[ch - <span class="number">97</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Match</span>(root-&gt;alphabet[ch - <span class="number">97</span>], word, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Match</span>(root-&gt;alphabet[i], word, index + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>LeetCode的模板题</p>
<p><a
href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211.
添加与搜索单词 - 数据结构设计</a></p>
<p>请你设计一个数据结构，支持 添加新单词 和
查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 WordDictionary ：<br />
* WordDictionary() 初始化词典对象<br />
* void addWord(word) 将 word
添加到数据结构中，之后可以对它进行匹配<br />
* bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true
；否则，返回  false 。word 中可能包含一些 '.' ，每个 .
都可以表示任何一个字母。</p>
<p>该数据结构的设计思想是，Dictionary是一本字典，其中的字典树数据结构负责存储和查询工作，字典树的一般缩写是Trie，这是一颗多叉树，同时维护一个bool变量来表示查询到当前深度的路径上经过的字母能否组成一个单词，该数据结构在查询上的优势是空间复用，随着单词输入的增加，耗费空间并不是线性增加，因为很多单词有相同的前缀，那么它们共用一段查询路径。</p>
<p>按单词字母往路径下搜索和链表的往后搜索操作类似，让当前指针指向下一个节点。当一个单词查询到最后一个字母的时候，检查指针所指的节点维护的bool变量是否为真，如果为真，说明以当前位置结束存在一个单词。由于字典树的查询是按照给定单词的字母顺序查找岔路，所以不可能出现下一个字母是a但是查询去了分岔b的情况，因此节点也不需要额外的字符变量存储字符来应对查询，因为路径一定是对的，只是有可能字符串还没查完字母，但是当前路径下所有路口都是nullptr，这个时候说明字典从来没有存储过这个长度和路径的单词，只能返回false</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>CAP定理</title>
    <url>/blog/2023/10/11/data/CSAPP/database/CAP%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="一什么是cap定理">一、什么是CAP定理</h1>
<p>引用wiki上对<a
href="https://link.juejin.cn/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FCAP%25E5%25AE%259A%25E7%2590%2586">CAP定理</a>的解释</p>
<p>在理论计算机科学中，CAP定理（CAP
theorem），又被称作布鲁尔定理（Brewer's
theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li><p>一致性（Consistency）
（等同于所有节点访问同一份最新的数据副本）<br />
</p></li>
<li><p>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）<br />
</p></li>
<li><p>分区容错性（Partition
tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择）<br />
![[Pasted image 20230824220328.png]]<br />
专业名词一般都很晦涩难懂，我尝试用人类的语言描述下</p></li>
<li><p>C-一致性：外部访问任意一个节点，获取的数据都应该是一样的；（额外需要说明是，CAP的中C区别于数据库事务ACID中C，指代的是线性一致性，数据库事务中的C适用于理解为逻辑一致性）<br />
</p></li>
<li><p>A-可用性：挂掉任何一个节点，系统还是可以正常的响应所有外部的访问，不要出现大面积的失败和超时；<br />
</p></li>
<li><p>P-分区容错性：节点之间的网络通信断了，整个系统还是可以继续提供服务，而不是直接崩溃。</p></li>
</ul>
<p>那么三者为什么不可能同时完成呢？我们分场景进行简单的证明：</p>
<h3 id="首先是可用性">首先是可用性</h3>
<p>![[Pasted image 20230824220342.png]]<br />
一般来说我们最优先考虑的一定是系统整体的可用性，为了提高可用性防止单点故障导致对外的服务不可用，我们会尝试在系统中增加多个节点一同提供服务。</p>
<h3 id="其次是一致性">其次是一致性</h3>
<p>![[Pasted image 20230824220350.png]]<br />
但是增加节点后，会引入一个新的问题，多个节点中的状态、数据可能并不一致。我们尝试通过各种手段去提升系统各个节点中的一致性。最理想的模式就是在每个单一节点对外响应服务之前，如有对于状态、数据变更的操作，全部同步到所有节点后再返回响应给客户端。</p>
<h3 id="最后遇到了网络分区">最后遇到了网络分区</h3>
<p>![[Pasted image 20230824220401.png]]<br />
但是如果网络出现大量的延迟，甚至网络直接产生了分区，隔断了整个将整个系统分为两片。这个时候如果每一个分区都有可能收到来自服务网络区域的请求。在这个时候，如果需要保持系统的一致性那么就会应该直接返回失败，而从降低了可用性；反之，如果为了可用性继续提供服务，那么分区之间的数据在一定时间内是无法达成一致性的，客户端在不同网络区域访问同一个系统可能会获取不同的状态和数据。</p>
<h3 id="结论">结论</h3>
<p>那么我们了解到的一个分布式系统是无法同时满足的CAP三个要求的。CAP定理最大的意义可能就是启发各位系统架构师与开发人员如何合理的根据自身系统的特性去平衡CAP。
CAP定理虽然给出了一套不错的方法论，但是我还是建议不要拿了锤子见什么都是钉子，简单的用CAP去理解一些主流软件的方案，比如MySQL在大多数分类中都被归类到了CA系统，但是在应用特定的HA方案下，MySQL一样可以以牺牲部分C的前提下提升P。下面我们将首先带入MySQL的常见部署方案来结合CAP三个特点进行分析。</p>
<h1 id="二mysql关于一致性的取舍">二、MySQL关于一致性的取舍</h1>
<p>首先，我们这里讨论的一致性都是分布式系统的一致性。按照分布式系统的一致性，我们可以将一致性简单分为两种：强一致性和弱一致性。除此之外，我们还常见一个最终一致性的词，我们可以先把他归类到弱一致性。</p>
<h2 id="弱一致性">弱一致性</h2>
<p>所谓弱一致性指的是在数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。
弱一致性中最典型的便是最终一致性。最常见的最终一致性的场景就是我们的DNS服务。我们在今天提交了一条DNS记录，在当前可能并不会理科全网反映出这条变更，但在72小时之后，全王所有的节点都会反映出这条记录的变更。</p>
<h2 id="强一致性">强一致性</h2>
<p>分布式系统中的强一致性又常被称为原子一致性（Atomic
Consistency）和线性一致性（Linearizable Consistency）。强一致性要求
任何一次读都能读到某个数据的最近一次写的数据，并且系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简单的说就是全部节点的数据状态都一模一样。</p>
<h2 id="mysql-replication">MySQL Replication</h2>
<p>![[Pasted image 20230824220412.png]]<br />
MySQL中多节点一致性主要应用便是利用同步（Replication）将数据在集群的多个节点同步、备份，以提高集群数据的可用性。
传统最常见的手段就是同步日志进行同步。
MySQL默认提供的同步模式是异步同步即在单个机器上完成了日志记录后，不确认节点其他机器的响应，先提交事务。然后其他节点自行根据日志同步操作的模式。这种同步模式下，我们经常使用的部方案就是主从同步与多主同步。</p>
<h3 id="主从同步">主从同步</h3>
<p>MySQL
Replication中Slave节点会启动后关注Master节点的bin-log，一旦发现存在更新，便会将日志拉回自身节点进行重放已达成同步的目的。
在传统的MySQL
Replication中Master节点其实并不感知任何Slave机器的存在。只需要在Slave实例上配置需要关注的Master节点的连接信息和日志路径即可。再配合客户端使用读写分离模式对数据机型访问，总体上通过牺牲一部分一致性（C）前提的下提高了整体的可用性(A)。同时我们也可以发现如何平衡CAP不仅是服务端的问题，同时也通过调整客户端应用方案进行调整。</p>
<h3 id="多主同步">多主同步</h3>
<p>多主同步其实就是多套MySQL实例互为主从的部署模式。想法很美好，但是在实际应用过程中，只有用过的人才知道多主同步能有多坑。首先是主键冲突，因为即使是多主同步，其同步的手段默认还是异步同步（并不是强一致性），所以两个节点中的数据一定会存在一个时间差上有不统一，造成两个Master都提交插入了主键相同的数据，造成冲突。虽然在MySQL
5.7以后的版本中，官方通过增加了GTID（全局事务ID）下的同步模式（区别于仅使用bin-log下的同步模式）一定程度上解决了这个问题。但多主模式下，由于两个节点的沟通模式是异步的，还是无法避免在单一节点事务提交后与另一节点造成数据冲突。</p>
<h3
id="异步同步模式下的主从模式的优缺点">异步同步模式下的主从模式的优缺点</h3>
<p>首先，缺点显而易见，因为采用了异步同步，没有保证强一致性，如有多个节点同时修改（多主模式）会带来大量数据问题。其次，单主模式下一单在主库发生了故障，系统也基本可以默认是不可用了，如果进行主从切换因为一致性的问题又一定会丢失部分数据。最终，多主模式下虽然在一定程度上解决了单点故障的问题（提升了A），但是又引入了网络分区情况下两个Master节点单独提供服务导致的问题（P跪了）。
但该模式下还是有很多可取的优点：</p>
<ol type="1">
<li>部署容易，成本优势大；<br />
</li>
<li>一主多从下只有Master节点提供写服务，从节点可以提供读服务；如部分核心业务对一致性要求高，也可以将对应的读写操作都放在Master节点上进行；<br />
</li>
<li>Slave节点是通过日志进行同步的，可以只同步部分关心的表操作，Slave节点中的数据可以是Master的子集。并且使用的数据引擎和索引都可以与Master节点不同，可以充分利用这点对Slave上节点做应用场景下的索引和数据引擎优化；</li>
</ol>
<h3 id="除了异步同步还有别选择吗">除了异步同步还有别选择吗</h3>
<p>了解了异步模式，我们发现即时系统中存在多个节点，但只有一个Master节点，只要Master节点不可用，整个系统就可以认为是不可用。
为了解决这个问题，我们才正式进入了分布式架构系统的世界。
在MySQL分布式架构方案中，常见的有：</p>
<ul>
<li>MySQL Group Replication（MGR）<br />
</li>
<li>MySQL Fabirc<br />
</li>
<li>MySQL Cluster 其中尤其要说的是MySQL
Cluster，它通过NDB集群构建的数据节点来完成强一致性即实时同步。并且在SQL
Server层面通过构建多主来避免单点故障。在这个层面上MySQL才能“真正”意义上的成为了一套分布式系统。</li>
</ul>
<p>下图是官方给的大致的架构说明。<br />
![[Pasted image 20230824220423.png]]</p>
<p>刚才在上面的话题中，我们曾经指出过过异步同步模式下一个问题，多个Master单独处理事务后进行同步而导致的数据冲突问题。
在下一篇中，我们将对这个话题展开，聊一下如何在节点提交事务前，整个系统为了避免提交后的一致性问题，是如何达成共识进行展开说明。</p>
<h2 id="小结">小结</h2>
<p>我们大致了解了MySQL主要的集中部署模式，从最原始的单例，到一主多从，到多主同步，最后演化成了分布式集群方案。我大致主观的总结了下每种模式下的关键问题。<br />
![[Pasted image 20230824220436.png]]<br />
### 单例部署-&gt;一主多从</p>
<p>为了解决单点I/O压力过大，结合客户端的读写分离方案，提高了系统整体承载压力上限。但是异步同步的方案又引入了系统一致性的问题。同时如果Master节点单点故障，整体系统还是会有一段时间处于不可用的状态。</p>
<h3 id="一主多从-多主同步">一主多从-&gt;多主同步</h3>
<p>为了解决一主多从模式下Master节点的单点故障问题，引入了多个Master节点负责。可以通过其他HA方案，同时使多个Master节点同时对外提供服务。但在默认异步同步模式下，每个Master节点在提交事务操作数据时都以自己的状态为准，一旦发生了网络分区的情况，多个Master可能会发生各自维护一个单独数据副本造成数据不一致的问题。</p>
<h3 id="多主同步-分布式集群">多主同步-&gt;分布式集群</h3>
<p>为了解决多个Master节点操作数据时无法达成一致的问题，引入算法使每个Master在提交事务前与整个网络中其他节点达成共识，保证数据在整个网络中的一致性。
同时在网络发生分区时，通过HA或者选举算法避免或降低造成脑裂的问题。</p>
<h2
id="最后还是要吐槽一下有钱还是真的香">最后，还是要吐槽一下，有钱还是真的香!</h2>
<p>看完上面的图，结合Oracle的方案来对比一下。</p>
<ul>
<li>RAC用于避免单点故障，在集群中冗余实例，提高A；<br />
</li>
<li>SAN来解决多个实例之间的数据的一致性问题，提高C。
最后辅助OGG和ADG的软件来解决跨数据系统、跨网络分区的数据同步问题。
一套方案下来除了贵，不好扩展，好像没有任何毛病。应用开发工程师只需要关心怎么写好代码，架构师只需要关心才能把这套方案的预算合理的编进去。其他什么问题都不用太担心了。</li>
</ul>
<p>开源方案的确是便宜、好扩展、透明，唯一的缺点大概就是有点费头发。</p>
<p>作者：废柴大叔阿基拉</p>
<p>链接：<a
href="https://juejin.cn/post/6895761455358935053">https://juejin.cn/post/6895761455358935053</a></p>
<p>来源：稀土掘金</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode的MySQL插件无法连接？</title>
    <url>/blog/2023/10/11/data/CSAPP/database/VScode%E7%9A%84MySQL%E6%8F%92%E4%BB%B6%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%EF%BC%9F/</url>
    <content><![CDATA[<p>报错：Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support
authentication protocol requested by server; consider upgrading MySQL
client</p>
<p>发现在终端是可以连上mysql的，但用vscode却不行</p>
<p>数据库版本： 8.0.22</p>
<p>Server version: 8.0.22 MySQL Community Server - GPL</p>
<p>原因：登录数据库的客户端跟mysql8.0不兼容了，mysql8.0密码认证采用了新的密码格式</p>
<p>解决办法：mysql终端输入下面命令</p>
<p>mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH
mysql_native_password BY 'password';</p>
<p>root、password 分别为数据库账户，密码</p>
<p>mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH
mysql_native_password BY '123456';</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt;</p>
<p>在vs code重新连接便可以连上了</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>撤销错误的commit（未推送的话）</title>
    <url>/blog/2023/10/11/data/CSAPP/git/%E6%92%A4%E9%94%80%E9%94%99%E8%AF%AF%E7%9A%84commit%EF%BC%88%E6%9C%AA%E6%8E%A8%E9%80%81%E7%9A%84%E8%AF%9D%EF%BC%89/</url>
    <content><![CDATA[<p>如果要撤销未未推送的commit还是比较简单的，参考<a
href="%5Bgit%20如何撤销%20commit、git%20commit%20提交之后如何取消本次提交、如何更改提交的内容_怎么撤销commit_云影sky的博客-CSDN博客%5D(https://blog.csdn.net/qq_32281471/article/details/95478314)">这篇博客</a></p>
<h2 id="软撤销">软撤销</h2>
<p>本地代码不会变化，只是 git 转改会恢复为 commit 之前的状态<br />
不删除工作空间改动代码，撤销 commit，不撤销 git add .<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure></p>
<p>表示撤销最后一次的 commit ，1 可以换成其他更早的数字</p>
<h2 id="硬撤销">硬撤销</h2>
<p>本地代码会直接变更为指定的提交版本，慎用。删除工作空间改动代码，撤销
commit，撤销 <code>git add .</code>
注意完成这个操作后，就恢复到了上一次的commit状态。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~1</span><br></pre></td></tr></table></figure></p>
<p>如果仅仅是 commit 的消息内容填错了，输入：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure> 进入 vim 模式，对 message 进行更改</p>
<p>还有一个 --mixed<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --mixed HEAD~1</span><br></pre></td></tr></table></figure> 意思是：不删除工作空间改动代码，撤销commit，并且撤销git
add . 操作<br />
这个为默认参数,git reset --mixed HEAD~1 和 git reset HEAD~1
效果是一样的。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS不同类型的服务解析</title>
    <url>/blog/2023/10/11/data/CSAPP/network/DNS%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>另外，虽然我成功验证了DNS记录，但是我有些疑惑，DNS服务解析不是用于解析IP地址的吗？验证的时候类型选择TXT，然后填入一个主机记录，这个主机记录并不是一个IP，那么我向DNS服务器解析这个TXT类型的记录会得到什么？除了IP解析之外，DNS还可以怎么解析？</p>
<p>ChatGPT</p>
<p>你的理解是对的，DNS（域名系统）最初的主要功能是将人类友好的域名解析为IP地址。但实际上，DNS提供了许多其他类型的记录，可以用于各种各样的用途，而不仅仅是将域名解析为IP地址。</p>
<p>关于你的问题：</p>
<ol type="1">
<li><p><strong>TXT记录</strong>：TXT记录主要用于存储任意文本信息。它们经常用于各种验证过程（例如，证明域名所有权，或为电子邮件验证提供SPF或DKIM信息）。当你查询TXT记录时，你会得到与该记录关联的文本字符串。</p></li>
<li><p><strong>其他DNS记录类型</strong>：除了常见的A记录（将域名解析为IPv4地址）和AAAA记录（将域名解析为IPv6地址），还有很多其他类型的DNS记录。以下是一些例子：</p>
<ul>
<li><strong>CNAME记录</strong>：为域名指定一个别名。当你查询这个域名时，查询会继续到这个别名所指向的位置。<br />
</li>
<li><strong>MX记录</strong>：指定接收域名电子邮件的邮件服务器。<br />
</li>
<li><strong>NS记录</strong>：指定负责特定域名的域名服务器。<br />
</li>
<li><strong>SOA记录</strong>：提供关于DNS区域的信息。<br />
</li>
<li><strong>SRV记录</strong>：为特定的服务和协议指定服务器位置。<br />
</li>
<li><strong>PTR记录</strong>：用于反向DNS查找，将IP地址解析为域名。<br />
</li>
</ul></li>
<li><p><strong>解析结果</strong>：当你对特定类型的记录进行DNS查询时，你会得到与该类型对应的数据。例如，查询A记录会返回一个IP地址，而查询TXT记录会返回文本字符串。</p></li>
</ol>
<p>DNS的设计允许其支持各种不同类型的记录，以满足各种网络需求。虽然其最常见的用途是域名到IP地址的解析，但其功能远不止于此。</p>
<p>DNS服务器就是基本只运行DNS解析服务的机器？</p>
<p>ChatGPT</p>
<p>基本上，是的。DNS服务器的主要任务是解析和响应关于域名的查询，将域名转换为与之关联的IP地址或返回其他类型的DNS记录。但是，在更广泛的上下文中，DNS服务器可能有更复杂的配置和功能。以下是一些关于DNS服务器的要点：</p>
<ol type="1">
<li><p><strong>基础功能</strong>：其核心任务是响应来自客户端的DNS查询，返回关于特定域名的信息。</p></li>
<li><p><strong>类型</strong>：有几种不同类型的DNS服务器，每种都有其特定的用途。</p>
<ul>
<li><strong>权威DNS服务器</strong>：为特定域名或区域提供“权威”答案。它包含有关该域的实际DNS记录。<br />
</li>
<li><strong>递归DNS服务器</strong>（或解析服务器）：为常规用户或客户端设备处理DNS查询。当这些服务器收到查询时，它们会递归地查询其他服务器直到获取答案，然后将答案返回给客户端。<br />
</li>
<li><strong>转发DNS服务器</strong>：将所有查询转发到另一个DNS服务器（通常是递归服务器）以获取答案，而不自己进行递归解析。<br />
</li>
</ul></li>
<li><p><strong>缓存</strong>：大多数DNS服务器使用缓存来提高性能。当服务器解析一个域名并收到答案后，它会在本地存储这个答案一段时间。这意味着对同一个域名的后续查询可以迅速从缓存中获得答案，而不必重新进行完整的解析。</p></li>
<li><p><strong>额外功能</strong>：虽然DNS的核心功能是域名解析，但一些DNS服务器可能还提供其他功能，如负载均衡、地理定向、防御DDoS攻击等。</p></li>
<li><p><strong>软件</strong>：DNS服务器通常由软件提供服务。常见的DNS服务器软件包括BIND、Microsoft
DNS、Unbound、dnsmasq等。</p></li>
<li><p><strong>安全</strong>：随着对网络安全意识的提高，现代DNS实践也集成了安全增强功能，如DNSSEC（DNS安全扩展）。</p></li>
</ol>
<p>因此，虽然DNS服务器的基本任务是处理和响应DNS查询，但其配置、操作和用途可能会根据具体情况而有所不同。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS递归查询规则</title>
    <url>/blog/2023/10/11/data/CSAPP/network/DNS%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>我还有一个疑问，如果域名在本地DNS服务器无法查询得到，它会递归地向上级DNS服务器查询，直到根服务器，难道根服务器有所有域名记录吗？</p>
<p>ChatGPT</p>
<p>不，根服务器并不保存所有域名的记录。根服务器的主要作用是指向各个顶级域（TLD）的权威名称服务器。例如，对于<code>.com</code>、<code>.org</code>、<code>.net</code>等TLD，根服务器会知道如何到达管理这些TLD的权威服务器。</p>
<p>以下是递归解析的基本步骤：</p>
<ol type="1">
<li><p><strong>本地缓存</strong>：当一个DNS解析请求首先发起时，递归服务器首先检查它的本地缓存看是否有这个域名的记录。如果有，则直接返回结果。</p></li>
<li><p><strong>查询根服务器</strong>：如果本地缓存没有这个域名的记录，递归服务器会向根服务器查询。根服务器不会知道具体域名的记录，但它会知道如何找到特定顶级域（例如<code>.com</code>或<code>.org</code>）的权威服务器。</p></li>
<li><p><strong>查询TLD服务器</strong>：递归服务器接着会向TLD服务器发起查询。例如，对于域名<code>example.com</code>，它会查询<code>.com</code>的权威服务器。TLD服务器会返回管理<code>example.com</code>域的权威名称服务器的地址。</p></li>
<li><p><strong>查询权威名称服务器</strong>：最后，递归服务器会直接向<code>example.com</code>的权威名称服务器查询，并获取所需的DNS记录（例如A记录或MX记录）。</p></li>
<li><p><strong>返回答案</strong>：一旦递归服务器得到答案，它会将该答案返回给请求者（例如用户的计算机或浏览器）。同时，递归服务器通常也会在其本地缓存中存储此记录一段时间，这样对同一域名的后续请求可以更快地得到答案。</p></li>
</ol>
<p>这个过程被称为“递归”，因为递归服务器会连续地向多个服务器查询，直到获取所需的答案。但在实际操作中，由于缓存的存在，很多请求可能会在达到根服务器或TLD服务器之前就得到答案。</p>
<p>也就是说，<code>a.b.c</code>这个域名中，<code>c</code>，是顶级域，如果级别<code>a</code>和级别<code>b</code>等级的DNS服务器查询不到记录的话，会去<code>c</code>等级的DNS服务器查询？</p>
<p>ChatGPT</p>
<p>准确地说，对于域名<code>a.b.c</code>：</p>
<ul>
<li><code>c</code>是顶级域 (TLD)。<br />
</li>
<li><code>b.c</code>是二级域。<br />
</li>
<li><code>a.b.c</code>是三级域。</li>
</ul>
<p>当你尝试解析<code>a.b.c</code>时，解析过程如下：</p>
<ol type="1">
<li><p>递归服务器首先查询其<strong>本地缓存</strong>，看是否有<code>a.b.c</code>的记录。</p></li>
<li><p>如果没有，递归服务器会向<strong>根服务器</strong>查询，询问哪个服务器知道<code>.c</code>的信息。根服务器将返回指向管理<code>.c</code>
TLD的权威名称服务器的指针。</p></li>
<li><p>接着，递归服务器会向<code>.c</code>的<strong>权威名称服务器</strong>查询，询问哪个服务器知道<code>b.c</code>的信息。这个权威名称服务器将返回指向<code>b.c</code>域的权威名称服务器的指针。</p></li>
<li><p>递归服务器再次查询，这次是向<code>b.c</code>的<strong>权威名称服务器</strong>，询问<code>a.b.c</code>的具体记录。这个服务器或者提供了该记录，或者通知递归服务器该记录不存在。</p></li>
</ol>
<p>这个递归过程确保了DNS查询可以从根服务器开始，然后逐级向下，直到找到具体的记录或确定该记录不存在。</p>
<p>但需要注意的是，实际操作中由于缓存的存在，很多DNS查询可能不需要从根服务器开始，而是直接从某个级别开始。例如，如果递归服务器刚好缓存了关于<code>.c</code>
TLD的信息，那么它可能会直接从第三步开始。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>ICMP网络控制报文协议</title>
    <url>/blog/2023/10/11/data/CSAPP/network/ICMP%E7%BD%91%E7%BB%9C%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>为什么服务器要开放ICMP才能被Ping通？</p>
<p>ChatGPT</p>
<p>ICMP（Internet Control Message
Protocol）是IP协议族的一个重要组成部分，用于在网络节点之间传递控制消息。Ping是一个使用ICMP协议的网络诊断工具，它发送ICMP
Echo请求消息并等待Echo应答。当你尝试ping一个服务器或设备时，你实际上是在发送ICMP
Echo请求给那台服务器或设备。</p>
<p>为什么服务器需要开放ICMP才能被Ping通：</p>
<ol type="1">
<li><p><strong>ICMP过滤</strong>：许多防火墙或安全策略默认情况下会阻止或过滤掉进入或离开网络的ICMP流量，因为ICMP在某些情况下可以被用于网络攻击（例如，DoS攻击）或侦察（例如，确定哪些IP地址是活动的）。</p></li>
<li><p><strong>Echo请求与应答</strong>：当服务器的ICMP功能被关闭或被阻止时，它不会响应ICMP
Echo请求，这意味着你的ping命令不会收到Echo应答，从而使得服务器似乎是不可达的，即使它实际上在线并正常运行。</p></li>
<li><p><strong>网络诊断</strong>：Ping是一个基本的网络诊断工具，用于检测网络连接的可用性和延迟。要进行这些检测，服务器或设备必须允许ICMP流量。</p></li>
</ol>
<p>然而，值得注意的是，仅仅因为一个服务器不能被ping通，并不意味着服务器是离线的或存在问题。它可能只是不响应ICMP请求。同样，如果一个服务器能够响应ping请求并返回应答，也并不意味着上面的所有服务都正常运行。</p>
<p>因此，当评估网络连通性或服务器的健康状况时，Ping只是众多诊断工具之一，并应与其他方法和工具结合使用。</p>
<p>ICMP并不是一个特定端口的服务是吗？既然它是用于传递控制信息，那么它可以控制网络的速率？或者说网络堵塞的时候调整网络收发速率之类的？</p>
<p>ChatGPT</p>
<p>你是对的，ICMP不是基于端口的服务。而是一个网络层的协议，与TCP和UDP一样，但它不使用端口号。它的工作原理与这些协议不同，主要用于发送和接收网络控制消息，而不是数据流。</p>
<p>关于你的问题：</p>
<ol type="1">
<li><p><strong>ICMP与流量控制</strong>：ICMP本身不是用来控制网络的速率或调整收发速率的。但它确实为网络管理员和设备提供了关于网络健康、连通性和路由选择等方面的反馈。</p></li>
<li><p><strong>ICMP与网络拥塞</strong>：当路由器或交换机检测到网络拥塞时，它们可能会使用ICMP源抑制消息（Source
Quench）来请求发送数据的主机减慢其发送速率。然而，这种机制在现代网络中已经很少使用，因为TCP协议自身有更有效的拥塞控制机制。</p></li>
<li><p><strong>其他ICMP消息类型</strong>：ICMP有多种消息类型，如Echo请求和应答（用于ping）、目的地不可达（Destination
Unreachable, 用于指示数据包因某种原因无法到达目标）、时间超过（Time
Exceeded,
通常用于traceroute工具）等。这些消息提供了关于网络状态和问题的有用信息，但不是直接用来控制网络的速率。</p></li>
<li><p><strong>拥塞控制</strong>：如上所述，TCP协议中有自己的拥塞控制机制，当网络拥塞时，TCP会自动调整其发送速率来减轻拥塞。这与ICMP无关。</p></li>
</ol>
<p>总的来说，尽管ICMP提供了有关网络状况的有用信息，但它并不直接用于控制或调整网络速率。现代网络中的拥塞控制主要依赖于传输层协议，如TCP。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的半关闭对方会收到什么消息？</title>
    <url>/blog/2023/10/11/data/CSAPP/network/TCP%E7%9A%84%E5%8D%8A%E5%85%B3%E9%97%AD%E5%AF%B9%E6%96%B9%E4%BC%9A%E6%94%B6%E5%88%B0%E4%BB%80%E4%B9%88%E6%B6%88%E6%81%AF%EF%BC%9F/</url>
    <content><![CDATA[<p>TCP链接双方都是可以读写的两个通道，如果半关闭写通道，对方会收到什么消息吗？</p>
<p>2023/7/22 14:31:11</p>
<p>当一个TCP连接的一方关闭写通道（也就是发送了FIN），对方会收到一个带有FIN标志的TCP段。</p>
<p>这表示关闭方认为自己已经发送完所有的数据，并且不再发送任何数据。通过关闭写通道，关闭方告诉对方它不会再有新的数据发送给对方。</p>
<p>对方在接收到这个带有FIN标志的TCP段后，会继续读取已经到达的数据，直到没有更多的数据可读。然后，对方也会关闭写通道，并向关闭方发送一个带有FIN标志的TCP段作为确认。</p>
<p>这时候，双方的连接处于半关闭状态。半关闭状态指的是只有一方关闭了写通道，另一方仍然可以继续读取数据或者发送数据。</p>
<p>需要注意的是，在半关闭状态下，关闭写通道的一方仍然可以接收对方发送的数据，而对方无法接收关闭方发送的新数据。如果关闭方尝试发送数据，对方会回复一个带有RST（复位）标志的TCP段，表示连接已经被非法终止。</p>
<p>总结起来，当一方关闭写通道时，对方会收到带有FIN标志的TCP段，表示关闭方不再发送新的数据。双方处于半关闭状态，关闭方仍然可以接收数据，但对方无法接收新的数据。</p>
<p>2023/7/22 14:32:10</p>
<p>如果半关闭的是读通道，对方会收到FIN吗？</p>
<p>2023/7/22 14:32:30</p>
<p>当一个TCP连接的一方关闭读通道（即停止接收数据），对方将不会收到FIN标志的TCP段。</p>
<p>关闭读通道意味着关闭方不再希望继续接收对方发送的数据。但是，关闭方仍然可以向对方发送数据，并且对方可以正常接收。</p>
<p>对方在发送数据时，关闭方会正常接收并发送确认。但如果对方尝试发送FIN标志的TCP段来关闭连接的写通道，关闭方则会发送一个带有RST（复位）标志的TCP段，表示连接已经被非法终止。这是因为关闭方已经关闭了读通道，不再接收对方发送的FIN。</p>
<p>总结起来，当一方关闭读通道时，对方不会收到任何特定的消息或FIN标志的TCP段。关闭方无法再接收对方发送的数据，但仍然可以发送数据给对方。如果对方尝试发送FIN以关闭写通道，关闭方会发送RST来终止连接。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>URL哪些部分不区分大小写</title>
    <url>/blog/2023/10/11/data/CSAPP/network/URL%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99/</url>
    <content><![CDATA[<p>网页链接居然是不区分大小写的？</p>
<p>ChatGPT</p>
<p>网页链接（URL）的某些部分是区分大小写的，而另一些部分则不是。URL由几个不同的组成部分构成，其中一些是大小写敏感的，而另一些则不是。下面是URL的组成部分的一些常见规则：</p>
<ol type="1">
<li><p><strong>协议</strong>（如 <code>http</code> 或
<code>https</code>）：不区分大小写。</p></li>
<li><p><strong>域名</strong>：不区分大小写。也就是说，<code>example.com</code>、<code>Example.com</code>
和 <code>EXAMPLE.COM</code> 被视为相同的URL。</p></li>
<li><p><strong>路径</strong>和<strong>查询参数</strong>：这些通常是区分大小写的。例如，<code>example.com/PageOne</code>
和 <code>example.com/pageone</code> 通常被视为不同的页面。</p></li>
<li><p><strong>锚点</strong>（<code>#section</code>）：区分大小写。</p></li>
</ol>
<p>然而，即便路径和查询参数通常是区分大小写的，Web服务器也可能被配置为不区分大小写。因此，实际的大小写敏感性可能会根据服务器的配置而有所不同。</p>
<p>总之，当输入或处理URL时，最好假定URL是区分大小写的，除非您确定服务器配置为不区分大小写。在创建网页或URL时，保持一致的大小写使用也是一种最佳实践，以避免混淆或错误的链接。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统冗余方案</title>
    <url>/blog/2023/10/11/data/CSAPP/network/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%86%97%E4%BD%99%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>高可用性一直为分布式系统设计所追求的重要目标。其目的是在错误不可避免发生的计算环境中构建出高可用的系统。常见错误包括计算设备故障、网络传输故障、软件运行故障等。冗余策略是实现系统高可用性的常见方法。该策略通过对计算任务采用多副本的冗余执行，提高任务执行的成功率。</p>
<p>图 1
所示冗余策略分为主动冗余和被动冗余。在主动冗余下，一个任务所有的副本同时执行，只要存在一个副本执行成功，则该任务执行成功。该策略的优点是，错误恢复时间很快，几乎接近为零；缺点是浪费计算资源，且副本之间状态同步开销较大。在被动冗余下，一个任务只有一个副本执行，当该副本执行失败，再启动备份的副本执行。该策略的优点是节省计算资源，但是错误恢复时间较慢，可能需要回滚到之前的状态重复执行。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/9s6WJ9ibpxVDqhxcVUyibtqWveYBvBe84mTPiaY7UVnVA2ZgYAlQMkpPmm0r5jt7ichFsCudn42ibFbiah8iaRhV4ibDmQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>（a）主动冗余</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/9s6WJ9ibpxVDqhxcVUyibtqWveYBvBe84mBeJ1ml5qhyxVStfsnX6aO8LzicDVL3OzqoYA5QJDH2L1tEib0y0qUuPA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>（b）被动冗余</p>
<p>图 1 两种不同类型冗余策略：主动冗余与被动冗余</p>
<p>总结起来，主动冗余是用资源换时间，而被动冗余是用时间来节省资源。主动冗余适合用在资源较为充分，且对任务执行实时性有较高要求的场景；被动冗余适合任务实时性要求不高，但是系统资源紧张或者负载压力大的场景。</p>
<p>分布式系统到底该选择哪一种冗余策略呢？最新Time-Sensitive Networks
(TSN)
网络中的冗余路径传输协议，采用的是主动冗余策略；而传统TCP/IP网络中的TCP重传机制采用的是被动冗余策略。大数据并行计算框架
Hapdoop采用的是被动冗余策略，系统检测到存在straggler任务的时候，会启动新的冗余任务替代执行；而最新有关可靠边缘计算大部分文献采用的是主动冗余策略。</p>
<p>实际系统由于计算资源高度动态特性以及负载的不可预测属性。某一特定的冗余策略往往无法发挥最优的潜能。《中庸》所言：“不偏不倚不极端乃君子之道”。在古人智慧的启发下，华南理工大学的研究团队设计一种新的介于主动冗余与被动冗余之间的智能冗余策略，并将该策略用于现代网络中虚拟网络（VNF）功能服务链的可靠调度之中[1][2]。以下为该工作的具体介绍。</p>
<p><strong>可靠性感知的服务功能链调度方法</strong></p>
<p>VNF服务链调度可靠性很重要。为了提高可靠性，采用冗余VNF的机制。冗余VNF服务链的调度，可以通过适当延迟VNF的执行，缓解资源的负载压力。零时间延迟意味着主动冗余模式，即一个VNF所有副本都立即执行，如果某个副本先执行完，则其他的副本将停止执行，该方法存在一定的资源浪费。采用一定延迟执行的方法，即被动冗余方法，推迟某个副本的执行；在其他副本成功执行的前提下，避免冗余副本的执行，从而节省一定资源；但是存在问题是，一旦先执行的副本失败，那么该VNF需要等到接下来副本执行成功才行，导致错误恢复时间长。因此，提出基于强化学习的智能冗余方法，根据当前环境以及资源的使用情况，智能地决策是否延迟副本的执行，以及延迟多长时间。强化学习智能体的动作为所有就绪任务的延迟率，即每一个决策周期延迟执行哪些VNF。该方法具有较好的自适应性。当环境中资源节点发生变化，也不需要重新学习和在此部署RL模型。传统的基于RL的调度方法，直接学习节点选择策略，在新环境下需要重新学习模型。</p>
<p><strong>1. 服务链调度问题</strong></p>
<p>服务链调度问题旨在决定计算节点在何时何地部署和处理给定的VNF，以达到特定的目标（如网络资源开销最小、平均完成时间最小等）。VNF在计算节点上的执行需要一定时间完成，但是系统中可以同时存在多个服务链，它们各自的VNF都需要被执行，因此，如何在多个服务链同时存在的情况下，合理安排计算节点上的VNF执行顺序从而实现高效调度成为亟待解决的问题。</p>
<p>相比于服务链部署问题，服务链调度问题更贴近实际且更加复杂。服务链部署问题考虑的是所有服务链请求和网络资源信息已知的情况下，如何在底层的网络上对VNF进行实例化并分配所需资源，服务链部署问题考虑的是一种VNF放置问题。而服务链调度问题需要考虑时间这一维度，VNF的执行需要一定时间，如何在系统中存在多个服务链时，对网络资源进行分配。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/9s6WJ9ibpxVDqhxcVUyibtqWveYBvBe84mPe9nCqox9fEDevvZgh1Ot5CGW93lhwZD6OgP0j9ia2dcLICfpYNXByw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>图 2 服务功能链调度系统模型</p>
<p>考虑图 2
所示的研究场景，网络中的计算节点资源有限，若干个服务功能链请求SFC是随机到达的，一个服务功能链SFC包含了一组有序的虚拟网络功能VNF需要执行，服务功能链请求是时间敏感和可靠性敏感的，调度器需要根据请求的截止时间和可靠性要求来决定该服务链中的每个VNF冗余度，以及每个VNF应该分配到哪个计算节点上执行。此外，如果计算节点需要运行一个与它先前部署的VNF类型不相同的VNF实例，该节点需要花费额外的时间进行重部署。调度器的最终目标是最大化系统中服务链请求在其截止时间内完成的成功率。</p>
<p><strong>2. 可靠性感知的动态服务链调度方法</strong></p>
<p>为了解决这个问题，我们提出了一种可靠性感知的动态SFC调度方法（Reliability-aware
Dynamic SFC Scheduling Approach，RDSSA）。图
3 展示了RDSSA方法的工作流程。它主要包括三个步骤：</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/9s6WJ9ibpxVDqhxcVUyibtqWveYBvBe84mZyxWCXdPl3xtib9XBLy9VUrUPT4tCxHTkVZ1xK5QdArDYHpKk3ibHviag/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>图 3 RDSSA工作流程</p>
<p>（1）<strong>冗余决策</strong>。当有SFC请求时，根据SFC可靠性要求计算VNFs的最优冗余。它指定应该复制SFC中的哪个VNF以及应该部署多少个冗余VNFs。这些未调度的VNFs正在队列中等待。VNF的优先级是基于在相应的证监会截止时间之前的剩余时间。</p>
<p>（2）<strong>计算节点选择</strong>。基于规则的节点选择方法提供了一种策略，为队列头的VNF选择合适的计算节点。在这个过程中，我们引入了一种名为延迟执行的机制，这意味着调度器可以延迟输入VNF的执行，其目的是减少冗余VNF所消耗的计算资源。</p>
<p>（3）<strong>基于强化学习的服务链调度</strong>。根据网络环境的变化学习一种推迟策略，如果它决定延迟一个VNF,
VNF将返回到等待队列。否则，调度程序采用基于规则的方式为VNF分配计算节点。</p>
<p>图 4 所示基于强化学习的服务链调度方法框架。智能体观测到网络中服务链请求和计算节点的相关信息，这些信息被称为状态（state），状态输入到智能体的策略网络后输出一个调度决策，称为动作（action），动作是智能体认为在当前系统状态下的最优决策，在智能体在执行动作后获得环境反馈的奖励（reward），并以此更新神经网络中的参数。在此，智能体使用嵌入网络（embedding
network）将原始的状态信息向量编码为输入到强化学习网络的低维特征向量。智能体通过不断地观测系统状态，输出动作触发系统环境的奖励反馈和系统状态更新，智能体通过这种方式在和环境交互的过程中不断学习更优的策略。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/9s6WJ9ibpxVDqhxcVUyibtqWveYBvBe84mUeyFLx5SRhhickQwJn9rgrYlWGrMlqkKXibgTI8emyjg5F7w9fU78F4A/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>图 4 基于强化学习的服务链调度方法框架</p>
<h4 id="调度事件"><strong>调度事件</strong></h4>
<p>本文提出的调度模型是任务触发的，系统中未被调度的VNF在队列中等待，当VNF等待队列非空的时候，智能体需要做出调度决策。VNF队列的行为如下：</p>
<p>（1）队列的优先级基于当前时刻距离服务链的截止时间（deadline）的长度，即剩余时间。剩余时间越短的服务链中的VNF在队列中优先级越高。</p>
<p>（2）新到达的服务链的首个VNF，包括它的所有冗余将被加入队列。</p>
<p>（3）当一个VNF以及它的所有冗余实例执行完成后，该VNF的后继VNF任务将被添加到队列中，除非前者是所属服务链的最后一个VNF任务。此外，如果一个VNF的所有冗余都失效，我们认为该VNF所属的服务链被终止，后续的VNF将不会被添加到队列中。</p>
<p>（4）对于某个VNF来说，如果其中一个冗余执行完成，其它的冗余将从队列中移除，如果它们已经部署在计算节点上，它们的执行过程将被终止。</p>
<p>（5）位于队列头部的VNF将首先由智能体调度器调度。</p>
<h4 id="状态"><strong>状态</strong></h4>
<p>状态（state）为智能体的输入，在本文中，状态主要包括：VNF类型、服务链中剩余的VNF数量、服务链的长度、VNF运算量、服务链的剩余时间、计算节点已部署的VNF类型、计算节点的提前时间。VNF提前时间为加权VNF截止时间与预计完成时间之差。</p>
<h4 id="动作"><strong>动作</strong></h4>
<p>动作（action）是强化学习智能体的输出，它决定了应该将VNF部署在何处。这里，我们引入了一种叫作“推迟执行”的机制。当存在一个VNF任务需要部署时，服务链调度器或强化学习智能体可以将这个VNF推迟到下一个调度事件。推迟执行可以使一些冗余的VNF不被立即执行，而是暂时留在队列中等待。此时，如果之前已经部署好的VNF可以成功执行完成，这些推迟执行的VNF便可以从队列中移除，从而减少冗余VNF占用的计算资源，提高成功率。基于这个动机，我们在实验中评估了推迟执行对成功率的影响，实验的结果表明，推迟执行显著影响了成功率，这支撑了我们的采用推迟执行机制的动机。然而，采用固定概率的推迟执行不能适应动态变化的计算资源。因此，我们考虑设计一种根据动态环境提供不同推迟执行概率的方法。在本文中，我们采用了不同于其它使用强化学习的相关工作的智能体动作。我们的策略网络输出一个推迟概率，即输入的待调度VNF任务被推迟执行的概率。如果VNF被推迟执行，调度器将不会分配任何计算节点来部署它，VNF将留在队列中等待下一个调度事件。否则，VNF将基于某种规则部署在计算节点上。此外，有了这个动作设计，我们的智能体可以在不改变模型的情况下适应不同数量的计算节点。这是因为我们设计的智能体不是将VNF部署在哪个特定的计算节点上，相反，智能体只提供推迟VNF执行的概率，间接影响着调度的顺序。</p>
<h4 id="奖励"><strong>奖励</strong></h4>
<p>奖励（reward）是动作执行后来自环境的反馈。为了指导智能体学习，我们根据服务链调度目标设计了一个奖励函数。每个VNF必须在服务链截止时间之前完成，以提高成功率。我们认为如果一条服务链中的每个VNF都能在其VNF截止时间之前完成，则整个链将满足该截止时间。因此，我们使用VNF提前时间作为奖励，即。当为负数时，由于VNF的滞后完成，我们用一个负的奖励作为惩罚智能体。当为正数时，智能体将因为VNF在VNF截止时间前完成而获得奖励。需要注意的是，在实验中我们对奖励的绝对值进行了限制，以防止训练过程中智能体因为过大的反馈信号而导致网络不收敛。</p>
<h4 id="服务链状态信息编码"><strong>服务链状态信息编码</strong></h4>
<p>强化学习的智能体将观测信息作为特征输入传递给策略网络。传统地，特征向量被设计成包含所有的状态信息，但是这种方法不能处理服务链数量和服务链长度都是非固定的情况。在本文中，我们使用了一种卷积神经网络TextCNN，将服务链的状态信息编码成嵌入向量，解决了输入信息维度非固定的问题，实现了可扩展性。TextCNN是一种用于句子分类任务的深度学习方法，我们采用它作为状态信息的编码器，可以将高维稀疏向量压缩为低维稠密向量。我们的嵌入（embedding）层将服务链信息作为输入，输出两个层级的嵌入向量。第一层级是服务链编码，它聚合了关于整个VNF链的信息。SFC嵌入网络将SFC中的每个VNF特征转换为向量。第二层级是全局编码，它归纳了系统中所有的服务链状态信息。同样，全局嵌入网络将所有的SFC嵌入作为输入输出一个全局摘要向量。</p>
<p><strong>3. 结论</strong></p>
<p>本文介绍了一种分布式系统中冗余策略的全新智能冗余方法，不同于传统“单一极端”的主动冗余或被动冗余策略，采用强化学习，根据系统可用资源以及负载状态，动态智能地选择“合适中庸”的冗余策略，在有限资源下，保障计算任务的低时延与高可靠性的需求。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>一个字到底等于多少字节？</title>
    <url>/blog/2023/10/11/data/CSAPP/os/%E4%B8%80%E4%B8%AA%E5%AD%97%E5%88%B0%E5%BA%95%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9F/</url>
    <content><![CDATA[<p>论据：</p>
<p>先看一段摘抄自《Computer system: a programmer's
perspective》的说明：</p>
<p>Buses are typically designed to transfer fixed-sized chunks of bytes
known aswords. The<br />
number of bytes in a word (the word size) is a fundamental system
parameter that<br />
varies across systems. Most machines today have word sizes of either 4
bytes (32<br />
bits)or8bytes(64bits).</p>
<p>翻译过来就是说：总线一般被设计来传输固定大小的一块数据，这块数据被称为字(word),一个字包含的字节数(即字的大小)是各种计算机系统里面的基本参数，而且这个参数在不同的系统里通常是不同的。大多数的现代计算机系统里面，一个字要么是4个字节（32位），要么是8个字节（64位）.</p>
<p>结论：<br />
&gt;
一个字等于多少个字节，与系统硬件（总线、cpu命令字位数等）有关，不应该毫无前提地说一个字等于多少位。</p>
<p>正确的说法：<br />
1字节（byte） = 8位（bit）<br />
在16位的系统中（比如i8086）1字（word）= 2字节（byte）= 16 bit<br />
在32位的系统中（比如win32）1字（word）= 4字节（byte）= 32 bit<br />
在64位的系统中（比如win64）1字（word）= 8字节（byte）= 64 bit</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>一个标准的空引导boot程序</title>
    <url>/blog/2023/10/11/data/CSAPP/os/%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84%E7%A9%BA%E5%BC%95%E5%AF%BCboot%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; boot code</span><br><span class="line"></span><br><span class="line">[org 0x7C00]  ; 设置代码加载地址</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    ; 引导代码的入口点</span><br><span class="line"></span><br><span class="line">    ; 此处是引导代码的实际逻辑</span><br><span class="line"></span><br><span class="line">    ; 结尾处写入0xAA55标识符</span><br><span class="line">    times 510-($-$$) db 0  ; 填充剩余空间为0</span><br><span class="line">    dw 0xAA55             ; 写入0xAA55标识符</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>产生死锁的四个条件</title>
    <url>/blog/2023/10/11/data/CSAPP/os/%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="资源互斥">资源互斥：</h2>
<p>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p>
<h2 id="不可剥夺">不可剥夺:</h2>
<p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p>
<h2 id="请求保持">请求保持：</h2>
<p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
<h2 id="环路等待">环路等待:</h2>
<p>存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被
链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …,
pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …,
n-1)，Pn等待的资源被P0占有，如图2-15所示。</p>
<p>直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所
要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。
例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0,
1, …, n}。</p>
<p>Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他
一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待,
如图2-16所示。因此循环等待只是死锁的必要条件。</p>
<figure>
<img
src="data:image/jpeg;base64,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"
alt="这里写图片描述" />
<figcaption aria-hidden="true">这里写图片描述</figcaption>
</figure>
<p>资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于1。但若系统中每类资
源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>小端序和大端序存储方式差异</title>
    <url>/blog/2023/10/11/data/CSAPP/os/%E5%B0%8F%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<p>如果向地址0x1000写入数据0x12345678的话，大端序和小端序在磁盘上的存储结果如下：<br />
![[Pasted image 20230819181019.png]]</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>常见存储器每条磁道多少扇区？</title>
    <url>/blog/2023/10/11/data/CSAPP/os/%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%99%A8%E6%AF%8F%E6%9D%A1%E7%A3%81%E9%81%93%E5%A4%9A%E5%B0%91%E6%89%87%E5%8C%BA%EF%BC%9F/</url>
    <content><![CDATA[<p>The number of sectors a track has on a hard disk or floppy disk is
dependent on the specific design and formatting of that disk. However, I
can provide some common examples:</p>
<ol type="1">
<li><strong>Floppy Disks</strong>:
<ul>
<li><strong>3.5-inch High-Density (1.44MB)</strong>: 18 sectors per
track<br />
</li>
<li><strong>5.25-inch High-Density</strong>: 15 sectors per track for
many formats<br />
</li>
</ul></li>
<li><strong>Hard Disks</strong>:
<ul>
<li>The number of sectors per track for hard disks can vary greatly and
has increased over time. Early hard disks might have had as few as 17
sectors per track, while modern disks can have many more, with the
number often varying across tracks on the disk due to zoned bit
recording (ZBR). In ZBR, outer tracks, which are longer, have more
sectors than inner tracks.<br />
</li>
</ul></li>
<li><strong>CDs and DVDs</strong>:
<ul>
<li>These use a different format than magnetic disks and don't have
traditional "sectors" and "tracks" in the same sense. However, they do
have sectors in the sense of data blocks. A standard CD has a sector
size of 2,352 bytes (for raw data, including error correction codes),
and sectors are laid out in a continuous spiral, not in concentric
tracks like on a hard or floppy disk.<br />
</li>
</ul></li>
<li><strong>Modern Storage Technologies</strong>:
<ul>
<li>As technology has evolved, especially with the rise of Solid State
Drives (SSDs), the traditional concept of tracks and sectors is becoming
less relevant. SSDs don't have moving parts, so they don't have tracks
and sectors in the way magnetic disks do.</li>
</ul></li>
</ol>
<p>When dealing with specific hardware or situations where the
sector/track configuration matters, it's essential to refer to the
documentation or specifications for that particular disk or device.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统开机启动流程</title>
    <url>/blog/2023/10/11/data/CSAPP/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一bios">一、BIOS</h1>
<p><strong>1 、BIOS是什么</strong></p>
<p>BIOS：基本输入输出系统（Basic Input Output
System），它是一组固化到计算机内主板上一个ROM（Read-Only
Memory）只读存储器，不需要供电就可保持数据不丢失芯片上的程序，BIOS保存着计算机最重要的基本输入输出的程序、系统设置信息、开机上电自检程序和系统启动自检程序。</p>
<p><strong>2、BIOS的功能及作用</strong></p>
<p>a、POST上电自检及初始化：执行不同初始化和计算机硬件检测的函数或例程，开机后BIOS最先被启动，然后它会对电脑的硬件设备（CPU、640K基本内存（640K
BASE MEMORY）、1MB以上扩展内存（EXTEND MEMORY）、ROM（READ-ONLY
MEMORY，只读存储器）、主板、CMOS存储器、串口、并口、显卡、软盘子系统、硬盘子系统、键盘）进行完全彻底的检验和测试</p>
<p>b、BIOS 系统操作系统启动程序：完成 POST 自检后， ROM
BIOS 将按照系统 CMOS 设置中的启动顺序搜寻软硬盘驱动器及 CDROM 、网络服务器等有效的启动驱动器 ，读入操作系统引导记录，然后将系统控制权交给引导记录，由引导记录完成系统的启动。 </p>
<p>c、BIOS 中断服务程序：开机时，BIOS会告诉CPU各硬件设备的中断号，当用户发出使用某个设备的指令后，CPU就根据中断号使用相应的硬件完成工作，再根据中断号跳回原来的工作。</p>
<p>d、程序服务：BIOS直接与计算机的I/O(Input/Output，即输入/输出)设备打交道，通过特定的数据端口发出命令，传送或接收各种外部设备的数据，实现软件程序对硬件的直接操作</p>
<p>BIOS 系统设置程序： 机器部件的配置情况是存放在一块可读写的 CMOS RAM
芯片中的，它保存着系统 CPU 、软硬盘驱动器、显示器、键盘等部件的信息。
关机后，系统通过一块后备电池向 CMOS 供电以保持其中的信息。如果 CMOS
中关于微机的配置信息不正确，会导致系统性能降低、零部件不能识别，并由此引发一系统的软硬件故障</p>
<h1 id="二cmos">二、CMOS</h1>
<p><strong>1、CMOS是什么</strong></p>
<p>CMOS：（Complementary
Metal-Oxide-Semiconductor）主板上的一块可读写的 RAM 芯片，
CMOS用来保存计算机基本启动信息（如日期、时间、启动设置等）和当前系统的硬件配置和用户某些参数的设定的芯片，CMOS的特性是可读写的，因此在电脑的主板上是用来保存BIOS的设置电脑硬件参数的数据，这个芯片仅仅用来存储数据，CMOS是靠主板上的纽扣电池供电的，就算主机断电也能保存数据。CMOS芯片一般被集成在南北桥芯片组里面。</p>
<p><strong>2、CMOS芯片中存储了哪些数据</strong></p>
<p>CPU的类型、内存的容量与类型、硬盘的类型和基本的参数</p>
<p><strong>3、BIOS和CMOS的区别、联系</strong></p>
<p>联系：BIOS中的系统设置程序是完成CMOS参数设置的手段，即通过BIOS设置程序对CMOS参数进行设置。CMOS既是BIOS设置系统参数的存放场所，又是BIOS设置系统参数的结果。</p>
<p>区别：
bios保存系统的重要信息和设置系统参数的设置程序（BIOSSetup程序)，而cmos是主板上的一块可读写的RAM芯片，里面装的是关于系统配置的具体参数，其内容可通过设置程序进行读写。</p>
<h1 id="三ec">三、EC</h1>
<p>EC（Embed Controller，嵌入式控制权）又称开机控制芯片</p>
<p><strong>1、EC是什么？</strong></p>
<p>EC是一个16位单片机，它内部本身也有一定容量的Flash来存储EC的代码。由于早期的EC主要管控键盘，所以也称KBC（KeyBoard
Controller，<a
href="https://www.baidu.com/s?wd=%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">键盘控制器</a>）。EC在系统中的地位绝不次于南北桥，在系统开启的过程中，EC控制着绝大多数重要信号的时序。</p>
<p>在笔记本中，EC是一直开着的，无论你是在开机或者是关机状态，除非你把电池和Adapter完全卸除。
在关机状态下，EC一直保持运行，并在等待用户的开机信息。而在开机后，EC更作为<a
href="https://www.baidu.com/s?wd=%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">键盘控制器</a>，充电指示灯以及风扇等设备的控制，它甚至控制着系统的待机、休眠等状态。</p>
<p><strong>2、EC的作用</strong></p>
<p>在系统关机的时候，只有RTC（实时时钟）部分和EC部分在运行。RTC部分维持着计算机的时钟和CMOS设置信息，而EC则在等待用户按开机键。在检测到用户按开机键后，EC会通知整个系统把电源打开，CPU被RESET后，会去读BIOS内一个特定地址内的指令（其实是一个跳转指令，这个地址是由CPU硬件设定的）。在CPU读到所发出的地址内的指令后，执行它被RESET后的第一个指令。在这个系统中，EC起到了桥接BIOS和南桥（或者说整个系统）的作用。
EC是一个单独的处理器，在开机前和开机过程中对整个系统起着全局的管理。而BIOS是在等EC把内部的物理环境初始化后才开始运行的。如果说BIOS
是底层系统的话，那EC 似乎更加底层。 在南桥上还有一个功能块就是<a
href="https://www.baidu.com/s?wd=%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">电源管理</a>单元（PM，Power
Management）。 一般来说，他和EC来共同配合完成。这里包括从开机（power
button）键按下后，启动，待机，休眠，关机的全部功能。还包括对背光亮度，声音等的控制等等。
至于现在Intel的Speed
Step技术，也有部分功能是透过南桥来实现的（南桥发送SLP、STPCLK（sleep，Stop
Clock）来实现睡眠、深睡眠等）。 (Embedded
Controller，嵌入式控制器)在一组特定系统中，新增到固定位置，完成一定任务的控制装置就称为嵌入式控制器。</p>
<p>参考网址：<a
href="https://blog.csdn.net/maomaovv/article/details/1549819">https://blog.csdn.net/maomaovv/article/details/1549819</a></p>
<h1 id="四计算机开机启动流程">四、计算机开机启动流程</h1>
<p><strong>Stage1：加电开机</strong></p>
<p>按下电源的开关，电源马上开始向主板和其它的设别开始供电，但此时的电压还不是很稳定，主板上的控制芯片组会向CPU发出并保持一个reset（重置）信号，让CPU内部自动恢复到初始状态下，当芯片组检测到电源已经开始稳定的供电了（从不稳定到稳定的过程中只需要一瞬间即可），芯片组则开始撤去reset信号，CPU马上开始从FFFF0H出执行指令，这个地址是在系统的BIOS的地址范围内，其实放在这里的只是一条跳转指令，指向BIOS中真正的启动代码地方。</p>
<p><strong>Stage2：BIOS启动，POST自检（Power-On-self-test）</strong></p>
<p>BIOS启动后，第一件事情就是执行POST自检阶段，主要针对系统的一些关键设备是否存在或者是功能是否正常，如：内存、显卡等，如果在POST过程中系统设备存在致命的问题，BIOS将会发出声音来报告检测过程中出现的错误，声音的长短及次数对应着系统的错误类型。POST过程会非常快速，对用户几乎感觉不出来。</p>
<p>显卡初始化：在POST过程中，BIOS会去查找显卡的BIOS，并且去调用显卡BIOS的代码，由显卡BIOS去初始化显卡，这个时候显示器一般会显示一些初始化的信息，同时系统BIOS也会去查找其它设备的BIOS，分别调用她们的初始化代码来初始化设备。</p>
<p>BIOS报错声音对应链接：<a
href="https://baike.baidu.com/item/BIOS%E6%8A%A5%E8%AD%A6%E5%A3%B0/4231622?fr=aladdin">https://baike.baidu.com/item/BIOS%E6%8A%A5%E8%AD%A6%E5%A3%B0/4231622?fr=aladdin</a></p>
<p>总之：如果硬件出现问题，主板会发出不同的蜂鸣，启动中止，如果没有问题，则显示器会显示相关信息。</p>
<p><strong>Stage3：启动顺序</strong></p>
<p>硬件自检结束后，BIOS这个时候将控制权交给下一阶段的启动程序，但是这个时候BIOS需要知道“下一个阶段要启动的程序具体放在了哪一个设备上”也就是我们平时说的BIOS下的启动顺序，但排在第一位的是优先转交的设备，这个叫做启动顺序。</p>
<p>启动顺序，我们日常工作中可以开机进入BIOS的去调节启动设备的优先级。</p>
<p><strong>Stage4：主引导记录</strong></p>
<p>BIOS按照设定好的启动顺序，将控制权交给排在第一位的存储设备，即开始从第一位设备中读取设备的MBR，并且将程序放在0x7c000的内存地址位中。</p>
<p>MBR：存储设备中的第一个扇区，磁盘最前面的512Byte，称为“主引导扇区”（Master
boot record，缩写为MBR）</p>
<p>这个时候计算机会去读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，BIOS会继续去找下一个设备，并将控制权转交给”启动顺序”中的下一个设备。</p>
<p><strong>主引导记录（MBR）的结构组成：</strong></p>
<p>MBR很小，只有512字节，存放程序很小，其主要作用是：告诉计算机在哪一个位置去找操作系统。</p>
<p>主引导记录由三个部分组成：</p>
<p>1、1-446字节：调用操作系统的程序</p>
<p>2、447-520字节：分区表</p>
<p>3、511-512字节：主引导记录的签名（0x55和0xAA）</p>
<p><strong>分区表：</strong></p>
<p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。</p>
<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。</p>
<p>每个主分区的16个字节，由6个部分组成：</p>
<p>（1）
第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</p>
<p>（2）
第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</p>
<p>（3） 第5个字节：主分区类型。</p>
<p>（4） 第6-8个字节：主分区最后一个扇区的物理位置。</p>
<p>（5） 第9-12字节：该主分区第一个扇区的逻辑地址。</p>
<p>（6） 第13-16字节：主分区的扇区总数。</p>
<p>注：最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p>
<p><strong>Stage5：硬盘启动</strong></p>
<p>这时，计算机要将控制权转交给硬盘的某个分区，但是分区又会出现几种情况：</p>
<p>1、卷引导记录</p>
<p>四个分区中，只有一个是激活的，计算机开始读取激活的第一个扇区，叫“卷引导记录"（Volume
boot record，缩写为VBR）</p>
<p>卷引导记录主要作用：告诉计算机，操作系统在这个分区，可以开始加载操作系统</p>
<p>2、扩展分区和逻辑分区</p>
<p>扩展分区：分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended
partition）。可以在扩展分区中继续分区</p>
<p>逻辑分区：指在扩展区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical
partition）</p>
<p>计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot
record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p>
<p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p>
<p>3、启动管理器</p>
<p>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot
loader），由用户选择启动哪一个操作系统。</p>
<p>Boot loader：是在<a
href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用<a
href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/297824">操作系统内核</a>准备好正确的环境</p>
<p><strong>Stage6：操作系统启动</strong></p>
<p>控制权转交给操作系统后，操作系统的内核被载入内存。</p>
<p>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>
<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>栈帧是如何开辟空间的？</title>
    <url>/blog/2023/10/11/data/CSAPP/os/%E6%A0%88%E5%B8%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<p>由于函数调用会产生一个栈帧，而ESP寄存器总是指向栈帧的头部（在栈由高地址向低地址增长的语义下，栈帧的头部指的是这一帧内存区域中地址最小的位置）。当函数要使用临时变量，比如声明了一个int类型，需要四字节的空间来存放这个数值，此时ESP寄存器就会先向低地址移动对应的字节，然后在此处写入四字节int数据，注意，写入数据是往高地址增长的，这也是为什么ESP寄存器要预先往低地址移动足够的长度，留出空间给即将写入的数据，数据写入都是低地址写完了，就+1，到下一个更高的地址去写入。</p>
<h3 id="push-指令">push 指令</h3>
<p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack
上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP
寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP
寄存器所保存的地址。</p>
<p>然后，开始执行第一行代码。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">push   3</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>push</code>指令用于将运算子放入
Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>
<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出
ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP
寄存器。使用减法是因为 Stack
从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后，
3 就会写入这个地址开始的四个字节。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>进程地址空间</title>
    <url>/blog/2023/10/11/data/CSAPP/os/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>![[process structure.jpg]]</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>预防死锁（死锁的基本处理方法）</title>
    <url>/blog/2023/10/11/data/CSAPP/os/%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%EF%BC%88%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="处理死锁的基本方法">处理死锁的基本方法</h2>
<p>目前，处理死锁的方法可归结为以下四种：</p>
<h3 id="预防死锁">1 预防死锁</h3>
<p>这是一种较为简单和直观的事先预防的方法。该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但由于所施加的限制条件往往太严格，因而可能导致系统资源利用率和系统吞吐量降低。</p>
<h3 id="避免死锁">2 避免死锁</h3>
<p>该方法同样是属于事先预防策略，但它并不需要事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。这种方法只需事先施加较弱的限制条件，便可获得较高的资源利用率及系统吞吐量，但在实现上有一定的难度。目前在较完善的系统中常用此方法来避免发生死锁。</p>
<h3 id="检测死锁">3 检测死锁</h3>
<p>这种方法并不需要事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时的检测出死锁的发生，并精确的确定与死锁有关的进程和资源；然后采取适当措施从系统中将已发生的死锁清除掉。</p>
<h3 id="解除死锁">4  解除死锁</h3>
<p>这是与检测死锁相配套的一种措施。当检测到系统中已经发生死锁时，将进程从死锁状态中解脱出来。常用的方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已经处于阻塞状态的进程，使之转为就绪态，以继续运行。死锁的检测和解除措施有可能使系统获得较好的资源利用率和吞吐量，但是实现上难度也最大。</p>
<p>预防死锁的基本方法</p>
<p>预防死锁和避免死锁这两种方法实质上都是通过施加某些限制条件，来预防发生死锁。两者的主要差别在于：为预防死锁所施加的限制条件比较严格，这往往会影响进程的并发执行；而为避免死锁所加的限</p>
<p>制条件则比较宽松，这给进程的运行提供了较宽松的环境，有利于进程的并发。</p>
<h2 id="一预防死锁">一、预防死锁</h2>
<p>预防死锁的方法是使四个必要条件中的第2、3、4个条件之一不能成立，来避免发生死锁。至于必要条</p>
<p>件1，因为它是由设备的固有特性所决定的，不仅不能改变，还应加以保证。</p>
<h3 id="摒弃请求和保持条件">1）摒弃“请求和保持”条件</h3>
<p>在采用这种方法时，系统规定所有进程在开始运行之前，都必须一次性的申请其在整个运行过程所需的全部资源。此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给进程，这样，该进程在整个运行期间便不会再提出资源要求，从而摒弃了请求条件。但在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需各资源都空闲，也不分配给该进程，而让该进程等待。由于在该进程的等待期间，它并未占用任何资源，因而也摒弃了保持条件，从而避免发生死锁。</p>
<p>这种方法的缺点是：首先表现为资源被严重浪费，因为一个进程是一次性地获得其整个运行过程中所需的全部资源的，且独占资源，其中可能有些资源很少用，甚至在整个运行期间都未使用，这就严重的恶化了系统资源的利用率；其次是使进程延迟运行，仅当进程在获得了其所需的全部资源后，才能开始运行，但可能因有些资源已长期被其它进程占用而使等待该资源的进程迟迟不能运行。</p>
<h3 id="摒弃不可剥夺条件">2）摒弃“不可剥夺”条件</h3>
<p>在采用这种方法时系统规定，进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。这意味着某一进程已经占有的资源，在运行过程中会被占时释放掉，也可认为是被剥夺了，从而摒弃了“不可剥夺”条件。</p>
<h3 id="摒弃环路等待条件">3）摒弃“环路等待”条件</h3>
<p>这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。例如，令输入机的序号为1，打印机的序号为2，磁带机为3，磁盘为4.所有进程对资源的请求必须严格按照资源序号递增的次序</p>
<p>提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。</p>
<h2 id="二系统安全状态">二、系统安全状态</h2>
<p>在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终处于安全状态，便可避免发生</p>
<p>死锁。</p>
<h3 id="安全状态">1.安全状态</h3>
<p>在避免死锁的方法中，允许进程动态的申请资源，但系统在进行资源分配之前，应先计算此次资源分配</p>
<p>的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程，否则，令进程等待。</p>
<p>所谓安全状态，是指系统能按某种进程顺序（P1,P2,……,Pn）（称&lt;“P1,P2,…,Pn&gt;序列为安全序列），来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺</p>
<p>利完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p>
<p>虽然并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进而进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。因此，避免死锁的实质在于：系</p>
<p>统在进行资源分配时，如何使系统不进入不安全状态。</p>
<p>2.安全状态之例</p>
<p>假定系统中有三个进程P1、P2和P3，共有12台磁带机。进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假设在T0时刻，进程P1、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，</p>
<p>如下表所示：</p>
<figure>
<img
src="data:image/png;base64,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"
alt="这里写图片描述" />
<figcaption aria-hidden="true">这里写图片描述</figcaption>
</figure>
<p>经分析发现，在T0时刻系统是安全的，因为这时存在一个安全序列《P2,P1,P3》，即只要系统按此进程序列分配资源，就能使每个进程都顺利完成。例如，将剩余的磁带机取2台分配给P2，使之继续运行，待P2完成，便可释放出4台磁带机，于是可用资源增至5台；以后再将这些全部分配给进程P1，使之运行，待P1完成后，将释放出10台磁带机，P3便能获得足够的资源，从而使P1、P2、P3每个进程都能顺利完成。</p>
<p>3.由安全状态向不安全状态的转换。</p>
<p>如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如在T0时刻以后，P3又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入不安全状态。因为此时无法再找到一个安全序列，例如，把剩余的2台分配给P2，这样，在P2完成后只能释放出4台，既不能满足P1尚需5台的要求，也不能满足P3尚需6台的需求，致使它们都无法推进前行，彼此都在等待对方释放资源，即陷入僵局，结果导致死锁。类似地，如果我们将剩余的两台磁带机先分配给P1或P3，也同样都无法使它们推进完成，因此，从给P3分配了第三台磁带机开始，系统便又进入了不安全状态。由此可见，在P3请求资源时，尽管系统中尚有可用的磁带机，但却不能分配给它，必须让P3一直等待到P1和P2完成，释放出资源后再将足够的资源分配给P3，它才能顺利完成。</p>
<p>三、利用银行家算法避免死锁</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>OI WIKI</title>
    <url>/blog/2023/10/11/data/algorithmn/OI%20WIKI/OI%20WIKI/</url>
    <content><![CDATA[<p>这个网站包含了大部分的算法知识和练习，可以学习参考</p>
<p><a href="https://oi-wiki.org/">OI Wiki - OI Wiki
(oi-wiki.org)</a></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>OI WIKI</tag>
      </tags>
  </entry>
  <entry>
    <title>2811. 熄灯问题</title>
    <url>/blog/2023/10/11/data/algorithmn/openjudge/2811.%20%E7%86%84%E7%81%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>描述</p>
<p>有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。</p>
<p><img src="http://media.openjudge.cn/images/2811_1.jpg" /><br />
在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。</p>
<p><img src="http://media.openjudge.cn/images/2811_2.jpg" /><br />
请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道：<br />
1.
第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次<br />
2. 各个按钮被按下的顺序对最终的结果没有影响<br />
3.
对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的</p>
<p><strong>输入</strong><br />
5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。</p>
<p><strong>输出</strong><br />
5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。</p>
<p>样例输入<br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0 1 1 0 1 0</span><br><span class="line">1 0 0 1 1 1</span><br><span class="line">0 0 1 0 0 1</span><br><span class="line">1 0 0 1 0 1</span><br><span class="line">0 1 1 1 0 0</span><br></pre></td></tr></table></figure></p>
<p>样例输出<br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1 0 1 0 0 1</span><br><span class="line">1 1 0 1 0 1</span><br><span class="line">0 0 1 0 1 1</span><br><span class="line">1 0 0 1 0 0</span><br><span class="line">0 1 0 0 0 0</span><br></pre></td></tr></table></figure></p>
<p>这是一个枚举问题，首先题目给出的三点提示是比较重要的，但是并未说出真正的重点，按照题目提示的思路去想，则要么最后一行不能全部熄灭，要么最后一列无法全部熄灭，并且在只剩一行或一列时，无法再按照题目的提示去消除了。按照行的顺序来消除，则一般情况下只能消除前四行，仔细想想，这是合理的，一共有五行，但是我们只提供了四行的解，自然有一行无解。因为后面行的解都依赖于前一行，所以第一行的解最重要，但是短时间内我们无法找出规律直接得到第一行的解，因此必须枚举，好在需要枚举的情况并不多，一行只有6个
0/1 可变状态，因此可能的解是 <span class="math inline">\(2^6=64\)</span>
种，我们只需要枚举开关状态从<code>000000</code>到<code>111111</code>的情况即可。</p>
<p>在代码实现上，只要状态小于64位，都可以使用内置的数值类型来进行位运算提高计算效率。本题的开关状态需要6个bit来表示，因此一个字节就可以完成表示，我们使用char类型来表示一行灯泡的状态，6个char组成的数组来表示整个灯泡矩阵。</p>
<p>我们还需要一些便利的位运算工具函数来完成位运算操作：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取某一位</span></span><br><span class="line"><span class="function">uint <span class="title">get_bit</span><span class="params">(byte b, uint i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置某一位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_bit</span><span class="params">(byte*b, uint i, uint v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v)</span><br><span class="line">        *b = *b |  (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *b = *b &amp; ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 翻转某一位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev_bit</span><span class="params">(byte*b, uint i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *b = *b ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次，相比于leetcode等核心题目模式，ACM使用原始输入模式，这要求用户自己补全所需的头文件以及相关的I/O处理（用例输入和结果输出）：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> byte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"></span><br><span class="line">byte matrix[<span class="number">5</span>];</span><br><span class="line">byte result[<span class="number">5</span>];</span><br><span class="line">uint num_cases;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;num_cases);</span><br><span class="line"><span class="keyword">while</span> (num_cases--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// reset matrix for each test case</span></span><br><span class="line">	<span class="built_in">memset</span>(matrix, <span class="number">0</span>, <span class="built_in">sizeof</span>(matrix));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// I use uint for loop counter just for the</span></span><br><span class="line">	<span class="comment">// convenient that I don&#x27;t need to  do  the</span></span><br><span class="line">	<span class="comment">// int -&gt; uint convertion when call set_bit</span></span><br><span class="line">	uint tmp;</span><br><span class="line">	<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;tmp);</span><br><span class="line">			<span class="built_in">set_bit</span>(&amp;matrix[i], j, tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是完整代码：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> byte;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"></span><br><span class="line">byte matrix[<span class="number">5</span>];</span><br><span class="line">byte result[<span class="number">5</span>];</span><br><span class="line">uint num_cases;</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">get_bit</span><span class="params">(byte b, uint i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_bit</span><span class="params">(byte*b, uint i, uint v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev_bit</span><span class="params">(byte*b, uint i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_byte</span><span class="params">(byte b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_result</span><span class="params">(byte result[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;num_cases);</span><br><span class="line">    <span class="keyword">while</span> (num_cases--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// reset matrix for each test case</span></span><br><span class="line">        <span class="built_in">memset</span>(matrix, <span class="number">0</span>, <span class="built_in">sizeof</span>(matrix));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// I use uint for loop counter just for the</span></span><br><span class="line">        <span class="comment">// convenient that I don&#x27;t need to  do  the</span></span><br><span class="line">        <span class="comment">// int -&gt; uint convertion when call set_bit</span></span><br><span class="line">        uint tmp;</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;tmp);</span><br><span class="line">                <span class="built_in">set_bit</span>(&amp;matrix[i], j, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// enumerate all switch cases of the first line</span></span><br><span class="line">        byte mbtrix[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (byte curswt = <span class="number">0</span>; curswt &lt; <span class="number">64</span>; ++curswt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// don&#x27;t pollute the original matrix</span></span><br><span class="line">            <span class="built_in">memcpy</span>(mbtrix, matrix, <span class="built_in">sizeof</span>(matrix));</span><br><span class="line">            byte tmpswt = curswt;</span><br><span class="line">            <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                result[i] = tmpswt;</span><br><span class="line">                <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">	                <span class="comment">// 如果这个位置的开关没开，则不进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">get_bit</span>(tmpswt, j)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// simulate the flip operation</span></span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">rev_bit</span>(&amp;mbtrix[i], j - <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">rev_bit</span>(&amp;mbtrix[i], j);</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; <span class="number">5</span>)</span><br><span class="line">                        <span class="built_in">rev_bit</span>(&amp;mbtrix[i], j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">4</span>)</span><br><span class="line">                    mbtrix[i + <span class="number">1</span>] = mbtrix[i + <span class="number">1</span>] ^ tmpswt;</span><br><span class="line">                <span class="comment">// current lighted positions indicate swithes to be pressed</span></span><br><span class="line">                <span class="comment">// in the next line</span></span><br><span class="line">                tmpswt = mbtrix[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((uint)mbtrix[<span class="number">4</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// printf(&quot;- switch -\n&quot;, (uint)curswt);</span></span><br><span class="line">                <span class="comment">// print_result(result);</span></span><br><span class="line">                <span class="comment">// printf(&quot;- matrix -\n&quot;);</span></span><br><span class="line">                <span class="comment">// print_byte(mbtrix[0]);</span></span><br><span class="line">                <span class="comment">// print_byte(mbtrix[1]);</span></span><br><span class="line">                <span class="comment">// print_byte(mbtrix[2]);</span></span><br><span class="line">                <span class="comment">// print_byte(mbtrix[3]);</span></span><br><span class="line">                <span class="comment">// print_byte(mbtrix[4]);</span></span><br><span class="line">                <span class="built_in">print_result</span>(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// byte testb = 0;</span></span><br><span class="line">    <span class="comment">// set_bit(&amp;testb, 1, 1);</span></span><br><span class="line">    <span class="comment">// print_byte(testb);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%u %u\n&quot;, get_bit(testb, 1), get_bit(testb, 0));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">get_bit</span><span class="params">(byte b, uint i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_bit</span><span class="params">(byte*b, uint i, uint v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v)</span><br><span class="line">        *b = *b |  (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *b = *b &amp; ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev_bit</span><span class="params">(byte*b, uint i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *b = *b ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_byte</span><span class="params">(byte b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;%u %u %u %u %u %u\n&quot;</span>,</span><br><span class="line">        <span class="built_in">get_bit</span>(b, <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">get_bit</span>(b, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">get_bit</span>(b, <span class="number">2</span>),</span><br><span class="line">        <span class="built_in">get_bit</span>(b, <span class="number">3</span>),</span><br><span class="line">        <span class="built_in">get_bit</span>(b, <span class="number">4</span>),</span><br><span class="line">        <span class="built_in">get_bit</span>(b, <span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_result</span><span class="params">(byte result[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">&quot;%u %u %u %u %u %u\n&quot;</span>,</span><br><span class="line">            <span class="built_in">get_bit</span>(result[i], <span class="number">0</span>),</span><br><span class="line">            <span class="built_in">get_bit</span>(result[i], <span class="number">1</span>),</span><br><span class="line">            <span class="built_in">get_bit</span>(result[i], <span class="number">2</span>),</span><br><span class="line">            <span class="built_in">get_bit</span>(result[i], <span class="number">3</span>),</span><br><span class="line">            <span class="built_in">get_bit</span>(result[i], <span class="number">4</span>),</span><br><span class="line">            <span class="built_in">get_bit</span>(result[i], <span class="number">5</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>openjudge</tag>
      </tags>
  </entry>
  <entry>
    <title>acwj-A complier writting journey</title>
    <url>/blog/2023/10/11/data/compiler%20principle/acwj/acwj-A%20complier%20writting%20journey/</url>
    <content><![CDATA[<p><a
href="%5BDoctorWkt/acwj:%20A%20Compiler%20Writing%20Journey%20(github.com)%5D(https://github.com/DoctorWkt/acwj)">github
page</a></p>
]]></content>
      <categories>
        <category>compiler principle</category>
      </categories>
      <tags>
        <tag>compiler principle</tag>
        <tag>acwj</tag>
      </tags>
  </entry>
  <entry>
    <title>ADD 和 COPY命令什么区别，分别在什么时候使用？</title>
    <url>/blog/2023/10/11/data/deployment/docker/ADD%20%E5%92%8C%20COPY%E5%91%BD%E4%BB%A4%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="introduction">1. Introduction</h2>
<p>When creating Dockerfiles, it's often necessary to transfer files
from the host system into the Docker image. These could be property
files, native libraries, or other static content that our applications
will require at runtime.</p>
<p>The Dockerfile specification provides two ways to copy files from the
source system into an image: the COPY and ADD directives.</p>
<p>In this article, we'll look at the differences between them and when
it makes sense to use each one.</p>
<h2 id="difference-between-copy-and-add">2. Difference Between COPY and
ADD</h2>
<p>At first glance, the COPY and ADD directives look the same. They have
the same syntax:</p>
<p>COPY <source> <destination><br />
ADD <source> <destination>Copy</p>
<p>And both copy files from the host system to the <a
href="https://www.baeldung.com/ops/efficient-docker-images">Docker
image</a>.</p>
<p>So what's the difference? In short, the ADD directive is more capable
than COPY.</p>
<p>While functionally similar, the ADD directive is more powerful in two
ways:</p>
<ul>
<li>It can handle remote URLs<br />
</li>
<li>It can auto-extract <a
href="https://www.baeldung.com/linux/tar-command">tar files</a></li>
</ul>
<p>Let's look at these more closely.</p>
<p>First, the ADD directive can accept a remote URL for its source
argument. The COPY directive, on the other hand, can only accept local
files.</p>
<p>Note that using ADD to fetch remote files and copying is not
typically ideal. This is because the file will increase the overall
Docker image size. Instead, we should use <a
href="https://www.baeldung.com/linux/curl-wget">curl or wget</a> to
fetch remote files and remove them when no longer needed.</p>
<p>Second, the ADD directive will automatically expand tar files into
the image file system. While this can reduce the number of Dockerfile
steps required to build an image, it may not be desired in all
cases.</p>
<p>Note that the auto-expansion only occurs when the source file is
local to the host system.</p>
<h2 id="when-to-use-add-or-copy">3. When to Use ADD or COPY</h2>
<p>According to the <a
href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy">Dockerfile
best practices guide</a>, we should always prefer COPY over ADD unless
we specifically need one of the two additional features of ADD.</p>
<p>As noted above, using ADD to copy remote files into a Docker image
creates an extra layer and increases the file size. If we use wget or
curl instead, we can remove the files afterward, and they don't remain a
permanent part of the Docker image.</p>
<p>Additionally, since the ADD command automatically expands tar files
and certain compressed formats, it can lead to unexpected files being
written to the file system in our images.</p>
<h2 id="conclusion">4. Conclusion</h2>
<p>In this quick tutorial, we've seen the two primary ways to copy files
into a Docker image: ADD and COPY. While functionally similar, the COPY
directive is preferred for most cases. This is because the ADD directive
provides additional functionality that should be used with caution and
only when needed.</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础-AUFS</title>
    <url>/blog/2023/10/11/data/deployment/docker/Docker%E5%9F%BA%E7%A1%80-AUFS/</url>
    <content><![CDATA[<p>AUFS是一种Union File
System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合
mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。</p>
<p>AUFS又叫Another UnionFS，后来叫Alternative
UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS。是个叫Junjiro
Okajima（岡島順治郎）在2006年开发的，AUFS完全重写了早期的UnionFS
1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS
2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union
mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。</p>
<p>不过，好在有很多发行版都用了AUFS，比如：Ubuntu 10.04，Debian6.0,
Gentoo Live CD支持AUFS，所以，也OK了。</p>
<p>好了，扯完这些闲话，我们还是看一个示例吧（环境：Ubuntu 14.04）</p>
<p>首先，我们建上两个目录（水果和蔬菜），并在这两个目录中放上一些文件，水果中有苹果和蕃茄，蔬菜有胡萝卜和蕃茄。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── fruits</span><br><span class="line">│   ├── apple</span><br><span class="line">│   └── tomato</span><br><span class="line">└── vegetables</span><br><span class="line">    ├── carrots</span><br><span class="line">    └── tomato</span><br></pre></td></tr></table></figure> 然后，我们输入以下命令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个mount目录</span><br><span class="line">$ mkdir mnt</span><br><span class="line"></span><br><span class="line"># 把水果目录和蔬菜目录union mount到 ./mnt目录中</span><br><span class="line">$ sudo mount -t aufs -o dirs=./fruits:./vegetables none ./mnt</span><br><span class="line"></span><br><span class="line">#  查看./mnt目录</span><br><span class="line">$ tree ./mnt</span><br><span class="line">./mnt</span><br><span class="line">├── apple</span><br><span class="line">├── carrots</span><br><span class="line">└── tomato</span><br></pre></td></tr></table></figure>
我们可以看到在./mnt目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了./mnt目录下了。</p>
<p>我们来修改一下其中的文件内容：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo mnt &gt; ./mnt/apple</span><br><span class="line">$ cat ./mnt/apple</span><br><span class="line">mnt</span><br><span class="line">$ cat ./fruits/apple</span><br><span class="line">mnt</span><br></pre></td></tr></table></figure>
上面的示例，我们可以看到./mnt/apple的内容改了，./fruits/apple的内容也改了。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo mnt_carrots &gt; ./mnt/carrots</span><br><span class="line">$ cat ./vegetables/carrots </span><br><span class="line"></span><br><span class="line">$ cat ./fruits/carrots</span><br><span class="line">mnt_carrots</span><br></pre></td></tr></table></figure>
上面的示例，我们可以看到，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits/carrots的目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容。</p>
<p>也就是说，我们在mount
aufs命令中，我们没有指它vegetables和fruits的目录权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）</p>
<p>所以，如果我们像下面这样指定权限来mount
aufs，你就会发现有不一样的效果（记得先把上面./fruits/carrots的文件删除了）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt</span><br><span class="line"></span><br><span class="line">$ echo &quot;mnt_carrots&quot; &gt; ./mnt/carrots </span><br><span class="line"></span><br><span class="line">$ cat ./vegetables/carrots</span><br><span class="line">mnt_carrots</span><br><span class="line"></span><br><span class="line">$ cat ./fruits/carrots</span><br><span class="line">cat: ./fruits/carrots: No such file or directory</span><br></pre></td></tr></table></figure>
现在，在这情况下，如果我们要修改./mnt/tomato这个文件，那么究竟是哪个文件会被改写？<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;mnt_tomato&quot; &gt; ./mnt/tomato </span><br><span class="line"></span><br><span class="line">$ cat ./fruits/tomato</span><br><span class="line">mnt_tomato</span><br><span class="line"></span><br><span class="line">$ cat ./vegetables/tomato</span><br><span class="line">I am a vegetable</span><br></pre></td></tr></table></figure>
可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高。</p>
<p>你可以用这个例子做一些各种各样的试验，我这里主要是给大家一个感性认识，就不展开试验下去了。</p>
<p>那么，这种UnionFS有什么用？</p>
<p>历史上，有一个叫<a
href="https://zh.wikipedia.org/wiki/Knoppix">Knoppix的Linux发行版</a>，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把CD/DVD上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把CD/DVD这个文件系统和USB这个可写的系统给联合mount起来，这样你对CD/DVD上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对CD/DVD上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西。</p>
<p>我们可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working
directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad
hoc snapshot。</p>
<p>Docker把UnionFS的想像力发挥到了容器的镜像。你是否还记得我在<a
href="https://coolshell.cn/articles/17010.html"
title="Docker基础技术：Linux Namespace（上）">介绍Linux
Namespace上篇</a>中用mount
namespace和chroot山寨了一镜像。现在当你看过了这个UnionFS的技术后，你是不是就明白了，你完全可以用UnionFS这样的技术做出分层的镜像来。</p>
<p>下图来自Docker的官方文档<a
href="http://docs.docker.com/terms/layer/">Layer</a>，其很好的展示了Docker用UnionFS搭建的分层镜像。</p>
<figure>
<img
src="https://coolshell.cn/wp-content/uploads/2015/04/docker-filesystems-multilayer.png"
alt="docker-filesystems-multilayer" />
<figcaption
aria-hidden="true">docker-filesystems-multilayer</figcaption>
</figure>
<p>关于docker的分层镜像，除了aufs，docker还支持btrfs,
devicemapper和vfs，你可以使用 -s 或 –storage-driver=
选项来指定相关的镜像存储。在Ubuntu 14.04下，docker默认Ubuntu的
aufs（在CentOS7下，用的是devicemapper，关于devicemapper，我会以以后的文章中讲解）你可以在下面的目录中查看相关的每个层的镜像：<br />
/var/lib/docker/aufs/diff/&lt;id&gt;</p>
<p>在docker执行起来后（比如：docker run -it ubuntu /bin/bash
），你可以从/sys/fs/aufs/si_[id]目录下查看aufs的mount的情况，下面是个示例：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ls /sys/fs/aufs/si_b71b209f85ff8e75/</span><br><span class="line">br0      br2      br4      br6      brid1    brid3    brid5    xi_path</span><br><span class="line">br1      br3      br5      brid0    brid2    brid4    brid6 </span><br><span class="line"></span><br><span class="line"># cat /sys/fs/aufs/si_b71b209f85ff8e75/*</span><br><span class="line">/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7=rw</span><br><span class="line">/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7-init=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/d0955f21bf24f5bfffd32d2d0bb669d0564701c271bc3dfc64cfc5adfdec2d07=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/9fec74352904baf5ab5237caa39a84b0af5c593dc7cc08839e2ba65193024507=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/a1a958a248181c9aa6413848cd67646e5afb9797f1a3da5995c7a636f050f537=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/f3c84ac3a0533f691c9fea4cc2ceaaf43baec22bf8d6a479e069f6d814be9b86=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158=ro+wh</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">/run/shm/aufs.xino</span><br></pre></td></tr></table></figure></p>
<p>你会看到只有最顶上的层（branch）是rw权限，其它的都是ro+wh权限只读的。</p>
<p>关于docker的aufs的配置，你可以在/var/lib/docker/repositories-aufs这个文件中看到。</p>
<p>目录</p>
<ul>
<li><a
href="https://coolshell.cn/articles/17061.html#AUFS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7"
title="AUFS的一些特性">AUFS的一些特性</a>
<ul>
<li><a
href="https://coolshell.cn/articles/17061.html#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"
title="相关术语">相关术语</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17061.html#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"
title="相关问题">相关问题</a><br />
</li>
</ul></li>
<li><a
href="https://coolshell.cn/articles/17061.html#AUFS%E7%9A%84%E6%80%A7%E8%83%BD"
title="AUFS的性能">AUFS的性能</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17061.html#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"
title="延伸阅读">延伸阅读</a></li>
</ul>
<h4 id="aufs的一些特性">AUFS的一些特性</h4>
<p>AUFS有所有Union
FS的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被mount好的目录。而且，他还能在多个可写的branch/dir间进行负载均衡。</p>
<p>上面的例子，我们已经看到AUFS的mount的示例了。下面我们来看一看被union的目录（分支）的相关权限：</p>
<ul>
<li>rw表示可写可读read-write。<br />
</li>
<li>ro表示read-only，如果你不指权限，那么除了第一个外ro是默认值，对于ro分支，其永远不会收到写操作，也不会收到查找whiteout的操作。<br />
</li>
<li>rr表示real-read-only，与read-only不同的是，rr标记的是天生就是只读的分支，这样，AUFS可以提高性能，比如不再设置inotify来检查文件变动通知。</li>
</ul>
<p>权限中，我们看到了一个术语：whiteout，下面我来解释一下这个术语。</p>
<p>一般来说ro的分支都会有wh的属性，比如
“[dir]=ro+wh”。所谓whiteout的意思，如果在union中删除的某个文件，实际上是位于一个readonly的分支（目录）上，那么，在mount的union这个目录中你将看不到这个文件，但是read-only这个层上我们无法做任何的修改，所以，我们就需要对这个readonly目录里的文件作whiteout。AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。</p>
<p>看个例子：</p>
<p>假设我们有三个目录和文件如下所示（test是个空目录）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tree</span><br><span class="line">.</span><br><span class="line">├── fruits</span><br><span class="line">│   ├── apple</span><br><span class="line">│   └── tomato</span><br><span class="line">├── test</span><br><span class="line">└── vegetables</span><br><span class="line">    ├── carrots</span><br><span class="line">    └── tomato</span><br></pre></td></tr></table></figure> 我们如下mount：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mkdir mnt</span><br><span class="line"></span><br><span class="line"># mount -t aufs -o dirs=./test=rw:./fruits=ro:./vegetables=ro none ./mnt</span><br><span class="line"></span><br><span class="line"># # ls ./mnt/</span><br><span class="line">apple  carrots  tomato</span><br></pre></td></tr></table></figure>
现在我们在权限为rw的test目录下建个whiteout的隐藏文件.wh.apple，你就会发现./mnt/apple这个文件就消失了:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # touch ./test/.wh.apple</span><br><span class="line"></span><br><span class="line"># ls ./mnt</span><br><span class="line">carrots  tomato</span><br></pre></td></tr></table></figure> 上面这个操作和 rm ./mnt/apple是一样的。</p>
<h5 id="相关术语">相关术语</h5>
<p><strong>Branch</strong> –
就是各个要被union起来的目录（就是我在上面使用的dirs的命令行参数）</p>
<ul>
<li>Branch根据被union的顺序形成一个stack，一般来说最上面的是可写的，下面的都是只读的。<br />
</li>
<li>Branch的stack可以在被mount后进行修改，比如：修改顺序，加入新的branch，或是删除其中的branch，或是直接修改branch的权限</li>
</ul>
<p><strong>Whiteout</strong> 和 <strong>Opaque</strong></p>
<ul>
<li><p>如果UnionFS中的某个目录被删除了，那么就应该不可见了，就算是在底层的branch中还有这个目录，那也应该不可见了。</p></li>
<li><p>Whiteout就是某个上层目录覆盖了下层的相同名字的目录。用于隐藏低层分支的文件，也用于阻止readdir进入低层分支。</p></li>
<li><p>Opaque的意思就是不允许任何下层的某个目录显示出来。</p></li>
<li><p>在隐藏低层档的情况下，whiteout的名字是’.wh.&lt;filename&gt;’。</p></li>
<li><p>在阻止readdir的情况下，名字是’.wh..wh..opq’或者
’.wh.__dir_opaque’。</p></li>
</ul>
<h5 id="相关问题">相关问题</h5>
<p>看到上面这些，你一定会有几个问题：</p>
<p><strong>其一、你可能会问，要有文件在原来的地方被修改了会怎么样？</strong>mount的目录会一起改变吗？答案是会的，也可以是不会的。因为你可以指定一个叫udba的参数（全称：User’s
Direct Branch Access），这个参数有三个取值：</p>
<ul>
<li><strong>udba=none</strong> –
设置上这个参数后，AUFS会运转的更快，因为那些不在mount目录里发生的修改，aufs不会同步过来了，所以会有数据出错的问题。<br />
</li>
<li><strong>udba=reval</strong> –
设置上这个参数后，AUFS会去查文件有没有被更新，如果有的话，就会把修改拉到mount目录内。<br />
</li>
<li><strong>udba=notify</strong> –
这个参数会让AUFS为所有的branch注册inotify，这样可以让AUFS在更新文件修改的性能更高一些。</li>
</ul>
<p><strong>其二、如果有多个rw的branch（目录）被union起来了，那么，当我创建文件的时候，aufs会创建在哪里呢？</strong> aufs提供了一个叫create的参数可以供你来配置相当的创建策略，下面有几个例子。</p>
<p><strong>create=rr |
round−robin</strong> 轮询。下面的示例可以看到，新创建的文件轮流写到三个目录中<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen$ sudo mount -t aufs  -o dirs=./1=rw:./2=rw:./3=rw -o create=rr none ./mnt</span><br><span class="line">hchen$ touch ./mnt/a ./mnt/b ./mnt/c</span><br><span class="line">hchen$ tree</span><br><span class="line">.</span><br><span class="line">├── 1</span><br><span class="line">│   └── a</span><br><span class="line">├── 2</span><br><span class="line">│   └── c</span><br><span class="line">└── 3</span><br><span class="line">    └── b</span><br></pre></td></tr></table></figure> <strong>create=mfs[:second] |
most−free−space[:second]</strong> 选一个可用空间最好的分支。可以指定一个检查可用磁盘空间的时间。</p>
<p><strong>create=mfsrr:low[:second]</strong> 选一个空间大于low的branch，如果空间小于low了，那么aufs会使用
round-robin 方式。</p>
<p>更多的关于AUFS的细节使用参数，大家可以直接在Ubuntu 14.04下通过 <a
href="http://aufs.sourceforge.net/aufs3/man.html">man
aufs</a> 来看一下其中的各种参数和命令。</p>
<h4 id="aufs的性能">AUFS的性能</h4>
<p>AUFS的性能慢吗？也慢也不慢。因为AUFS会把所有的分支mount起来，所以，在查找文件上是比较慢了。因为它要遍历所有的branch。是个O(n)的算法（很明显，这个算法有很大的改进空间的）所以，branch越多，查找文件的性能也就越慢。但是，一旦AUFS找到了这个文件的inode，那后以后的读写和操作原文件基本上是一样的。</p>
<p>所以，如果你的程序跑在在AUFS下，open和stat操作会有明显的性能下降，branch越多，性能越差，但是在write/read操作上，性能没有什么变化。</p>
<p>IBM的研究中心对Docker的性能给了一份非常不错的性能报告（PDF）《<a
href="http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/$File/rc25482.pdf">An
Updated Performance Comparison of Virtual Machinesand Linux
Containers</a>》</p>
<p>我截了两张图出来，第一张是顺序读写，第二张是随机读写。基本没有什么性能损失的问题。而KVM在随机读写的情况也就有点慢了（但是，如果硬盘是SSD的呢？）</p>
<p><a
href="https://coolshell.cn/wp-content/uploads/2015/08/docker.seq_.jpg"><img
src="https://coolshell.cn/wp-content/uploads/2015/08/docker.seq_.jpg" /></a></p>
<p><strong>顺序读写</strong></p>
<p><a
href="https://coolshell.cn/wp-content/uploads/2015/08/docker.rand_.jpg"><img
src="https://coolshell.cn/wp-content/uploads/2015/08/docker.rand_.jpg" /></a></p>
<p><strong>随机读写</strong></p>
<h4 id="延伸阅读">延伸阅读</h4>
<ul>
<li><a href="http://www.linuxjournal.com/article/7714">Introduce
UnionFS</a><br />
</li>
<li><a href="http://lwn.net/Articles/325369/">Union file systems:
Implementations, part I</a><br />
</li>
<li><a href="http://lwn.net/Articles/327738/">Union file systems:
Implementations, part 2</a><br />
</li>
<li><a href="http://lwn.net/Articles/403012/">Another union filesystem
approach</a><br />
</li>
<li><a href="http://lwn.net/Articles/324291/">Unioning file systems:
Architecture, features, and design choices</a></li>
</ul>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础-CGROUP</title>
    <url>/blog/2023/10/11/data/deployment/docker/Docker%E5%9F%BA%E7%A1%80-CGROUP/</url>
    <content><![CDATA[<p>前面，我们介绍了<a href="https://coolshell.cn/articles/17010.html"
title="Docker基础技术：Linux Namespace">Linux
Namespace</a>，但是Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux
CGroup出来了的原因。</p>
<p>Linux CGroup全称Linux Control Group，
是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul
Menage和Rohit Seth），最早的名称为进程容器（process
containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。</p>
<p>Linux CGroupCgroup
可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU
时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​
cgroup，拒​​​绝​​​ cgroup 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​
cgroup。</p>
<p>主要提供了如下功能：</p>
<ul>
<li><strong>Resource limitation</strong>:
限制资源使用，比如内存使用上限以及文件系统的缓存限制。<br />
</li>
<li><strong>Prioritization</strong>:
优先级控制，比如：CPU利用和磁盘IO吞吐。<br />
</li>
<li><strong>Accounting</strong>:
一些审计或一些统计，主要目的是为了计费。<br />
</li>
<li><strong>Control</strong>: 挂起进程，恢复执行进程。</li>
</ul>
<p>使​​​用​​​
cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。</p>
<p>在实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：</p>
<ul>
<li>隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。<br />
</li>
<li>为这组进程 分配其足够使用的内存<br />
</li>
<li>为这组进程分配相应的网络带宽和磁盘存储限制<br />
</li>
<li>限制访问某些设备（通过设置设备的白名单）</li>
</ul>
<p>那么CGroup是怎么干的呢？我们先来点感性认识吧。</p>
<p>首先，Linux把CGroup这个事实现成了一个file
system，你可以mount。在我的Ubuntu
14.04下，你输入以下命令你就可以看到cgroup已为你mount好了。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)</span><br></pre></td></tr></table></figure> 或者使用lssubsys命令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lssubsys  -m</span><br><span class="line">cpuset /sys/fs/cgroup/cpuset</span><br><span class="line">cpu /sys/fs/cgroup/cpu</span><br><span class="line">cpuacct /sys/fs/cgroup/cpuacct</span><br><span class="line">memory /sys/fs/cgroup/memory</span><br><span class="line">devices /sys/fs/cgroup/devices</span><br><span class="line">freezer /sys/fs/cgroup/freezer</span><br><span class="line">blkio /sys/fs/cgroup/blkio</span><br><span class="line">net_cls /sys/fs/cgroup/net_cls</span><br><span class="line">net_prio /sys/fs/cgroup/net_prio</span><br><span class="line">perf_event /sys/fs/cgroup/perf_event</span><br><span class="line">hugetlb /sys/fs/cgroup/hugetlb</span><br></pre></td></tr></table></figure>
我们可以看到，在/sys/fs下有一个cgroup的目录，这个目录下还有很多子目录，比如：
cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。</p>
<p>如果你没有看到上述的目录，你可以自己mount，下面给了一个示例：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir cgroup</span><br><span class="line">mount -t tmpfs cgroup_root ./cgroup</span><br><span class="line">mkdir cgroup/cpuset</span><br><span class="line">mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/</span><br><span class="line">mkdir cgroup/cpu</span><br><span class="line">mount -t cgroup -ocpu cpu ./cgroup/cpu/</span><br><span class="line">mkdir cgroup/memory</span><br><span class="line">mount -t cgroup -omemory memory ./cgroup/memory/</span><br></pre></td></tr></table></figure>
一旦mount成功，你就会看到这些目录下就有好文件了，比如，如下所示的cpu和cpuset的子系统：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/ </span><br><span class="line">/sys/fs/cgroup/cpu:</span><br><span class="line">cgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent</span><br><span class="line">cgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks</span><br><span class="line">cgroup.procs           cpu.cfs_quota_us      notify_on_release  user</span><br><span class="line"></span><br><span class="line">/sys/fs/cgroup/cpuset/:</span><br><span class="line">cgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance</span><br><span class="line">cgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level</span><br><span class="line">cgroup.procs           cpuset.memory_pressure          notify_on_release</span><br><span class="line">cgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent</span><br><span class="line">cpuset.cpu_exclusive   cpuset.memory_spread_page       tasks</span><br><span class="line">cpuset.cpus            cpuset.memory_spread_slab       user</span><br><span class="line">cpuset.mem_exclusive   cpuset.mems</span><br></pre></td></tr></table></figure>
你可以到/sys/fs/cgroup的各个子目录下去make个dir，你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel</span><br><span class="line">[sudo] password for hchen: </span><br><span class="line">hchen@ubuntu:/sys/fs/cgroup/cpu$ ls ./haoel</span><br><span class="line">cgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks</span><br><span class="line">cgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release</span><br></pre></td></tr></table></figure></p>
<p>好了，我们来看几个示例。</p>
<p>目录</p>
<ul>
<li><a
href="https://coolshell.cn/articles/17049.html#CPU_%E9%99%90%E5%88%B6"
title="CPU 限制">CPU 限制</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6"
title="内存使用限制">内存使用限制</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#%E7%A3%81%E7%9B%98IO%E9%99%90%E5%88%B6"
title="磁盘I/O限制">磁盘I/O限制</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#CGroup%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F"
title="CGroup的子系统">CGroup的子系统</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#CGroup%E7%9A%84%E6%9C%AF%E8%AF%AD"
title="CGroup的术语">CGroup的术语</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84CGroup"
title="下一代的CGroup">下一代的CGroup</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#%E5%8F%82%E8%80%83"
title="参考">参考</a></li>
</ul>
<h4 id="cpu-限制">CPU 限制</h4>
<p>假设，我们有一个非常吃CPU的程序，叫deadloop，其源码如下：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;) i++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
用sudo执行起来后，毫无疑问，CPU被干到了100%（下面是top命令的输出）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     </span><br><span class="line">3529 root      20   0    4196    736    656 R 99.6  0.1   0:23.13 deadloop</span><br></pre></td></tr></table></figure>
然后，我们这前不是在/sys/fs/cgroup/cpu下创建了一个haoel的group。我们先设置一下这个group的cpu利用的限制：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~# cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us </span><br><span class="line">-1</span><br><span class="line">root@ubuntu:~# echo 20000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>
我们看到，这个进程的PID是3529，我们把这个进程加到这个cgroup中：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo 3529 &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks</span><br></pre></td></tr></table></figure>
然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     </span><br><span class="line">3529 root      20   0    4196    736    656 R 19.9  0.1   8:06.11 deadloop</span><br></pre></td></tr></table></figure> 下面的代码是一个线程的示例：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_main</span><span class="params">(<span class="type">void</span> *threadid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 把自己加入cgroup中（syscall(SYS_gettid)为得到线程的系统tid） */</span></span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo %ld &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks&quot;</span>, syscall(SYS_gettid));</span><br><span class="line">    system(cmd); </span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo %ld &gt;&gt; /sys/fs/cgroup/cpuset/haoel/tasks&quot;</span>, syscall(SYS_gettid));</span><br><span class="line">    system(cmd);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> tid;</span><br><span class="line">    tid = (<span class="type">long</span>)threadid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World! It&#x27;s me, thread #%ld, pid #%ld!\n&quot;</span>, tid, syscall(SYS_gettid));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num_threads;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        num_threads = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num_threads&lt;=<span class="number">0</span> || num_threads&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">        num_threads = NUM_THREADS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置CPU利用率为50% */</span></span><br><span class="line">    mkdir(<span class="string">&quot;/sys/fs/cgroup/cpu/haoel&quot;</span>, <span class="number">755</span>);</span><br><span class="line">    system(<span class="string">&quot;echo 50000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mkdir(<span class="string">&quot;/sys/fs/cgroup/cpuset/haoel&quot;</span>, <span class="number">755</span>);</span><br><span class="line">    <span class="comment">/* 限制CPU只能使用#2核和#3核 */</span></span><br><span class="line">    system(<span class="string">&quot;echo \&quot;2,3\&quot; &gt; /sys/fs/cgroup/cpuset/haoel/cpuset.cpus&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span>* threads = (<span class="type">pthread_t</span>*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*num_threads);</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">long</span> t;</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;num_threads; t++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In main: creating thread %ld\n&quot;</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, thread_main, (<span class="type">void</span> *)t);</span><br><span class="line">        <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR; return code from pthread_create() is %d\n&quot;</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last thing that main() should do */</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">free</span>(threads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="内存使用限制">内存使用限制</h4>
<p>我们再来看一个限制内存的例子（下面的代码是个死循环，其它不断的分配内存，每次512个字节，每次休息一秒）：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chunk_size = <span class="number">512</span>;</span><br><span class="line">    <span class="type">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(p, chunk_size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;out of memory!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">1</span>, chunk_size);</span><br><span class="line">        size += chunk_size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] - memory is allocated [%8d] bytes \n&quot;</span>, getpid(), size);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后，在我们另外一边：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建memory cgroup</span><br><span class="line">$ mkdir /sys/fs/cgroup/memory/haoel</span><br><span class="line">$ echo 64k &gt; /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes</span><br><span class="line"></span><br><span class="line"># 把上面的进程的pid加入这个cgroup</span><br><span class="line">$ echo [pid] &gt; /sys/fs/cgroup/memory/haoel/tasks</span><br></pre></td></tr></table></figure> 你会看到，一会上面的进程就会因为内存问题被kill掉了。</p>
<h4 id="磁盘io限制">磁盘I/O限制</h4>
<p>我们先看一下我们的硬盘IO，我们的模拟命令如下：（从/dev/sda1上读入数据，输出到/dev/null上）</p>
<p>sudo dd if=/dev/sda1 of=/dev/null</p>
<p>我们通过iotop命令我们可以看到相关的IO速度是55MB/s（虚拟机内）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          </span><br><span class="line">8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd if=/de~=/dev/null...</span><br></pre></td></tr></table></figure> 然后，我们先创建一个blkio（块设备IO）的cgroup<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/blkio/haoel</span><br></pre></td></tr></table></figure>
并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0
是设备号，你可以通过ls -l /dev/sda1获得）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# echo &#x27;8:0 1048576&#x27;  &gt; /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device </span><br><span class="line">root@ubuntu:~# echo 8128 &gt; /sys/fs/cgroup/blkio/haoel/tasks</span><br></pre></td></tr></table></figure></p>
<p>再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          </span><br><span class="line">8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd if=/de~=/dev/null...</span><br></pre></td></tr></table></figure></p>
<h4 id="cgroup的子系统">CGroup的子系统</h4>
<p>好了，有了以上的感性认识我们来，我们来看看control
group有哪些子系统：</p>
<ul>
<li>blkio —
这​​​个​​​子​​​系​​​统​​​为​​​块​​​设​​​备​​​设​​​定​​​输​​​入​​​/输​​​出​​​限​​​制​​​，比​​​如​​​物​​​理​​​设​​​备​​​（磁​​​盘​​​，固​​​态​​​硬​​​盘​​​，USB
等​​​等​​​）。<br />
</li>
<li>cpu — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​调​​​度​​​程​​​序​​​提​​​供​​​对​​​ CPU 的​​​ cgroup 任​​​务​​​访​​​问​​​。​​​<br />
</li>
<li>cpuacct — 这​​​个​​​子​​​系​​​统​​​自​​​动​​​生​​​成​​​ cgroup 中​​​任​​​务​​​所​​​使​​​用​​​的​​​ CPU 报​​​告​​​。​​​<br />
</li>
<li>cpuset — 这​​​个​​​子​​​系​​​统​​​为​​​ cgroup 中​​​的​​​任​​​务​​​分​​​配​​​独​​​立​​​
CPU（在​​​多​​​核​​​系​​​统​​​）和​​​内​​​存​​​节​​​点​​​。​​​<br />
</li>
<li>devices — 这​​​个​​​子​​​系​​​统​​​可​​​允​​​许​​​或​​​者​​​拒​​​绝​​​ cgroup 中​​​的​​​任​​​务​​​访​​​问​​​设​​​备​​​。​​​<br />
</li>
<li>freezer — 这​​​个​​​子​​​系​​​统​​​挂​​​起​​​或​​​者​​​恢​​​复​​​ cgroup 中​​​的​​​任​​​务​​​。​​​<br />
</li>
<li>memory — 这​​​个​​​子​​​系​​​统​​​设​​​定​​​ cgroup
中​​​任​​​务​​​使​​​用​​​的​​​内​​​存​​​限​​​制​​​，并​​​自​​​动​​​生​​​成​​​​​内​​​存​​​资​​​源使用​​​报​​​告​​​。​​​<br />
</li>
<li>net_cls — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​等​​​级​​​识​​​别​​​符​​​（classid）标​​​记​​​网​​​络​​​数​​​据​​​包​​​，可​​​允​​​许​​​
Linux 流​​​量​​​控​​​制​​​程​​​序​​​（tc）识​​​别​​​从​​​具​​​体​​​ cgroup 中​​​生​​​成​​​的​​​数​​​据​​​包​​​。​​​<br />
</li>
<li>net_prio — 这个子系统用来设计网络流量的优先级<br />
</li>
<li>hugetlb —
这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。</li>
</ul>
<p>​​​</p>
<p>注意，你可能在Ubuntu
14.04下看不到net_cls和net_prio这两个cgroup，你需要手动mount一下： 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo modprobe cls_cgroup</span><br><span class="line">$ sudo mkdir /sys/fs/cgroup/net_cls</span><br><span class="line">$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls</span><br><span class="line"></span><br><span class="line">$ sudo modprobe netprio_cgroup</span><br><span class="line">$ sudo mkdir /sys/fs/cgroup/net_prio</span><br><span class="line">$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio</span><br></pre></td></tr></table></figure> 关于各个子系统的参数细节，以及更多的Linux
CGroup的文档，你可以看看下面的文档：</p>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/">Linux
Kernel的官方文档</a><br />
</li>
<li><a
href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html#ch-Subsystems_and_Tunable_Parameters">Redhat的官方文档</a></li>
</ul>
<h4 id="cgroup的术语">CGroup的术语</h4>
<p>CGroup有下述术语：</p>
<ul>
<li><strong>任务（Tasks）</strong>：就是系统的一个进程。<br />
</li>
<li><strong>控制组（Control
Group）</strong>：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。<br />
</li>
<li><strong>层级（Hierarchy）</strong>：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。<br />
</li>
<li><strong>子系统（Subsystem）</strong>：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。</li>
</ul>
<h4 id="下一代的cgroup">下一代的CGroup</h4>
<p>上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。</p>
<p>不过，对此，有个叫Tejun Heo的同学非常不爽，他在Linux社区里<a
href="https://lwn.net/Articles/484254/">对cgroup吐了一把槽</a>，还引发了内核组的各种讨论。</p>
<p>对于Tejun
Heo同学来说，cgroup设计的相当糟糕。他给出了些例子，大意就是说，如果有多种层级关系，也就是说有多种对进程的分类方式，比如，我们可以按用户来分，分成Professor和Student，同时，也有按应用类似来分的，比如WWW和NFS等。那么，当一个进程即是Professor的，也是WWW的，那么就会出现多层级正交的情况，从而出现对进程上管理的混乱。另外，一个case是，如果有一个层级A绑定cpu，而层级B绑定memory，还有一个层级C绑定cputset，而有一些进程有的需要AB，有的需要AC，有的需要ABC，管理起来就相当不易。</p>
<p>层级操作起来比较麻烦，而且如果层级变多，更不易于操作和管理，虽然那种方式很好实现，但是在使用上有很多的复杂度。你可以想像一个图书馆的图书分类问题，你可以有各种不同的分类，分类和图书就是一种多对多的关系。</p>
<p>所以，在Kernel 3.16后，引入了<a
href="http://lwn.net/Articles/601840/">unified
hierarchy</a>的新的设计，这个东西引入了一个叫**__DEVEL__sane_behavior**的特性（这个名字很明显意味目前还在开发试验阶段），它可以把所有子系统都挂载到根层级下，只有叶子节点可以存在tasks，非叶子节点只进行资源控制。</p>
<p>我们mount一下看看：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mount -t cgroup -o __DEVEL__sane_behavior cgroup ./cgroup</span><br><span class="line"></span><br><span class="line">$ ls ./cgroup</span><br><span class="line">cgroup.controllers  cgroup.procs  cgroup.sane_behavior  cgroup.subtree_control </span><br><span class="line"></span><br><span class="line">$ cat ./cgroup/cgroup.controllers</span><br><span class="line">cpuset cpu cpuacct memory devices freezer net_cls blkio perf_event net_prio hugetlb</span><br></pre></td></tr></table></figure>
我们可以看到有四个文件，然后，你在这里mkdir一个子目录，里面也会有这四个文件。<strong>上级的cgroup.subtree_control控制下级的cgroup.controllers。</strong></p>
<p>举个例子：假设我们有以下的目录结构，b代表blkio，m代码memory，其中，A是root，包括所有的子系统（）。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># A(b,m) - B(b,m) - C (b)</span><br><span class="line">#               \ - D (b) - E</span><br><span class="line"></span><br><span class="line"># 下面的命令中， +表示enable， -表示disable</span><br><span class="line"></span><br><span class="line"># 在B上的enable blkio</span><br><span class="line"># echo +blkio &gt; A/cgroup.subtree_control</span><br><span class="line"></span><br><span class="line"># 在C和D上enable blkio </span><br><span class="line"># echo +blkio &gt; A/B/cgroup.subtree_control</span><br><span class="line"></span><br><span class="line"># 在B上enable memory  </span><br><span class="line"># echo +memory &gt; A/cgroup.subtree_control</span><br></pre></td></tr></table></figure> 在上述的结构中，</p>
<ul>
<li>cgroup只有上线控制下级，无法传递到下下级。所以，C和D中没有memory的限制，E中没有blkio和memory的限制。而本层的cgroup.controllers文件是个只读的，其中的内容就看上级的subtree_control里有什么了。<br />
</li>
<li><strong>任何被配置过subtree_control的目录都不能绑定进程，根结点除外</strong>。所以，A,C,D,E可以绑上进程，但是B不行。</li>
</ul>
<p>我们可以看到，<strong>这种方式干净的区分开了两个事，一个是进程的分组，一个是对分组的资源控制</strong>（以前这两个事完全混在一起），在目录继承上增加了些限制，这样可以避免一些模棱两可的情况。</p>
<p>当然，这个事还在演化中，cgroup的这些问题这个事目前由cgroup的吐槽人Tejun
Heo和华为的Li
Zefan同学负责解决中。总之，这是一个系统管理上的问题，而且改变会影响很多东西，但一旦方案确定，老的cgroup方式将一去不复返。</p>
<h4 id="参考">参考</h4>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/">Linux
Kernel Cgroup Documents</a><br />
</li>
<li><a
href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html">Reahat
Resource Management Guide</a><br />
</li>
<li><a href="https://lwn.net/Articles/484251/">Fixing control
groups</a><br />
</li>
<li><a href="http://lwn.net/Articles/601840/">The unified control group
hierarchy in 3.16</a><br />
</li>
<li><a
href="http://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf">Cgroup
v2(PDF)</a></li>
</ul>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础-DEVICEMAPPER</title>
    <url>/blog/2023/10/11/data/deployment/docker/Docker%E5%9F%BA%E7%A1%80-DEVICEMAPPER/</url>
    <content><![CDATA[<p>在上一篇<a
href="https://coolshell.cn/articles/17061.html">介绍AUFS的文章</a>中，大家可以看到，Docker的分层镜像是怎么通过UnionFS这种文件系统做到的，但是，因为Docker首选的AUFS并不在Linux的内核主干里，所以，对于非Ubuntu的Linux分发包，比如CentOS，就无法使用AUFS作为Docker的文件系统了。于是作为第二优先级的DeviceMapper就被拿出来做分层镜像的一个实现。</p>
<p>目录</p>
<ul>
<li><a
href="https://coolshell.cn/articles/17200.html#Device_Mapper_%E7%AE%80%E4%BB%8B"
title="Device Mapper 简介">Device Mapper 简介</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17200.html#Thin_Provisioning_%E7%AE%80%E4%BB%8B"
title="Thin Provisioning 简介">Thin Provisioning 简介</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17200.html#Thin_Provisioning_Snapshot_%E6%BC%94%E7%A4%BA"
title="Thin Provisioning Snapshot 演示">Thin Provisioning Snapshot
演示</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17200.html#Docker%E7%9A%84DeviceMapper"
title="Docker的DeviceMapper">Docker的DeviceMapper</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17200.html#Device_Mapper_%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F"
title="Device Mapper 行不行？">Device Mapper 行不行？</a></li>
</ul>
<h4 id="device-mapper-简介">Device Mapper 简介</h4>
<p>DeviceMapper自Linux
2.6被引入成为了Linux最重要的一个技术。它在内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包含三个重要的对象概念，Mapped
Device、Mapping Table、Target device。</p>
<p>Mapped Device
是一个逻辑抽象，可以理解成为内核向外提供的逻辑设备，它通过Mapping
Table描述的映射关系和 Target Device 建立映射。Target device 表示的是
Mapped Device 所映射的物理空间段，对 Mapped Device
所表示的逻辑设备来说，就是该逻辑设备映射到的一个物理设备。</p>
<p>Mapping Table里有 Mapped Device 逻辑的起始地址、范围、和表示在 Target
Device 所在物理设备的地址偏移量以及Target
类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512
个字节大小，所以，当你看到128的时候，其实表示的是128*512=64K）。</p>
<p>DeviceMapper 中的逻辑设备Mapped
Device不但可以映射一个或多个物理设备Target
Device，还可以映射另一个Mapped
Device，于是，就是构成了一个迭代或递归的情况，就像文件系统中的目录里除了文件还可以有目录，理论上可以无限嵌套下去。</p>
<p>DeviceMapper在内核中通过一个一个模块化的 Target Driver 插件实现对 IO
请求的过滤或者重新定向等工作，当前已经实现的插件包括软
Raid、加密、多路径、镜像、快照等，这体现了在 Linux
内核设计中策略和机制分离的原则。如下图所示。从图中，我们可以<strong>看到DeviceMapper只是一个框架，在这个框架上，我们可以插入各种各样的策略</strong>（让我不自然地想到了面向对象中的策略模式），在这诸多“插件”中，<strong>有一个东西叫Thin
Provisioning
Snapshot，这是Docker使用DeviceMapper中最重要的模块</strong>。</p>
<figure>
<img
src="https://coolshell.cn/wp-content/uploads/2015/08/device.mapper.2.gif"
alt="图片来源：http://people.redhat.com/agk/talks/FOSDEM_2005/" />
<figcaption
aria-hidden="true">图片来源：http://people.redhat.com/agk/talks/FOSDEM_2005/</figcaption>
</figure>
<p>图片来源：<a
href="http://people.redhat.com/agk/talks/FOSDEM_2005/">http://people.redhat.com/agk/talks/FOSDEM_2005/</a></p>
<h4 id="thin-provisioning-简介"><strong>Thin Provisioning
简介</strong></h4>
<p>Thin
Provisioning要怎么翻译成中文，真是一件令人头痛的事，我就不翻译了。这个技术是虚拟化技术中的一种。它是什么意思呢？<strong>你可以联想一下我们计算机中的内存管理中用到的——“虚拟内存技术”</strong>——操作系统给每个进程N多N多用不完的内址地址（32位下，每个进程可以有最多2GB的内存空间），但是呢，我们知道，物理内存是没有那么多的，如果按照进程内存和物理内存一一映射来玩的话，那么，我们得要多少的物理内存啊。所以，操作系统引入了虚拟内存的设计，<strong>意思是，我逻辑上给你无限多的内存，但是实际上是实报实销</strong>，因为我知道你一定用不了那么多，于是，达到了内存使用率提高的效果。（今天云计算中很多所谓的虚拟化其实完全都是在用和“虚拟内存”相似的Thin
Provisioning的技术，所谓的超配，或是超卖）</p>
<p>好了，话题拉回来，我们这里说的是存储。看下面两个图（<a
href="http://www.architecting.it/2009/06/04/enterprise-computing-why-thin-provisioning-is-not-the-holy-grail-for-utilisation/">图片来源</a>），第一个是Fat
Provisioning，第二个是Thin
Provisioning，其很好的说明了是个怎么一回事（和虚拟内存是一个概念）</p>
<p><img
src="https://coolshell.cn/wp-content/uploads/2015/08/thin-provisioning-1.jpg"
alt="thin-provisioning-1" /><img
src="https://coolshell.cn/wp-content/uploads/2015/08/thin-provisioning-2.jpg"
alt="thin-provisioning-2" /></p>
<p>那么，Docker是怎么使用Thin
Provisioning这个技术做到像UnionFS那样的分层镜像的呢？答案是，Docker使用了Thin
Provisioning的Snapshot的技术。下面我们来介绍一下Thin
Provisioning的Snapshot。</p>
<h4 id="thin-provisioning-snapshot-演示">Thin Provisioning Snapshot
演示</h4>
<p>下面，我们用一系列的命令来演示一下Device Mapper的Thin Provisioning
Snapshot是怎么玩的。</p>
<p>首先，我们需要先建两个文件，一个是data.img，一个是meta.data.img：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dd if=/dev/zero of=/tmp/data.img bs=1K count=1 seek=10M</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">1024 bytes (1.0 kB) copied, 0.000621428 s, 1.6 MB/s</span><br><span class="line"></span><br><span class="line">~hchen$ sudo dd if=/dev/zero of=/tmp/meta.data.img bs=1K count=1 seek=1G</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">1024 bytes (1.0 kB) copied, 0.000140858 s, 7.3 MB/s</span><br></pre></td></tr></table></figure>
注意命令中<code>seek</code>选项，其表示为略过<code>of</code>选项指定的输出文件的前10G个output的bloksize的空间后再写入内容。因为bs是1个字节，所以也就是10G的尺寸，但其实在硬盘上是没有占有空间的，占有空间只有1k的内容。当向其写入内容时，才会在硬盘上为其分配空间。我们可以用ls命令看一下，实际分配了12K和4K。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo ls -lsh /tmp/data.img</span><br><span class="line">12K -rw-r--r--. 1 root root 11G Aug 25 23:01 /tmp/data.img</span><br><span class="line"></span><br><span class="line">~hchen$ sudo ls -slh /tmp/meta.data.img</span><br><span class="line">4.0K -rw-r--r--. 1 root root 101M Aug 25 23:17 /tmp/meta.data.img</span><br></pre></td></tr></table></figure>
然后，我们为这个文件创建一个loopback设备。（loop2015和loop2016是我乱取的两个名字）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo losetup /dev/loop2015 /tmp/data.img</span><br><span class="line">~hchen$ sudo losetup /dev/loop2016 /tmp/meta.data.img</span><br><span class="line"></span><br><span class="line">~hchen$ sudo losetup -a</span><br><span class="line">/dev/loop2015: [64768]:103991768 (/tmp/data.img)</span><br><span class="line">/dev/loop2016: [64768]:103991765 (/tmp/meta.data.img)</span><br></pre></td></tr></table></figure> 现在，我们为这个设备建一个Thin
Provisioning的Pool，用dmsetup命令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup create hchen-thin-pool \</span><br><span class="line">                  --table &quot;0 20971522 thin-pool /dev/loop2016 /dev/loop2015 \</span><br><span class="line">                           128 65536 1 skip_block_zeroing&quot;</span><br></pre></td></tr></table></figure> 其中的参数解释如下（更多信息可参看<a
href="https://github.com/torvalds/linux/blob/master/Documentation/device-mapper/thin-provisioning.txt">Thin
Provisioning的man page</a>）：</p>
<ul>
<li>dmsetup create是用来创建thin pool的命令<br />
</li>
<li>hchen-thin-pool 是自定义的一个pool名，不冲突就好。<br />
</li>
<li>–table是这个pool的参数设置
<ul>
<li>0代表起的sector位置<br />
</li>
<li>20971522代码结句的sector号，前面说过，一个sector是512字节，所以，20971522个正好是10GB<br />
</li>
<li>/dev/loop2016是meta文件的设备（前面我们建好了）<br />
</li>
<li>/dev/loop2015是data文件的设备（前面我们建好了）<br />
</li>
<li>128是最小的可分配的sector数<br />
</li>
<li>65536是最少可用sector的water mark，也就是一个threshold<br />
</li>
<li>1 代表有一个附加参数<br />
</li>
<li>skip_block_zeroing是个附加参数，表示略过用0填充的块</li>
</ul></li>
</ul>
<p>然后，我们就可以看到一个Device Mapper的设备了：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo ll /dev/mapper/hchen-thin-pool</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 23:24 /dev/mapper/hchen-thin-pool -&gt; ../dm-4</span><br></pre></td></tr></table></figure> 接下来，我们的初始还没有完成，还要创建一个Thin
Provisioning 的 Volume：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_thin 0&quot;</span><br><span class="line">~hchen$ sudo dmsetup create hchen-thin-volumn-001 \</span><br><span class="line">            --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 0&quot;</span><br></pre></td></tr></table></figure> 其中：</p>
<ul>
<li>第一个命令中的create_thin是关键字，后面的0表示这个Volume的device 的
id<br />
</li>
<li>第二个命令，是真正的为这个Volumn创建一个可以mount的设备，名字叫hchen-thin-volumn-001。2097152只有1GB</li>
</ul>
<p>好了，在mount前，我们还要格式化一下：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo mkfs.ext4 /dev/mapper/hchen-thin-volumn-001</span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Discarding device blocks: done</span><br><span class="line">Filesystem label=</span><br><span class="line">OS type: Linux</span><br><span class="line">Block size=4096 (log=2)</span><br><span class="line">Fragment size=4096 (log=2)</span><br><span class="line">Stride=16 blocks, Stripe width=16 blocks</span><br><span class="line">65536 inodes, 262144 blocks</span><br><span class="line">13107 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=268435456</span><br><span class="line">8 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">32768, 98304, 163840, 229376</span><br><span class="line"></span><br><span class="line">Allocating group tables: done</span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (8192 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br></pre></td></tr></table></figure>
好了，我们可以mount了（下面的命令中，我还创建了一个文件）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo mkdir -p /mnt/base</span><br><span class="line">~hchen$ sudo mount /dev/mapper/hchen-thin-volumn-001 /mnt/base</span><br><span class="line">~hchen$ sudo echo &quot;hello world, I am a base&quot; &gt; /mnt/base/id.txt</span><br><span class="line">~hchen$ sudo cat /mnt/base/id.txt</span><br><span class="line">hello world, I am a base</span><br></pre></td></tr></table></figure> 好了，接下来，我们来看看snapshot怎么搞：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 1 0&quot;</span><br><span class="line">~hchen$ sudo dmsetup create mysnap1 \</span><br><span class="line">                   --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 1&quot;</span><br><span class="line"></span><br><span class="line">~hchen$ sudo ll /dev/mapper/mysnap1</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 23:49 /dev/mapper/mysnap1 -&gt; ../dm-5</span><br></pre></td></tr></table></figure> 上面的命令中：</p>
<ul>
<li><p>第一条命令是向hchen-thin-pool发一个create_snap的消息，后面跟两个id，第一个是新的dev
id，第二个是要从哪个已有的dev id上做snapshot（0这个dev
id是我们前面就创建了了）</p></li>
<li><p>第二条命令是创建一个mysnap1的device，并可以被mount。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo mkdir -p /mnt/mysnap1</span><br><span class="line">~hchen$ sudo mount /dev/mapper/mysnap1 /mnt/mysnap1</span><br><span class="line"></span><br><span class="line">~hchen$ sudo ll /mnt/mysnap1/</span><br><span class="line">total 20</span><br><span class="line">-rw-r--r--. 1 root root 25 Aug 25 23:46 id.txt</span><br><span class="line">drwx------. 2 root root 16384 Aug 25 23:43 lost+found</span><br><span class="line"></span><br><span class="line">~hchen$ sudo cat /mnt/mysnap1/id.txt</span><br><span class="line">hello world, I am a base</span><br></pre></td></tr></table></figure>
我们来修改一下/mnt/mysnap1/id.txt，并加上一个snap1.txt的文件：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo echo &quot;I am snap1&quot; &gt;&gt; /mnt/mysnap1/id.txt</span><br><span class="line">~hchen$ sudo echo &quot;I am snap1&quot; &gt; /mnt/mysnap1/snap1.txt</span><br><span class="line"></span><br><span class="line">~hchen$ sudo cat /mnt/mysnap1/id.txt</span><br><span class="line">hello world, I am a base</span><br><span class="line">I am snap1</span><br><span class="line"></span><br><span class="line">~hchen$ sudo cat /mnt/mysnap1/snap1.txt</span><br><span class="line">I am snap1</span><br></pre></td></tr></table></figure> 我们再看一下/mnt/base，你会发现没有什么变化：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo ls /mnt/base</span><br><span class="line">id.txt      lost+found</span><br><span class="line">~hchen$ sudo cat /mnt/base/id.txt</span><br><span class="line">hello world, I am a base</span><br></pre></td></tr></table></figure> 你是不是已经看到了分层镜像的样子了？</p></li>
</ul>
<p>你还要吧继续在刚才的snapshot上再建一个snapshot<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 2 1&quot;</span><br><span class="line">~hchen$ sudo dmsetup create mysnap2 \</span><br><span class="line">                   --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 2&quot;</span><br><span class="line"></span><br><span class="line">~hchen$ sudo ll /dev/mapper/mysnap2</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 23:52 /dev/mapper/mysnap1 -&gt; ../dm-7</span><br><span class="line"></span><br><span class="line">~hchen$ sudo mkdir -p /mnt/mysnap2</span><br><span class="line">~hchen$ sudo mount /dev/mapper/mysnap2 /mnt/mysnap2</span><br><span class="line">~hchen$ sudo  ls /mnt/mysnap2</span><br><span class="line">id.txt  lost+found  snap1.txt</span><br></pre></td></tr></table></figure> 好了，我相信你看到了分层镜像的样子了。</p>
<p>看完演示，我们再来补点理论知识吧：</p>
<ul>
<li>Snapshot来自LVM（Logic Volumn
Manager），它可以在不中断服务的情况下为某个device打一个快照。<br />
</li>
<li>Snapshot是Copy-On-Write的，也就是说，只有发生了修改，才会对对应的内存进行拷贝。</li>
</ul>
<p>另外，这里有篇文章<a
href="http://searchstorage.techtarget.com/tip/Storage-thin-provisioning-benefits-and-challenges">Storage
thin provisioning benefits and challenges</a>可以前往一读。</p>
<h4 id="docker的devicemapper">Docker的DeviceMapper</h4>
<p>上面基本上就是Docker的玩法了，我们可以看一下docker的loopback设备：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen $ sudo losetup -a</span><br><span class="line">/dev/loop0: [64768]:38050288 (/var/lib/docker/devicemapper/devicemapper/data)</span><br><span class="line">/dev/loop1: [64768]:38050289 (/var/lib/docker/devicemapper/devicemapper/metadata)</span><br></pre></td></tr></table></figure> 其中data 100GB，metadata 2.0GB<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen $ sudo ls -alhs /var/lib/docker/devicemapper/devicemapper</span><br><span class="line">506M -rw-------. 1 root root 100G Sep 10 20:15 data</span><br><span class="line">1.1M -rw-------. 1 root root 2.0G Sep 10 20:15 metadata</span><br></pre></td></tr></table></figure>
下面是相关的thin-pool。其中，有个当一大串hash串的device是正在启动的容器：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen $ sudo ll /dev/mapper/dock*</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 07:57 /dev/mapper/docker-253:0-104108535-pool -&gt; ../dm-2</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 11:13 /dev/mapper/docker-253:0-104108535-deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf -&gt; ../dm-3</span><br></pre></td></tr></table></figure> 我们可以看一下它的device
id（Docker都把它们记下来了）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen $ sudo cat /var/lib/docker/devicemapper/metadata/deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf</span><br><span class="line">&#123;&quot;device_id&quot;:24,&quot;size&quot;:10737418240,&quot;transaction_id&quot;:26,&quot;initialized&quot;:false&#125;</span><br></pre></td></tr></table></figure> device_id是24，size是10737418240，除以512，就是20971520
个 sector，我们用这些信息来做个snapshot看看（注：我用了一个比较大的dev
id – 1024）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup message &quot;/dev/mapper/docker-253:0-104108535-pool&quot; 0 \</span><br><span class="line">                                    &quot;create_snap 1024 24&quot;</span><br><span class="line">~hchen$ sudo dmsetup create dockersnap --table \</span><br><span class="line">                    &quot;0 20971520 thin /dev/mapper/docker-253:0-104108535-pool 1024&quot;</span><br><span class="line">~hchen$ sudo mkdir /mnt/docker</span><br><span class="line">~hchen$ sudo mount /dev/mapper/dockersnap /mnt/docker/</span><br><span class="line">~hchen$ sudo ls /mnt/docker/</span><br><span class="line">id lost+found rootfs</span><br><span class="line">~hchen$ sudo ls /mnt/docker/rootfs/</span><br><span class="line">bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>
我们在docker的容器里用findmnt命令也可以看到相关的mount的情况（因为太长，下面只是摘要）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># findmnt</span><br><span class="line">TARGET                SOURCE               </span><br><span class="line">/                 /dev/mapper/docker-253:0-104108535-deefcd630a60[/rootfs]</span><br><span class="line">/etc/resolv.conf  /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/resolv.conf]</span><br><span class="line">/etc/hostname     /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hostname]</span><br><span class="line">/etc/hosts        /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hosts]</span><br></pre></td></tr></table></figure></p>
<h4 id="device-mapper-行不行">Device Mapper 行不行？</h4>
<p>Thin Provisioning的文档中说，这还处理实验阶段，不要上Production.</p>
<blockquote>
<p>These targets are very much still in the EXPERIMENTAL state. Please
do not yet rely on them in production.</p>
</blockquote>
<p>另外，Jeff Atwood在Twitter上发过这样的一推</p>
<p><a
href="https://twitter.com/codinghorror/status/604096348682485760"><img
src="https://coolshell.cn/wp-content/uploads/2015/08/Jeff.Atwood.DeviceMapper.png"
alt="Jeff.Atwood.DeviceMapper" /></a></p>
<p>这个推指向的<a
href="https://forums.docker.com/t/rmi-not-freeing-disk-space-in-devicemapper-sparse-file-centos-6-6/1640/3">这个讨论</a>中，其中指向了这个<a
href="https://github.com/discourse/discourse_docker/commit/48f22d14f39496c8df446cbc65ee04b258c5a1a0">code
diff</a>，基本上就是说，DeviceMapper这种东西问题太多了，我们应该把其加入黑名单。Doker的Founder也这样回复到：</p>
<p><a
href="https://twitter.com/solomonstre/status/604055267303636992"><img
src="https://coolshell.cn/wp-content/uploads/2015/08/Solomon.Hykeys.DeviceMapper.png" /></a></p>
<p>所以，如果你在使用loopback的devicemapper的话，当你的存储出现了问题后，正确的解决方案是：</p>
<p>rm -rf /var/lib/docker</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础上</title>
    <url>/blog/2023/10/11/data/deployment/docker/Docker%E5%9F%BA%E7%A1%80%E4%B8%8A/</url>
    <content><![CDATA[<p>目录</p>
<ul>
<li> <a
href="https://coolshell.cn/articles/17010.html#_%E7%AE%80%E4%BB%8B"
title="简介">简介</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17010.html#clone%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"
title="clone()系统调用">clone()系统调用</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17010.html#UTS_Namespace"
title="UTS Namespace">UTS Namespace</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17010.html#IPC_Namespace"
title="IPC Namespace">IPC Namespace</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17010.html#PID_Namespace"
title="PID Namespace">PID Namespace</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17010.html#Mount_Namespace"
title="Mount Namespace">Mount Namespace</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17010.html#Docker%E7%9A%84_Mount_Namespace"
title="Docker的 Mount Namespace">Docker的 Mount Namespace</a></li>
</ul>
<h4 id="简介"> 简介</h4>
<p>Linux
Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux
Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。</p>
<p>举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程
看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID
namespace中的进程无法看到彼此）</p>
<p><strong>Linux Namespace 有如下种类</strong>，官方文档在这里《<a
href="http://lwn.net/Articles/531114/">Namespace in Operation</a>》</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>分类</th>
<th>系统调用参数</th>
<th>相关内核版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Mount namespaces</strong></td>
<td>CLONE_NEWNS</td>
<td><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux
2.4.19</a></td>
</tr>
<tr class="even">
<td><strong>UTS namespaces</strong></td>
<td>CLONE_NEWUTS</td>
<td><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td>
</tr>
<tr class="odd">
<td><strong>IPC namespaces</strong></td>
<td>CLONE_NEWIPC</td>
<td><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td>
</tr>
<tr class="even">
<td><strong>PID namespaces</strong></td>
<td>CLONE_NEWPID</td>
<td><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td>
</tr>
<tr class="odd">
<td><strong>Network namespaces</strong></td>
<td>CLONE_NEWNET</td>
<td><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于
Linux 2.6.29</a></td>
</tr>
<tr class="even">
<td><strong>User namespaces</strong></td>
<td>CLONE_NEWUSER</td>
<td><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于
Linux 3.8)</a></td>
</tr>
</tbody>
</table>
<p>主要是三个系统调用</p>
<ul>
<li><strong><code>clone</code>()</strong> –
实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。<br />
</li>
<li><strong><code>unshare</code>()</strong> –
使某进程脱离某个namespace<br />
</li>
<li><strong><code>setns</code>()</strong> –
把某进程加入到某个namespace</li>
</ul>
<p>unshare() 和 setns() 都比较简单，大家可以自己man，我这里不说了。</p>
<p>下面还是让我们来看一些示例（以下的测试程序最好在Linux
内核为3.8以上的版本中运行，我用的是ubuntu 14.04）。</p>
<h4 id="clone系统调用">clone()系统调用</h4>
<p>首先，我们来看一下一个最简单的clone()系统调用的示例，（后面，我们的程序都会基于这个程序做修改）：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个给 clone 用的栈，栈大小1M */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span></span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。</p>
<p>下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。</p>
<h4 id="uts-namespace">UTS Namespace</h4>
<p>下面的代码，我略去了上面那些头文件和数据结构的定义，只有最重要的部分。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>); <span class="comment">/*启用CLONE_NEWUTS Namespace隔离 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container。</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./uts</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">root@container:~# hostname</span><br><span class="line">container</span><br><span class="line">root@container:~# uname -n</span><br><span class="line">container</span><br></pre></td></tr></table></figure></p>
<h4 id="ipc-namespace">IPC Namespace</h4>
<p>IPC全称 Inter-Process
Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。</p>
<p>要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure> 首先，我们先创建一个IPC的Queue（如下所示，全局的Queue
ID是0）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ ipcmk -Q </span><br><span class="line">Message queue id: 0</span><br><span class="line"></span><br><span class="line">hchen@ubuntu:~$ ipcs -q</span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line">0xd0d56eb2 0          hchen      644        0            0</span><br></pre></td></tr></table></figure>
如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC
Queue。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./uts </span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line"></span><br><span class="line">root@container:~# ipcs -q</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line">0xd0d56eb2 0          hchen      644        0            0</span><br></pre></td></tr></table></figure>
但是，如果我们运行加上了CLONE_NEWIPC的程序，我们就会下面的结果：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~$ sudo./ipc</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line"></span><br><span class="line">root@container:~/linux_namespace# ipcs -q</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br></pre></td></tr></table></figure> 我们可以看到IPC已经被隔离了。</p>
<h4 id="pid-namespace">PID Namespace</h4>
<p>我们继续修改上面的程序：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="comment">/*启用PID namespace - CLONE_NEWPID*/</span></span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, <span class="literal">NULL</span>); </span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行结果如下（我们可以看到，子进程的pid是1了）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./pid</span><br><span class="line">Parent [ 3474] - start a container!</span><br><span class="line">Container [ 1] - inside the container!</span><br><span class="line">root@container:~# echo $$</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>你可能会问，PID为1有个毛用啊？我们知道，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。</p>
<p><strong>但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程</strong>。说明并没有完全隔离。这是因为，像ps,
top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。</p>
<p>所以，我们还需要对文件系统进行隔离。</p>
<h4 id="mount-namespace">Mount Namespace</h4>
<p>下面的例程中，我们在启用了mount
namespace并在子进程中重新mount了/proc文件系统。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* 重新mount proc文件系统到 /proc下 */</span></span><br><span class="line">    system(<span class="string">&quot;mount -t proc proc /proc&quot;</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="comment">/* 启用Mount Namespace - 增加CLONE_NEWNS参数 */</span></span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行结果如下：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./pid.mnt</span><br><span class="line">Parent [ 3502] - start a container!</span><br><span class="line">Container [    1] - inside the container!</span><br><span class="line">root@container:~# ps -elf </span><br><span class="line">F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD</span><br><span class="line">4 S root         1     0  0  80   0 -  6917 wait   19:55 pts/2    00:00:00 /bin/bash</span><br><span class="line">0 R root        14     1  0  80   0 -  5671 -      19:56 pts/2    00:00:00 ps -elf</span><br></pre></td></tr></table></figure> 上面，我们可以看到只有两个进程
，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@container:~# ls /proc</span><br><span class="line">1          dma          key-users   net            sysvipc</span><br><span class="line">16         driver       kmsg        pagetypeinfo   timer_list</span><br><span class="line">acpi       execdomains  kpagecount  partitions     timer_stats</span><br><span class="line">asound     fb           kpageflags  sched_debug    tty</span><br><span class="line">buddyinfo  filesystems  loadavg     schedstat      uptime</span><br><span class="line">bus        fs           locks       scsi           version</span><br><span class="line">cgroups    interrupts   mdstat      self           version_signature</span><br><span class="line">cmdline    iomem        meminfo     slabinfo       vmallocinfo</span><br><span class="line">consoles   ioports      misc        softirqs       vmstat</span><br><span class="line">cpuinfo    irq          modules     stat           zoneinfo</span><br><span class="line">crypto     kallsyms     mounts      swaps</span><br><span class="line">devices    kcore        mpt         sys</span><br><span class="line">diskstats  keys         mtrr        sysrq-trigger</span><br></pre></td></tr></table></figure>
下图，我们也可以看到在子进程中的top命令只看得到两个进程了。<br />
<img
src="https://coolshell.cn/wp-content/uploads/2015/04/mount.namespace.jpg"
alt="子进程top结果" /></p>
<p>这里，多说一下。在通过CLONE_NEWNS创建mount
namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。</p>
<p>你可能会问，我们是不是还有别的一些文件系统也需要这样mount? 是的。</p>
<h4 id="docker的-mount-namespace">Docker的 Mount Namespace</h4>
<p>下面我将向演示一个“山寨镜像”，其模仿了Docker的Mount Namespace。</p>
<p>首先，我们需要一个rootfs，也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs$ ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var</span><br></pre></td></tr></table></figure> 然后，我们把一些我们需要的命令copy到
rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin</span><br><span class="line"> </span><br><span class="line">./bin:</span><br><span class="line">bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty</span><br><span class="line">cat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount</span><br><span class="line">chgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname</span><br><span class="line">chmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which</span><br><span class="line"></span><br><span class="line">./usr/bin:</span><br><span class="line">awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs</span><br></pre></td></tr></table></figure>
注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs/bin$ ldd bash</span><br><span class="line">  linux-vdso.so.1 =&gt;  (0x00007fffd33fc000)</span><br><span class="line">  libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000)</span><br><span class="line">  libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000)</span><br><span class="line">  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000)</span><br><span class="line">  /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000)</span><br></pre></td></tr></table></figure> 下面是我的rootfs中的一些so文件：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/</span><br><span class="line"></span><br><span class="line">./lib64:</span><br><span class="line">ld-linux-x86-64.so.2</span><br><span class="line"></span><br><span class="line">./lib/x86_64-linux-gnu/:</span><br><span class="line">libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1</span><br><span class="line">libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0</span><br><span class="line">libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so</span><br><span class="line">libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2</span><br><span class="line">libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1</span><br><span class="line">libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5</span><br><span class="line">libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9</span><br><span class="line">libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so</span><br><span class="line">libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1</span><br><span class="line">libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1</span><br><span class="line">libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1</span><br><span class="line">libdl.so.2       libnss_compat.so.2     libpthread.so.0</span><br><span class="line">libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1</span><br><span class="line">libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0</span><br></pre></td></tr></table></figure> 包括这些命令依赖的一些配置文件：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs$ ls ./etc</span><br><span class="line">bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  </span><br><span class="line">resolv.conf  shadow</span><br></pre></td></tr></table></figure>
你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard
code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ ls ./conf</span><br><span class="line">hostname     hosts     resolv.conf</span><br></pre></td></tr></table></figure>
这样，我们的父进程就可以动态地设置容器需要的这些文件的配置，
然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。</p>
<p>好了，终于到了我们的程序。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys types.h=&quot;&quot;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys wait.h=&quot;&quot;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys mount.h=&quot;&quot;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-l&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set hostname</span></span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information</span></span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;rootfs/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>) !=<span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;proc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;rootfs/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sys&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;none&quot;</span>, <span class="string">&quot;rootfs/tmp&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;tmp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;udev&quot;</span>, <span class="string">&quot;rootfs/dev&quot;</span>, <span class="string">&quot;devtmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dev&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;rootfs/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dev/pts&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;shm&quot;</span>, <span class="string">&quot;rootfs/dev/shm&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dev/shm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;rootfs/run&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 模仿Docker的从外向容器里mount相关的配置文件 </span></span><br><span class="line"><span class="comment">     * 你可以查看：/var/lib/docker/containers/&lt;container_id&gt;/目录，</span></span><br><span class="line"><span class="comment">     * 你会看到docker的这些文件的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;conf/hosts&quot;</span>, <span class="string">&quot;rootfs/etc/hosts&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span> ||</span><br><span class="line">          mount(<span class="string">&quot;conf/hostname&quot;</span>, <span class="string">&quot;rootfs/etc/hostname&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span> ||</span><br><span class="line">          mount(<span class="string">&quot;conf/resolv.conf&quot;</span>, <span class="string">&quot;rootfs/etc/resolv.conf&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;conf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */</span></span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;/tmp/t1&quot;</span>, <span class="string">&quot;rootfs/mnt&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mnt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* chroot 隔离目录 */</span></span><br><span class="line">    <span class="keyword">if</span> ( chdir(<span class="string">&quot;./rootfs&quot;</span>) != <span class="number">0</span> || chroot(<span class="string">&quot;./&quot;</span>) != <span class="number">0</span> )&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir/chroot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    perror(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/container_id&gt;&lt;/unistd.h&gt;&lt;/signal.h&gt;&lt;/sched.h&gt;&lt;/stdio.h&gt;&lt;/sys&gt;&lt;/sys&gt;&lt;/sys&gt;</span><br></pre></td></tr></table></figure>
sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./mount </span><br><span class="line">Parent [ 4517] - start a container!</span><br><span class="line">Container [    1] - inside the container!</span><br><span class="line">root@container:/# mount</span><br><span class="line">proc on /proc type proc (rw,relatime)</span><br><span class="line">sysfs on /sys type sysfs (rw,relatime)</span><br><span class="line">none on /tmp type tmpfs (rw,relatime)</span><br><span class="line">udev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755)</span><br><span class="line">devpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000)</span><br><span class="line">tmpfs on /run type tmpfs (rw,relatime)</span><br><span class="line">/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line">/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line">/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line"></span><br><span class="line">root@container:/# ls /bin /usr/bin</span><br><span class="line">/bin:</span><br><span class="line">bash   chmod  echo  hostname  less  more  mv   ping  rm   sleep  tail  test    top   truncate  uname</span><br><span class="line">cat    chown  grep  ip        ln    mount  nc   ps    sed  tabs   tar   timeout  touch  tty     which</span><br><span class="line">chgrp  cp     gzip  kill      ls    mountpoint  netstat  pwd   sh   tac    tee   toe    tr   umount</span><br><span class="line"></span><br><span class="line">/usr/bin:</span><br><span class="line">awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs</span><br></pre></td></tr></table></figure></p>
<p>关于如何做一个chroot的目录，这里有个工具叫<a
href="https://wiki.ubuntu.com/DebootstrapChroot">DebootstrapChroot</a>，你可以顺着链接去看看（英文的哦）</p>
<p>接下来的事情，你可以自己玩了，我相信你的想像力 。：）</p>
<p>在下一篇，我将向你介绍User Namespace、Network
Namespace以及Namespace的其它东西。</p>
<p><strong><a href="https://coolshell.cn/articles/17029.html"
title="Docker基础技术：Linux Namespace（下）">&lt;&lt;&lt;&lt;
Docker基础技术：Linux Namespace（下）&gt;&gt;&gt;&gt;</a></strong></p>
<p>（上篇完，<a href="https://coolshell.cn/articles/17029.html"
title="Docker基础技术：Linux Namespace（下）">请参看下篇</a>）</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础下</title>
    <url>/blog/2023/10/11/data/deployment/docker/Docker%E5%9F%BA%E7%A1%80%E4%B8%8B/</url>
    <content><![CDATA[<p>在 <strong><a href="https://coolshell.cn/articles/17010.html"
title="Docker基础技术：Linux Namespace（上）">Docker基础技术：Linux
Namespace（上篇）</a></strong>中我们了解了，UTD、IPC、PID、Mount
四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。</p>
<p>好，下面我们就介绍一下还剩下的这两个Namespace。</p>
<p>目录</p>
<ul>
<li><a href="https://coolshell.cn/articles/17029.html#User_Namespace"
title="User Namespace">User Namespace</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17029.html#Network_Namespace"
title="Network Namespace">Network Namespace</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17029.html#Namespace%E6%96%87%E4%BB%B6"
title="Namespace文件">Namespace文件</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17029.html#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"
title="参考文档">参考文档</a></li>
</ul>
<h4 id="user-namespace">User Namespace</h4>
<p>User
Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。</p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改 <strong>/proc/&lt;pid&gt;/uid_map</strong> 和 <strong>/proc/&lt;pid&gt;/gid_map</strong> 这两个文件。这两个文件的格式为：</p>
<p><strong>ID-inside-ns ID-outside-ns length</strong></p>
<p>其中：</p>
<ul>
<li>第一个字段ID-inside-ns表示在容器显示的UID或GID，<br />
</li>
<li>第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。<br />
</li>
<li>第三个字段表示映射的范围，一般填1，表示一一对应。</li>
</ul>
<p>比如，把真实的uid=1000映射成容器内的uid=0<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/2465/uid_map</span><br><span class="line">         0       1000          1</span><br></pre></td></tr></table></figure>
再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/$$/uid_map</span><br><span class="line">         0          0          4294967295</span><br></pre></td></tr></table></figure> 另外，需要注意的是：</p>
<ul>
<li>写这两个文件的进程需要这个namespace中的CAP_SETUID
(CAP_SETGID)权限（可参看<a
href="http://man7.org/linux/man-pages/man7/capabilities.7.html">Capabilities</a>）<br />
</li>
<li>写入的进程必须是此user namespace的父或子的user namespace进程。<br />
</li>
<li>另外需要满如下条件之一：1）父进程将effective
uid/gid映射到子进程的user
namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。</li>
</ul>
<p>这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂）：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/capability.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_map</span><span class="params">(<span class="type">char</span>* file, <span class="type">int</span> inside_id, <span class="type">int</span> outside_id, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    FILE* mapfd = fopen(file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == mapfd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(mapfd, <span class="string">&quot;%d %d %d&quot;</span>, inside_id, outside_id, len);</span><br><span class="line">    fclose(mapfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_uid_map</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> inside_id, <span class="type">int</span> outside_id, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> file[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;/proc/%d/uid_map&quot;</span>, pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_gid_map</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> inside_id, <span class="type">int</span> outside_id, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> file[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;/proc/%d/gid_map&quot;</span>, pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">            (<span class="type">long</span>) geteuid(), (<span class="type">long</span>) getegid(), (<span class="type">long</span>) getuid(), (<span class="type">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待父进程通知后再往下执行（进程间的同步） */</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    read(pipefd[<span class="number">0</span>], &amp;ch, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - setup hostname!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="comment">//set hostname</span></span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information</span></span><br><span class="line">    mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> gid=getgid(), uid=getuid();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">            (<span class="type">long</span>) geteuid(), (<span class="type">long</span>) getegid(), (<span class="type">long</span>) getuid(), (<span class="type">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">    pipe(pipefd);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - Container [%5d]!\n&quot;</span>, getpid(), container_pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//To map the uid/gid, </span></span><br><span class="line">    <span class="comment">//   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span></span><br><span class="line">    <span class="comment">//The file format is</span></span><br><span class="line">    <span class="comment">//   ID-inside-ns   ID-outside-ns   length</span></span><br><span class="line">    <span class="comment">//if no mapping, </span></span><br><span class="line">    <span class="comment">//   the uid will be taken from /proc/sys/kernel/overflowuid</span></span><br><span class="line">    <span class="comment">//   the gid will be taken from /proc/sys/kernel/overflowgid</span></span><br><span class="line">    set_uid_map(container_pid, <span class="number">0</span>, uid, <span class="number">1</span>);</span><br><span class="line">    set_gid_map(container_pid, <span class="number">0</span>, gid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - user/group mapping done!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知子进程 */</span></span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user
namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。</p>
<p>整个程序的运行效果如下：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ id</span><br><span class="line">uid=1000(hchen) gid=1000(hchen) groups=1000(hchen)</span><br><span class="line"></span><br><span class="line">hchen@ubuntu:~$ ./user #&lt;--以hchen用户运行</span><br><span class="line">Parent: eUID = 1000;  eGID = 1000, UID=1000, GID=1000 </span><br><span class="line">Parent [ 3262] - start a container!</span><br><span class="line">Parent [ 3262] - Container [ 3263]!</span><br><span class="line">Parent [ 3262] - user/group mapping done!</span><br><span class="line">Container [    1] - inside the container!</span><br><span class="line">Container: eUID = 0;  eGID = 0, UID=0, GID=0 #&lt;---Container里的UID/GID都为0了</span><br><span class="line">Container [    1] - setup hostname!</span><br><span class="line"></span><br><span class="line">root@container:~# id #&lt;----我们可以看到容器里的用户和命令行提示符是root用户了</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),65534(nogroup)</span><br></pre></td></tr></table></figure>
虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，我们容器的安全性会得到提高。</p>
<p>我们注意到，User
Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User
Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。</p>
<h4 id="network-namespace">Network Namespace</h4>
<p>Network的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network
Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw
Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。</p>
<p>首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）</p>
<figure>
<img
src="https://coolshell.cn/wp-content/uploads/2015/04/network.namespace.jpg"
alt="network.namespace" />
<figcaption aria-hidden="true">network.namespace</figcaption>
</figure>
<p>上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。</p>
<p>当你启动一个Docker容器后，你可以使用ip link show或ip addr
show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state ... </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...</span><br><span class="line">    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: veth22a38e6: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure> 那么，要做成这个样子应该怎么办呢？我们来看一组命令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 首先，我们先增加一个网桥lxcbr0，模仿docker0</span><br><span class="line">brctl addbr lxcbr0</span><br><span class="line">brctl stp lxcbr0 off</span><br><span class="line">ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址</span><br><span class="line"></span><br><span class="line">## 接下来，我们要创建一个network namespace - ns1</span><br><span class="line"></span><br><span class="line"># 增加一个namesapce 命令为 ns1 （使用ip netns add命令）</span><br><span class="line">ip netns add ns1 </span><br><span class="line"></span><br><span class="line"># 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）</span><br><span class="line">ip netns exec ns1   ip link set dev lo up </span><br><span class="line"></span><br><span class="line">## 然后，我们需要增加一对虚拟网卡</span><br><span class="line"></span><br><span class="line"># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span><br><span class="line">ip link add veth-ns1 type veth peer name lxcbr0.1</span><br><span class="line"></span><br><span class="line"># 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了</span><br><span class="line">ip link set veth-ns1 netns ns1</span><br><span class="line"></span><br><span class="line"># 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）</span><br><span class="line">ip netns exec ns1  ip link set dev veth-ns1 name eth0 </span><br><span class="line"></span><br><span class="line"># 为容器中的网卡分配一个IP地址，并激活它</span><br><span class="line">ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span><br><span class="line">brctl addif lxcbr0 lxcbr0.1</span><br><span class="line"></span><br><span class="line"># 为容器增加一个路由规则，让容器可以访问外面的网络</span><br><span class="line">ip netns exec ns1     ip route add default via 192.168.10.1</span><br><span class="line"></span><br><span class="line"># 在/etc/netns下创建network namespce名称为ns1的目录，</span><br><span class="line"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span><br><span class="line">mkdir -p /etc/netns/ns1</span><br><span class="line">echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure> 上面基本上就是docker网络的原理了，只不过，</p>
<ul>
<li>Docker的resolv.conf没有用这样的方式，而是用了<a
href="https://coolshell.cn/articles/17010.html"
title="Docker基础技术：Linux Namespace（上）">上篇中的Mount
Namesapce的那种方式</a><br />
</li>
<li>另外，docker是用进程的PID来做Network Namespace的名称的。</li>
</ul>
<p>了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link add peerA type veth peer name peerB </span><br><span class="line">brctl addif docker0 peerA </span><br><span class="line">ip link set peerA up </span><br><span class="line">ip link set peerB netns $&#123;container-pid&#125; </span><br><span class="line">ip netns exec $&#123;container-pid&#125; ip link set dev peerB name eth1 </span><br><span class="line">ip netns exec $&#123;container-pid&#125; ip link set eth1 up ; </span><br><span class="line">ip netns exec $&#123;container-pid&#125; ip addr add $&#123;ROUTEABLE_IP&#125; dev eth1 ;</span><br></pre></td></tr></table></figure>
上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。</p>
<p>这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。</p>
<p>当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。</p>
<p>这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个<a
href="https://lwn.net/Articles/620087/">IPVLAN的驱动</a>，这基本上就是为Docker量身定制的。</p>
<h4 id="namespace文件">Namespace文件</h4>
<p>上面就是目前Linux Namespace的玩法。
现在，我来看一下其它的相关东西。</p>
<p>让我们运行一下上篇中的那个pid.mnt的程序（也就是PID
Namespace中那个mount proc的程序），然后不要退出。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ./pid.mnt </span><br><span class="line">[sudo] password for hchen: </span><br><span class="line">Parent [ 4599] - start a container!</span><br><span class="line">Container [    1] - inside the container!</span><br></pre></td></tr></table></figure> 我们到另一个shell中查看一下父子进程的PID：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ pstree -p 4599</span><br><span class="line">pid.mnt(4599)───bash(4600)</span><br></pre></td></tr></table></figure> 下面是父进程的：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ls -l /proc/4599/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure> 下面是子进程的：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ls -l /proc/4600/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026532520]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026532522]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026532521]</span><br></pre></td></tr></table></figure>
我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。</p>
<p>这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount
–bind /proc/4600/ns/uts ~/uts 来hold这个namespace。</p>
<p>另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setns</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> nstype)</span>;</span><br></pre></td></tr></table></figure>
其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/proc/4600/ns/nts&quot;</span>, O_RDONLY);  <span class="comment">// 获取namespace文件描述符</span></span><br><span class="line">setns(fd, <span class="number">0</span>); <span class="comment">// 加入新的namespace</span></span><br></pre></td></tr></table></figure> #### 参考文档</p>
<ul>
<li><ul>
<li><a href="http://lwn.net/Articles/531114/">Namespaces in
operation</a>
<ul>
<li><a
href="http://man7.org/linux/man-pages/man7/namespaces.7.html">Linux
Namespace Man Page</a><br />
</li>
<li><a
href="http://crosbymichael.com/creating-containers-part-1.html">Creat
Containers – Part 1</a><br />
</li>
<li><a
href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/">Introduction
to Linux namespaces</a></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>golang镜像dockerfile示例</title>
    <url>/blog/2023/10/11/data/deployment/docker/golang%E9%95%9C%E5%83%8Fdockerfile%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FROM golang:<span class="number">1.19</span> as builder</span><br><span class="line">ARG TARGETOS</span><br><span class="line">ARG TARGETARCH</span><br><span class="line"></span><br><span class="line"># entering workspace</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># <span class="built_in">copy</span> the whole project</span><br><span class="line">COPY . .</span><br><span class="line">COPY conf ./common/conf</span><br><span class="line">COPY misc ./common/misc</span><br><span class="line"># cache dependencies so that source changes won<span class="string">&#x27;t break the download layer</span></span><br><span class="line"><span class="string">RUN go env -w GOPROXY=https://goproxy.cn,direct \</span></span><br><span class="line"><span class="string"> &amp;&amp; go env -w GO111MODULE=on \</span></span><br><span class="line"><span class="string"> &amp;&amp; go mod download \</span></span><br><span class="line"><span class="string"> &amp;&amp; CGO_ENABLE=0 GOOS=$&#123;TARGETOS:-linux&#125; GOARCH=$&#123;TARGETARCH&#125; go build -a -o main .</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FROM gcr.io/distroless/base:nonroot</span></span><br><span class="line"><span class="string">WORKDIR /app</span></span><br><span class="line"><span class="string">COPY --from=builder /app/main .</span></span><br><span class="line"><span class="string">COPY --from=builder /app/common .</span></span><br><span class="line"><span class="string">USER 65532:65532</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CMD [&quot;./main&quot;]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Clash作为docker daemon的代理</title>
    <url>/blog/2023/10/11/data/deployment/docker/%E4%BD%BF%E7%94%A8Clash%E4%BD%9C%E4%B8%BAdocker%20daemon%E7%9A%84%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="docker-daemon">docker daemon</h2>
<p>docker向各个仓库拉取镜像的时候默认是不走代理的，并且拉取镜像的操作由docker
daemon来完成，因此如果是公司内部网络或者需要翻墙的外网仓库，往往就需要配置docker
daemon这个systemd
service服务启动时的环境变量了（==注意，环境变量是相对于进程而言的，每个进程有自己的环境变量，我们平时ssh登录的终端进程环境变量，systemd中的服务是不知道的，因为很多systemd管理的服务比连接进来的终端先启动，它们并没有什么特殊的环境变量==），通过在<code>/etc/systemd/system</code>目录下创建<code>docker.service.d</code>目录，并在其中存放docker服务相关的配置文件（.conf），这样docker相关的服务在启动时会读取这些配置文件。</p>
<p>在配置目录中新建任意名称的配置文件.conf，在其中填入如下内容：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/systemd/system/docker.service.d/proxy.conf</span> </span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://127.0.0.1:7890&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7890/&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=localhost,127.0.0.1&quot;</span><br></pre></td></tr></table></figure></p>
<p>启动docker后，在使用docker拉取其他仓库的镜像时，只要仓库网址解析出的IP地址不在<code>NO_PROXY</code>列表中，则分流使用HTTP和HTTPS的代理发送请求。</p>
<p>如果还没有安装docker程序，请参考<a
href="https://docs.docker.com/engine/install/">docker官方网站</a>的教程安装，或者尝试使用以下脚本安装（适用于Debian系列Linux发行版）：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">	curl \</span><br><span class="line">	gnupg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo mkdir -m 0755 -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line">echo \</span><br><span class="line">	&quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \</span><br><span class="line">	&quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \</span><br><span class="line">	  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line">sudo docker run hello-world</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add current use to docker group</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">so that sudo is not  needed  at</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">each time</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $&#123;USER&#125;</span><br><span class="line">sudo newgrp docker</span><br></pre></td></tr></table></figure></p>
<h2 id="clash">Clash</h2>
<p>Clash是一款基于Golang编写的，可以试用规则分流的代理终端，在win下具有图形界面，在Linux下具有良好的终端输出（方便我们直接将输出重定向到日志文件中进行后处理）。</p>
<p>安装Clash可以直接在<a
href="https://github.com/Dreamacro/clash">Clash的GitHub仓库</a>下载Linux
amd64
v3版本的二进制文件，就是单个文件，非常方便使用，不用安装，因此就不会污染系统目录了。</p>
<p>至于clash的订阅文件，只能各显神通了，毕竟这是一个先有鸡还是先有蛋的问题，没有梯子就没办法获取到订阅文件（有时候运气好可以穿墙），可以直接bing或者baidu搜索便宜的一两块钱的机场，或者找其他人的代理服务器先白嫖代理一下，下载完代理文件之后就可以用自己的梯子一直续费了。clash的一个比较优质的机场是<a
href="https://dogess.work/user">dogess</a>。</p>
<p>Clash运行需要两个文件，其一是<a
href="https://github.com/Dreamacro/maxmind-geoip/releases/download/20230812/Country.mmdb">Country.mmdb</a>，用来定义路由网络，分流导向等。还有就是各个代理服务器节点信息的配置文件，这个需要去各个机场购买才有，并且也必须是clash能够解析的yaml格式文件，如果是其他类型的解析协议比如shadowsocks（SS），shadowsocksR（SSR），可以在网上找一些订阅链接转换器转换成clash的yaml订阅节点配置文件。<br />
&gt; <code>Country.mmdb</code> 文件利用 GeoIP2
服务能识别互联网用户的地点位置，以供规则分流时使用。</p>
<p>把clash下载下来之后，使用<code>./clash -d .</code>来运行clash，其中<code>-d</code>参数指的是两个依赖文件的存放目录路径，成功运行，没有接收到代理请求之前，应该会输出如下内容：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat programfiles/clash/clash.log </span><br><span class="line">nohup: ignoring input</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Start initial compatible provider 🍃 Proxies&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Start initial compatible provider ☁️ Others&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Start initial compatible provider 🍂 Domestic&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Start initial compatible provider ⭐️ Auto&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Mixed(http+socks) proxy listening at: [::]:7890&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;DNS server listening at: [::]:5353&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;RESTful API listening at: [::]:9090&quot;</span><br></pre></td></tr></table></figure>
如果从端口监听到了转发请求，一样会输出信息，主要是本地ip:port和目的ip:port：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time=&quot;2023-07-27T10:52:10+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:39466 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:11+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:39482 --&gt; auth.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:44+08:00&quot; level=warning msg=&quot;[TCP] dial ☁️ Others (match Match/) 127.0.0.1:47064 --&gt; registry-1.docker.io:443 error: a1jexzshnphscpcr.wudaki972.me:9011 connect error: dial tcp4 112.47.7.133:9011: i/o timeout&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:47+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47432 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:47+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47448 --&gt; auth.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:48+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47464 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:49+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47480 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:50+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47494 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:50+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47510 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:50+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47518 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:51+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47542 --&gt; production.cloudflare.docker.com:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:51+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47530 --&gt; production.cloudflare.docker.com:443 match Match() using ☁️ Others[香港-03]&quot;</span><br></pre></td></tr></table></figure></p>
<p>为了让clash的启动和关闭更加便捷，我写了两个简单的启动和关闭脚本，如下所示</p>
<p>启动脚本：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy mode <span class="string">&#x27;manual&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http port 7890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http host <span class="string">&#x27;127.0.0.1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https port 7890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https host <span class="string">&#x27;127.0.0.1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.socks port 7891</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.socks host <span class="string">&#x27;127.0.0.1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy ignore-hosts <span class="string">&quot;[&#x27;localhost&#x27;, &#x27;127.0.0.0/8&#x27;, &#x27;::1&#x27;]&quot;</span></span></span><br><span class="line"></span><br><span class="line">clash_home=$(dirname $(command -v clash))</span><br><span class="line"></span><br><span class="line">read -p &quot;specify a configure directory under the clash root: &quot; confdir</span><br><span class="line">if [ ! -n &quot;$&#123;confdir&#125;&quot; ]; then</span><br><span class="line">	echo &quot;no dir specified, use clash root as conf dir&quot;</span><br><span class="line">	confdir=$&#123;clash_home&#125;</span><br><span class="line">else</span><br><span class="line">	if [ ! -d $&#123;confdir&#125; ]; then</span><br><span class="line">		echo &quot;specified confdir not exists, use clash root as conf dir&quot;</span><br><span class="line">		confdir=$&#123;clash_home&#125;</span><br><span class="line">	fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">nohup $&#123;clash_home&#125;/clash -d $&#123;confdir&#125; &gt; $&#123;clash_home&#125;/clash.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$&#123;clash_home&#125;</span>/clash -d <span class="variable">$&#123;confdir&#125;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export HTTP_PROXY=http://127.0.0.1:7890</span><br><span class="line">export HTTPS_PROXY=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure> 关闭脚本：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clash_procid=$(ps -ef | grep clash | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">if [ -n &quot;$&#123;clash_procid&#125;&quot; ]; then</span><br><span class="line">	echo &quot;$&#123;clash_procid&#125;&quot; | xargs kill -SIGKILL</span><br><span class="line">	unset HTTP_PROXY</span><br><span class="line">	unset HTTPS_PROXY</span><br><span class="line">	unset FTP_PROXY</span><br><span class="line">	unset ALL_PROXY</span><br><span class="line">else</span><br><span class="line">	echo &quot;no clash process found...&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>以后在使用docker前就必须打开clash代理才能让docker正常拉取仓库镜像，因为已经配置了docker
daemon的代理环境变量了，如果不需要代理可以把docker.service.d下的代理配置文件删除或者注释内容后重启docker服务。开启clash代理后，docker往clash监听代理请求的端口发送拉取镜像请求，然后clash安排这些请求去能穿墙的节点服务器帮忙获取http
response。</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>前台运行和后台运行区别</title>
    <url>/blog/2023/10/11/data/deployment/docker/%E5%89%8D%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%92%8C%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="docker-容器后台运行和前台运行的区别">Docker
容器后台运行和前台运行的区别</h1>
<h2 id="后台运行vs前台运行">后台运行vs前台运行</h2>
<p>当你启动一个docker
容器的时候，第一件事就是要确认你要在前台运行还是在后台运行：</p>
<p>-d=false:Detached mode:Run container in the background,printnew
container id</p>
<h3 id="后台运行--d">后台运行 (-d)</h3>
<p>后台运行直接指定 (-d=true or just
-d),这样的话所有的操作类似网络连接，共享操作等等都不会再接受命令行的命令控制。你就要使用attach命令
来进入一个容器，再管理它，注意当你attach链接到一个容器的时候，你就不能再使用
rm 来删除这个容器。</p>
<h3 id="前台运行">前台运行</h3>
<p>当你不指定-d时，就是在前台运行， docker run
可以启动一个进程，并且通过console 连接进程的标准输入
输出和标准错误。它甚至可以伪装成一个TTY，发送信号量。所有这一切都是可以配置的。</p>
<p>-a=[]:Attach to
<code>STDIN</code>,<code>STDOUT</code>and/or<code>STDERR</code>-t=false:Allocate
a pseudo-tty</p>
<p>--sig-proxy=true:Proxify all received signal to the process (even in
non-tty mode)-i=false:Keep STDIN open even ifnot attached</p>
<p>如果你不想使用 -a
来连接容器的所有输入输出，那么你可以指定你希望接受的流STDIN, STDOUT,
STDERR)：</p>
<p>$ docker run -a stdin -a stdout -i -t ubuntu /bin/bash</p>
<p>在交互式的情况下，你最希望得到一个类似TTY那样的shell，你可以 指定 -i
-t</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>挂载目录和文件</title>
    <url>/blog/2023/10/11/data/deployment/docker/%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="作用">作用</h2>
<p>docker挂载就是用本机文件或文件夹覆盖容器内的文件或文件夹</p>
<p>注：docker
挂载配置文件时，一定要注意不要把要挂载的配置文件的内容写错，否则创建容器之后，启动不了</p>
<h2 id="背景介绍">背景介绍</h2>
<p>docker volume
可以使我们在启动docker容器时，动态的挂载一些文件（如配置文件）,
以覆盖镜像中原有的文件</p>
<h2 id="目录挂载">目录挂载</h2>
<p>host上文件夹一定会覆盖container中文件夹：</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td>host</td>
<td>container</td>
<td>mount result</td>
</tr>
<tr class="even">
<td>文件夹不存在/文件夹存在但为空</td>
<td>文件夹不存在/存在但为空/存在且不为空</td>
<td>container中文件被覆盖（清空）</td>
</tr>
<tr class="odd">
<td>文件夹存在且不为空</td>
<td>文件夹不存在/存在但为空/存在且不为空</td>
<td>container中文件夹内容被覆盖（原内容清空，
覆盖为host上文件夹内容）</td>
</tr>
</tbody>
</table>
<p>允许不存在的文件夹或者存在的空文件夹挂载进container,
container中对应的文件夹将被清空</p>
<p>非空文件夹挂载进container将会覆盖container中原有文件夹</p>
<h2 id="文件挂载">文件挂载</h2>
<p>文件挂载与文件夹挂载最大的不同点在于：<br />
docker
禁止用主机上不存在的文件挂载到container中已经存在的文件文件挂载不会对同一文件夹下的其他文件产生任何影响存在的文件挂载进container中将会覆盖container中对应的文件，
若文件不存在则新建</p>
<h2 id="总结">总结</h2>
<p>host上文件一定会覆盖container中文件</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td>host</td>
<td>container</td>
<td>mount result</td>
</tr>
<tr class="even">
<td>不存在的文件</td>
<td>已经存在的文件</td>
<td>禁止行为</td>
</tr>
<tr class="odd">
<td>存在的文件</td>
<td>不存在的文件/已经存在的文件</td>
<td>新增/覆盖 （若目录不存在则会创建目录）</td>
</tr>
</tbody>
</table>
<h2 id="应用场景">应用场景</h2>
<p>从上面的分析可知，文件夹挂载以整个文件夹为单位进行文件覆盖，故可在需要将大量文件挂载进container时使用，另外，如果挂载一个空文件夹或者不存在的文件夹，一般是做逆向使用：
即容器启动后，可能会在容器内挂载点的文件夹下生成一些文件（如日志），此时，在对应的host上的文件夹内就能直接看到。</p>
<p>文件挂载由于只会覆盖单个文件而不会影响container中同一文件夹下的其他文件，常常被用来挂载配置文件，以在运行时，动态的修改默认配置。</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>配置docker daemon代理来拉取国外镜像</title>
    <url>/blog/2023/10/11/data/deployment/docker/%E9%85%8D%E7%BD%AEdocker%20daemon%E4%BB%A3%E7%90%86%E6%9D%A5%E6%8B%89%E5%8F%96%E5%9B%BD%E5%A4%96%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>如何配置docker通过代理服务器拉取镜像</p>
<p>2021-09-22</p>
<p>标签： <a href="https://www.lfhacks.com/tags/docker/">DOCKER</a></p>
<p>如果 docker
所在的环境是通过代理服务器和互联网连通的，那么需要一番配置才能让 docker
正常从外网正常拉取镜像。然而仅仅通过配置环境变量的方法是不够的。本文结合已有文档，介绍如何配置代理服务器能使docker正常拉取镜像。</p>
<p>本文使用的docker 版本是19.03</p>
<p>问题现象</p>
<p>如果不配置代理服务器就直接拉镜像，docker
会直接尝试连接镜像仓库，并且连接超时报错。如下所示：</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td>$ docker pull busybox</td>
</tr>
<tr class="even">
<td>Using default tag: latest</td>
</tr>
<tr class="odd">
<td>Error response from daemon: Get <a
href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>:
net/http: request canceled</td>
</tr>
<tr class="even">
<td>while waiting for connection (Client.Timeout exceeded while awaiting
headers)</td>
</tr>
</tbody>
</table>
<p>容易误导的官方文档</p>
<p>有这么一篇关于 docker 配置代理服务器的 <a
href="https://docs.docker.com/network/proxy/#configure-the-docker-client">官方文档</a> ，如果病急乱投医，直接按照这篇文章配置，是不能成功拉取镜像的。</p>
<p>我们来理解一下这篇文档，文档关键的原文摘录如下：</p>
<p>If your container needs to use an HTTP, HTTPS, or FTP proxy server,
you can configure it in different ways: Configure the Docker client On
the Docker client, create or edit the file ~/.docker/config.json in the
home directory of the user that starts containers.</p>
<p>…</p>
<p>When you create or start new containers, the environment variables
are set automatically within the container.</p>
<p>这篇文档说：如果你的容器需要使用代理服务器，那么可以以如下方式配置：
在运行容器的用户 home
目录下，配置 ~/.docker/config.json 文件。重新启动容器后，这些环境变量将自动设置进容器，从而容器内的进程可以使用代理服务。</p>
<p>所以这篇文章是讲如何配置运行容器的环境，与如何拉取镜像无关。如果按照这篇文档的指导，如同南辕北辙。</p>
<p>要解决问题，我们首先来看一般情况下命令行如何使用代理。</p>
<p>环境变量</p>
<p>常规的命令行程序如果要使用代理，需要设置两个环境变量：HTTP_PROXY 和 HTTPS_PROXY ，设置环境变量的方法见 <a
href="https://www.lfhacks.com/test/cypress-download-failure#env">这篇文章</a> 。但是仅仅这样设置环境变量，也不能让
docker 成功拉取镜像。</p>
<p>我们仔细观察 <a
href="https://www.lfhacks.com/tech/pull-docker-images-behind-proxy/#problem">上面的报错信息</a>，有一句说明了报错的来源：</p>
<p>Error response from daemon:</p>
<p>因为镜像的拉取和管理都是 docker daemon 的职责，所以我们要让 docker
daemon 知道代理服务器的存在。而 docker daemon 是由 systemd
管理的，所以我们要从 systemd 配置入手。</p>
<p>正确的官方文档</p>
<p>关于 systemd 配置代理服务器的 <a
href="https://docs.docker.com/config/daemon/systemd/#httphttps-proxy">官方文档在这里</a>，原文说：</p>
<p>The Docker daemon uses the HTTP_PROXY, HTTPS_PROXY, and NO_PROXY
environmental variables in its start-up environment to configure HTTP or
HTTPS proxy behavior. You cannot configure these environment variables
using the daemon.json file.</p>
<p>This example overrides the default docker.service file.</p>
<p>If you are behind an HTTP or HTTPS proxy server, for example in
corporate settings, you need to add this configuration in the Docker
systemd service file.</p>
<p>这段话的意思是，docker daemon 使用 HTTP_PROXY, HTTPS_PROXY,
和 NO_PROXY 三个环境变量配置代理服务器，但是你需要在 systemd
的文件里配置环境变量，而不能配置在 daemon.json 里。</p>
<p>具体操作</p>
<p>下面是来自 <a
href="https://www.lfhacks.com/tech/pull-docker-images-behind-proxy/#correct">官方文档</a> 的操作步骤和详细解释：</p>
<ol type="1">
<li>创建 dockerd 相关的 systemd 目录，这个目录下的配置将覆盖 dockerd
的默认配置</li>
</ol>
<p>$ sudo mkdir -p /etc/systemd/system/docker.service.d</p>
<ol type="1">
<li>新建配置文件 /etc/systemd/system/docker.service.d/http-proxy.conf，这个文件中将包含环境变量</li>
</ol>
<table>
<tbody>
<tr class="odd">
<td>[Service]</td>
</tr>
<tr class="even">
<td>Environment="HTTP_PROXY=http://proxy.example.com:80"</td>
</tr>
<tr class="odd">
<td>Environment="HTTPS_PROXY=https://proxy.example.com:443"</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>如果你自己建了私有的镜像仓库，需要 dockerd
绕过代理服务器直连，那么配置 NO_PROXY 变量：</li>
</ol>
<table>
<tbody>
<tr class="odd">
<td>[Service]</td>
</tr>
<tr class="even">
<td>Environment="HTTP_PROXY=http://proxy.example.com:80"</td>
</tr>
<tr class="odd">
<td>Environment="HTTPS_PROXY=https://proxy.example.com:443"</td>
</tr>
<tr class="even">
<td>Environment="NO_PROXY=your-registry.com,10.10.10.10,*.example.com"</td>
</tr>
</tbody>
</table>
<p>多个 NO_PROXY 变量的值用逗号分隔，而且可以使用通配符（<em>），极端情况下，如果 NO_PROXY=</em>，那么所有请求都将不通过代理服务器。</p>
<ol type="1">
<li>重新加载配置文件，重启 dockerd</li>
</ol>
<table>
<tbody>
<tr class="odd">
<td>$ sudo systemctl daemon-reload</td>
</tr>
<tr class="even">
<td>$ sudo systemctl restart docker</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>检查确认环境变量已经正确配置：</li>
</ol>
<p>$ sudo systemctl show --property=Environment docker</p>
<ol type="1">
<li>从 docker info 的结果中查看配置项。</li>
</ol>
<figure>
<img
src="data:image/png;base64,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"
alt="Docker Root Debug Mode: HTTP Proxy: HTTPS Proxy: Dir: /var/lib/docker false No Proxy: localhost, 127.0.0. 1 , dockeé-regi: Registry: https://index.docker.io/vl/" />
<figcaption aria-hidden="true">Docker Root Debug Mode: HTTP Proxy: HTTPS
Proxy: Dir: /var/lib/docker false No Proxy: localhost, 127.0.0. 1 ,
dockeé-regi: Registry: https://index.docker.io/vl/</figcaption>
</figure>
<p>这样配置后，应该可以正常拉取 docker 镜像。</p>
<p>结论</p>
<p>docker 镜像由 docker daemon 管理，所以不能用修改 shell
环境变量的方法使用代理服务，而是从 systemd 角度设置环境变量。</p>
<p>来自 &lt;<a
href="https://www.lfhacks.com/tech/pull-docker-images-behind-proxy/">https://www.lfhacks.com/tech/pull-docker-images-behind-proxy/</a>&gt;</p>
<p>需要注意的是，如果你的代理服务器并不支持https，那么https的代理同样要走http协议，也就是HTTPS_PROXY的值，必须是以http://开头的代理服务器，而不是https://，否则无法联通，关于这个问题，可以看<a
href="https://stackoverflow.com/questions/51890390/docker-not-able-to-pull-images-behind-proxy-tls-handshake-timeout">这篇StackOverflow</a></p>
<p>16</p>
<p>The config file is:</p>
<p>[Service]<br />
Environment=“HTTP_PROXY=http://pqr.corp.xxx.com:8080”<br />
Environment=“HTTPS_PROXY=https://pqr.corp.xxx.com:8080”<br />
Environment=“NO_PROXY=localhost,127.0.0.1”</p>
<p>Notice that 3rd line: HTTPS_PROXY=https</p>
<p>Is the proxy server support HTTPS? Or there should be an error.</p>
<p>Maybe HTTPS_PROXY=http is correct.</p>
<p>By the way, a similar error is Get <a
href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>:
proxyconnect tcp: EOF</p>
<p>来自 &lt;<a
href="https://stackoverflow.com/questions/51890390/docker-not-able-to-pull-images-behind-proxy-tls-handshake-timeout">https://stackoverflow.com/questions/51890390/docker-not-able-to-pull-images-behind-proxy-tls-handshake-timeout</a>&gt;</p>
]]></content>
      <categories>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>京东0923秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E4%BA%AC%E4%B8%9C0923%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>题目难度适中，但是总体比较灵活，需要转一些弯。模拟题的话，需要仔细处理，否则很容易出错。（由刷题的小菜鸡提供）</p>
<h2 id="第一题">第一题</h2>
<p>小红需要n个不同的魔法药剂，她可以从商店以ai的价格购买第i种红色版本魔法药剂，也可以用两种其他的红色版本药剂配置蓝色版本
小红想知道，她最少需要花多少钱才能得到1到n个不同的魔法药剂，蓝色或者红色都可以。</p>
<p><strong>输入描述</strong></p>
<p>第一行输入一个整数n，表示魔法药剂数量。</p>
<p>第二行输入n个整数ai，表示第i种红色版本魔法药剂的价格。</p>
<p>接下来n行，每行两个整数bi和ci，表示用第 bi 种和第 ci
种红色版本魔法药剂配置第 i 种蓝色版本魔法药剂。</p>
<p>1 &lt;= n &lt;= 1e5</p>
<p>1 &lt;= ai &lt;= 1e4</p>
<p>1 &lt;= bi,ci &lt;= n</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示最少需要花多少钱才能得到1到n个不同的魔法药剂，蓝色或者红色都可以。</p>
<p><strong>示例1</strong></p>
<p><strong>输入</strong></p>
<p><code>5   2 4 10 1 3</code></p>
<p><strong>输出</strong></p>
<p><code>16</code></p>
<p><strong>说明</strong></p>
<p>红色药剂的价格分别为<code>[2, 4, 10, 1, 3]</code></p>
<p>蓝色药剂的价格分别为<code>[14, 4, 6, 7, 3]</code></p>
<p>配置第三种蓝色药剂，其他都购买红色药剂花费 16。</p>
<p><strong>思路与代码：</strong></p>
<p>模拟，哪种做法便宜选哪个<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">using</span> gg = <span class="type">long</span> <span class="type">long</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> gg n; cin &gt;&gt; n;  </span><br><span class="line"> <span class="function">vector&lt;gg&gt; <span class="title">red</span><span class="params">(n)</span></span>;  </span><br><span class="line"> <span class="function">vector&lt;gg&gt; <span class="title">price</span><span class="params">(n, <span class="number">1000005</span>)</span></span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">  cin &gt;&gt; red[i];  </span><br><span class="line"> &#125;  </span><br><span class="line"> vector&lt;vector&lt;gg&gt;&gt; <span class="built_in">blue</span>(n, <span class="built_in">vector</span>&lt;gg&gt;(<span class="number">2</span>));  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">  cin &gt;&gt; blue[i][<span class="number">0</span>] &gt;&gt; blue[i][<span class="number">1</span>];  </span><br><span class="line">  blue[i][<span class="number">0</span>]--; blue[i][<span class="number">1</span>]--;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//sort(red.begin(), red.end());  </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">  price[i] = <span class="built_in">min</span>(red[i], red[blue[i][<span class="number">0</span>]] + red[blue[i][<span class="number">1</span>]]);  </span><br><span class="line"> &#125;  </span><br><span class="line"> gg ans = <span class="number">0</span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span> x : price) ans += x;  </span><br><span class="line"> cout &lt;&lt; ans &lt;&lt; endl;  </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第二题">第二题</h2>
<p>小红有一个长度为n的数组。如果存在一个长度为3的子数组，使得a_i &lt;=
a_i+1 &lt;=
a_i+2，那么这个数组就是有趣的。每次操作可以修改数组的一个值，请问最少需要几次操作才能使得这个数组变得不有趣</p>
<p><strong>输入描述</strong></p>
<p>第一行输入一个整数n，表示数组的长度。第二行输入几个整数a1,
a2，···，an，表示数组的初始值。</p>
<p>1&lt;= n &lt;=1e5    1&lt;= ai &lt;= 1e9</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示答案</p>
<p><strong>示例</strong></p>
<p><strong>输入</strong></p>
<p><code>5   6 2 4 5 1</code></p>
<p><strong>输出</strong></p>
<p><code>1</code></p>
<p><strong>思路与代码</strong></p>
<p>贪心+找规律</p>
<p>首先找出所有连续的有趣子数组，记录其长度；</p>
<p>对于递增子数组，可以通过将其中间的数改为一个较大值进行破坏，可以证明破坏边缘不如破坏中间；</p>
<p>长度为3，需要1次；</p>
<p>长度为4，需要1次；</p>
<p>长度为5，相当于破坏1次+长度为3；</p>
<p>长度为6，相当于破坏一次+长度为4；</p>
<p>找规律为 破坏次数 = （(连续递增子数组长度 - 1 ) /
2），累加就行了<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">using</span> gg = <span class="type">long</span> <span class="type">long</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> gg n; cin &gt;&gt; n;  </span><br><span class="line"> <span class="function">vector&lt;gg&gt; <span class="title">arr</span><span class="params">(n)</span></span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; arr[i];  </span><br><span class="line"> vector&lt;gg&gt; nums;  </span><br><span class="line"> gg len = <span class="number">1</span>, ans = <span class="number">0</span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;  </span><br><span class="line">  <span class="keyword">if</span>(arr[i] &gt;= arr[i<span class="number">-1</span>]) len++;  </span><br><span class="line">  <span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span>(len &gt;= <span class="number">3</span>) nums.<span class="built_in">push_back</span>(len);  </span><br><span class="line">   len = <span class="number">0</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">if</span>(len &gt;= <span class="number">3</span>) nums.<span class="built_in">push_back</span>(len);  </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) ans += (x<span class="number">-1</span>) / <span class="number">2</span>;  </span><br><span class="line"> cout &lt;&lt; ans &lt;&lt; endl;  </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三题">第三题</h2>
<p>小红有一个长度为 n
的排列，她每次可以选择两个数ai和aj，要求i和j的奇偶性相同，然后交换这两个数。问最少需要多少次操作才能使得数组变成有序的，如果不能变的有序，输出-1。</p>
<p><strong>输入描述</strong></p>
<p>第一行输入一个整数n，表示数组的长度</p>
<p>第二行输入n个整数 a1,a2，.,an，表示数组的元素。</p>
<p>1 &lt;= n &lt;= 1e5</p>
<p>1 &lt;= ai &lt;= n</p>
<p><strong>输出描述</strong></p>
<p>如果能变成有序的，输出最少需要的操作次数，否则输出-1.</p>
<p><strong>示例</strong></p>
<p><strong>输入</strong></p>
<p><code>5   1 4 5 2 3</code></p>
<p><strong>输出</strong></p>
<p><code>2</code></p>
<p><strong>说明</strong></p>
<p>需要交换a2,a4和a3,a5，得到[1, 2, 3, 4, 5]</p>
<p><strong>思路与代码：</strong></p>
<p>奇偶分组+任意交换让数组变有序的最小操作</p>
<p>首先判定能否完成，对奇偶分组进行排序再合并，与原数组排序后对比，如果不相等代表不能完成；</p>
<p>在能完成情况下，就是分开算奇偶数组变有序的最小操作；</p>
<p>具体做法是跟排序后的对比，建立值到索引的映射，找出循环节个数，总长度-循环节个数就是最小交换次数</p>
<p>经过验证，题目中的有序是代表升序，尝试过降序反而会错。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">using</span> gg = <span class="type">long</span> <span class="type">long</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function">gg <span class="title">mer</span><span class="params">(vector&lt;gg&gt; &amp;a)</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">auto</span> b = a;  </span><br><span class="line"> <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());  </span><br><span class="line"> unordered_map&lt;gg, gg&gt; mp;  </span><br><span class="line"> gg len = a.<span class="built_in">size</span>();  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) mp[b[i]] = i;  </span><br><span class="line"> gg loops = <span class="number">0</span>;  </span><br><span class="line"> <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(len, <span class="literal">false</span>)</span></span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </span><br><span class="line">  <span class="keyword">if</span>(!flag[i]) &#123;  </span><br><span class="line">   gg j = i;  </span><br><span class="line">   <span class="keyword">while</span>(!flag[j]) &#123;  </span><br><span class="line">    flag[j] = <span class="literal">true</span>;  </span><br><span class="line">    j = mp[a[j]];  </span><br><span class="line">   &#125;  </span><br><span class="line">   loops++;  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">return</span> len - loops;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> gg n; cin &gt;&gt; n;  </span><br><span class="line"> <span class="function">vector&lt;gg&gt; <span class="title">arr</span><span class="params">(n)</span></span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; arr[i];  </span><br><span class="line"> vector&lt;vector&lt;gg&gt;&gt; <span class="built_in">jiou</span>(<span class="number">2</span>);  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) jiou[i % <span class="number">2</span>].<span class="built_in">push_back</span>(arr[i]);  </span><br><span class="line"> <span class="keyword">auto</span> ou = jiou[<span class="number">0</span>], ji = jiou[<span class="number">1</span>];  </span><br><span class="line"> <span class="built_in">sort</span>(ji.<span class="built_in">begin</span>(), ji.<span class="built_in">end</span>());  </span><br><span class="line"> <span class="built_in">sort</span>(ou.<span class="built_in">begin</span>(), ou.<span class="built_in">end</span>());  </span><br><span class="line"> <span class="function">vector&lt;gg&gt; <span class="title">sorted</span><span class="params">(n)</span></span>;  </span><br><span class="line"> <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">  <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) sorted[i] = ou[i/<span class="number">2</span>];  </span><br><span class="line">  <span class="keyword">else</span> sorted[i] = ji[i/<span class="number">2</span>];  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">if</span>(arr != sorted) &#123;  </span><br><span class="line">  cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> gg ans = <span class="built_in">mer</span>(jiou[<span class="number">1</span>]) + <span class="built_in">mer</span>(jiou[<span class="number">0</span>]);  </span><br><span class="line"> cout &lt;&lt; ans &lt;&lt; endl;  </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>华为0913秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E5%8D%8E%E4%B8%BA0913%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="快递中转站">快递中转站</h2>
<p>快递公司有一个业务要求，所有当天下发到快递中转站的快递，最迟在第二天送达用户手中。</p>
<p>假设已经知道接下来n天每天下发到快递中转站的快递重量。快递中转站负责人需要使用快递运输车运输给用户，每一辆运输车最大只能装k重量的快递。</p>
<p>每天可以出车多次，也可以不出车，也不要求运输车装满。当天下发到快递中转站的快递，最晚留到第二天就要运输走送给用户。</p>
<p>快递中转站负责人希望出车次数最少，完成接下来n天的快递运输。</p>
<p><strong>解答要求</strong></p>
<p>时间限制: C/C++ 1000ms,其他语言: 2000ms内存限制: C/C++256MB其他语言:
512MB</p>
<p><strong>输入</strong></p>
<p>输入第一行包含两个整数n(1&lt;=
n&lt;=200000)，k(1&lt;=k&lt;=100000000)</p>
<p>第二行包含n个整数ai，表示第i天下发到快递中转站的快递重量。</p>
<p><strong>输出</strong></p>
<p>输出最少需要的出车次数。</p>
<p><strong>样例1</strong></p>
<p><strong>输入</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3 2  </span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>第一天的快递出车一次送走2个重量，留1个重量到第二天</p>
<p>第二天送走第一天留下的1个重量和当前的1个重量，留1个重量到第三天送走。</p>
<p><strong>思路与代码</strong></p>
<p>打卡题。</p>
<p>直接模拟即可，注意如果第二天凑不满一车也还是得发一车。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, k;  </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        cin &gt;&gt; a[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> re = a[i] + left;  </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t1 = re / k;  </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t2 = re % k;  </span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="number">0</span> &amp;&amp; left != <span class="number">0</span>) &#123;  </span><br><span class="line">            t1++;  </span><br><span class="line">            t2 = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ans += t1;  </span><br><span class="line">        left = t2;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">0</span>) &#123;  </span><br><span class="line">        ans++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="互通设备集">互通设备集</h2>
<p>局一局域网内的设备可以相互发现，具备直连路由的两个设备可以互通。假定设备A和B互通，B和C互通，那么可以将B作为中心设备，通过多跳路由策略使设备A和C互通。这样，A、B、C三个设备就组成了一个互通设备集。其中，互通设备集包括以下几种情况:</p>
<ol type="1">
<li><p>直接互通的多个设备</p></li>
<li><p>通过多跳路由第略间接互通的多个设备</p></li>
<li><p>没有任何互通关系的单个设备现给出某一局域网内的设备总数以及具备直接互通关系的设备，请计算该局域网内的互通设备集有多少个?</p></li>
</ol>
<p><strong>输入</strong></p>
<p>第一行: 某一局域网内的设备总数M，32位有符号整数表示。1&lt;=
M&lt;=200</p>
<p>第二行:具备直接互通关系的数量N，32位有符号整数表示。0&lt;=
N&lt;200</p>
<p>第三行到第N+2行:
每行两个有符号32位整数，分别表示具备直接互通关系的两个设备的编号，用空格隔开。每个设备具有唯一的编号，0&lt;设备编号&lt;
M</p>
<p><strong>输出</strong></p>
<p>互通设备集的数量，32位有符号整数表示。</p>
<p><strong>样例1</strong></p>
<p><strong>输入</strong><br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3  </span><br><span class="line">2  </span><br><span class="line">0 1  </span><br><span class="line">0 2</span><br></pre></td></tr></table></figure></p>
<p><strong>输出</strong><br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p><strong>解释:</strong></p>
<p>编号0和1以及编号0和2的设备直接互通，编号1和2的设备可通过编号0的设备建立互通关系，互通设备集可合并为1个。</p>
<p><strong>思路与代码</strong></p>
<p>并查集。</p>
<p>类似LC的岛屿问题，可以直接使用并查集模板即可。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fa;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;  </span><br><span class="line">    fa.<span class="built_in">assign</span>(n, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        fa[i] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="built_in">find</span>(fa[x]));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  </span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> m, n;  </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;  </span><br><span class="line">    <span class="built_in">init</span>(m);  </span><br><span class="line">    <span class="type">int</span> u, v;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;  </span><br><span class="line">        <span class="built_in">Union</span>(u, v);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) &#123;  </span><br><span class="line">            ans++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基站建设">基站建设</h2>
<p>运营商建设基站时需要关注很多因素，其中:
基站的信号覆盖范围、建设成本就是要考虑的部分因素。</p>
<p>以一个二维数组(10000* 10000)
表示需要服务的有效地域范围，假设个基站坐标为(2,2)，可覆盖的范围为基站为中心的3*3的矩阵(若不在有效地域范围则无效)。</p>
<p>现有多个基站候选点，我们需要决策在哪些地点建设基站，要求:在尽可能多地覆盖服务地域的前提下尽可能少地建设基站</p>
<p><strong>输入</strong></p>
<p>第一行为候选基站的坐标点个数n
(0&lt;n&lt;10000)，后面的每一行都表示候选基站的行列位置，格式为:
行位置+空格+列位置</p>
<p><strong>输出</strong></p>
<p>格式为:建造的基站个数+空格+覆盖的地域面积</p>
<p><strong>样例1</strong></p>
<p><strong>输入</strong><br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">4  </span><br><span class="line">2 2  </span><br><span class="line">5 5  </span><br><span class="line">5 4  </span><br><span class="line">5 3  </span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p><strong>输出</strong></p>
<p><code>3 24</code></p>
<p><strong>解释:</strong></p>
<p>最佳的策略为选择(2,2)、(5,5)、(5,3)这三个基站候选点，他们的覆盖面积为24</p>
<p><strong>思路与代码</strong></p>
<p>模拟。</p>
<p>这是300分的题。。。。据说直接输出一些特殊值也能拿不少分数，不过可能像去年那样会重新增强样例......</p>
<p>总体是使用标记法，标后周围全部都&gt;1的就是被其他点覆盖的。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cin &gt;&gt; n;  </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pos</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        cin &gt;&gt; pos[i][<span class="number">0</span>] &gt;&gt; pos[i][<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; vis;  </span><br><span class="line">    <span class="type">int</span> cnt = n;  </span><br><span class="line">    <span class="type">int</span> square = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        <span class="type">int</span> x = pos[i][<span class="number">0</span>], y = pos[i][<span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-1</span>; k &lt;= <span class="number">1</span>; k++) &#123;  </span><br><span class="line">                <span class="type">int</span> nx = x + j, ny = y + k;  </span><br><span class="line">                <span class="keyword">if</span> (x + j &lt; <span class="number">-1</span> || x + j &gt;= <span class="number">10001</span> || y + k &lt; <span class="number">-1</span> || y + k &gt;= <span class="number">10001</span>) &#123;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (vis.<span class="built_in">count</span>(nx * <span class="number">10001</span> + ny) == <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (x + j &lt; <span class="number">0</span> || x + j &gt;= <span class="number">10000</span> || y + k &lt; <span class="number">0</span> || y + k &gt;= <span class="number">10000</span>) &#123;  </span><br><span class="line">                        ;  </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        square++;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                vis[nx * <span class="number">10001</span> + ny]++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        <span class="type">int</span> x = pos[i][<span class="number">0</span>], y = pos[i][<span class="number">1</span>];  </span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;  </span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-1</span>; k &lt;= <span class="number">1</span>; k++) &#123;  </span><br><span class="line">                <span class="type">int</span> nx = x + j, ny = y + k;  </span><br><span class="line">                <span class="keyword">if</span> (x + j &lt; <span class="number">-1</span> || x + j &gt;= <span class="number">10001</span> || y + k &lt; <span class="number">-1</span> || y + k &gt;= <span class="number">10001</span>) &#123;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (vis[nx * <span class="number">10001</span> + ny] &gt; <span class="number">1</span>) &#123;  </span><br><span class="line">                    flag++;  </span><br><span class="line">                &#125;  </span><br><span class="line">                total++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (flag == total) &#123;  </span><br><span class="line">            cnt--;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++) &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-1</span>; k &lt;= <span class="number">1</span>; k++) &#123;  </span><br><span class="line">                    <span class="type">int</span> nx = x + j, ny = y + k;  </span><br><span class="line">                    <span class="keyword">if</span> (x + j &lt; <span class="number">-1</span> || x + j &gt;= <span class="number">10001</span> || y + k &lt; <span class="number">-1</span> || y + k &gt;= <span class="number">10001</span>) &#123;  </span><br><span class="line">                        <span class="keyword">continue</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> (vis[nx * <span class="number">10001</span> + ny] &gt; <span class="number">1</span>) &#123;  </span><br><span class="line">                        vis[nx * <span class="number">10001</span> + ny]--;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; square &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>华为1011秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E5%8D%8E%E4%B8%BA1011%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>难度适中，至少150不是很难。</p>
<p>第一题偏打卡。</p>
<p>第二题贪心+动态规划，但是藏的比较浅。</p>
<p>第三题是比较麻烦的模拟，注定满分不是那么好拿的。</p>
<h2 id="计算最少流控请求数">计算最少流控请求数</h2>
<p>服务器性能有限，对于突发请求，有时需要通过流控保护系统不受冲击。假设某服务器的系统要求任意M分钟内只能处理N条请求，超出的请求必须流控掉。已知连续X分钟,每分钟的实际请求数，请给出至少流控掉多少请求才能保证上述系统不受冲击。</p>
<p><strong>解答要求</strong></p>
<p>时间限制: C/C++ 1000ms,其他语言: 2000ms 内存限制: C/C++
256MB,其他语言:512MB</p>
<p><strong>输入</strong></p>
<p>第一行: M和N M范围<code>[1,10]</code>
N的范围<code>[0.10000]</code></p>
<p>第二行: 连续分钟数X，X范围为<code>[1,100000]</code></p>
<p>第三行:每分钟的请求数范围<code>[0,1000]</code></p>
<p><strong>输出</strong></p>
<p>最少可以流控的请求数</p>
<p><strong>样例1</strong><br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入:4 6  </span><br><span class="line">    6  </span><br><span class="line">    2 1 2 2 3 2  </span><br><span class="line">输出:3  </span><br><span class="line">解释:输入:  </span><br><span class="line">第一行系统要求:每4分钟只能接受6个请求。第二行:连续6分钟  </span><br><span class="line">第三行:每分钟的实际请求数。  </span><br><span class="line">至少流控3个请求 (可以是: 第4分钟流控1个请求，第5分钟流控1个请求，第6分钟流控1个请求》，才可以满足系统4分钟内只能处理6条请求的要求</span><br></pre></td></tr></table></figure></p>
<p><strong>思路与代码</strong></p>
<p>滑动窗口。</p>
<p>使用长度为M的滑动窗口进行模拟即可。<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M,N = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  </span><br><span class="line">X = <span class="built_in">int</span>(<span class="built_in">input</span>())  </span><br><span class="line">requests = [<span class="built_in">int</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">input</span>().split()]  </span><br><span class="line">  </span><br><span class="line">r = M  </span><br><span class="line">res = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span>(r&lt;=X):  </span><br><span class="line">    window = requests[r-M:r]  </span><br><span class="line">    total_requests = <span class="built_in">sum</span>(window)  </span><br><span class="line">    <span class="keyword">if</span> total_requests&gt;N:  </span><br><span class="line">        to_remove = total_requests - N  </span><br><span class="line">        res += to_remove  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r-<span class="number">1</span>, r-M-<span class="number">1</span>, -<span class="number">1</span>):  </span><br><span class="line">            <span class="keyword">if</span> to_remove&gt;requests[i]:  </span><br><span class="line">               to_remove -= requests[i]  </span><br><span class="line">               requests[i] = <span class="number">0</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">               requests[i] = requests[i] - to_remove  </span><br><span class="line">               <span class="keyword">break</span>  </span><br><span class="line">    r += <span class="number">1</span>  </span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></p>
<h2 id="快乐时间">快乐时间</h2>
<p>小明在工作之余喜欢在电子书城阅读不同的书籍并且获得最大的满足感，因此根据书城针对每本书籍的评分收集了n个书籍的打分清单books，例如第一本书的打分<code>books[0]=5</code>代表该书的满意程度为5，第二本书<code>books[1]=-2</code>代表该书的满意程度为-2.</p>
<p>阅读每本书花费的都是1单位时间，time定义为阅读本书及之前所有书的时间之和。因此第一本阅读的书籍<code>time[0]=1</code>，第二本阅读的书籍<code>time[1]=2</code>，第三本阅读的书籍<code>time[2]=3</code>并以此类推。</p>
<p>每本书籍的<code>[快乐时间]</code>系数为阅读该书籍和之前每本书籍所花费的时间乘以对这本书籍的满意程度，即<code>time[i]*books[i]</code>，其中i从0开始。</p>
<p>小明想了解自己如何安排阅读计划才能获得最大的快乐时间，请帮忙计算一下阅读给定书籍<code>[快乐时间]</code>总和最大的值是多少，可以按照任意顺序调整阅读书籍顺序(即每本书对应的<code>time[i]</code>是可以对调的)，也可以放弃阅读某些书籍。</p>
<p><strong>解答要求</strong></p>
<p>时国限制:C/C++ 1000ms其他语言: 2000ms 内存限制:C/C++ 256MB其他语言:
512MB</p>
<p><strong>输入</strong></p>
<p>输入为字符串，字符串内容为代表每本书籍的喜爱指数</p>
<p><strong>输出</strong></p>
<p>输出为数字，代表最大的快乐时间。</p>
<p><strong>样例1</strong><br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: 4,3,2  </span><br><span class="line">输出: 20  </span><br><span class="line">解释:按照原来顺序相反的时间阅读书籍(2*1+32+43=20)，评分越高的书籍越后面阅读可以获得最大的快乐时间</span><br></pre></td></tr></table></figure></p>
<p><strong>思路与代码</strong></p>
<p>动态规划。</p>
<p>这里使用记忆化搜索的思路进行实现。<code>f[i,j]</code>表示从第i天开始往后考虑，当前看第j本书可以获取的最大开心值。每一天都有看和不看两种选择，即可枚举出所有的可能。时间复杂度为O(n^2)<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cache  </span><br><span class="line">  </span><br><span class="line">books = [<span class="built_in">int</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">input</span>().split(<span class="string">&quot;,&quot;</span>)]  </span><br><span class="line">books.sort()  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@cache  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,p</span>):  </span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(books): <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i+<span class="number">1</span>,p), dfs(i+<span class="number">1</span>,p+<span class="number">1</span>) + books[i] * p)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(dfs(<span class="number">0</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="稀疏存储">稀疏存储</h2>
<p>在虚拟化技术、芯片仿真器等领域，存在一种场景，即实际读写的数据量比较小，但要求可访问的地址空间却很大(要求4GB、甚至128GB地址空间)。</p>
<p>实现一个地址范围为32G的，可在该地址范围内任意位置读写数据的虚拟化
内存机制(数据默认清零)</p>
<p>对应功能: 1.读取任意地址数据: 2.往任意地址写入任意数据
3.清空数据，并释放内存</p>
<p>输入格式: Command Address Length Data</p>
<p>解释: 1、Command为Read、Write、 Clear之一
2、Address采用64位无符号十六进制数，全大写
3、Length采用64位无符号十进制数，单位为“字节”;
4、Data采用字节流(2个16进制数表示一个Byte)
，全大写;5、如果指定的Length大于实际给定的Data，需要程序自行末尾补0，小于则
末尾截断</p>
<p><strong>解答要求：</strong></p>
<p>时间限制: C/C++ 1000ms其他语言: 2000ms内存限制: /C++ 32MB.其他语言:
64MB</p>
<p><strong>输入</strong></p>
<p>每条指今一行，一个用例输入可以是多条指令混合，只有Read指令有输出。每个用例保证指令、参数格式正确，但不保证参数范围，需要程序按照题目规格要求自行校验，参数不合法，则对应的指令无效。</p>
<p>每个用例保证需要存储的总数据量最大不超过16MB，一个用例最多不超过500条指令。<br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">例如(3表示有3条指令)  </span><br><span class="line">3  </span><br><span class="line">Write 0x100 7 001122AA  </span><br><span class="line">Read 0x100 4  </span><br><span class="line">Clear</span><br></pre></td></tr></table></figure></p>
<p><strong>输出</strong><br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">采用字节流(2个16进制数表示一个Byte)，全大写  </span><br><span class="line">例如  </span><br><span class="line">001122AA  </span><br><span class="line">每条Read指令对应一行输出数据，如果指令给的参数不合法，对应的输出为空(不换行)</span><br></pre></td></tr></table></figure></p>
<p><strong>思路与代码</strong></p>
<p>大模拟题。【以下代码可能有纰漏的样例】</p>
<p>总体思想使用哈希表进行模拟每一个地址存储的值。<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict  </span><br><span class="line">  </span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())  </span><br><span class="line">  </span><br><span class="line">address_map = defaultdict(<span class="keyword">lambda</span>: <span class="string">&quot;0&quot;</span>)  </span><br><span class="line">mx = <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>  </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):  </span><br><span class="line">    instruction = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">&quot;Read&quot;</span>:  </span><br><span class="line">        address, length = instruction[<span class="number">1</span>], <span class="built_in">int</span>(instruction[<span class="number">2</span>])  </span><br><span class="line">        address = <span class="built_in">int</span>(address, <span class="number">16</span>)  </span><br><span class="line">        <span class="keyword">if</span> address + length * <span class="number">2</span> * <span class="number">8</span> &gt;= mx - <span class="number">1</span>: <span class="keyword">continue</span>  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * length):  </span><br><span class="line">            <span class="built_in">print</span>(address_map[address + i * <span class="number">8</span>], end=<span class="string">&quot;&quot;</span>)  </span><br><span class="line">        <span class="built_in">print</span>()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">&quot;Write&quot;</span>:  </span><br><span class="line">        address, length, data = instruction[<span class="number">1</span>], <span class="built_in">int</span>(instruction[<span class="number">2</span>]) , instruction[<span class="number">3</span>]  </span><br><span class="line">        address = <span class="built_in">int</span>(address, <span class="number">16</span>)  </span><br><span class="line">        <span class="keyword">if</span> address + length * <span class="number">2</span> * <span class="number">8</span> &gt;= mx - <span class="number">1</span>: <span class="keyword">continue</span>  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * length):  </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(data):  </span><br><span class="line">                address_map[address + i * <span class="number">8</span>] = data[i]  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        address_map = defaultdict(<span class="keyword">lambda</span>: <span class="string">&quot;0&quot;</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>小红书0819秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E5%B0%8F%E7%BA%A2%E4%B9%A60819%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>前言：</strong></p>
<p>本次题目难度总体并不大，但是题目比较灵活，特别是第三题，表面诱导你dp，实际则是个序列问题。</p>
<p>话说七夕了，我特意这么晚发你还看题？</p>
<h2 id="小红背单词">1、小红背单词</h2>
<p>小红每天都要背单词，然后她会把每天记住了多少单词记录下来，并在小红书上打卡。当小红背单词时，如果她已经记住了i个单词，且背了一个没有记住的新单词i+1次，则她就会记住这个新单词。</p>
<p>例如，当她按顺序背[“you“、“thank”、"thank”]时，她第一次背单词"you"时她就能记住“you”。而由于她已经记住了一个单词，所以需要背两次“thank"才能记住"thank”。现在你知道了小红背单词的顺序，请你求出小红今天记住了多少个单词。</p>
<p><strong>输入描述：</strong></p>
<p>第一行一个整数n(1&lt;=n&lt;=10000)。接下来n行，每行一个字符串，保证每个字符串长度不超过
10.</p>
<p><strong>输出描述：</strong></p>
<p>输出一个整数，表示她记住了多少个单词。</p>
<p><strong>样例输入：</strong></p>
<p><code>5   you   thank   queue   queue   thank</code></p>
<p><strong>样例输出</strong></p>
<p><code>2</code></p>
<p><strong>提示：</strong></p>
<p>小红先记住了单词"you”，又因为背了两次"queue"于是记住了单词"queue”.由于已经记住了两个单词，所以背两次"thank"还不能让小红记住.</p>
<p><strong>思路与代码：</strong></p>
<p>用HashMap记录每个单词的次数，同时用set记录已经背过的单词，已经背过的单词不计入。<br />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main11111</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();  </span><br><span class="line">        String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[n];  </span><br><span class="line">        sc.nextLine();  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;  </span><br><span class="line">            s[i] = sc.nextLine();  </span><br><span class="line">        &#125;  </span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(set.contains(s[i]))<span class="keyword">continue</span>;  </span><br><span class="line">            map.put(s[i], map.getOrDefault(s[i],<span class="number">0</span>) + <span class="number">1</span>);  </span><br><span class="line">            <span class="keyword">if</span>(map.get(s[i]) &gt; ans)&#123;  </span><br><span class="line">                ans++;  </span><br><span class="line">                set.add(s[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="小红的回文串">2、小红的回文串</h2>
<p>小红有一个字符串，她可以进行以下操作:</p>
<p>-拆分。把’w'拆成2个’v'，’m’拆成 2个'n’。</p>
<p>-轴堆成。把’b’轴对称成’d’，’p’轴对称成’q’，反之亦然。</p>
<p>-翻转。把’b’反转成’q’，把’d’翻转成’p’，把’n’翻转成’u’</p>
<p>经过若干次操作，小红想知道这个字符串能不能变成回文串。</p>
<p><strong>输入描述：</strong></p>
<p>第一行输入一个整数 T(1&lt;=T&lt;=10^4)表示询问次数</p>
<p>接下来T行，每行输入一个字符串表示询问。</p>
<p>所有字符串长度之和不超过 10^5。</p>
<p><strong>输出描述：</strong></p>
<p>输出T行，每行输出"YES”或“NO”表示是否可以变成回文串。</p>
<p><strong>样例输入：</strong></p>
<p><code>5   Wovv   bod   pdd   moom   lalalai</code></p>
<p><strong>样例输出</strong></p>
<p><code>YES   YES   YES   YES   NO</code></p>
<p><strong>思路与代码：</strong></p>
<p>使用一个StringBuilder转换字符串s，如果为bdqp，统一转换为b。</p>
<p>如果为w，转为vv 如果为n，转为u 如果为m，转为uu<br />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;  </span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();  </span><br><span class="line">        String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[n];  </span><br><span class="line">        sc.nextLine();  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;  </span><br><span class="line">            s[i] = sc.nextLine();  </span><br><span class="line">        &#125;  </span><br><span class="line">        String[] ans = <span class="keyword">new</span> <span class="title class_">String</span>[n];  </span><br><span class="line">        Arrays.fill(ans, <span class="string">&quot;NO&quot;</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(String str : s)&#123;  </span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)&#123;  </span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);  </span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;b&#x27;</span> || c == <span class="string">&#x27;d&#x27;</span> || c == <span class="string">&#x27;q&#x27;</span> || c ==<span class="string">&#x27;p&#x27;</span>)sb.append(<span class="string">&#x27;b&#x27;</span>);  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;w&#x27;</span>)sb.append(<span class="string">&#x27;v&#x27;</span>).append(<span class="string">&#x27;v&#x27;</span>);  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;m&#x27;</span>)sb.append(<span class="string">&#x27;u&#x27;</span>).append(<span class="string">&#x27;u&#x27;</span>);  </span><br><span class="line">                <span class="keyword">else</span>  <span class="keyword">if</span>(c == <span class="string">&#x27;n&#x27;</span>)sb.append(<span class="string">&#x27;u&#x27;</span>);  </span><br><span class="line">                <span class="keyword">else</span> sb.append(c);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> sb.toString();  </span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = s1.length() - <span class="number">1</span>;  </span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i) != s1.charAt(j))&#123;  </span><br><span class="line">                    flag = <span class="literal">false</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                i++;  </span><br><span class="line">                j--;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;  </span><br><span class="line">                ans[index] = <span class="string">&quot;YES&quot;</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            index++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(String x : ans)&#123;  </span><br><span class="line">            System.out.println(x);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="小红的攻略">3、小红的攻略</h2>
<p>小红是小红书的一个博主，她有很多的粉丝，有一些粉丝想让小红出一篇上尾市的旅游攻略。</p>
<p>上尾市有n个景点，有 m条路线，每个景点的攻略价值是
a，要花费h时间浏览，不同景点之间的交通时间为 w。</p>
<p>小红最多会选择3个相邻的景点，然后按顺序将景点写进攻略，她需要保证每个景点的浏览时间加上景点之间的交通时间总和不超过k，并且使得攻略的价值尽可能大，即是点的总价值尽可能大。</p>
<p>求小红的攻略的最大价值。</p>
<p><strong>输入描述：</strong></p>
<p>第一行输入三个整数 n,m(1&lt;=n,m &lt;=10^5),k(1 &lt;=k&lt;= 10^9)</p>
<p>第二行输入n 个整数表示数组 a(1 &lt;=a:i&lt;=10^9)。</p>
<p>第三行输入n个整数表示数组 h(1&lt;=h&lt;=10^9)</p>
<p>接下来m行，每行输入三个整数 u,v(1&lt;=u,v &lt;=n),w(1&lt;=
w&lt;=10^9) 表示景点u,v 之间的交通时间为 w。</p>
<p><strong>输出描述</strong></p>
<p>一个整数，小红的攻略的最大价值。</p>
<p><strong>样例输入：</strong></p>
<p><code>4 4 6   4 3 2 1   1 2 3 4   1 2 1   2 3 1   2 4 1   3 4 1</code></p>
<p>样例输出：</p>
<p><code>9</code></p>
<p><strong>说明</strong></p>
<p>路线3-2-1的价值为4 + 3 + 2 = 9耗费时间1+1+2+1+3 = 8
路线1-2-3也一样，都是最优方案 可以证明，答案最大不超过9</p>
<p><strong>思路与代码：</strong></p>
<p>枚举终点，每次枚举时按照消耗的代价从小到大进行排序。用一个pre数组记录前缀结点的最大价值
对于每个终点，从代价由大到小枚举中间点，再利用二分找出这个中间点的相邻点，因为代价是从小排序的，所以价值加上二分找到的点的pre值即可。<br />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.Collections;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxn</span> <span class="operator">=</span> <span class="number">100010</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] a = <span class="keyword">new</span> <span class="title class_">long</span>[maxn];  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] h = <span class="keyword">new</span> <span class="title class_">long</span>[maxn];  </span><br><span class="line">    <span class="keyword">static</span> List&lt;Edge&gt;[] E = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[maxn];  </span><br><span class="line">    <span class="keyword">static</span>  <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] pre = <span class="keyword">new</span> <span class="title class_">long</span>[maxn];  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();  </span><br><span class="line">        <span class="type">long</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextLong();  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;  </span><br><span class="line">            a[i] = sc.nextLong();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;  </span><br><span class="line">            h[i] = sc.nextLong();  </span><br><span class="line">            <span class="keyword">if</span>(h[i] &lt;= k)&#123;  </span><br><span class="line">                res = Math.max(res, a[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxn; i++)&#123;  </span><br><span class="line">            E[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> sc.nextInt();  </span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> sc.nextInt();  </span><br><span class="line">            <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> sc.nextInt();  </span><br><span class="line">            E[from].add(<span class="keyword">new</span> <span class="title class_">Edge</span>(a[to], time + h[to]));  </span><br><span class="line">            E[to].add(<span class="keyword">new</span> <span class="title class_">Edge</span>(a[from], time + h[from]));  </span><br><span class="line">            <span class="keyword">if</span>(time + h[from] + h[to] &lt;= k)&#123;  </span><br><span class="line">                res = Math.max(res, a[from] + a[to]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//枚举终点，挑两个点满足条件，权值尽可能大，带价值和&lt;k并且value尽可能大，第三个点的下标要&lt;第二个点的下标  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(E[i].size() &lt; <span class="number">2</span>)&#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//代价从小到大排序  </span></span><br><span class="line">            Collections.sort(E[i], (e1, e2) -&gt; Long.compare(e1.time, e2.time));  </span><br><span class="line">            kaishi(i);  </span><br><span class="line">            res = Math.max(res, a[i] + function(i, k - h[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(res);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//价值的前缀最大值  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kaishi</span><span class="params">(<span class="type">int</span> x)</span>&#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> E[x].size();  </span><br><span class="line">        pre[<span class="number">0</span>] = E[x].get(<span class="number">0</span>).value;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sum; i++)&#123;  </span><br><span class="line">            pre[i] = Math.max(E[x].get(i).value, pre[i - <span class="number">1</span>]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> st, <span class="type">long</span> last)</span>&#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = E[st].size() - <span class="number">1</span>,ans = -<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span>(E[st].get(mid).time &lt;= last)&#123;  </span><br><span class="line">                ans = mid;  </span><br><span class="line">                l = mid + <span class="number">1</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                r = mid - <span class="number">1</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//枚举两个点中代价最大的点，根据时间限制二分找出  </span></span><br><span class="line">    <span class="keyword">static</span>  <span class="type">long</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> last)</span>&#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">//枚举中间点  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> E[x].size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> get(x, last - E[x].get(i).time);  </span><br><span class="line">            id = Math.min(id, i - <span class="number">1</span>);  </span><br><span class="line">            <span class="keyword">if</span>(id &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            ans = Math.max(ans, E[x].get(i).value + pre[id]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;  </span><br><span class="line">        <span class="type">long</span> value, time;  </span><br><span class="line">        Edge(<span class="type">long</span> value, <span class="type">long</span> time)&#123;  </span><br><span class="line">            <span class="built_in">this</span>.value = value;  </span><br><span class="line">            <span class="built_in">this</span>.time = time;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>得物0823秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E5%BE%97%E7%89%A90823%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>前言</p>
<p>本次题目比较简单，第一题是个贪心问题，手推一下过程基本就能找到规律（比字节那种规律好找多了），大家都要争取AK呀（本次题解由一串甜投稿）</p>
<h2 id="开幕式排练">开幕式排练</h2>
<p>时间限制:3000MS 内存限制:655360KB</p>
<p><strong>题目描述:</strong></p>
<p>导演在组织进行大运会开幕式的排练，其中一个环节是需要参演人员围成一个环形。演出人员站成了一圈，出于美观度的考虑，导演不希望某一个演员身边的其他人比他低太多或者高太多。</p>
<p>现在给出n个参演人员的身高，问在他们站成一圈时，相邻演员的身高差的最大值至少是多少?
请你帮忙计算。</p>
<p><strong>输入描述</strong></p>
<p>输入包括两行，第一行有1个正整数，代表人数n。</p>
<p>第二行有n个空格隔开的正整数h表示第i个演员的身高。</p>
<p>数据保证2&lt;=n&lt;=10<sup>5,1&lt;=hi&lt;=10</sup>9。</p>
<p><strong>输出描述</strong></p>
<p>输出包括一个正整数，表示答案。</p>
<p><strong>样例输入</strong></p>
<p><code>5   2 1 1 3 2</code></p>
<p><strong>样例输出</strong></p>
<p><code>1</code></p>
<p><strong>思路与代码</strong></p>
<p>将数组排序，然后声明一个新数组，均匀的向两边插入元素，最后遍历一遍数组求出最大值。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;p[i];</span><br><span class="line">   <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">   ans.<span class="built_in">push_back</span>(p[n<span class="number">-1</span>]);</span><br><span class="line">   <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(j % <span class="number">2</span>==<span class="number">0</span>) ans.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">      <span class="keyword">else</span> ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(),p[i]);</span><br><span class="line">      j^=<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">       maxx=<span class="built_in">max</span>(maxx,<span class="built_in">abs</span>(ans[i]-ans[(i+<span class="number">1</span>)%n]));</span><br><span class="line">   cout &lt;&lt;maxx&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最少数字">最少数字</h2>
<p>小明用计算机随机生成了N个正整数，他希望从这N个数中选取若千个数，使得它们的和等于M。这些随机生成的数字可能会相同，但是每个数字最多只允许使用一次。</p>
<p>当然这样的选取方案可能不存在，也可能有多个。现在希望你编写一个程序，能够找出数字个数最少的选取方案，输出对应的最少数字的个数，如果无解输出“No
solution”。</p>
<p><strong>输入描述</strong></p>
<p>单组输入，每组输入2行。</p>
<p>第1行包含两个正整数N和M，分别表示初始输入的正整数个数和目标数字和(N&lt;=1e3,M&lt;=1e5)。</p>
<p>第2行为N个正整数，两两之间用空格隔开(每一个正整数均小于等于1e5)。</p>
<p><strong>输出描述</strong></p>
<p>输出数字个数最少的选取方案中所包含的最少数字个数，如果无解输出“No
solution”</p>
<p><strong>样例输入</strong></p>
<p><code>5 5   1 3 2 1 1</code></p>
<p><strong>样例输出</strong></p>
<p><code>2</code></p>
<p><strong>思路与代码</strong></p>
<p>设置一个f数组，初始值都设置为10^9级别，这个数组代表的意思是，和为当前数组下标所需的最小数字个数，然后遍历输入的数组arr，将f中的值调整为最优。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>   </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">100010</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;  </span><br><span class="line">	<span class="type">int</span> inf =<span class="number">0x3f3f3f3f</span>;  </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		f[i]=inf; </span><br><span class="line">	</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		cin&gt;&gt;arr[i];  </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;  </span><br><span class="line">		<span class="type">int</span> j=m;  </span><br><span class="line">		<span class="keyword">while</span> (j&gt;=arr[i]) &#123;  </span><br><span class="line">			<span class="keyword">if</span>(f[j-arr[i]]!=inf) f[j]=min[f[j],f[j-arr[i]]+<span class="number">1</span>);  </span><br><span class="line">			j--;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">if</span>(f[m] != inf)</span><br><span class="line">		cout &lt;&lt; f[m] &lt;&lt; endl;  </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout <span class="string">&quot;No solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>微众银行1008秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E5%BE%AE%E4%BC%97%E9%93%B6%E8%A1%8C1008%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>难度比较低，第一题是简单的最短路。第二题第三题都是比较基础的题目，第三题更加离谱，看起来很难，实际上非常水</p>
<h2 id="第一题">第一题</h2>
<p>现在小丽在城镇A，小明在城镇B。小丽要出发找小明。</p>
<p>城镇之间有双向通行的道路，通过道路要消耗一定的时间。</p>
<p>其中已知城镇C和城镇D之间有双向的传送门，可以不消耗时间瞬间传送过去</p>
<p>现在请你求出小丽从城镇A抵达城镇B的最短时间。保证从起点到终点有路径可达。</p>
<p><strong>输入描述</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行两个正整数n,m，以空格分开，表示总共有n个城镇，有m条道路相连  </span><br><span class="line">第二行两个正整数A,B，以空格分开，分别表示小丽所在城镇A，小明所在城镇B。  </span><br><span class="line">第三行两个正整数C，D，以空格分开，表示城镇C和城镇D之间有瞬间的双向传送门。  </span><br><span class="line">接下来m行，每行三个正整数u,v, c，以空格分开，表示城镇u和城镇v之间有道路，通过道路消耗时间c。  </span><br><span class="line">对于100%的数据保证 1&lt;=n &lt;=100,1&lt;=m&lt;=2*n，每条道路的时间花费在[1,10]之间</span><br></pre></td></tr></table></figure></p>
<p><strong>输出描述</strong></p>
<p>一行，一个整教表示最短到达时间。</p>
<p><strong>样例输入</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3  </span><br><span class="line">1 4  </span><br><span class="line">1 3  </span><br><span class="line">1 2 1  </span><br><span class="line">2 3 1  </span><br><span class="line">2 4 1</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p><strong>思路与代码</strong></p>
<p>Floyd算法求最短路的经典应用。按照题意建图，并且手动更改城镇C和D之间的距离为0，进而跑最短路即可。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">int</span> n,m,a,b,c,d;  </span><br><span class="line"><span class="type">int</span> dis[<span class="number">555</span>][<span class="number">555</span>];  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);  </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;  </span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u,v,x,i = <span class="number">1</span>; i&lt;=m; i++) &#123;  </span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;x;  </span><br><span class="line">        dis[u][v] = <span class="built_in">min</span>(dis[u][v], x);  </span><br><span class="line">        dis[v][u] = <span class="built_in">min</span>(dis[v][u], x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    dis[c][d] = dis[d][c] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k&lt;=n; k++) &#123;  </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=n; j++) dis[i][j] = <span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);  </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; dis[a][b];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第二题">第二题</h2>
<p>时间限制:4000MS 内存限制:589824KB</p>
<p><strong>题目描述:</strong></p>
<p>A市可以看作是一个n行m列的方格图，第i行第j列的坐标为(i,j)。其中一些坐标上有楼房，一些位置则为空。</p>
<p>这个区域内需要在(Xt,yt)这个坐标修一栋大楼，因此需要启用塔吊来完成这项建筑工作。但是塔吊不能安置在吊臂长度的范围内有其他楼房的位置。更准确地说，塔吊的吊管长度为R，设塔吊安装的坐标为(Xd,Yd)，楼房的坐标为(x,y)，那么所有楼房的坐标都必须满足|xd-x|+|yd-y|&gt;R.</p>
<p>同时，塔吊吊臂必须能够到需要修大楼的位置，也就是|xd-xt|+|yd-yt|&lt;=R。</p>
<p>你的任务是找出有多少个坐标可以安置这个塔吊。注意，你只能把塔吊安置在空地位置.</p>
<p><strong>输入描述</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入三个正整数n,m,R  </span><br><span class="line">接下来输入一个n行m列的字符矩阵，其中字符0表示这个地方为空地，1表示这个地方有一栋楼房，2表示需要修大楼的坐标，数据保证字符矩阵恰好有一个2.  </span><br><span class="line">对于100%的数据,1&lt;=n,m,R&lt;=400</span><br></pre></td></tr></table></figure></p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示能安置塔吊的坐标数量。</p>
<p><strong>样例输入</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 2  </span><br><span class="line">01000  </span><br><span class="line">00010  </span><br><span class="line">00200  </span><br><span class="line">00001</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p><strong>提示</strong></p>
<p>可以放在(3,1)和(4,2)。</p>
<p><strong>思路与代码</strong></p>
<p>先维护出目标位置和每个有楼房的位置。然后枚举每个空地当做候选点，按照题意进行验证，满足要求则可以该位置安置塔吊，统计即可。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">int</span> n,m,r;  </span><br><span class="line"><span class="type">int</span> a[<span class="number">555</span>][<span class="number">555</span>];  </span><br><span class="line"><span class="type">int</span> tx, ty;  </span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; vv;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;r;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=m; j++) &#123;  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>, &amp;a[i][j]);  </span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">2</span>) tx = i, ty = j;  </span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">1</span>) vv.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,j));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=m; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(a[i][j] != <span class="number">0</span>) <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(i-tx) + <span class="built_in">abs</span>(j-ty) &gt; r) <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="type">int</span> ok = <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : vv) &#123;  </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(x.first-i) + <span class="built_in">abs</span>(x.second-j) &lt;= r) &#123;ok = <span class="number">0</span>;<span class="keyword">break</span>;&#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(ok == <span class="number">1</span>) ans ++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; ans;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三题">第三题</h2>
<p>时间限制: 2000MS内存限制: 65536KB</p>
<p><strong>题目描述:</strong></p>
<p>小明在玩一款全新的挂机游戏，小明有n个英雄，每天都在自动帮小明讨伐怪物获取赏金，渐渐地这些赏金无法满足小明的发展需求了，需要挑战更因难的关卡获得更多的赏金，小明要给这些英雄升级来满足更因难关卡的入门要求，而这个游戏的升级方式非常特别，唯一升级方式就是让玩家自己选择自己的两个英雄进行每日历练，如果这两个英雄等级相同，则不有任何事情发生。如果等级不同，等级高的那个英雄可以增加一级等级，而等级低的那个英维等级不会发生任何变化，小明想要挑战的下一个关卡需求至少一位英维等级达到2147483647级，小明想知道自己有多少个英雄有望达成这样的要求。</p>
<p><strong>输入描述</strong></p>
<p><code>第一行1个整数n，表示小明的英雄数量   第二行n个整数u1u2...un。表示小明英雄们的初始等级   对于100%的数据，1&lt;=n&lt;=50000，1&lt;=ui&lt;=100000</code></p>
<p><strong>输出描述</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行1个整数n，表示小明的英雄数量  </span><br><span class="line">第二行n个整数u1u2...un。表示小明英雄们的初始等级  </span><br><span class="line">对于100%的数据，1&lt;=n&lt;=50000，1&lt;=ui&lt;=100000</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输入</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5  </span><br><span class="line">1 2 3 1 2</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p><strong>思路与代码</strong></p>
<p>由题意知，只要一个英雄可以被升级，那么就可以达到2147483647级。而只有最小等级的英雄不会被升级，其他等级的英雄都可以和最小等级的英雄一起历练从而升级。所以只需要统计有哪些英雄不是最小的等级的即可。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>],n;  </span><br><span class="line"><span class="type">int</span> mn = <span class="number">1e9</span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cin&gt;&gt;n;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;  </span><br><span class="line">        cin&gt;&gt;a[i];  </span><br><span class="line">        mn = <span class="built_in">min</span>(a[i], mn);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> ans = n;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(a[i] == mn) ans--;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; ans;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>转载：<a
href="%5B微众银行1008秋招笔试真题解析%20(qq.com)%5D(https://mp.weixin.qq.com/s/ovhjvK14LWLRGI0M9IyPjA)">微众银行1008秋招笔试真题解析</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>滴滴0928秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E6%BB%B4%E6%BB%B40928%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>题目难度中等偏上，第一题的dp用记忆化搜索来做会更好思考，直接迭代维度有点多，不太好写。第二题树形dp也需要多关注规定的性质才好推导。</p>
<h2 id="第一题">第一题</h2>
<p>一家木材厂需要加工三根圆木。这三根圆木长度分别为
a,b,c，一共需要进行不超过n次加工程序。第i道加工程序需要选择其中一根长度严格大于i的圆木，将其切割，使其长度减少i。被切下的部分不再进入后续的加工流程。如果这三根圆木的长度能够组成一个面积大于0的三角形，那么就称此时的圆木长度三元组(ab,c)是好的
现在的问题是:一共可能形成多少种好的三元组?</p>
<p><strong>输入描述</strong></p>
<p>输入仅一行四个正整数n,a,b,c。对于100%的数据，1&lt;=n,a,b,c&lt;=100</p>
<p><strong>输出描述</strong></p>
<p>输出一行，一个整数，表示好的三元组的个数</p>
<p><strong>样例输入</strong></p>
<p>5 3 4 5</p>
<p><strong>样例输出</strong></p>
<p>10</p>
<p><strong>提示</strong></p>
<p>有如下10种三元组
(1,4,4),(2,2,2),(2,4,3),(2,4,5),(3,2,4),(3,3,3),(3,3,5),(3,4,2),(3,4,4),(3,4,5)</p>
<p>n为5即可加工不超过5次，原始3根圆木的长度为3，4，5</p>
<p>以(1,4,4)为例，可以第1道加工长度为5的圆木，使其长度变为4，第2道加工长度为3的圆木，使其长度变为1。此时不再进行加工，3根圆木的长度为1，4，4可以构成面积不为0的三角形</p>
<p>以(2,2,2)为例，可以第1道加工长度为3的圆木，使其长度变为2，第2道加工长度为4的圆木，使其长度变为2;第3道加工长度为5的圆木，使其长度变为2。此时不再进行加工，3根圆木的长度为2,2,2可以构成面积不为0的三角形</p>
<p>其他组合以此类推</p>
<p><strong>思路与代码：</strong></p>
<p>动态规划（偏暴力） 或 记忆化dfs</p>
<p>给出动态规划的思路和代码</p>
<p>定义dp[i] [j] [k] [l] 表示，第i次加工，三根木棍分别长j k
l是否存在;</p>
<p>同时定义vis[j] [k] [l] 表示，三元组j k l是否已访问;</p>
<p>判断能否构成三角形可以通过两条短边之和是否大于最大边来判断；</p>
<p>在过程中判断能构成三角形的三元组在第一次访问时累加答案；</p>
<p>初始情况为dp[0] [a] [b] [c] = 1;</p>
<p>接下来就是循环中分别尝试对三条边做减操作；</p>
<p>时间复杂度O(nabc)，题目时限4s，能过<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> ma = <span class="built_in">max</span>(&#123;a, b, c&#125;);</span><br><span class="line"> <span class="keyword">if</span>(a + b + c - ma &gt; ma) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> n, a, b, c;</span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"> cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"> <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"> <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line"> dp[<span class="number">0</span>][a][b][c] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">judge</span>(a, b, c) == <span class="number">1</span>) &#123;</span><br><span class="line">  ans++;</span><br><span class="line"> &#125;</span><br><span class="line"> vis[a][b][c] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a; j++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= b; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= c; l++) &#123;</span><br><span class="line">     <span class="keyword">if</span>(j - i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j][k][l] != <span class="number">0</span>) &#123;</span><br><span class="line">      dp[i][j - i][k][l] = dp[i - <span class="number">1</span>][j][k][l];</span><br><span class="line">      <span class="keyword">if</span>(vis[j - i][k][l] == <span class="number">0</span> &amp;&amp; <span class="built_in">judge</span>(j - i, k, l) == <span class="number">1</span>) &#123;</span><br><span class="line">       ans++;</span><br><span class="line">       vis[j - i][k][l] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(k - i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j][k][l] != <span class="number">0</span>) &#123;</span><br><span class="line">      dp[i][j][k - i][l] = dp[i - <span class="number">1</span>][j][k][l];</span><br><span class="line">      <span class="keyword">if</span>(vis[j][k - i][l] == <span class="number">0</span> &amp;&amp; <span class="built_in">judge</span>(j, k - i, l) == <span class="number">1</span>) &#123;</span><br><span class="line">       ans++;</span><br><span class="line">       vis[j][k - i][l] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(l - i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j][k][l] != <span class="number">0</span>) &#123;</span><br><span class="line">      dp[i][j][k][l - i] = dp[i - <span class="number">1</span>][j][k][l];</span><br><span class="line">      <span class="keyword">if</span>(vis[j][k][l - i] == <span class="number">0</span> &amp;&amp; <span class="built_in">judge</span>(j, k, l - i) == <span class="number">1</span>) &#123;</span><br><span class="line">       ans++;</span><br><span class="line">       vis[j][k][l - i] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第二题">第二题</h2>
<p>小明正在把玩一棵树。他正在研究树的平衡性，他为了辅助研究，为树定义了一个函数S(x)，表示对树中节点x，其到树中其他所有节点的距离之和，注意树上相邻节点之间距离为1而且树根为1号节点。现在他想让你帮他进行计算!</p>
<p><strong>输入描述</strong></p>
<p>第一行两个正整数n和m，分别表示树上节点数和询问数。</p>
<p>接下来一行n-1个数P2，P3，... ,Pn· 表示节点i的父亲为Pi。</p>
<p>接下来一行m个数x1，x2，xm，分别表示每次询问所使用的x值
对于所有数据，1&lt;= n ,m&lt;=20000，1&lt;= pi &lt; n，1&lt;= xi&lt;
n</p>
<p><strong>输出描述</strong></p>
<p>输出一行m个数，单空格隔开，分别表示每次询问的答案</p>
<p><strong>样例输入</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 1</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出</strong><br />
<code>2 3 3</code></p>
<p><strong>提示</strong></p>
<p>样例图为 1是根节点，2、3节点是1号节点的子节点；</p>
<p>1号节点到2号节点的距离为1，到3号节点的距离为1，所以答案为2；</p>
<p>2号节点到1号节点的距离为1，到3号节点的距离为2，所以答案为3；</p>
<p>3号节点到1号节点的距离为1，到2号节点的距离为2，所以答案为3。</p>
<p><strong>思路与代码：</strong></p>
<p>换根dp，力扣834题的变形</p>
<p>首先计算根节点到其他节点的距离和</p>
<p><code>dp[u]</code>表示以u为根的子树，其所有子节点到它的距离，<code>nodes[u]</code>
表示以u为根的子树的节点数量，可以得到树形dp递推式</p>
<p>由此dfs可得到<code>dp[root]</code>。</p>
<p>为了避免每个根都重复计算，接下来要进行换根操作</p>
<p>让 v 换到根u的位置，u 变为其孩子节点，同时维护原有的 dp
信息，该过程中只会改变<code>dp[u]</code>和<code>dp[v]</code>，只更新这两者即可</p>
<p>回顾之前计算<code>dp[]</code>的过程，改动后，<code>dp[u]</code>要减去原来节点v的部分，即<code>dp[u] -= dp[v] + nodes[v]</code></p>
<p>同时nodes也要相应减少，<code>nodes[u] -= nodes[v];</code></p>
<p>与此同时，<code>dp[v]</code>
和<code>nodes[v]</code>也有相应的加操作<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[v] += dp[u] + nodes[u]; nodes[v] += nodes[u];</span><br></pre></td></tr></table></figure></p>
<p>此时就完成了换根，在O(1)时间内得到以v为根的dp值，之后就是dfs和相应的回溯操作；</p>
<p>本题的改动点就在于树的边的输入，以及查询，另外节点是从1开始的，代码上统一调整从0开始；<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">using</span> gg = <span class="type">long</span> <span class="type">long</span>;  </span><br><span class="line">  </span><br><span class="line">vector&lt;vector&lt;gg&gt;&gt; map1;  </span><br><span class="line">vector&lt;gg&gt; dp, nodes, ans;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(gg u, gg fa)</span> </span>&#123;  </span><br><span class="line"> dp[u] = <span class="number">0</span>;  </span><br><span class="line"> nodes[u] = <span class="number">1</span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : map1[u]) &#123;  </span><br><span class="line">  <span class="keyword">if</span>(ch == fa) <span class="keyword">continue</span>;  </span><br><span class="line">  <span class="built_in">dfs</span>(ch, u);  </span><br><span class="line">  dp[u] += dp[ch] + nodes[ch];  </span><br><span class="line">  nodes[u] += nodes[ch];  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(gg u, gg fa)</span> </span>&#123;  </span><br><span class="line"> ans[u] = dp[u];  </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : map1[u]) &#123;  </span><br><span class="line">  <span class="keyword">if</span>(ch == fa) <span class="keyword">continue</span>;  </span><br><span class="line">  gg su = dp[u], sc = nodes[u];  </span><br><span class="line">  gg cu = dp[ch], cc = nodes[ch];  </span><br><span class="line">          </span><br><span class="line">  dp[u] -= dp[ch] + nodes[ch];  </span><br><span class="line">  nodes[u] -= nodes[ch];  </span><br><span class="line">  dp[ch] += dp[u] + nodes[u];  </span><br><span class="line">  nodes[ch] += nodes[u];  </span><br><span class="line">          </span><br><span class="line">  <span class="built_in">dfs2</span>(ch, u);  </span><br><span class="line">  <span class="comment">// 回溯  </span></span><br><span class="line">  dp[u] = su; nodes[u] = sc;  </span><br><span class="line">  dp[ch] = cu; nodes[ch] = cc;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> gg n, m; cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line"> dp.<span class="built_in">resize</span>(n); ans.<span class="built_in">resize</span>(n); nodes.<span class="built_in">resize</span>(n);  </span><br><span class="line"> map1.<span class="built_in">resize</span>(n, &#123;&#125;);  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">  gg x; cin &gt;&gt; x;  </span><br><span class="line">  gg u = i - <span class="number">1</span>, v = x - <span class="number">1</span>;  </span><br><span class="line">  map1[u].<span class="built_in">push_back</span>(v);  </span><br><span class="line">  map1[v].<span class="built_in">push_back</span>(u);  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);  </span><br><span class="line"> <span class="built_in">dfs2</span>(<span class="number">0</span>, <span class="number">-1</span>);  </span><br><span class="line"> <span class="function">vector&lt;gg&gt; <span class="title">pans</span><span class="params">(m)</span></span>;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">  gg ask; cin &gt;&gt; ask;  </span><br><span class="line">  pans[i] = ans[ask<span class="number">-1</span>];  </span><br><span class="line"> &#125;  </span><br><span class="line"> cout &lt;&lt; pans[<span class="number">0</span>];  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pans[i];  </span><br><span class="line"> cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;   </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>米哈游0813秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E7%B1%B3%E5%93%88%E6%B8%B80813%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>看到米哈游的校招其实还蛮感慨的，在20届的春招（也就是2020年4月份），米哈游开出的sp是23.8w。那个时候米哈游的面试强度已经很大了，很多拿到米哈游的同学后面都接了其他公司的offer，21届的同学拿到差不多就有30w左右了，20届被倒挂懵了，当然后面也都涨上来了（倒挂最严重的是tplink，19届被20届倒挂了十来万）。短短两三年时间，米哈游也成为了一家当之无愧的一线大厂。个人还是非常喜欢米哈游这家公司的，一家有情怀的大厂！</p>
<p>本场题目难度适中，最后一题数学题可能有些绕（也有dp的思路）。争取至少要A2道！</p>
<h2 id="第一题">第一题</h2>
<p>米小游和奥托主教冲虚树之树后，掉入量子之海里失散了，但她不知道奥托主教在哪里，所以她决定先去寻找月下，再让月下带着她一起去找奥托主教。</p>
<p>已知量子之海可以认为是一个n*
m的矩阵，左下角坐标为(1,1)，右上角坐标是(n,m)。米小游每次可以走到相邻的坐标，即当|x1-x2|十|y1
-y2|= 1时，米小游可以从(x1,y1)走到(x2,y2)。</p>
<p>另外，量子之海有一个特殊的特性，其左边界和右边界是相邻的，上边界和下边界也是相邻的。也就是说，(x,1)和(x,m)
相邻，(1,y)和(n,y)也是相邻的。</p>
<p>现在按顺序给定了米小游、月下和奥托主教的坐标，请你判断米小游最少需要走几步。</p>
<p><strong>输入描述</strong></p>
<p>第一行输入两个整数n,m(1&lt;=n,m&lt;=10^9)表示量子之海大小。</p>
<p>接下来三行，每行输入两个整数x(1
&lt;=x&lt;=n),y(1&lt;=y&lt;=m)表示按顺序给出的点的坐标。</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数表示最少需要走的步数。</p>
<p><strong>思路与代码</strong></p>
<p>每次移动只会改变x或者y，因此可以独立进行考虑考虑×1移动到×2时,怎样才能最短
有两种做法,要么顺着走,要么逆着走因此两个分别计算，取最小值即可<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n , m= <span class="built_in">map</span>(<span class="built_in">int</span> , <span class="built_in">input</span>().split())</span><br><span class="line">x1 , y1 = <span class="built_in">map</span>(<span class="built_in">int</span> , <span class="built_in">input</span>().split())</span><br><span class="line">x2 , y2 = <span class="built_in">map</span>(<span class="built_in">int</span> , <span class="built_in">input</span>().split())</span><br><span class="line">x3 , y3 = <span class="built_in">map</span>(<span class="built_in">int</span> , <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">x , y , n</span>) :</span><br><span class="line">    v = <span class="built_in">abs</span>(x -y)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(v , n - v)</span><br><span class="line"><span class="comment">#独立计算x和y的最小距离和</span></span><br><span class="line"><span class="built_in">print</span>(calc(x1 , x2 , n) + calc( x2 , x3 , n) + calc(y1 , y2 , m) + calc(y2 , y3 , m))</span><br></pre></td></tr></table></figure></p>
<h2 id="第二题">第二题</h2>
<p>米小游拿到了一棵有根树，树上有
n个节点，根节点编号为1，所有边的长度均为1。</p>
<p>米小游每一次操作可以将一个新叶子节点接在原来的一个叶子上，新加的边的边长度也是1。米小游可以进行任意次操作。</p>
<p>她想知道，操作结束后，与根节点的距离不超过k
的节点个数的最大值是多少。</p>
<p><strong>输入描述</strong></p>
<p>第一行输入两个整数n(1&lt;=n&lt;=10<sup>5),k(0&lt;=k&lt;=10</sup>9)</p>
<p>接下来n-1行，每行输入两个整数u,u(1&lt;=u,v&lt;=n)表示节点u和节点v之间有一条边。</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数表示答案。</p>
<p><strong>示例1</strong></p>
<p><strong>输入</strong></p>
<p><code>4 2   1 2   1 3   2 4</code></p>
<p><strong>输出</strong></p>
<p><code>5</code></p>
<p><strong>说明</strong></p>
<p>如下图，1号节点为根节点(粉色)，初始时3号节点和4号节点为叶子节点，可以在3号节点上增加一个叶子节点，也就是5号节点(蓝色)。在4号节点上增加节点并不会影响答案，因此答案为5。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/yUlgRBVNujJDoTiaGPJtBnCbWobXnzN4EI3ETBZR4Avzz07mXL1Lsib5FcOHy3rGtsqSUjuqKt3ica3bx0RjxJVpg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p><strong>思路与代码</strong></p>
<p>bfs遍历。</p>
<p>标记所有节点距离根节点的距离。如果存在一个节点为叶子节点且距离小于k，那么说明可以不断地在该节点添加k-dis[i]个新节点。<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n , k = <span class="built_in">map</span>(<span class="built_in">int</span> , <span class="built_in">input</span>().split())</span><br><span class="line">edge = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="comment"># edge保存边</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">	x , y = <span class="built_in">map</span>(<span class="built_in">int</span> , <span class="built_in">input</span>().split())</span><br><span class="line">	edge [x].append(y)</span><br><span class="line">	edge[y].append(x)<span class="comment">#添加双向边</span></span><br><span class="line">que = deque()</span><br><span class="line">que.append(<span class="number">1</span>)</span><br><span class="line">dis = [-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">leaf = [<span class="literal">True</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"><span class="comment"># dis表示1号点到其他点的距离/深度,leaf表示该点是否是叶子</span></span><br><span class="line">dis [<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> L&lt; <span class="built_in">len</span>(que):<span class="comment">#进行bfs, que表示bfs的队列</span></span><br><span class="line">    x = que.popleft()</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> edge[x] :</span><br><span class="line">        <span class="keyword">if</span> dis[y] == -<span class="number">1</span> :<span class="comment">#如果y点未出现过，则添加到队列里，并更新信息</span></span><br><span class="line">            leaf[x] = <span class="literal">False</span></span><br><span class="line">            dis[y] = dis [x] +<span class="number">1</span></span><br><span class="line">            que.append(y)</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , n+ <span class="number">1</span>):<span class="comment">#遍历所有节点</span></span><br><span class="line">    <span class="keyword">if</span> dis[i] &gt;k:<span class="comment">#如果距离大于k,则对答案没有贡献,直接跳过</span></span><br><span class="line">     <span class="keyword">continue</span></span><br><span class="line">    ans += <span class="number">1</span> <span class="comment">#否则则对答案有1的贡献</span></span><br><span class="line">    <span class="keyword">if</span> leaf[i] :<span class="comment">#如果它是叶子，则能够在该点不断添加新叶子，对答案产生新的贡献</span></span><br><span class="line">     ans += k - dis [i]</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure></p>
<h2 id="第三题">第三题</h2>
<p>米小游原神up池已经好久没有歪啦！给大家来点小小的九连不歪震撼！</p>
<p>已知《原神》和《崩坏：星穹铁道》中的抽卡系统的概率如下：</p>
<p>在未触发大保底机制时，每抽一发有 p/2 的概率抽到当期5星，有p/2
的概率抽到常驻5星，其余的1- p 概率不出5星。</p>
<p>当抽到常驻5星后，触发了大保底机制，以后每抽一发有 p
的概率抽到当期5星，其余的 1-p 概率不出5星。</p>
<p>另外，当连续89抽未出5星时，下一抽必出5星。也就是说，若未触发大保底机制，本次抽卡
1/2 概率抽到当期5星，有 1/2
的概率抽到常驻5星，若已触发了大保底机制，则100%概率抽到当期5星。</p>
<p>现在给定了抽中5星的概率
p。米小游想要抽到一张当期5星卡，她想知道抽卡次数的期望是多少?</p>
<p><strong>输入描述</strong></p>
<p>一个小数 p(0 &lt; p&lt; 1)，代表抽中5星的概率。</p>
<p><strong>输出描述</strong></p>
<p>一个浮点数，代表抽卡次数的期望。如果你的答案和正确答案的误差不超过
10^-6，则认为答案正确。</p>
<p><strong>示例1</strong></p>
<p><strong>输入</strong></p>
<p><code>0.006</code></p>
<p><strong>输出</strong></p>
<p><code>104.5497057</code></p>
<p><strong>思路与代码</strong></p>
<p>数学题。</p>
<p>这个题目的代码思路就是通过枚举每一种情况下触发大保底机制前和触发大保底机制后所需的抽卡次数来计算最终的答案。</p>
<p>函数 <code>calc(x)</code> 来计算在第 <code>x</code> 次抽卡时抽到5星的概率。这个函数的实现是通过计算前 <code>x-1</code> 次都没有抽到5星的概率，然后乘以第 <code>x</code> 次抽到5星的概率。如果 <code>x &lt; 90</code>，那么第 <code>x</code> 次抽到5星的概率就是 <code>p</code>，否则就是1。</p>
<p>我们计算在未触发大保底机制时抽到当期5星卡的期望次数。这个期望次数可以通过枚举每一次抽卡时抽到当期5星卡的概率来计算。因为在未触发大保底机制时，每次抽卡有 <code>p/2</code> 的概率抽到当期5星卡，所以我们可以用 <code>ans += i * calc(i) / 2</code> 来累加每一次抽卡时抽到当期5星卡的期望次数。</p>
<p>最后，我们计算在触发大保底机制后抽到当期5星卡的期望次数。这个期望次数可以通过枚举触发大保底机制时所需的抽卡次数和触发大保底机制后再抽多少次才能抽到当期5星卡来计算。因为在触发大保底机制后，每次抽卡有 <code>p</code> 的概率抽到当期5星卡，所以我们可以用 <code>ans += (i + j) * p1 * p2</code> 来累加每一种情况下触发大保底机制后再抽多少次才能抽到当期5星卡的期望次数。<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">x</span>) :</span><br><span class="line">    tmp = <span class="built_in">pow</span>(<span class="number">1</span> -p , x -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> x&lt; <span class="number">90</span> :</span><br><span class="line">     tmp *= p</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">    </span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , <span class="number">91</span>) :<span class="comment">#枚举第一次出五星没歪的期望</span></span><br><span class="line"> ans += i * calc(i)/ <span class="number">2</span><span class="comment">#计算第i次出货的概率，累计对应的期望</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , <span class="number">91</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , <span class="number">91</span>） :<span class="comment">#枚举第一次出五星歪了的概率</span></span><br><span class="line">		p1 , p2 =calc(i)/ <span class="number">2</span> , calc(j)</span><br><span class="line">		<span class="comment"># p1表示第i次出货但是歪了的概率，p2表示歪了后第j次出大保底的概率</span></span><br><span class="line">		ans += (i +j)* p1* p2<span class="comment">#累计对应的期望</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯0910秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E8%85%BE%E8%AE%AF0910%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="第一题">第一题</h3>
<p>牛牛有一棵二叉树，该二叉树节点的权值为0/1.
牛牛给你这棵二叉树,想让你告诉他该二叉树从根节点到叶子节点的所有路径中,节点"权值1的个数"比权值0的个数"多1的路径有多少条呢。
返回路径数目。</p>
<p><strong>示例1</strong></p>
<p><code>// 输入   &#123;1, 0, 0, 1, 0, #, 1&#125;      // 输出   2</code></p>
<p><strong>示例2</strong></p>
<p><code>// 输入   &#123;0, 1, 1, 0, 1, 1, 0&#125;      // 输出   2</code></p>
<p><strong>思路与代码：</strong></p>
<p>题目比较简单，<strong>深度优先搜索</strong>，并记录权值为1的节点个数
one 和 权值为0的节点个数
zero，对叶子节点进行判断，<code>ans += ((one - zero) == 1)</code> ；<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathNumber</span><span class="params">(TreeNode* root)</span> </span>&#123;  </span><br><span class="line">        <span class="built_in">helper</span>(root, <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">int</span> one, <span class="type">int</span> zero)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">int</span> d1 = root-&gt;val == <span class="number">1</span>, d2 = root-&gt;val == <span class="number">0</span>;  </span><br><span class="line">        one += d1, zero += d2;  </span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) ans += ((one - zero) == <span class="number">1</span>);  </span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left, one, zero);  </span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right, one, zero);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="第二题">第二题</h2>
<p>牛牛有—个长度为n的序列a，以及—个长度为n-1的序列b，序列b中的元素不重复。
对于这个序列a牛牛会先求出他的中位数，然后再根据序列b的顺序依次删除原序列a中对应下标的元素，即删除α[b[i]],0&lt;=i&lt;n
-1.
每次删除完—个数后，牛牛会统计序列a中剩下的数的中位数是什么，若剩下的数为奇数牛牛会取中问数(排序后),若为偶数牛牛会取中间两个数的平均值(排序后)。
牛牛把每次的结果都记录下来了，但是他怕出错，给你初始的序列a和b，希望你能帮他验证一下。</p>
<p><strong>输入描述：</strong></p>
<p>第一行为一个t,表示有t组数据。
接下来有3×行,每组数据的第一行为n表示序列长度。第二行为n个整数，表示序列a的元素。
第三行为n-1个整数,表示序列b的元素。</p>
<p><strong>输出描述：</strong></p>
<p>输出为行,每行有n个整数,表示每组数据的答案,其中输出若是浮点数保留小数点后一位,否则按整数输出。</p>
<p><strong>示例1：</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输入  </span><br><span class="line">2  </span><br><span class="line">5  </span><br><span class="line">2 2 1 3 5  </span><br><span class="line">3 1 2 5  </span><br><span class="line">4  </span><br><span class="line">1 1 1 1   </span><br><span class="line">1 2 3  </span><br><span class="line">  </span><br><span class="line">// 输出  </span><br><span class="line">2 2.5 3 4 3  </span><br><span class="line">1 1 1 1  </span><br><span class="line">  </span><br><span class="line">// 说明  </span><br><span class="line">第一组数据中,初始序列a的中位数为2,输出2。  </span><br><span class="line">第一次要删掉α[b[0]]=a[3]=1后,中位数变为2.5，输出2.5,序列变为[2,2,3,5]。  </span><br><span class="line">第二次删掉a[b[1]]一2后,中位数变为3,输出3,序列度为[2,3,5]  </span><br><span class="line">第三次删掉a[b[2]=2后,中位数变为4,输出4，序列变为[3,5]  </span><br><span class="line">第四次删掉a[b[3]]=5后,中位数变为3,输出3，序列为[3]。</span><br></pre></td></tr></table></figure></p>
<p><strong>思路与代码：</strong></p>
<p>（本题存疑）使用multiset保存数组a的全部元素，同时保存中位数迭代器：</p>
<ul>
<li><p>数组长度为奇数，it为中位数迭代器</p></li>
<li><p>数组长度为偶数，it为较大中位数迭代器</p></li>
</ul>
<p>然后根据每次删除的元素和迭代器it指向元素的大小关系，分情况讨论，并移动中位数迭代器：</p>
<ul>
<li><p>删除元素大</p></li>
<li><p>删除元素小</p></li>
<li><p>删除元素和迭代器it指向元素相等</p></li>
</ul>
<p>还有一个需要注意的点是，输出格式，如果是整数则正常输出，否则保留1位小数；这里采用的方法是int截断后，判断差值是否大于0.1；<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;  </span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;  </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n - <span class="number">1</span>)</span></span>;  </span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ans;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; a[i];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) cin &gt;&gt; b[i];  </span><br><span class="line">        <span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(a.begin(), a.end())</span></span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// test  </span></span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">next</span>(st.<span class="built_in">begin</span>(), (n / <span class="number">2</span>));  </span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans.<span class="built_in">push_back</span>(*it);  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="type">double</span> a = *it;  </span><br><span class="line">            it--;  </span><br><span class="line">            <span class="type">double</span> b = *it;  </span><br><span class="line">            ++it;  </span><br><span class="line">            ans.<span class="built_in">push_back</span>((a + b) / <span class="number">2.0</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e : b) &#123;  </span><br><span class="line">            <span class="type">int</span> sz = st.<span class="built_in">size</span>();  </span><br><span class="line">            <span class="type">int</span> de = a[e - <span class="number">1</span>];  </span><br><span class="line">            <span class="keyword">if</span> (de &gt; *it) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (sz &amp; <span class="number">1</span>) &#123;  </span><br><span class="line">                    <span class="type">double</span> a = *it;  </span><br><span class="line">                    <span class="keyword">auto</span> tt = it--;  </span><br><span class="line">                    <span class="type">double</span> b = *it;  </span><br><span class="line">                    ++it;  </span><br><span class="line">                    ans.<span class="built_in">push_back</span>((a + b) / <span class="number">2.0</span>);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    it--;  </span><br><span class="line">                    ans.<span class="built_in">push_back</span>(*it);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (de &lt; *it) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (sz &amp; <span class="number">1</span>) &#123;  </span><br><span class="line">                    <span class="type">double</span> a = *it;  </span><br><span class="line">                    ++it;  </span><br><span class="line">                    <span class="type">double</span> b = *(it);  </span><br><span class="line">                    ans.<span class="built_in">push_back</span>((a + b) / <span class="number">2.0</span>);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    ans.<span class="built_in">push_back</span>(*it);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (sz &amp; <span class="number">1</span>) &#123;  </span><br><span class="line">                    --it;  </span><br><span class="line">                    <span class="type">double</span> a = *it;  </span><br><span class="line">                    ++it; ++it;  </span><br><span class="line">                    <span class="type">double</span> b = *it;  </span><br><span class="line">                    ans.<span class="built_in">push_back</span>((a + b) / <span class="number">2.0</span>);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    it--;  </span><br><span class="line">                    ans.<span class="built_in">push_back</span>(*it);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">auto</span> iter = st.<span class="built_in">find</span>(de);  </span><br><span class="line">            st.<span class="built_in">erase</span>(iter);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : ans) &#123;  </span><br><span class="line">            <span class="type">int</span> c = e;  </span><br><span class="line">            <span class="keyword">if</span> (e - c &gt; <span class="number">0.1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%.1f &quot;</span>, e);  </span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三题">第三题</h2>
<p>牛牛有一个长度为n的数组a={a1, a2,...,
an}，定义f(a)为数组α中每个元素出现次数的最大值,如:f({1,2,3,3})-2,f({1,1,1})=3.
现在牛牛最多可以删除k个数字,现在他想使删除若干数字之后的f(a)尽可能的小,删除a_i的代价是i,请你帮牛牛计算f(a)的最小值以及使f(a)达到最小值的最小代价。</p>
<p><strong>输入描述：</strong></p>
<p>第一行输入两个正整数n,k,表示数组α的长度和最多可以删除的数字的个数。
第二行输入n个由空格隔开的正整数a1,a2,.…., an表示数组a，<span
class="math inline">\(1&lt;k&lt;n&lt;10^5,1&lt;a_i&lt;10^9\)</span></p>
<p><strong>输出描述：</strong></p>
<p>一行输出由空格隔开的两个正整数分别表示f(a)所能达到的最小值以及使f(a)达到最小值的最少代价。</p>
<p><strong>示例1：</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输入  </span><br><span class="line">5 2  </span><br><span class="line">1 1 1 2 2  </span><br><span class="line">  </span><br><span class="line">// 输出  </span><br><span class="line">2 1  </span><br><span class="line">  </span><br><span class="line">// 说明  </span><br><span class="line">只删除a1，花费的代价为1,f(a)=2是最小值,因此答案为21。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输入3 31 1 1// 输出0 6// 说明删除 a1, a2, a3,f(a)-0为最小值。</span><br></pre></td></tr></table></figure></p>
<p><strong>思路与代码：</strong></p>
<p>f(a)越大，需要删除的数越小；f(a)越小，需要删除的数越多；因此f(a)和删除元素的个数是单调关系，因此可以使用 <strong>二分查找</strong>，找到最多删除k个数字达到的最小f(a)值。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;  </span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;  </span><br><span class="line">        cin &gt;&gt; arr[i];  </span><br><span class="line">        mp[arr[i]] += <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ll l = <span class="number">1</span>, r = n, ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;  </span><br><span class="line">        ll mid = (l + r) / <span class="number">2</span>;  </span><br><span class="line">        ll cnt = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : mp) &#123;  </span><br><span class="line">            <span class="type">int</span> k = p-&gt;first, v = p-&gt;second;  </span><br><span class="line">            <span class="keyword">if</span> (v &gt; mid) &#123;  </span><br><span class="line">                cnt += v - mid;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; k) r = mid - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ll t = r;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : mp) &#123;  </span><br><span class="line">        <span class="type">int</span> k = p-&gt;first, v = p-&gt;second;  </span><br><span class="line">        <span class="keyword">if</span> (v &gt; t) &#123;  </span><br><span class="line">            ll cc = (t + <span class="number">1</span> + v) * (v - t) / <span class="number">2</span>;  </span><br><span class="line">            ans += cc;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第四题">第四题</h2>
<p>有n个怪物,第i个怪物的战斗力为a，初始时，牛牛的战斗力为0
牛牛要与这n个怪物战斗，设牛牛与第i个怪物战斗时牛牛的战斗力为 x,，则:</p>
<ol type="1">
<li><p>若x&lt;a,则牛牛触发被动技能"勇敢牛牛不怕困难""使得自己的战斗力提升至α;并战胜这个怪物,这会让牛牛的勇气值提升
ai-x.</p></li>
<li><p>若x
≥a,则牛牛会直接战胜这个怪物,并且本次战斗结束后，牛牛的战斗力会降低至ai.</p></li>
</ol>
<p>牛牛可以任意决定与怪物战斗的顺序，牛牛想知道打败完所有的n只怪物之后，牛牛累计提升的勇气值最大可能是多少。</p>
<p><strong>输入描述：</strong></p>
<p>第一行一个整数n(1&lt;n &lt;200000)。 第二行n个整数a1, a2,..,
an()。</p>
<p><strong>输出描述：</strong></p>
<p>输出一个整数表示牛牛可以得到的最大勇气值。</p>
<p><strong>示例1：</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输入  </span><br><span class="line">2  </span><br><span class="line">1 2  </span><br><span class="line">  </span><br><span class="line">// 输出  </span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输入  </span><br><span class="line">3  </span><br><span class="line">1 2 2  </span><br><span class="line">  </span><br><span class="line">// 输出  </span><br><span class="line">3  </span><br><span class="line">  </span><br><span class="line">// 说明  </span><br><span class="line">牛牛先和编号为2的怪物战斗,此时牛牛的战斗力为0,牛牛获得a2-0=2-0=2的勇气值,之后牛牛的战斗力变为2。  </span><br><span class="line">牛牛再和编号为1的怪物战斗,此时牛牛的战斗力为2,牛牛获得0的勇气值,之后牛牛的战斗力变为1。  </span><br><span class="line">牛牛最后和编号为3的怪物战斗,此时牛牛的战斗力为1,牛牛获得a3-1=2-1=1的勇气值,之后牛牛的战斗力变为2。  </span><br><span class="line">牛牛总共获得2＋1一3的勇气值。</span><br></pre></td></tr></table></figure></p>
<p><strong>思路：</strong></p>
<p>（本题存疑）一个想法是：排序之后，优先和战斗力最大的怪物战斗，然后再和战斗力最小的怪物战斗，依次类推，得到最后答案；<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; a;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>, l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ans += arr[r] - c;</span><br><span class="line">        --r;</span><br><span class="line">        c = arr[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第五题">第五题</h2>
<p>某网站注册时需要输入密码，密码只能包含前m个小写字母，牛牛已经想好了自己密码的长度和某些位置的具体字符,现在需要你帮他确定其他位置的字符使得这个密码的复杂度尽可能大。
设一个密码的长度为len，则这个密码的复杂度等于在前len-1个字符中有多少字符与它后一个字符不同。
例如,对于密码abcc来说,他的复杂度为2，因为第—个和第二个位置的字符不同,第二个和第三个位置的字符也不同,而第三个和第四个位置的字符相同。</p>
<p><strong>输入描述：</strong></p>
<p>第一行两个空格分隔的正整数n,
m,代表牛牛的密码长度和只能使用前m个小写字母。
第二行一个长度为n只包含小写字母的字符串s,保证只含有前m个小写字母和?,?代表需要你来帮忙确定的字符。</p>
<p><strong>输出描述：</strong></p>
<p>一行一个正整数代表密码的最大复杂度。</p>
<p><strong>示例1：</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输入  </span><br><span class="line">9 26  </span><br><span class="line">niuniu???  </span><br><span class="line">  </span><br><span class="line">// 输出  </span><br><span class="line">8  </span><br><span class="line">  </span><br><span class="line">// 说明  </span><br><span class="line">一种可能的密码是niuniuabc。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输入  </span><br><span class="line">5 1  </span><br><span class="line">?????  </span><br><span class="line">  </span><br><span class="line">// 输出  </span><br><span class="line">0  </span><br><span class="line">  </span><br><span class="line">// 说明  </span><br><span class="line">唯一可能的密码是aaaaa。</span><br></pre></td></tr></table></figure></p>
<p><strong>思路与代码：</strong></p>
<p>复杂度的定义是：某个字符不等于它后一个字符的数目；那么贪心思想：如果m&gt;1的话，可以保证?都是满足复杂度定义条件的，而m=1时，就只可以填字符‘a’；因此可以根据m的值判断最终的答案；<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">    string s; cin &gt;&gt; s;  </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, i;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;?&#x27;</span>) <span class="keyword">continue</span>;  </span><br><span class="line">        ans += s[i - <span class="number">1</span>] != s[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) cout &lt;&lt; <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; n - <span class="number">1</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;  </span><br><span class="line">            ans = s[i - <span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span> ans ? : ans + <span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            cout &lt;&lt; ans + n - i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>茄子科技0830秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E8%8C%84%E5%AD%90%E7%A7%91%E6%8A%800830%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>本场难度比较低。不过越简单的笔试就越要注意一些细节，争取ak。</p>
<p>茄子招人其实不多，不过年薪还是很可观的，不比一线大厂低，大家可以试一试。</p>
<p>最后吐槽一句，腾讯的面试真没啥面的必要，面了大概率搞你心态而已。</p>
<h2 id="第一题">第一题</h2>
<p>由于某种众所周知的原因，食堂只开放了一个打饭窗口，已知一共会有n位学生陆陆续续进到食堂。</p>
<p>牛牛知道这n位学生的相关信息，首先将这n位学生编号为1,2,...; n.</p>
<p>每位学生的信息格式如下</p>
<p>l:到达食堂的时间。</p>
<p>s:强壮程度</p>
<p>a:打饭耗时</p>
<p>b:用餐耗时。</p>
<p>r(r&gt;l）:开班会的时间</p>
<p>学生按照到达食堂的时间进行排队，依次排到打饭窗口队伍的队尾，如果相同时间到达，则强壮程度值更高的排在前面，如果也同样强壮，则编号小的排在前面。</p>
<p>当轮到某位学生打饭时，会耗费 a
个单位时间，之后立即轮到排在这位学生后面的学生打饭；</p>
<p>打完饭之后会耗费b个单位时间用餐。</p>
<p>当且仅当用完餐时，尚未开始班会，才有可够赶上，即:如果从t时刻开始打饭，那么，当旦仅当t+a+b&lt;r时，才有可能赶上班会，否则，他/她将选择不吃这顿颈，直接去班会地点。</p>
<p>一旦某位学生发现自己按照现有排队情况无法赶上班会，则他/她会直接走出对列，前往班会地点，即使已经珍到他/她打饭，他/她也会直接离开，不会产生任何其它时间消耗。</p>
<p>假设每一位学生都足够聪明，请你判断每位学生是否能够用餐。</p>
<p><strong>输入描述</strong></p>
<p>本题为多组测试数据，第一行输入一个正整数
T(1&lt;=T&lt;=1000),代表测试数据的组数。</p>
<p>对于每组测试数据，第一行输入一个正整数
n(1&lt;=n&lt;=10^5)，代表到食堂就餐的学生数量。</p>
<p>接下去n行，第i+1行输入五个正整数l,s,a,b,r(1&lt;=l,s,a,b&lt;=10<sup>4;1&lt;=r&lt;=10</sup>9;l&lt;r)，表示编号为i的这位学生的相关信息，具体含义如题所述。</p>
<p>题目保证，所有测试数据的n之和不会超过10^5。</p>
<p><strong>输出描述</strong></p>
<p>对于每组测试数据，一行输出一个长度为n的01串，其中，第i个字符为1，则说明编号为i的这位学生能够顺利用餐;否则，说明这位学生来不及用餐。</p>
<p><strong>示例1</strong></p>
<p><strong>输入</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2  </span><br><span class="line">3  </span><br><span class="line">1 3 1 1 5  </span><br><span class="line">1 1 1 3 7  </span><br><span class="line">1 3 2 1 5  </span><br><span class="line">6  </span><br><span class="line">2 5 5 3 6  </span><br><span class="line">4 1 3 5 6  </span><br><span class="line">1 3 2 3 13  </span><br><span class="line">4 2 5 3 9  </span><br><span class="line">4 2 2 1 6  </span><br><span class="line">1 1 5 3 14</span><br></pre></td></tr></table></figure></p>
<p><strong>输出</strong><br />
<code>110   001001</code></p>
<p><strong>说明</strong></p>
<p>以第一组测试数据为例，根据规则，打饭窗口的队伍顺序从前往后的学生编号依次为
1，3，2，因为他们三位同时间到达食堂，1，3号学生比2号学生更强壮，在1号和3号学生同样强壮的前提下，编号小的排在前面。</p>
<p>1号学生在1时刻到达食堂，打饭耗时1，用餐耗时1，在3
时刻结束用餐，而班会在时刻5的时候才开始，所以他能赶上也就可以安心吃饭;</p>
<p>3 号学生在1号学生打完饭后，也就是2 时刻开始打饭，打饭耗时 2，用餐耗时
1，如果选择用餐的话，他/她会在时刻5的时候结束用餐，此时班会正好开始，来不及，所以这位同学不会选择吃饭，也就不会产生打饭耗时。</p>
<p>由于3号学生没有选择就餐，所以，在1号学生打完饭之后就轮到了2号，也就是2时刻开始打饭，打饭耗时1，用餐耗时
3，如果选择用餐的话，他/她会在时刻6的时候结束用餐，距离班会还有一个单位时间，能够赶上，所以这位同学可以安心吃饭。</p>
<p>综上，1，2 号同学可以吃饭，而 3 号同学不会选择就餐，因此，输出为
110。</p>
<p><strong>思路与代码</strong></p>
<p>模拟题。</p>
<p>/<em>用结构体存储每个学生信息，并进行&lt;重写，之后根据输入信息，判断每一名同学是否来的及班会，并用字符串存储结果</em>/<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span> &#123;  </span><br><span class="line"> <span class="type">int</span> L，s, a, b, r, id;  </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(stu&amp; t) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (L != t.L) <span class="keyword">return</span> L &lt; t.L;  </span><br><span class="line">  <span class="keyword">if</span> (s != t.s) <span class="keyword">return</span> s &gt; t.s;  </span><br><span class="line">  <span class="keyword">return</span> id &lt; t.id;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;a[<span class="number">100010</span>];  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> <span class="type">int</span> ni  </span><br><span class="line">  cin &gt;&gt; n;  </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">  cin &gt;&gt; a[i].L &gt;&gt; a[i].s &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].ri  </span><br><span class="line">   a[i].id = i;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="built_in">sort</span>(a + <span class="number">1</span>，a + <span class="number">1</span> + n);  </span><br><span class="line"> <span class="type">int</span> t = <span class="number">0</span>;  </span><br><span class="line"> string ans;  </span><br><span class="line">        ans.<span class="built_in">resize</span>(n);  </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">  t = <span class="built_in">max</span>(t，a[i].L);  </span><br><span class="line">  <span class="keyword">if</span> (t + a[i].a + a[i].b &lt; a[i].r) &#123;  </span><br><span class="line">   t += a[i].ai  </span><br><span class="line">          ans[a[i].id<span class="number">-1</span>] = <span class="string">&#x27;1&#x27;</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;  </span><br><span class="line">   ans[a[i].id<span class="number">-1</span>] = <span class="string">&#x27;0&#x27;</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"> &#125;  </span><br><span class="line"> cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> <span class="type">int</span> T;  </span><br><span class="line"> cin &gt;&gt; T;  </span><br><span class="line"> <span class="keyword">while</span> (T--) &#123;  </span><br><span class="line">  <span class="built_in">solve</span>();  </span><br><span class="line">  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第二题">第二题</h2>
<p>编写一个函数，将一个字符串中的空格替换成“%100”。</p>
<p><strong>输入描述</strong></p>
<p>输入一段字符串。</p>
<p><strong>输出描述</strong></p>
<p>输出替换空格后的字符串。</p>
<p><strong>示例1</strong></p>
<p><strong>输入</strong></p>
<p>Welcome To Chinatelecom</p>
<p><strong>输出</strong></p>
<p>Welcome%100To%100Chinatelecom</p>
<p><strong>思路与代码</strong></p>
<p>打卡题。</p>
<p>直接模拟即可。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这里注意字符串的输入方式，cin输入是不行的，因为遇到空格就停止了*/</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> tring s;  </span><br><span class="line"> <span class="built_in">getline</span>(cin, s);  </span><br><span class="line"> string ans = <span class="string">&quot;&quot;</span>  </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)&#123;  </span><br><span class="line">           <span class="keyword">if</span> (s[i]--<span class="string">&#x27;&#x27;)   ans += &quot;%100&quot;;  </span></span><br><span class="line"><span class="string">           else            ans += s[i];   </span></span><br><span class="line"><span class="string"> &#125;    </span></span><br><span class="line"><span class="string"> cout &lt;&lt; ans;  </span></span><br><span class="line"><span class="string"> return 0;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里0923秋招笔试真题解析</title>
    <url>/blog/2023/10/11/data/interview/%E4%B8%87%E8%AF%BAcoding/%E9%98%BF%E9%87%8C0923%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>前言：</strong></p>
<p>题目难度适中，最近的难度来看应该算是比较简单的了，大家且行且珍惜</p>
<h2 id="第一题">第一题</h2>
<p>小红有一个长度为n的数组a，她每次操作可以删掉一个三元组
(x,y,z)，要求x&lt;y&lt;z,y是x的倍数，z是y的倍数。小红想知道最多可以执行多少次操作。</p>
<p><strong>输入描述</strong></p>
<p>第一行一个整数几，表示数组的长度。</p>
<p>第二行n 个整数a1,a2，...,an，表示数组的元素</p>
<p>数据范围：<br />
<code>1&lt;=n&lt;=10^5</code><br />
<code>1&lt;=ai&lt;=6</code></p>
<p><strong>输出描述</strong></p>
<p><strong>示例1</strong></p>
<p><strong>输入</strong></p>
<p><code>7   1 1 2 3 4 5 6</code></p>
<p><strong>输出</strong></p>
<p><code>2</code></p>
<p><strong>说明</strong></p>
<p>先删除(1,2,4)，再删除(1,3,6)</p>
<p><strong>思路和代码</strong></p>
<p>全排列，把所有情况列举一遍存在数组里，把所有情况暴力枚举一遍，输出结果。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">int</span> dir[<span class="number">3</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>&#125;&#125;;  </span><br><span class="line"><span class="type">int</span> mp[<span class="number">6</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">7</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> x;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">        cnt[x]++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;  </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">7</span>)</span></span>;  </span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">6</span>;k++) c[k]=cnt[k];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;  </span><br><span class="line">            <span class="type">int</span> id=mp[i][j];  </span><br><span class="line">            <span class="type">int</span> minn=<span class="number">0x3f3f3f3f</span>;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++) minn=<span class="built_in">min</span>(minn,c[dir[id][k]]);  </span><br><span class="line">            sum+=minn;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++) c[dir[id][k]]-=minn;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum);  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第二题">第二题</h2>
<p>小红有一个字符串s，只包含小写字母。如果一个字符串中，不包含连续的三个相同的字母，并且不存在两个相同的字母紧挨着两个相同的字母，那么这个字符串就是合法的。例如，字符串“aaa”是不合法的，字符串"aabb"也是不合法的。字符串”aab”是合法的。</p>
<p>小红想知道，最少需要删除多少个字符，才能使得字符串变成合法的。</p>
<p><strong>输入描述</strong></p>
<p>第一行一个字符串s，长度不超过10^5，只包含小写字母。</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示最少需要删除的字符个数。</p>
<p><strong>示例1</strong></p>
<p><strong>输入</strong></p>
<p><code>aabbaa</code></p>
<p><strong>输出</strong></p>
<p><code>1</code></p>
<p><strong>说明</strong></p>
<p>删除一个字符b，得到 aabaa，是一个合法的字符串。</p>
<p><strong>思路和代码</strong></p>
<p>1、预处理字符串：为了方便后续的处理，代码将字符串<code>s</code>末尾添加了一个特殊字符<code>'#'</code>。2、遍历字符串：计算相同字符连续出现的次数，并将字符及其重复次数拼接到字符串<code>t</code>中。</p>
<p>3、构建向数组a<code>：根据字符串</code>t<code>构建了一个整数向量</code>a<code>，其中向量中的每个元素表示相应位置的字符出现的次数。如果连续的字符出现两次（如"aa"），则将2添加到向量</code>a`中，否则添加1。</p>
<p>4、处理连续的重复字符：如果向量<code>a</code>中的连续两个元素都是2（表示连续的字符出现了两次），则将第二个元素减少1，同时增加<code>ans</code>的值，以确保删除字符以最小化重复子串的数量。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">5</span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    string s;  </span><br><span class="line">    cin&gt;&gt;s;  </span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();  </span><br><span class="line">    s+=<span class="string">&#x27;#&#x27;</span>;  </span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,ans=<span class="number">0</span>;  </span><br><span class="line">    string t;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span> || s[i]==s[i<span class="number">-1</span>]) cnt++;  </span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            t+=<span class="built_in">string</span>(<span class="built_in">min</span>(<span class="number">2</span>,cnt),s[i<span class="number">-1</span>]);  </span><br><span class="line">            ans+=cnt-<span class="built_in">min</span>(<span class="number">2</span>,cnt);  </span><br><span class="line">            cnt=<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> m=t.<span class="built_in">size</span>();  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(i!=m<span class="number">-1</span>&amp;&amp;t[i]==t[i+<span class="number">1</span>])&#123;  </span><br><span class="line">            a.<span class="built_in">push_back</span>(<span class="number">2</span>);  </span><br><span class="line">            i+=<span class="number">1</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            a.<span class="built_in">push_back</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">int</span> sz=a.<span class="built_in">size</span>();  </span><br><span class="line">        <span class="keyword">if</span>(sz&gt;=<span class="number">2</span>&amp;&amp;a[sz<span class="number">-1</span>]==<span class="number">2</span>&amp;&amp;a[sz<span class="number">-2</span>]==<span class="number">2</span>)&#123;  </span><br><span class="line">            a[sz<span class="number">-1</span>]--;  </span><br><span class="line">            ans++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三题">第三题</h2>
<p>小红拿到了一个有根树，根节点为1号节点，每个节点到其每个孩子有条有向边。小红想取一条路径，满足路径上所有节点的权值都不相等。小红想知道，自己有多少种选择方案?</p>
<p><strong>输入描述</strong></p>
<p>第一行输入一个正整数n，代表节点的数量。</p>
<p>第二行输入n一1个正整数ai，代表2号节点到n号节点每个节点的父亲编号。</p>
<p>第三行输入n个正整数vi，代表1号节点到n号节点每个节点的权值。</p>
<p><code>2&lt;=n&lt;=2* 10^5   1&lt;=ai&lt;=i&lt;2* 10^5   1&lt;=vi&lt;=10^9</code></p>
<p><strong>输出描述</strong></p>
<p>小红选择路径的方案数。</p>
<p><strong>示例1</strong></p>
<p><strong>输入</strong></p>
<p><code>5   1 1 1 2   1 1 2 2 2</code></p>
<p><strong>输出</strong></p>
<p><code>8</code></p>
<p><strong>说明</strong></p>
<p>路径上有一个节点，有5种取法。路径上有两个节点的取法有:
1-3、1-4、2-5</p>
<p><strong>思路与代码</strong></p>
<p>深度优先搜索（DFS）：程序通过<code>dfs</code>函数进行深度优先搜索，遍历树的每个节点，并计算节点的深度。</p>
<ul>
<li><p>dfs<code>函数的参数包括当前节点</code>u<code>，其父节点</code>fa<code>，以及当前节点的深度</code>dd`。</p></li>
<li><p>在进入当前节点<code>u</code>之前，记录节点<code>u</code>上一次出现的深度，即<code>p[a[u]]</code>，并将当前节点的深度<code>dd</code>保存在<code>p[a[u]]</code>中。</p></li>
<li><p>计算当前节点<code>u</code>与其最近出现的节点之间的深度差距，即<code>gap = dd - near[u]</code>，并将其加到结果<code>res</code>中。</p></li>
<li><p>遍历节点<code>u</code>的所有子节点，如果子节点不是其父节点<code>fa</code>，则递归调用<code>dfs</code>函数，并将深度加1。</p></li>
<li><p>在递归回溯时，将节点<code>u</code>上一次出现的深度还原回<code>p[a[u]]</code>。</p></li>
<li></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">5</span>;  </span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;  </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[maxn];  </span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="type">int</span> a[maxn],near[maxn];  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readIn</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    cin&gt;&gt;n;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> x;  </span><br><span class="line">        cin&gt;&gt;x;  </span><br><span class="line">        e[x].<span class="built_in">push_back</span>(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dd)</span></span>;  </span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">readIn</span>();  </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);  </span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dd)</span></span>&#123;  </span><br><span class="line">    <span class="type">int</span> pre=p[a[u]];  </span><br><span class="line">    p[a[u]]=dd;  </span><br><span class="line">    near[u]=<span class="built_in">max</span>(pre,near[fa]);  </span><br><span class="line">    <span class="type">int</span> gap=dd-near[u];  </span><br><span class="line">    res+=gap;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])&#123;  </span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;  </span><br><span class="line">        <span class="built_in">dfs</span>(v,u,dd+<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    p[a[u]]=pre;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>万诺coding</tag>
      </tags>
  </entry>
  <entry>
    <title>golang interface{} 类型判空的坑</title>
    <url>/blog/2023/10/11/data/interview/%E5%AD%97%E8%8A%82/golang%20interface%7B%7D%20%E7%B1%BB%E5%9E%8B%E5%88%A4%E7%A9%BA%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>大家好，我是煎鱼。</p>
<p>前几天在读者交流群里看到一位小伙伴，针对 interface
的使用有了比较大的疑惑。</p>
<p>无独有偶，我也在网上看到有小伙伴在 Go 面试的时候被问到了：</p>
<figure>
<img
src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36d7ecb0da9e4b32a493dedce6ebc691~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>今天特意分享出来让大家避开这个坑。</p>
<h2 id="例子一">例子一</h2>
<p>第一个例子，如下代码：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    v = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(v == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你觉得输出结果是什么呢？<br />
答案是：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>为什么不是 <code>true</code>。明明都已经强行置为 <code>nil</code>
了。是不是 Go 编译器有问题？</p>
<h2 id="例子二">例子二</h2>
<p>第二个例子，如下代码：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data, data == <span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你觉得输出结果是什么呢？</p>
<p>答案是：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt; <span class="literal">true</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt; <span class="literal">true</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>这可就更奇怪了，为什么刚刚声明出来的 <code>data</code> 和
<code>in</code> 变量，确实是输出结果是 <code>nil</code>，判断结果也是
<code>true</code>。</p>
<p>怎么把变量 <code>data</code> 一赋予给变量
<code>in</code>，世界就变了？输出结果依然是
<code>nil</code>，但判定却变成了 <code>false</code>。</p>
<p>和上面的第一个例子结果类似，真是神奇。</p>
<h2 id="原因">原因</h2>
<p>interface 判断与想象中不一样的根本原因是，interface
并不是一个指针类型，虽然他看起来很像，以至于误导了不少人。</p>
<p>我们钻下去 interface，interface 共有两类数据结构：<br />
- <code>runtime.eface</code> 结构体：表示不包含任何方法的空接口，也称为
empty interface。<br />
- <code>runtime.iface</code> 结构体：表示包含方法的接口。</p>
<p>看看这两者相应的底层数据结构：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会发现 interface
不是单纯的值，而是<strong>分为类型和值</strong>。</p>
<p>所以传统认知的此 nil 并非彼 nil，<strong>必须得类型和值同时都为 nil
的情况下，interface 的 nil 判断才会为 true</strong>。</p>
<h2 id="解决办法">解决办法</h2>
<p>与其说是解决方法，不如说是委婉的破局之道。在不改变类型的情况下，方法之一是利用反射（reflect），如下代码：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(IsNil(in))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNil</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    vi := reflect.ValueOf(i)</span><br><span class="line">    <span class="keyword">if</span> vi.Kind() == reflect.Ptr &#123;</span><br><span class="line">        <span class="keyword">return</span> vi.IsNil()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用反射来做 nil 的值判断，在反射中会有针对 interface
类型的特殊处理，最终输出结果是：true，达到效果。</p>
<p>其他方法的话，就是改变原有的程序逻辑，例如：</p>
<ul>
<li>对值进行 nil 判断，再返回给 interface 设置。<br />
</li>
<li>返回具体的值类型，而不是返回 interface。</li>
</ul>
<h2 id="总结">总结</h2>
<p>Go interface 是 Go 语言中最常用的类型之一，大家用惯了
<code>if err != nil</code> 就很容易顺手就踩进去了。</p>
<p>建议大家要多留个心眼，如果对 interface
想要有更进一步的了解，可以看看我的这篇深入解析的文章：《一文吃透 Go
语言解密之接口 interface》。</p>
<p>作者：煎鱼eddycjy<br />
链接：https://juejin.cn/post/6960888943273312263<br />
来源：稀土掘金<br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>字节</tag>
      </tags>
  </entry>
  <entry>
    <title>左边的数都小于它，右边的数都大于它</title>
    <url>/blog/2023/10/11/data/interview/%E5%AD%97%E8%8A%82/%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%95%B0%E9%83%BD%E5%B0%8F%E4%BA%8E%E5%AE%83%EF%BC%8C%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%95%B0%E9%83%BD%E5%A4%A7%E4%BA%8E%E5%AE%83/</url>
    <content><![CDATA[<p>题目<br />
原描述：<br />
给出一个元素无序的数组，求出一个数，使得其左边的数都小于它，右边的数都大于等于它。<br />
要求时间复杂度n</p>
<p>整理及丰富细节：<br />
一个无序的数组，找出所有符合以下特点的数，返回它们的索引。<br />
这个数的左边的数都小于它，右边的数都大于等于它。<br />
要求时间复杂度 O(n) 。</p>
<p>思路<br />
使用单调栈<br />
11.
当元素入栈的时候，单调栈只能保证入栈元素比栈内元素都大，但是不能保证是数组中出现过的最大的<br />
12. 所以额外需要一个最大值，来增强入栈规则<br />
13.
出栈的元素曾经是满足条件的，但是现在出现更大的数字，不符合规则，被淘汰<br />
<img
src="https://pic.leetcode-cn.com/f25fee35a18bb380fb089535b8746c241aa65a054478b8e634eadf0970ffca3d-%E5%9B%BE%E7%89%87.png" /></p>
<p>用例<br />
输入：[3,2,1,4,7,6,5]<br />
输出：[3]</p>
<p>输入：[2,1,3,4,5,7,6]<br />
输出：[2,3,4]</p>
<p>输入：[7,6,5,4,3,2,1]<br />
输出：[]</p>
<p>输入：[6,5,4,3,2,1,7]<br />
输出：[6]</p>
<p>输入：[1,7,6,5,4,3,2]<br />
输出：[0]<br />
答题<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getMidNum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> maxn = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!ans.<span class="built_in">empty</span>() &amp;&amp; !(nums[ans.<span class="built_in">back</span>()] &lt; nums[i])) &#123;</span><br><span class="line">            ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxn) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用例：<br />
输入：[2,1,3,4,5,7,6]<br />
输出：[2,3,4]</p>
<hr />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2,1,3,4,5,7,6,</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">        [push]</span><br><span class="line">        ans:    2,</span><br><span class="line">        maxn = 2</span><br><span class="line"></span><br><span class="line">i = 1</span><br><span class="line">        [pop]</span><br><span class="line">        ans:</span><br><span class="line">        maxn = 2</span><br><span class="line"></span><br><span class="line">i = 2</span><br><span class="line">        [push]</span><br><span class="line">        ans:    3,</span><br><span class="line">        maxn = 3</span><br><span class="line"></span><br><span class="line">i = 3</span><br><span class="line">        [push]</span><br><span class="line">        ans:    3,4,</span><br><span class="line">        maxn = 4</span><br><span class="line"></span><br><span class="line">i = 4</span><br><span class="line">        [push]</span><br><span class="line">        ans:    3,4,5,</span><br><span class="line">        maxn = 5</span><br><span class="line"></span><br><span class="line">i = 5</span><br><span class="line">        [push]</span><br><span class="line">        ans:    3,4,5,7,</span><br></pre></td></tr></table></figure>
<p>作者：Ikaruga<br />
链接：https://leetcode.cn/circle/discuss/q5wVRM/view/982rpT/<br />
来源：力扣（LeetCode）<br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>字节</tag>
      </tags>
  </entry>
  <entry>
    <title>求数组左右部分最大值的最大差值</title>
    <url>/blog/2023/10/11/data/interview/%E5%AD%97%E8%8A%82/%E6%B1%82%E6%95%B0%E7%BB%84%E5%B7%A6%E5%8F%B3%E9%83%A8%E5%88%86%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
    <content><![CDATA[<p>给你一个数组，从中间切开，变成左部分和右部分，要求左右部分最少有一个数，现在，左右部分各自有最大值，请你求出左右部分最大值的最大差值。</p>
<p>最垃圾思路：</p>
<p>每到一个位置就左右遍历求最大值，时间复杂度O(n^2)</p>
<p>预处理思路：</p>
<p>申请两个辅助数组，分别记录当前位置左边的最大值以及右边的最大值，总共需要遍历三次，时间复杂度O(n)，空间复杂度O(n)</p>
<p>最优思路：</p>
<p>分析题目要求，这样考虑，既然数组被分成了左右两部分，那么，之前整个数组的最大值，一定在两部分中，最后结果也一定是这个数减去某个值。</p>
<p>假设我们找到整个数组的最大值，并知道他的位置，那么，把他划分进左边区域时，右边最小的最大值，就是最右边的数。因为最右边区域，无论如何划分，都会包含最后一个数，对吧？那么，如果存在比最后一个数大的数，最大值就不是最后一个数，结果肯定会变小，肯定会比只把最后一个数划分进右边区域的结果小，因此，最优解是减去最右边的数。如果存在比最后一个数小的数，那么右边最大值就是最后一个数，结果还是减去最后一个数，因此，无论如何，都是全局最大值减去最右一个数。同理，如果把全局最大值划分进右边区域，最后结果就是全局最大值减去最左边的数，所以，最后，只需要对比最右边和最左边哪个数小，全局最大值减去这个数就是最终结果。</p>
<p>同时，如果全局最大值出现在左右边界，另一边肯定比他小，因此，结果仍然正确。</p>
<p>最优解法时间复杂度O(n)，空间复杂度O(1)<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; range&#123;<span class="number">-100</span>, <span class="number">100</span>&#125;;</span><br><span class="line">std::random_device rd;</span><br><span class="line">std::default_random_engine rng&#123;<span class="built_in">rd</span>()&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randomFill</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invalid length\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        arr[i] = <span class="built_in">range</span>(rng) * (<span class="built_in">rand</span>() % <span class="number">2</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">computeMaxDiff_trivial</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty vector\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> xam;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">twoWayPass</span>(len - <span class="number">1</span>, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="comment">// left pass</span></span><br><span class="line">    xam = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; xam)</span><br><span class="line">            xam = arr[i];</span><br><span class="line">        twoWayPass[i].first = xam;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// right pass</span></span><br><span class="line">    xam = arr.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i + <span class="number">1</span>] &gt; xam)</span><br><span class="line">            xam = arr[i + <span class="number">1</span>];</span><br><span class="line">        twoWayPass[i].second = xam;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// record the max difference</span></span><br><span class="line">    xam = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">        xam = <span class="built_in">max</span>(xam, <span class="built_in">abs</span>(twoWayPass[i].first - twoWayPass[i].second));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> xam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">computeMaxDiff_refined</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty vector\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> xam = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : arr)</span><br><span class="line">        <span class="keyword">if</span> (num &gt; xam) xam = num;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">abs</span>(xam - arr[<span class="number">0</span>]), <span class="built_in">abs</span>(xam - arr.<span class="built_in">back</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)(<span class="built_in">time</span>(<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">test</span><span class="params">(SIZE)</span></span>;</span><br><span class="line">    <span class="built_in">randomFill</span>(test, SIZE);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;trivial: &quot;</span> &lt;&lt; <span class="built_in">computeMaxDiff_trivial</span>(test) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;refined: &quot;</span> &lt;&lt; <span class="built_in">computeMaxDiff_refined</span>(test) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>字节</tag>
      </tags>
  </entry>
  <entry>
    <title>不愧是腾讯天美，面的贼细！</title>
    <url>/blog/2023/10/11/data/interview/%E5%B0%8F%E6%9E%97coding/%E4%B8%8D%E6%84%A7%E6%98%AF%E8%85%BE%E8%AE%AF%E5%A4%A9%E7%BE%8E%EF%BC%8C%E9%9D%A2%E7%9A%84%E8%B4%BC%E7%BB%86%EF%BC%81/</url>
    <content><![CDATA[<p>大家好，我是小林。</p>
<p>明天就是国庆假期，假期之前，再给大家卷一卷。</p>
<p>今天分享一位同学的腾讯天美面经，对的就是那个王者荣耀部门的天美，问的问题很细节，会追着基础问题一直深问，直到你不会，才会换话题，主要注重计算机基础，操作系统这方面了。</p>
<h2 id="面试题">面试题</h2>
<ol type="1">
<li><p><strong>说一下你的认识和倾向，对哪些感兴趣，想从事什么</strong></p></li>
<li><p>这个一来我就懵逼了，就说自己目前还是比较喜欢开发，加上研究生期间基本也都是开发，所以比较倾向于后台开发方向。</p></li>
<li><p><strong>说一下你学习了那些课程</strong></p></li>
<li><p>编程语言，数据库，计网等</p></li>
<li><p><strong>说一下操作系统中虚拟内存的实现和为什么要使用虚拟内存</strong></p></li>
<li><p>实现：操作系统给进程提供虚拟内存的地址，进程要访问的时候由操作系统将虚拟地址转换成实际的物理地址读取数据，实现方法有页式、段式、段页式</p></li>
<li><p>好处：将有限的物理内存映射成了无限的虚拟内存，可以满足更多进程的需要；避免进程直接操作物理内存引发的安全问题</p></li>
<li><p><strong>说一下进程，线程，协程</strong></p></li>
<li><p>进程是系统分配资源的最小单位，线程作为进程的子一级，是分配cpu的最小单位，而协程算是用户态的线程，切换时不需要进入内核态。</p></li>
<li><p><strong>追问：你这里提到了线程的上下文切换，上下文指什么，怎么存储？</strong></p></li>
<li><p>上下文指线程当前执行到那一步以及一些运算结果，线程有自己私有的虚拟机栈和程序计数器</p></li>
<li><p><strong>再追问：线程运行过程中申请到的东西在切换时是否全部要保存，比如线程中有个循环，或者声明了很多对象，这些是否都要保存，也存在线程私有区吗</strong></p></li>
<li><p>（这个有些懵了）都要存，有些会存在公用的堆中（然后面试官说跳过）</p></li>
<li><p><strong>说一下同步和异步</strong></p></li>
<li><p>同步是指需要等待响应后继续后面的操作，异步是不需要等待响应，可以直接继续后面操作。这里我举了个读写例子：A发出读写请求，同步的话他要等读写完成后才继续后续；异步的话发出请求后就可以继续，等到读写完成后通知A或者直接将内容发给A</p></li>
<li><p><strong>追问：那谁来通知A，或者谁来检查读写完了没</strong></p></li>
<li><p>由操作系统或者是对应的服务方</p></li>
<li><p><strong>再追问：但是你A怎么确定是否读完，就算B告诉读取完了，A也需要回过头来检查一次。（这一套问题没大懂）</strong></p></li>
<li><p><strong>再追问：epoll有了解吗</strong></p></li>
<li><p>了解过，说明不清楚....（然后面试官说跳过）</p></li>
<li><p><strong>再再追问：硬中断、软中断有了解过吗</strong></p></li>
<li><p>我：硬中断：中断发生后立即处理中断内容，软中断：中断发生后可以稍缓再处理（完蛋）</p></li>
<li><p>查到的软硬中断是触发源不一样，硬中断是硬件触发，软中断是软件模拟触发</p></li>
<li><p><strong>更新</strong>：软硬中断是根据中断的实现机制来进行区分，硬中断指由CPU硬件实现的中断（Intel
CPU中中断、异常、INT指令都是），软中断是指由软件实现的，常见如linux系统中守护进程来实现</p></li>
<li><p>软中断是为了解决中断处理时间过长和中断丢失的问题。常见用来延迟处理硬中断未完成的工作</p></li>
<li><p><strong>说一下TCP和UDP的区别</strong></p></li>
<li><p>TCP是有链接的可靠交付，UDP是无连接的尽最大努力交付</p></li>
<li><p><strong>追问：说明下有无链接的体现</strong></p></li>
<li><p>TCP在通信时需要通过三次招收建立链接，通信完成后需要通过四次挥手断开链接；而UDP是直接将报文发出</p></li>
<li><p><strong>数据竞争有了解过吗</strong></p></li>
<li><p>（没有）猜的是多线程数据读写导致的问题，如多个线程执行i++</p></li>
<li><p><strong>栈帧是什么，如何计算长度，汇编语言中sp寄存器、bp寄存器还记得吗</strong></p></li>
<li><p>像函数调用或递归的时候，会将原本的数据压入栈中，就是一个栈帧。（感觉这个也说的很混乱，后面的长度计算和寄存器都不知道了）</p></li>
<li><p><strong>说一下你了解的排序算法，稳定性，什么时候选择稳定的排序</strong></p></li>
<li><p>选择、冒泡，归并，基数排序，快排，稳定性是指排序之后先前在前面的元素还是在前面，（开始诌）选择稳定的排序算法是元素的起始顺序对后面的操作有意义，不能随意打乱。</p></li>
<li><p><strong>手撕，合并区间问题，输入若干开始结束时间段，将有重叠的覆盖在一起</strong></p></li>
<li><p>先说思路，按开始时间对二元组们进行排序，之后就遍历合并</p></li>
<li><p>算法写完了，但是本地ide卡输入输出了，调试过程中面试官指出了一个问题。然后这时已经一个小时了，就没继续让跑了</p></li>
<li><p><strong>说一下你近期遇到的困难</strong></p></li>
<li><p>30所项目问题，对方在验收后又提出了很多原本设计上没有考虑的需求，最后经过协商和其他系统合作勉强达到了要求</p></li>
<li><p><strong>说一下你的未来2-3年的规划（我问具体指什么规划，面试官说什么都行，工作，生活都行）</strong></p></li>
<li><p>提升自己技术，见识和学习更多主流和前言的技术</p></li>
<li><p>生活上更加规律</p></li>
</ol>
<h2 id="反问">反问</h2>
<ol type="1">
<li><p>后台开发负责内容</p></li>
<li><p>技术栈</p></li>
<li><p>学习建议</p></li>
</ol>
<h2 id="面试总结">面试总结</h2>
<h3 id="感觉">感觉</h3>
<ul>
<li><p>很久没有面试了，上次面试还是电话面，感觉还是有些紧张，不能稳定清晰的表述自己的内容</p></li>
<li><p>问了很多基础但又深入的问题，不少还是拿不准</p></li>
</ul>
<h3 id="不足之处">不足之处</h3>
<ul>
<li><p>感觉被面试官牵着走，老是被带到说不清楚的问题然后尴尬收场</p></li>
<li><p>未来规划感觉经常被问，但是也没有什么好的回答</p></li>
</ul>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>小林coding</tag>
      </tags>
  </entry>
  <entry>
    <title>字节面试体验很棒！</title>
    <url>/blog/2023/10/11/data/interview/%E5%B0%8F%E6%9E%97coding/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E4%BD%93%E9%AA%8C%E5%BE%88%E6%A3%92%EF%BC%81/</url>
    <content><![CDATA[<p>今天分享秋招的字节、快手 Java
后端面经，我筛选了Java+MySQL+Redis+MQ+网络+操作系统共性的面试题，排除了项目和实习经历的问题，同学反馈字节面试体验很好，遇到不会的，面试官会一步一步引导，还会详细解释下，返回环节还介绍了部门情况。</p>
<p>整体难度不算太难，还算比较基础，很多都是高频面试题，可以收藏起来，反复复习。</p>
<h2 id="网络">网络</h2>
<h3
id="从输入域名到浏览器看见页面经历了什么过程">从输入域名到浏览器看见页面经历了什么过程？</h3>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfW5jtMU7dzOUhL6avJSwsulOMWcGG9YfxxiaT1IOzxLsn4p006zswayeApBCb8TRANCQ3qAvmYMvA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>简单的网络模型</p>
<ul>
<li><p>解析URL：分析 URL
所需要使用的传输协议和请求的资源路径。如果输入的 URL
中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查
URL
中是否出现了非法字符，则对非法字符进行转义后在进行下一过程。</p></li>
<li><p>缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里且没有失效，那么就直接使用，否则向服务器发起新的请求。</p></li>
<li><p>DNS解析：如果资源不在本地缓存，首先需要进行DNS解析。浏览器会向本地DNS服务器发送域名解析请求，本地DNS服务器会逐级查询，最终找到对应的IP地址。</p></li>
<li><p>获取MAC地址：当浏览器得到 IP 地址后，数据传输还需要知道目的主机
MAC 地址，因为应用层下发数据给传输层，TCP
协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的
IP
地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的
MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC
地址需要分情况处理。通过将 IP
地址与本机的子网掩码相结合，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用
APR 协议获取到目的主机的 MAC
地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过
ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC
地址应该为网关的地址。</p></li>
<li><p>建立TCP连接：主机将使用目标 IP地址和目标MAC地址发送一个TCP
SYN包，请求建立一个TCP连接，然后交给路由器转发，等路由器转到目标服务器后，服务器回复一个SYN-ACK包，确认连接请求。然后，主机发送一个ACK包，确认已收到服务器的确认，然后
TCP 连接建立完成。</p></li>
<li><p>HTTPS 的 TLS 四次握手：如果使用的是 HTTPS 协议，在通信前还存在
TLS 的四次握手。</p></li>
<li><p>发送HTTP请求：连接建立后，浏览器会向服务器发送HTTP请求。请求中包含了用户需要获取的资源的信息，例如网页的URL、请求方法（GET、POST等）等。</p></li>
<li><p>服务器处理请求并返回响应：服务器收到请求后，会根据请求的内容进行相应的处理。例如，如果是请求网页，服务器会读取相应的网页文件，并生成HTTP响应。</p></li>
</ul>
<h3
id="tcp的三次握手过程三次握手的原因是什么">TCP的三次握手过程？三次握手的原因是什么？</h3>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfW5jtMU7dzOUhL6avJSwsuORlbSH2ktOhYeUicGObyt1TJ2V1RoibSybI3xBjeoqOjmaNRHpNbiaDJw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>在这里插入图片描述</p>
<ul>
<li><p>第一次握手（SYN）：客户端向服务器发送一个带有SYN标志的数据包，请求建立连接。客户端会选择一个随机的初始序列号（ISN）作为起始序号。</p></li>
<li><p>第二次握手（SYN+ACK）：服务器收到客户端的请求后，会发送一个带有SYN和ACK（确认）标志的数据包作为响应。服务器也会选择一个随机的初始序列号，并将客户端的初始序列号加1作为确认号。同时，服务器也表示自己已经收到了客户端的请求。</p></li>
<li><p>第三次握手（ACK）：客户端收到服务器的响应后，会发送一个带有ACK标志的数据包作为确认。客户端会将服务器的初始序列号加1作为确认号，并向服务器表示自己已经收到了服务器的响应。</p></li>
</ul>
<p>完成了这三次握手后，TCP连接就建立起来了，双方可以开始进行数据的传输。</p>
<p>三次握手的目的是确保双方都能够收到对方的请求和确认，并且双方都同意建立连接。这样可以防止因为网络延迟或丢包等问题导致连接建立失败或不稳定。同时，三次握手也能够防止已经失效的连接请求报文段在网络中重新出现，避免了资源的浪费。</p>
<h3 id="tcp为什么可靠">TCP为什么可靠?</h3>
<ul>
<li><p>序列号与确认机制：TCP将每个数据包分配一个唯一的序列号，并且接收方会发送确认消息来确认已经接收到的数据。发送方会根据接收到的确认消息判断是否需要重新发送丢失的数据包。</p></li>
<li><p>数据校验和：TCP使用校验和来验证数据在传输过程中是否发生了损坏。接收方会计算校验和并与发送方发送的校验和进行比较，如果不一致，则说明数据包发生了损坏，需要重新发送。</p></li>
<li><p>滑动窗口机制：TCP使用滑动窗口来控制发送方发送数据的速度和接收方接收数据的速度，以避免因发送速度过快或接收速度过慢而导致的数据丢失或堵塞。</p></li>
<li><p>重传机制：如果发送方没有收到接收方的确认消息，或者接收方收到的数据包校验和不一致，发送方会重新发送数据包，确保数据的可靠传输。</p></li>
<li><p>拥塞控制：TCP具有拥塞控制机制，可以根据网络的拥塞情况来调整发送数据的速率，避免网络拥塞导致的数据丢失和延迟。</p></li>
</ul>
<h3 id="http状态码有哪些">HTTP状态码有哪些？</h3>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfW5jtMU7dzOUhL6avJSwsuqCQCA3iayya7LwUubvNKePCkVWI3Xpg6FwwnZDicustXrrA9pcYv6ia4Q/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>五大类 HTTP 状态码</p>
<p>1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p>
<ul>
<li><p>100 Continue</p></li>
<li><p>101 Switching Protocols</p></li>
<li><p>2xx：成功状态码，表示服务器已成功接收到请求并进行处理。</p></li>
</ul>
<p>200 OK 表示客户端请求成功</p>
<ul>
<li><p>204 No Content 成功，但不返回任何实体的主体部分</p></li>
<li><p>206 Partial Content 成功执行了一个范围（Range）请求</p></li>
</ul>
<p>3xx：重定向状态码，表示服务器要求客户端重定向。</p>
<ul>
<li><p>301 Moved Permanently
永久性重定向，响应报文的Location首部应该有该资源的新URL</p></li>
<li><p>302 Found
临时性重定向，响应报文的Location首部给出的URL用来临时定位资源</p></li>
<li><p>303 See Other
请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</p></li>
<li><p>304 Not Modified
服务器内容没有更新，可以直接读取浏览器缓存</p></li>
<li><p>307 Temporary Redirect 临时重定向。与302
Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现</p></li>
</ul>
<p>4xx：客户端错误状态码，表示客户端的请求有非法内容。</p>
<ul>
<li><p>400 Bad Request
表示客户端请求有语法错误，不能被服务器所理解</p></li>
<li><p>401 Unauthonzed 表示请求未经授权，该状态代码必须与
WWW-Authenticate 报头域一起使用</p></li>
<li><p>403 Forbidden
表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因</p></li>
<li><p>404 Not Found 请求的资源不存在，例如，输入了错误的URL</p></li>
</ul>
<p>5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p>
<ul>
<li><p>500 Internel Server Error
表示服务器发生不可预期的错误，导致无法完成客户端的请求</p></li>
<li><p>503 Service Unavailable
表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</p></li>
</ul>
<h2 id="操作系统">操作系统</h2>
<h3 id="进程间通信有哪些">进程间通信有哪些？</h3>
<ul>
<li><p>管道（Pipe）：管道是一种半双工的通信方式，可以在具有亲缘关系的进程之间进行通信。它可以分为匿名管道和命名管道。匿名管道只能在具有共同祖先的进程之间使用，而命名管道可以在不具有亲缘关系的进程之间使用。</p></li>
<li><p>优点：简单易用，无需额外的系统调用和复杂的设置。</p></li>
<li><p>缺点：只能在具有亲缘关系的进程之间进行通信，且只能实现单向通信。</p></li>
<li><p>信号（Signal）：信号是一种异步的通信方式，用于通知进程发生了某种事件。一个进程可以向另一个进程发送信号，接收信号的进程可以选择采取相应的行动。</p></li>
<li><p>优点：简单、快速，适用于简单的通信需求。</p></li>
<li><p>缺点：信号的发送和接收是异步的，无法传递大量数据，且不支持双向通信。</p></li>
<li><p>共享内存（Shared
Memory）：共享内存是一种高效的通信方式，多个进程可以将同一块内存空间映射到各自的地址空间中，从而实现共享数据。</p></li>
<li><p>优点：传输效率高，适用于大量数据的共享。</p></li>
<li><p>缺点：需要额外的同步机制来保证数据的一致性和互斥访问，容易造成数据竞争和死锁。</p></li>
<li><p>信号量（Semaphore）：信号量是一种用于进程间同步的机制，可以用来保护共享资源的互斥访问。</p></li>
<li><p>优点：可以用于进程间的同步和互斥。</p></li>
<li><p>缺点：只提供了同步和互斥的功能，无法传递大量数据。</p></li>
<li><p>消息队列：消息队列是一种消息传递的机制，可以在不同进程之间传递特定格式的消息。</p></li>
<li><p>优点：支持多对多的进程通信，每个消息都有特定的格式。</p></li>
<li><p>缺点：消息的发送和接收是同步的，且不支持实时性要求较高的通信。</p></li>
<li><p>套接字（Socket）：套接字是一种通用的进程间通信机制，可以在不同主机上的进程之间进行通信。</p></li>
<li><p>优点：支持网络通信，可以在不同主机上的进程之间进行通信。</p></li>
<li><p>缺点：相对于其他IPC方式，套接字的使用和编程复杂度较高。</p></li>
</ul>
<h3 id="电脑-4gb内存我申请-5gb内存可以吗">电脑 4GB内存，我申请
5GB内存可以吗？</h3>
<p>应用程序通过 malloc
函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。</p>
<p>虚拟内存的最大值首先操作系统的位数，32 位操作系统和 64
位操作系统的虚拟地址空间大小是不同的，在 Linux
操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，如下所示：</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfW5jtMU7dzOUhL6avJSwsunpM5Uhl2SD3BOyiaGALicxJ7EbTNxzvf4t2DHWiaibnS67IicVPhbTyx5icQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<ul>
<li><p><code>32</code> 位系统的内核空间占用 <code>1G</code>，位于最高处，剩下的 <code>3G</code> 是用户空间，所以<strong>在
32 位操作系统场景下，执行malloc申请5G内存，会失败。</strong></p></li>
<li><p><code>64</code> 位系统的内核空间和用户空间都是 <code>128T</code>，所以<strong>在
64 位操作系统场景下，即使物理内存只有
4G，但是还是可以申请5G虚拟内存，能申请成功。</strong></p></li>
</ul>
<h3
id="申请成功之后在使用这5g内存时候会有问题吗">申请成功之后，在使用这5G内存时候会有问题吗？</h3>
<p>会有问题，会发生 OOM 的错误，内存溢出。</p>
<p>当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存，
这时会发现这个虚拟内存没有映射到物理内存， CPU
就会产生<strong>缺页中断</strong>，进程会从用户态切换到内核态，并将缺页中断交给内核的
Page Fault Handler （缺页中断函数）处理。</p>
<p>缺页中断处理函数会看是否有空闲的物理内存：</p>
<ul>
<li><p>如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。</p></li>
<li><p>如果没有空闲的物理内存，那么内核就会开始进行的工作，如果回收内存工作结束后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了触发
OOM （Out of Memory）机制。</p></li>
</ul>
<h2 id="mysql">MySQL</h2>
<h3 id="索引的底层是怎么实现的">索引的底层是怎么实现的？</h3>
<p>MySQL 默认存储引擎是 InnoDB，InnoDB 默认是使用 B+树
作为索引的数据结构。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfW5jtMU7dzOUhL6avJSwsuSePCPa98D1wzIMlus4zOD77jKuiaHNS5elp21Jktxxsapwcjqm81Uvw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>主键索引 B+Tree</p>
<h3 id="为什么用b树呢">为什么用B+树呢？</h3>
<ul>
<li><p>B+Tree vs 二叉树：对于有 N 个叶子节点的
B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d
表示节点允许的最大子节点个数为 d 个。在实际的应用当中， d
值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree
的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4
次的磁盘 I/O
操作就能查询到目标数据。而二叉树的每个父节点的儿子节点个数只能是 2
个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree
高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</p></li>
<li><p>B+Tree vs Hash：Hash 在做等值查询的时候效率贼快，搜索复杂度为
O(1)。但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree
索引要比 Hash 表索引有着更广泛的适用场景的原因。</p></li>
<li><p>B+Tree vs B Tree：B+Tree 只在叶子节点存储数据，而 B 树
的非叶子节点也要存储数据，所以 B+Tree
的单个节点的数据量更小，在相同的磁盘 I/O
次数下，就能查询更多的节点。另外，B+Tree
叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B
树无法做到这一点。</p></li>
</ul>
<h3
id="你是如何选择什么字段来做索引的">你是如何选择什么字段来做索引的？</h3>
<ul>
<li><p>字段有唯一性限制的，比如商品编码；</p></li>
<li><p>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</p></li>
<li><p>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在
B+Tree 中的记录都是排序好的。</p></li>
</ul>
<h3
id="假如现在有三个普通索引abcsql查询where-a-xx-and-b-xx-and-c-xx会怎么样">假如现在有三个普通索引a，b，c，sql查询where
a = xx and b = xx and c == xx会怎么样？</h3>
<p>会进行索引合并，对多个索引分别进行条件扫描，然后将它们各自的结果进行合并。</p>
<p>MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了索引合并优化技术，对同一个表可以使用多个索引分别进行条件扫描。</p>
<h3
id="那如果不想索引合并呢怎么解决">那如果不想索引合并呢？怎么解决？</h3>
<p>如果出现了索引合并，那么一般同时也意味着我们的索引建立得不太合理，因为索引合并
是可以通过建立联合索引进行更一步优化的，减少索引扫描的次数。</p>
<p>比如，建立联合索引（a, b,
c），这条查询语句遵循最左匹配原则，所以三个字段都可以利用联合索引。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfW5jtMU7dzOUhL6avJSwsuwxc3G8lcNK1XDdIaJf1DF70V4W5tRgxLynUMyUXV6ibiafMQfYvFW8hg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<h2 id="redis">Redis</h2>
<h3 id="redis在项目中的应用">Redis在项目中的应用？</h3>
<p>主要用做缓存，提升查询的性能，避免请求查询mysql。</p>
<h3 id="redis过期淘汰策略有哪些">Redis过期淘汰策略有哪些？</h3>
<p>Redis
内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p>
<p><em>1、不进行数据淘汰的策略</em></p>
<p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略）
：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</p>
<p><em>2、进行数据淘汰的策略</em></p>
<p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p>
<p>在设置了过期时间的数据中进行淘汰：</p>
<ul>
<li><p><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</p></li>
<li><p><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</p></li>
<li><p><strong>volatile-lru</strong>（Redis3.0
之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</p></li>
<li><p><strong>volatile-lfu</strong>（Redis 4.0
后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</p></li>
</ul>
<p>在所有数据范围内进行淘汰：</p>
<ul>
<li><p><strong>allkeys-random</strong>：随机淘汰任意键值;</p></li>
<li><p><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</p></li>
<li><p><strong>allkeys-lfu</strong>（Redis 4.0
后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</p></li>
</ul>
<h2 id="java">Java</h2>
<h3 id="hashmap底层原理">HashMap底层原理</h3>
<ul>
<li><strong>数据结构</strong>：在 JDK 1.7 版本之前， HashMap
数据结构是数组和链表，HashMap通过哈希算法将元素的键（Key）映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了，所以在
JDK
1.8版本的时候做了优化，当一个链表的长度超过8的时候就转换数据结构，不再使用链表存储，而是使用红黑树，查找时使用红黑树，时间复杂度O（log
n），可以提高查询性能，但是在数量较少时，即数量小于6时，会将红黑树转换回链表。</li>
</ul>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfW5jtMU7dzOUhL6avJSwsuZDX6iah5PhSzAx8UlmJNCQVdpnNnRqiauOojpKxcv8DATdmWJAq1NAXw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>image-20200905223727298</p>
<ul>
<li><p><strong>插入键值对的put方法的区别</strong>：JDK
1.8中会将节点插入到链表尾部，而1.7中是采用头插；</p></li>
<li><p><strong>哈希算法</strong>：JDK
1.7中的 <code>hash()</code> 扰动函数需要进行4次异或运算；而 JDK
1.8中则是将 (<code>h = key.hashCode()) ^ (h &gt;&gt;&gt; 16</code>)
的结果作为计算下标的hash值，只需要一次异或运算就可以让hashCode的高位和低位同时参与下标值的计算，更具有随机性，可以使元素分布更均匀；</p></li>
</ul>
<p><code>// JDK 1.7 hash 方法源码.   final int hash(Object k) &#123;       int h = hashSeed;       if (0 != h &amp;&amp; k instanceof String) &#123;           return sun.misc.Hashing.stringHash32((String) k);       &#125;          h ^= k.hashCode();          // This function ensures that hashCodes that differ only by       // constant multiples at each bit position have a bounded       // number of collisions (approximately 8 at default load factor).       h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);       return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);   &#125;         // JDK 1.8 hash 方法源码.   static final int hash(Object key) &#123;         int h;         // key.hashCode()：返回散列值也就是hashcode         // ^：按位异或         // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐         return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);     &#125;</code></p>
<h3 id="hashmap的扩容过程说一下">HashMap的扩容过程，说一下</h3>
<p>hashMap默认的负载因子是0.75，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容，扩容分为两个步骤：</p>
<ul>
<li><p>新的数组扩容 2 倍大小</p></li>
<li><p>计算每个元素新的位置，然后迁移元素</p></li>
</ul>
<p>JDK 1.8 在扩容 2
倍容量后，在迁移数据时，不需要重新计算元素的hash进行元素迁移，而是用原先位置key的hash值与旧数组的长度（oldCap）进行"与"操作。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfW5jtMU7dzOUhL6avJSwsuN8LeI7eY78KpmPwl83bpHa8KiaHhSjHvRxXLteiafdaliaFKJ9bTgmVzw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>image-20231010173913953</p>
<p>举一个例子，假设元素 e 存储在旧数据的桶位 i 中：</p>
<ul>
<li><p>如果(e.hash &amp; oldCap) == 0
，那么当前元素的桶位置不变。</p></li>
<li><p>如果(e.hash &amp; oldCap) ==
1，那么桶的位置就是原位置+原数组长度（oldCap）</p></li>
</ul>
<blockquote>
<p>为什么用 e.hash &amp; oldCap 计算新位置？</p>
</blockquote>
<p>首先我们要明确三点:</p>
<ol type="1">
<li><p>HashMap的数组大小一定是2的N次幂</p></li>
<li><p>HashMap扩容时一般为增大一倍，即size = size * 2</p></li>
<li><p>HashMap的索引计算方式为 hash(key) &amp; (size -
1)，由1可知，size-1的二进制「低位都为1」</p></li>
</ol>
<p>我们假设 oldCap = 16, 即 2^4，16 - 1 = 15,
二进制表示为 <code>0000 0000 0000 0000 0000 0000 0000 1111</code>，可见除了低4位,
其他位置都是0，则 <code>(16-1) &amp; hash</code> 自然就是取hash值的低4位，我们假设它为 <code>abcd</code>（abcd
各自的值可能是 0 或者 1）。</p>
<p>当我们将oldCap扩大两倍后，
新的index的位置就变成了 <code>(32-1) &amp; hash</code>, 其实就是取
hash值的低5位.。那么对于同一个Node, 低5位的值无外乎下面两种情况:</p>
<p><code>0abcd   1abcd</code></p>
<p>其中, <code>0abcd</code>与原来的index值一致,
而<code>1abcd</code> = <code>0abcd + 10000</code> = <code>0abcd + oldCap</code>（这里的oldCap是
16，二进制数：10000 ）</p>
<p>故虽然数组大小扩大了一倍，但是同一个<code>key</code>在新旧table中对应的index却存在一定联系：要么一致，要么相差一个 <code>oldCap</code>。</p>
<p>而新旧index是否一致就体现在hash值的第4位(我们把最低为称作第0位),
怎么拿到这一位的值呢, 只要:</p>
<p><code>hash &amp; 0000 0000 0000 0000 0000 0000 0001 0000</code></p>
<p>上式就等效于</p>
<p><code>hash &amp; oldCap</code></p>
<p>故得出结论:</p>
<ul>
<li><p>如果(e.hash &amp; oldCap) == 0
，那么当前元素的桶位置不变。</p></li>
<li><p>如果(e.hash &amp; oldCap) ==
1，那么桶的位置就是原位置+原数组长度（oldCap）</p></li>
</ul>
<h3
id="arraylist底层是怎么实现扩容的">ArrayList底层是怎么实现扩容的？</h3>
<ul>
<li><p>当创建ArrayList对象时，如果使用的是<strong>无参构造器</strong>，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData:为1.5倍</p></li>
<li><p>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。</p></li>
</ul>
<h3 id="arraylist和linkedlist的区别">ArrayList和LinkedList的区别</h3>
<ul>
<li><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p></li>
<li><p><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6
之前为循环链表，JDK1.7
取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p></li>
<li><p><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是
O(1)。但是如果要在指定位置 i
插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为
O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i
个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似
O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>）
时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></p></li>
<li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p></li>
<li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空
间浪费主要体现在在 list
列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li>
</ul>
<h2 id="消息队列">消息队列</h2>
<h3 id="mq如何防止消息不丢失">MQ如何防止消息不丢失？</h3>
<p>使用一个消息队列，其实就分为三大块：<strong>生产者、中间件、消费者</strong>，所以要保证消息就是保证三个环节都不能丢失数据。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfW5jtMU7dzOUhL6avJSwsu2mjicVf2ZjCmpS93xWFUBk07GK7hqvIdMawwKV5YjXF69jnAPyuceKQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>img</p>
<ul>
<li><p>消息生产阶段：生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。从消息被生产出来，然后提交给
MQ 的过程中，只要能正常收到 （ MQ 中间件） 的 ack
确认响应，就表示发送成功，所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。</p></li>
<li><p>消息存储阶段：RabbitMQ 或 Kafka
这类专业的队列中间件，在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。</p></li>
<li><p>消息消费阶段：消费者接收消息+消息处理之后，才回复 ack
的话，那么消息阶段的消息不会丢失。不能收到消息就回
ack，否则可能消息处理中途挂掉了，消息就丢失了。</p></li>
</ul>
<h3 id="mq消息大量堆积怎么办">MQ消息大量堆积怎么办？</h3>
<ul>
<li><p>从生产者端解决：一般我们的系统容量或者处理能力都是规划好的，出现消息堆积的情况，大部分是由于流量暴增引起，这个时候可以考虑控制生产者的速率，对前端机器流量进行限速限流。</p></li>
<li><p>从消费者端解决。消费者端解决的思路有两种：</p></li>
<li><p>假如消费者数还有增加的空间，那么我们加消费者解决。</p></li>
<li><p>假如没有拓展的可能，但吞吐量还没达到MQ的上限，只是消费者消费能力不足，比如消费者总体消费能力已经到达上线（数据库写入能力等），或者类似Kafka的消费者数量与partition数有关，如果前期设计没有做好水平拓展的设计，这个时候多少个partition就只能对应多少个消费者。这个时候我们可以先把一部分消息先打到另外一个MQ中或者先落到日志文件中，再拓展消费者进行消费，优先恢复上游业。</p></li>
<li><p>从整体系统上进行解决：第2点有提到就是有些MQ的设计限制，导致的消费者数是没法动态拓展的，这个时候可以考虑将原先队列进行拆分，比如新建一个topic
分担一部分消息，这个方式需要对系统的上下游都要进行调整，在实际操作难度可能比较高，处理起来可能也比较耗时，如果在事前有做好这个设计那事发后就能很好进行调整。</p></li>
</ul>
<p>转载：<a
href="https://mp.weixin.qq.com/s/e2waj6bmgfkgJzNBbE7i7g">字节面试体验很棒！</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>小林coding</tag>
      </tags>
  </entry>
  <entry>
    <title>小林coding - 字节230829</title>
    <url>/blog/2023/10/11/data/interview/%E5%B0%8F%E6%9E%97coding/%E5%B0%8F%E6%9E%97coding%20-%20%E5%AD%97%E8%8A%82230829/</url>
    <content><![CDATA[<p>大家好，我是小林。</p>
<p>分享一篇字节后端开发校招一面经，同学反馈面试官人很
nice，虽然问的很细节，但是会引导问题方向，但是可惜自己没把握住，深问一点细节的，就不会了。</p>
<p>这一面主要是拷打基础方向，重点拷打了网络IO、Linux
操作系统、网络协议、mysql、算法。</p>
<h2 id="项目相关">项目相关</h2>
<h3 id="epoll-的工作原理">epoll 的工作原理？</h3>
<p>先用 epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl
将需要监视的 socket 添加到epfd中，最后调用 epoll_wait
等待数据，当epoll_wait返回后，就可以遍历它返回的事件列表，然后根据事件类型做出相应的处理。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">bind(s, ...);  </span><br><span class="line">listen(s, ...)  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> epfd = epoll_create(...);  </span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;  </span><br><span class="line">    <span class="type">int</span> n = epoll_wait(...);  </span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;  </span><br><span class="line">        <span class="comment">//处理  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="epollselectpoll的区别">epoll、select、poll的区别？</h3>
<p>select 实现多路复用的方式是，将已连接的 Socket
都放到一个<strong>文件描述符集合</strong>，然后调用 select
函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此
Socket 标记为可读或可写，
接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的
Socket，然后再对其处理。</p>
<p>所以，对于 select 这种方式，需要进行 <strong>2
次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里
，而且还会发生 <strong>2
次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p>select 使用固定长度的
BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在
Linux 系统中，由内核中的 FD_SETSIZE 限制，
默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p>
<p>poll 不再用 BitsMap
来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了
select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p>
<p>但是 poll 和 select
并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket
集合，因此都需要遍历文件描述符集合来找到可读或可写的
Socket，时间复杂度为
O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
<p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p>
<ul>
<li><p><em>第一点</em>，epoll
在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的
socket
通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code>。而
select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket
的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而
epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket
，所以只需要传入一个待检测的
socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p></li>
<li><p><em>第二点</em>， epoll
使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个
socket
有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像
select/poll 那样轮询扫描整个 socket
集合，大大提高了检测的效率。</p></li>
</ul>
<p>可以看到 epoll 相关的接口作用：</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8FejqvF3vaZBmBc2JfgWG5BXtj3bNnj3w85TL6JfB735oJ28Q1cS37zw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>epoll 的方式即使监听的 Socket
数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket
的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll
被称为解决 C10K 问题的利器</strong>。</p>
<h3
id="select线性表要从用户态复制到内核态具体怎么复制的">select线性表要从用户态复制到内核态，具体怎么复制的？</h3>
<p>用户态准备一个文件描述符集合，通常是使用<code>fd_set</code>数据结构来表示，该集合包含要监视的文件描述符。调用<code>select</code>系统调用时，将该文件描述符集合作为参数传递给<code>select</code>函数。</p>
<p>内核态的<code>select</code>函数接收到用户态传递的文件描述符集合后，会在内核中创建一个与用户态相对应的数据结构
fdset，然后将用户空间的ufdset拷贝到内核空间fdset。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8FDyMDsia6UHug8EclUOKuOy3EAbqnFGXUMIoKB59DOBPJeqNlNmLeN8A/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<h2 id="操作系统">操作系统</h2>
<h3 id="进程线程协程的概念">进程、线程、协程的概念</h3>
<ul>
<li><p>进程（Process）：进程是操作系统中的一个执行实例，它拥有独立的内存空间和资源。每个进程都是独立运行的，拥有自己的地址空间、文件句柄、环境变量等。进程间通信需要通过特定的机制，如管道、消息队列、共享内存等。</p></li>
<li><p>线程（Thread）：线程是进程的一部分，是在同一进程内并发执行的执行单元。不同线程共享同一进程的内存空间和资源，包括全局变量、堆、文件描述符等。线程可以更轻量级地创建、切换和销毁，相对于进程而言，线程间的切换开销较小。线程之间可以通过共享内存等机制进行通信。</p></li>
<li><p>协程（Coroutine）：协程是一种用户级的轻量级线程。协程由用户控制，而不是由操作系统内核控制。在协程中，执行流可以在不同协程之间进行切换，切换由程序员手动控制，而不需要内核介入。协程可以在一个线程内实现并发，但无法利用多核心处理器。协程通常用于实现高效的异步编程和协作任务。</p></li>
</ul>
<h3
id="系统创建进程的时候会给进程分配哪些资源">系统创建进程的时候，会给进程分配哪些资源？</h3>
<p>会分配虚拟内存空间、文件描述符、信号资源。</p>
<h3 id="线程的资源怎么回收">线程的资源怎么回收？</h3>
<p>linux
线程退出有多种方式，如return，pthread_exit,pthread_cancel等；线程分为可结合的（joinable）和
分离的（detached）两种。</p>
<ul>
<li><p>如果没有在创建线程时设置线程的属性为PTHREAD_CREATE_DETACHED，则线程默认是可结合的。可结合的线程在线程退出后不会立即释放资源，必须要调用pthread_join来显式的结束线程。</p></li>
<li><p>分离的线程在线程退出时系统会自动回收资源。</p></li>
</ul>
<h3 id="怎么看进程当中有哪些线程">怎么看进程当中有哪些线程？</h3>
<p>使用<code>ps</code>命令：通过在终端中运行<code>ps -eLf</code>命令，可以列出所有进程及其对应的线程信息。每个线程都会显示线程ID（TID）、进程ID（PID）、线程优先级（PRI）、CPU占用率（%CPU）、内存占用（%MEM）等信息。</p>
<p><img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8F54qmEGu9WVlDLibXyz0XrW7OJJ9GzKgxiaMj4Qrpt5Q930PkZt9oLMfw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" /><br />
### 怎么查看网络的状态？</p>
<p>可以通过 netstat 命令。</p>
<p><img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8FCVOQGmjwjown45g1jZ0uNgu3eBFgIwWFR2dDBKbggq3oX1zvmnxPkQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" /><br />
### 如果只想看close_wait状态的连接，怎么看？</p>
<p><code>netstat -napt  | grep close_wait</code></p>
<h2 id="计网">计网</h2>
<h3
id="http协议状态码-500-501-502-503-504分别代表什么可以举出具体场景嘛">HTTP协议状态码
500 501 502 503 504分别代表什么？可以举出具体场景嘛？</h3>
<p>状态码500：<br />
- 服务器内部错误（Internal Server
Error）：表示服务器在处理请求时遇到了意外的错误，无法完成请求。</p>
<ul>
<li>场景：当服务器上的应用程序发生未处理的异常或错误时，可能会返回500状态码。例如，如果网站的后端代码出现了错误，导致无法正确处理请求，服务器可能会返回500状态码。</li>
</ul>
<p>状态码501：<br />
- 未实现（Not
Implemented）：表示服务器不支持客户端请求的功能或方法。</p>
<ul>
<li>场景：当客户端发送了一个服务器不支持的请求方法或功能时，服务器可以返回501状态码。例如，如果客户端发送了一个不被服务器支持的HTTP方法，如PROPFIND，服务器可能会返回501状态码。</li>
</ul>
<p>状态码502：<br />
- 错误网关（Bad
Gateway）：表示服务器作为网关或代理，从上游服务器接收到的响应无效。</p>
<ul>
<li>场景：当服务器作为网关或代理时，如果服务器从上游服务器接收到的响应无效，可能会返回502状态码。例如，当反向代理服务器无法访问后端服务器或后端服务器返回了无效的响应时，可能会返回502状态码。</li>
</ul>
<p>状态码503 ：<br />
- 服务不可用（Service
Unavailable）：表示服务器暂时无法处理请求，通常是由于服务器过载或维护。</p>
<ul>
<li>场景：当服务器暂时无法处理请求时，可能会返回503状态码。例如，当网站正在进行维护或升级时，服务器可以返回503状态码来告知客户端服务不可用。</li>
</ul>
<p>状态码504 ：<br />
- 网关超时（Gateway
Timeout）：表示服务器作为网关或代理，在等待上游服务器的响应时超时。</p>
<ul>
<li>场景：当服务器作为网关或代理时，在等待上游服务器的响应时超时，可能会返回504状态码。例如，如果反向代理服务器在规定的超时时间内无法从后端服务器获取响应，可能会返回504状态码。</li>
</ul>
<h3 id="说一说四次挥手的整个过程">说一说四次挥手的整个过程？</h3>
<p>TCP 四次挥手的过程如下：<br />
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8Fv7jJJwwGE0csE4AQbMfsfxn8fkb2Togxbic4AfHsxHOYOHpOkp1s7GQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" /></p>
<p>具体过程：<br />
- 客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个 FIN
报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；<br />
- 服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入
CLOSE_WAIT 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN
包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read
调用来感知这个 FIN 包，这个 EOF
会被<strong>放在已排队等候的其他已接收的数据之后</strong>，所以必须要得继续
read 接收缓冲区已接收的数据；<br />
- 接着，当服务端在 read 数据的时候，最后自然就会读到
EOF，接着 <strong>read() 就会返回
0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数</strong>，这时服务端就会发一个
FIN 包，这个 FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK
状态； - 客户端接收到服务端的 FIN 包，并发送 ACK
确认包给服务端，此时客户端将进入 TIME_WAIT 状态；<br />
- 服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；<br />
- 客户端经过 2MSL 时间之后，也进入 CLOSE 状态；</p>
<p>你可以看到，每个方向都需要<strong>一个 FIN 和一个
ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<h3 id="time_wait-为什么2msl">Time_wait 为什么2MSL ？</h3>
<p>主要是两个原因：<br />
- 防止历史连接中的数据，被后面相同四元组的连接错误的接收； -
保证「被动关闭连接」的一方，能被正确的关闭；</p>
<p><em>原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</em></p>
<p>假设 TIME-WAIT
没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8FxkiaDtTiaPic5nMTYibuc99tUTn47GaD5aN7MY6pJl1124fvcnIZbgGhsA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>TIME-WAIT 时间过短，收到旧连接的数据报文</p>
<p>如上图：<br />
-
服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。<br />
-
接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 <code>SEQ = 301</code> 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</p>
<p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP
设计了 TIME_WAIT
状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><em>原因二：保证「被动关闭连接」的一方，能被正确的关闭</em></p>
<p>在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：</p>
<p><em>TIME-WAIT - represents waiting for enough time to pass to be sure
the remote TCP received the acknowledgment of its connection termination
request.</em></p>
<p>也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK
能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>如果客户端（主动关闭方）最后一次 ACK
报文（第四次挥手）在网络中丢失了，那么按照 TCP
可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p>
<p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK
报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN
报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN
报文后，就会回 RST 报文。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8FTHCOiaibXqhmaKvG8KPibqzCDJtX0ZHguqUHyw4u1hyj74yRmnBjTSSvw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>TIME-WAIT 时间过短，没有确保连接正常关闭</p>
<p>服务端收到这个 RST 并将其解释为一个错误（Connection reset by
peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p>
<p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到
ACK，如果服务端没有收到 ACK，那么就会触发 TCP
重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL
的时间。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8FNbVIttAllb78oaqK4licVELx3ZXkg2xy1TJOVkg0cY9MWpRPXByGHqA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>TIME-WAIT 时间正常，确保了连接正常关闭</p>
<p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT
状态的等待时间，会重置回 2MSL。</p>
<h3
id="当存在大量close_wait的连接时怎么处理">当存在大量close_wait的连接时怎么处理？</h3>
<p>CLOSE_WAIT
状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close
函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT
状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT
状态的连接的时候，说明服务端的程序没有调用 close
函数关闭连接</strong>。</p>
<p>那什么情况会导致服务端的程序没有调用 close
函数关闭连接？这时候通常需要排查代码。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol type="1">
<li><p>创建服务端 socket，bind 绑定端口、listen 监听端口</p></li>
<li><p>将服务端 socket 注册到 epoll</p></li>
<li><p>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的
socket</p></li>
<li><p>将已连接的 socket 注册到 epoll</p></li>
<li><p>epoll_wait 等待事件发生</p></li>
<li><p>对方连接关闭时，我方调用 close</p></li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因，如下。</p>
<p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket
注册到
epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的
socket，那服务端自然就没机会对 socket 调用 close 函数了。</p>
<p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read
view 阶段就能发现的了。</p>
<p><strong>第二个原因</strong>：第 3 步没有做，有新连接到来时没有调用
accpet 获取该连接的
socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket
调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p>
<p>发生这种情况可能是因为服务端在执行 accpet
函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的
socket 后，没有将其注册到 epoll，导致后续收到 FIN
报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close
函数了。</p>
<p><strong>第四个原因</strong>：第 6
步没有做，当发现客户端关闭连接后，服务端没有执行 close
函数，可能是因为代码漏处理，或者是在执行 close
函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p>
<p>可以发现，当服务端出现大量 CLOSE_WAIT
状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用
close。</p>
<h2 id="mysql">mysql</h2>
<h3 id="什么是聚簇索引和非聚簇索引">什么是聚簇索引和非聚簇索引？</h3>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8FTecAbR8ib4stz31RKO25BjxrIhQgZnQsBC63gQwA8Q7bBDv1tlKwCIA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<ul>
<li><p>对于<strong>聚簇索引表</strong>来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。</p></li>
<li><p>对于<strong>非聚簇索引表</strong>来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。</p></li>
</ul>
<h3 id="inoodb-为什么要使用聚簇索引">InooDB 为什么要使用聚簇索引？</h3>
<p>使用聚簇索引的一些好处：</p>
<ul>
<li><p>数据行的物理存储顺序：使用聚集索引可以将数据行按照索引键的顺序存储在磁盘上，这样相邻的数据行在物理上也是相邻的。这种物理存储顺序可以提高基于范围查询的性能，因为相关的数据行在物理上是连续的，减少了磁盘I/O的次数。</p></li>
<li><p>覆盖索引查询：由于聚集索引包含了实际的数据行，当查询只需要使用聚集索引的键列时，可以避免访问数据行，提高查询性能。这种情况下也称为覆盖索引查询。</p></li>
</ul>
<h3 id="什么是-inoodb里面的联合索引">什么是 InooDB里面的联合索引？</h3>
<p>通过将多个字段组合成一个索引，该索引就被称为联合索引。</p>
<p>比如，将商品表中的 product_no 和 name
字段组合成联合索引<code>(product_no, name)</code>，创建联合索引的方式如下：</p>
<p><code>CREATE INDEX index_product_no_name ON product(product_no, name);</code></p>
<p>联合索引<code>(product_no, name)</code> 的 B+Tree
示意图如下（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8FKhzLTbdTZNwEjWS6SVicPRmxbGmdHwhqrwhzxrcdtxVM3AOic5Ey0k9g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>联合索引</p>
<p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key
值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no
相同的情况下再按 name 字段比较。</p>
<p>也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再
product_no 相同的情况再按 name 字段排序。</p>
<p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li><p>where a=1；</p></li>
<li><p>where a=1 and b=2 and c=3；</p></li>
<li><p>where a=1 and b=2；</p></li>
</ul>
<p>需要注意的是，因为有查询优化器，所以 a 字段在 where
子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li><p>where b=2；</p></li>
<li><p>where c=3；</p></li>
<li><p>where b=2 and c=3；</p></li>
</ul>
<p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按
a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c
排序。所以，<strong>b 和 c
是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p>
<p>我这里举联合索引（a，b）的例子，该联合索引的 B+ Tree
如下（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZcf06PvM1uEQRwdxo5Woia8FVDtES9bnYHKBu4vibHguVRclbINQVMXouHQ9dXKTUeozUPIIttDfScg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>img</p>
<p>可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b
是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行<code>where b = 2</code>这种查询条件没有办法利用联合索引的，<strong>利用索引的前提是索引里的
key 是有序的</strong>。</p>
<p>只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b
的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行<code>where a = 2 and b = 7</code>是
a 和 b 字段能用到联合索引的，也就是联合索引生效了。</p>
<h3
id="给出一个表a-有a1a5-个列联合索引a2a1select-a5-from-a-where-a21-and-a12-请问用到联合索引了嘛它的具体过程呢">给出一个表A
有a1~a5 个列，联合索引（a2,a1）select a5 from A where a2=1 and a1=2
请问用到联合索引了嘛？它的具体过程呢？</h3>
<p>查询符合最左匹配原则，可以a1 和 a2 都可以使用联合索引。</p>
<p>具体的查询过程，在二级索引 b+树找到符合条件 a2 和 a1
的记录，然后获取这些记录的 id 值，拿 id 值去主键索引查询 a5
列的值，这里涉及了回表的查询。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>小林coding</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试遇到联合索引，跪了....</title>
    <url>/blog/2023/10/11/data/interview/%E5%B0%8F%E6%9E%97coding/%E7%AC%94%E8%AF%95%E9%81%87%E5%88%B0%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%B7%AA%E4%BA%86..../</url>
    <content><![CDATA[<p>大家好，我是小林。</p>
<p>前几天，在朋友圈发了一个关于联合索引的笔试题，我简单说了我的想法，然后看看朋友圈其他大佬的想法。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/J0g14CUwaZcN3h33XB29mgBex89aoRCg3DmSgl1oOIDIlPsBWGrQEvEqPJSickfAX0wOthPqicJQZypGSMmdoUgw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<figure>
<img
src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/J0g14CUwaZcN3h33XB29mgBex89aoRCgCpnJWNqiaoCEKzL9ibLQUn0ibYYSmKtQR4FudwFsg8R3pTnDZxgh1Vd2Q/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>结果好家伙，出现了很多大佬一起来分析，每个人分析的思路都很不错，也是一个不错的学习素材，所以就今天整理了一下，给大家一起看看。</p>
<h3 id="同学a的想法">同学A的想法</h3>
<p>建省份与idCare联合索引，省份最左边 limit
10之后，在用子查询过滤sex。</p>
<h3 id="同学b的想法">同学B的想法</h3>
<p>其实还得校验下这个设计的，因为explain查询语句，有可能它最后没有采用索引，而采用了全表扫描，此时就得看查询计划的选择了。</p>
<h3 id="同学c的想法">同学C的想法</h3>
<p>如果数据总量不是很大的情况下，sex加索引也是有效的，另外，题主没有说明表数据的组成情况如果表中只有百分之一的女性，那么sex放第一个我觉得会更快，假如条件是女性的情况下，面试官想听到的应该是思考的过程，而不是特定的结果.</p>
<h3 id="同学d的想法">同学D的想法</h3>
<p>不考虑索引创建带来的存储开销，排序的单独建索引，性别可以建成bit索引。省份也可单独索引。相信数据库在投影上的查询优化。</p>
<h3 id="同学e的想法">同学E的想法</h3>
<p>我觉得这里应该说明一下数据多少的场景，看表字段，性别、省份、身份证号，能推断出是存人的基本信息，当数据量很大的时候，省份、性别区分度很低，不说维护索引导致变更操作效率会低的情况，即使建了索引，由于区分度很低的情况可能也会导致全表扫描，创建的（省份、性别、身份证）索引也不会走，导致身份证也会无序需要重新排列。</p>
<p>所以我的结论是:</p>
<ul>
<li><p>1.当数据量很大时，使用省份开头的复合索引也会全表扫时(全表扫描是)，可以就尝试创建idCard或是以idCard开始的复合索引。这样遍历当找到对应数据时无需进行排序。</p></li>
<li><p>2.当数据量比较小时，可以使用这里你回答的(shengfen、sex、idCard)索引，可以能全部走索引。</p></li>
<li><p>3.再次思考了下我思考的第一种方案，要全表扫，还是不行，太慢了，还是用你说得第二种方案更好，强制走索引，这样可以排除掉其他省份和性别的数据，然后可以优化</p></li>
<li><p>3.1优化可以把这部分数据提前按省份(或者再加上性别)创建视图，或是新的表，在新的表或视图里创建idCard
的索引，这样查询的时候可以直接使用省份(或者和性别)直接在对应的视图里排序</p></li>
<li><p>3.2还可以每次修改的时候，按省份性别按维护一个idCard
内含十条数据的最小堆(小顶堆)结构，这样直接查对应的堆结构即可。</p></li>
<li><p>4.最后写到这里的感悟，好像都是trade
off取舍，要查的快，就要提前每次修改时维护新的有顺序的结构，不然就允许查的慢一点。</p></li>
<li><p>4.1如果这种查的很多，可以选择每次维护下这个堆数据结构。</p></li>
<li><p>4.2如果很少，可以就让其慢一点。</p></li>
<li><p>4.3还可以折中，定时去维护这个结构。</p></li>
</ul>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>小林coding</tag>
      </tags>
  </entry>
  <entry>
    <title>最快的三匹马</title>
    <url>/blog/2023/10/11/data/interview/%E6%99%BA%E5%8A%9B%E9%A2%98/%E6%9C%80%E5%BF%AB%E7%9A%84%E4%B8%89%E5%8C%B9%E9%A9%AC/</url>
    <content><![CDATA[<p>有25匹马，赛道只有5道，现在想通过比赛得知前三名的马，请问至少需要比赛几次？这是一道智力题</p>
<p>ChatGPT</p>
<p>这是一道经典的智力题目。我们有25匹马，赛道只有5道，我们想知道最快的前三名马。这个问题的解决方案通常是这样的：</p>
<ol type="1">
<li><p><strong>阶段一：分组赛</strong> -
将25匹马分成5组（每组5匹马），并进行比赛。这样我们可以得知每组中的排名。这需要5次比赛。</p></li>
<li><p><strong>阶段二：组间赛</strong> -
用每组的第一名马进行一次比赛，以确定最快的那匹马。这需要1次比赛。</p></li>
<li><p><strong>阶段三：确定第二、第三名</strong> -
这一步稍微复杂一些。我们已经知道了最快的那匹马。为了确定第二和第三名，我们需要在以下这些马中找出最快的两匹：</p>
<ul>
<li>第一名马的组中的第二名和第三名马（2匹）<br />
</li>
<li>在第二阶段比赛中，排名第二的马的组中的第一名和第二名马（2匹）<br />
</li>
<li>在第二阶段比赛中，排名第三的马的组中的第一名马（1匹）</li>
</ul>
<p>这样，我们在这5匹马中进行一次比赛，以确定第二和第三名。这需要1次比赛。</p></li>
</ol>
<p>总结：我们至少需要进行 5+1+1=75+1+1=7 次比赛，以确定前三名的马。</p>
<p>为什么阶段二的第二第三名不一定是真正的最终的第二第三名，反而需要第七场比赛的特殊安排才能得知？</p>
<p>ChatGPT</p>
<p>这是一个很好的问题，让我们深入探讨一下。</p>
<p>在阶段二中，我们通过比赛每组的冠军来确定整体的冠军。但是，我们不能确定阶段二中的第二名和第三名是否是整体的第二名和第三名，原因如下：</p>
<ol type="1">
<li><p><strong>不同组的实力可能不均等</strong>：即使一匹马在其组中排名第二或第三，也有可能比其他组的冠军更快。例如，如果所有最快的马恰好都在同一组，那么该组的第二名和第三名马可能比其他组的冠军还要快。</p></li>
<li><p><strong>没有直接比较</strong>：在阶段二中，我们只比较了每组的冠军，而没有比较其他马。因此，我们不能直接得出阶段二中的第二名和第三名在整体中的排名。</p></li>
</ol>
<p>因此，在阶段三中，我们需要在一个较小的候选组中进行比赛，以确定整体的第二名和第三名。这个候选组包括：</p>
<ul>
<li>整体冠军的组中的第二名和第三名马（因为这两匹马没有与其他组的冠军比赛过）<br />
</li>
<li>阶段二中的第二名马的组中的冠军和第二名马（因为这两匹马只与整体冠军比赛过）<br />
</li>
<li>阶段二中的第三名马的组中的冠军（因为这匹马没有与整体冠军和阶段二的第二名马比赛过）</li>
</ul>
<p>这7匹马中的任何一匹都有可能是整体的第二名或第三名。因此，我们在阶段三中进行一次比赛，以确定整体的第二名和第三名。这样，我们总共进行了7次比赛，以确定前三名的马。</p>
<p>也就是说，假设每匹马每次比赛的成绩是固定的，那么正常人的思维应该是每个小组的第一名再比一次，每个小组的第二名再比一次，每个小组的第三名再比一次，一共需要8次比赛，但是最优方案是7次？</p>
<p>ChatGPT</p>
<p>是的，你理解得很对。在常规思维下，我们可能会认为需要分别比较每个小组的第一名、第二名和第三名，以确定总体的前三名。这样的确需要8次比赛。但是，通过巧妙的安排，我们实际上可以只用7次比赛就确定出总体的前三名。</p>
<p>这个问题的关键在于，一旦我们确定了最快的那匹马（通过第二阶段的比赛），我们就可以缩小确定第二名和第三名马的候选范围。我们不需要在所有的第二名和第三名马中进行比较，因为有些马在之前的比赛中已经被证明不可能是第二名或第三名。例如，第二阶段比赛中排名第四和第五的马就不可能是总体的第二名或第三名。</p>
<p>因此，我们可以在一个更小的候选组中进行比赛，以确定第二名和第三名，从而减少了所需的比赛次数。这就是为什么我们可以在7次比赛中确定前三名的原因。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>智力题</tag>
      </tags>
  </entry>
  <entry>
    <title>输电线点云处理主要方向</title>
    <url>/blog/2023/10/11/data/lab/point%20cloud/%E8%BE%93%E7%94%B5%E7%BA%BF%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86%E4%B8%BB%E8%A6%81%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p><img
src="https://pic3.zhimg.com/80/v2-a354d689809868225f756fbdc371e712_720w.webp" /></p>
<p>近几年，LiDAR三维激光扫描技术快速发展，在行业中的应用成熟度不断提高！为实景三维信息采集带来了极大的效率提升，随着LiDAR设备的不断精进，点云数据的精度、密度等关键参数也随之大幅提升，为行业应用带来了更多的可能！然而高效率、高密度的点云数据在带给行业诸多好处的同时，也为内业数据处理和应用筑起了一道无形的门槛！LiDAR电力巡检项目中的点云数据该如何使用？本期内容分享将为大家详细解读！欢迎感兴趣的朋友们报名参与！</p>
<p><img
src="https://pic3.zhimg.com/80/v2-bdffaa434d85fe57a0a18011a1f7b176_720w.webp" /></p>
<p>电力廊道全要素提取</p>
<p><img
src="https://pic3.zhimg.com/80/v2-afc388f5c9e0029c85e9d0b9094e9ec6_720w.webp" /></p>
<p>导线净空距离查询</p>
<p><img
src="https://pic2.zhimg.com/80/v2-fa1a109c668b3a013f892f0f64d30701_720w.webp" /></p>
<p>杆塔批量自动定位</p>
<p><img
src="https://pic1.zhimg.com/80/v2-b8660530183512857d71ff4937c5af88_720w.webp" /></p>
<p>杆塔批量定位结果</p>
<p><img
src="https://pic3.zhimg.com/80/v2-fdb43e115fa52e800ba8a3d4990b4c8e_720w.webp" /></p>
<p>导线批量自动提取</p>
<p><img
src="https://pic2.zhimg.com/80/v2-a48244bed19d2792fa485c377f33b7b5_720w.webp" /></p>
<p>线路及周边地形要素提取</p>
<p><img
src="https://pic1.zhimg.com/80/v2-1487a9f617c80480fde16cf9275c92f8_720w.webp" /></p>
<p><img
src="https://pic1.zhimg.com/80/v2-94593b5651d254bc7f970ccdf254dcb8_720w.webp" /></p>
<p>杆塔附件空间位置批量自动标注</p>
<p><img
src="https://pic4.zhimg.com/80/v2-53b85f20c99ebbdafeae1e6831340f9f_720w.webp" /></p>
<p>杆塔附件相对位置标注</p>
<p><img
src="https://pic3.zhimg.com/80/v2-28976ec3d7809b3de6a2bd0823f3ee32_720w.webp" /></p>
<p>树障点云自动化分类与标注</p>
<p><img
src="https://pic3.zhimg.com/80/v2-903e809c5e9c2b9cabeb21811e6929e2_720w.webp" /></p>
<p>线路全要素成果示例</p>
<p><img
src="https://pic2.zhimg.com/80/v2-9d4ed881518b8e965a18f6e002143bd9_720w.webp" /></p>
<p>杆塔及电力设施逆向三维建模</p>
<p><strong>活动日程</strong></p>
<p>2021年6月4日，周五，14:00-15:00</p>
<p><strong><em>分享内容将会全程录制，支持回放</em></strong></p>
<p><strong>分享内容</strong></p>
<ul>
<li>杆塔批量自动定位与标注<br />
</li>
<li>地面点云自动分类<br />
</li>
<li>导线自动化/半自动化提取<br />
</li>
<li>导线悬垂弧度、长度快速编辑<br />
</li>
<li>自动化生成导线连接点<br />
</li>
<li>导线点云自动分类<br />
</li>
<li>导线与树障空间位置分析<br />
</li>
<li>树障轮廓自动三维矢量化<br />
</li>
<li>导线至树障最小空间距离自动标注<br />
</li>
<li>导线交跨/对地净空距离自动分析与标注<br />
</li>
<li>并排导线之间最小距离自动分析与标注<br />
</li>
<li>线路空间尺寸标注信息快速出图<br />
</li>
<li>杆塔及电力设施逆向三维建模<br />
</li>
<li>互动问答</li>
</ul>
]]></content>
      <categories>
        <category>lab</category>
      </categories>
      <tags>
        <tag>lab</tag>
        <tag>point cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>import和require导入包的区别</title>
    <url>/blog/2023/10/11/data/languages/JavaScript/import%E5%92%8Crequire%E5%AF%BC%E5%85%A5%E5%8C%85%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>While importing packages in the Node.js project, you may have come
across the two keywords i.e., require and import. Well, both keywords
are used to import packages or modules in the Node.js project. But there
are certain differences between them.</p>
<h2 id="introduction">Introduction</h2>
<p>Let's first understand modules in Node.js. Modules are blocks of code
that are encapsulated in single or multiple files to facilitate related
functionality to the application. Modules break down the complex long
piece of code into smaller parts for easy debugging and management.
Modules also help in the re-usability of code.</p>
<p>Node.js has mainly two module systems:</p>
<ul>
<li>CommonJS modules and<br />
</li>
<li>ECMAScript modules.</li>
</ul>
<p>CommonJS is the default module system.</p>
<p>Node.js has three types of modules:</p>
<ol type="1">
<li><strong>Core Modules:</strong><br />
These are built-in modules like: http, fs, etc.<br />
</li>
<li><strong>Local Modules:</strong><br />
These modules are locally created by the programmer.<br />
</li>
<li><strong>Third-Party Modules:</strong><br />
These modules are available to use after installation using NPM(Node
Package Manager) like: express, mongoose etc.</li>
</ol>
<p>Now Let's look into the different ways to include these modules in
our application:<br />
## Require in Node.js</p>
<p>As discussed above that Node.js follows the CommonJS module system,
and the built-in require function is the easiest way to include modules
in this system. When we call require in Node.js then the require
function first reads a JavaScript file, executes that file, and then the
require function proceeds to return the exports object.</p>
<p>When require function is invoked Node goes through the following
sequence of steps:</p>
<ul>
<li><strong>Resolving:</strong><br />
In this step Node gets the absolute path of the module. It follows the
following steps to resolve the path:
<ul>
<li>For const test = require('example') syntax:
<ul>
<li>It first looks for core modules with that name.<br />
</li>
<li>If no such core module is present then it looks for a file with the
name node_modules/ of the current folder and still if no module is found
then it will look for it in the parent folders of the current
folder.<br />
</li>
<li>If a folder is found with that name containing an index.js file then
that index.js file is loaded.<br />
</li>
</ul></li>
<li>For syntax with path starting with ./ or ../ like: const test =
require('./lib/example.js') :
<ul>
<li>Such syntax may contain an absolute path or a relative path. So the
file present at that location is loaded in this case.</li>
</ul></li>
</ul></li>
</ul>
<p><strong>Note:</strong> If no file is found after these steps then an
error is thrown.</p>
<ul>
<li><strong>Loading:</strong><br />
In this step Node loads the module and determines the type of file
content.<br />
</li>
<li><strong>Wrapping:</strong><br />
After loading, the module code is wrapped in a special function that
will give access to a couple of objects. It also gives a separate scope
to the variables.<br />
</li>
<li><strong>Evaluating:</strong><br />
At this step JavaScript Engine (usually V8) executes the code present in
the wrapper function and exports functions or variables mentioned with
the module.exports in the file.<br />
</li>
<li><strong>Caching:</strong><br />
After the evaluation step, Node.js modules are cached (i.e., stored for
future use) when the module is loaded for the first time. And later if
you need to load the same node module next time then node.js does not go
through above mentioned steps for that module again as it will copy that
module from the cache.</li>
</ul>
<h3 id="syntax-and-examples-for-require-in-node.js">Syntax and Examples
for Require in Node.js</h3>
<p><strong>Loading core modules</strong></p>
<p><strong>Syntax:</strong><br />
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">&#x27;module_name&#x27;</span>)</span><br></pre></td></tr></table></figure> <strong>Example:</strong><br />
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>Loading local modules</strong></p>
<p>For loading locally created modules, we can provide a path to the
required function in the following ways.</p>
<p><strong>Using absolute path</strong></p>
<p><strong>Syntax:</strong><br />
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">&#x27;/&lt;folder1&gt;/&lt;folder2&gt;/.../module&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>Example:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;/lib/obj/util.js&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Using relative path</strong></p>
<p>We can also provide a relative path using ./ or ../ in the required
function.</p>
<p><strong>Syntax:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">&#x27;./module_name&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Example:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">&#x27;../hello.js&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br />
You can omit the .js extension in the above example also i.e. if you
don't provide any extension then Node searches for a file with
that module_name and .js extension and loads it.</p>
<p><strong>Using folder path</strong></p>
<p>You can load modules just by folder path also:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">&#x27;./folder_name&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Example:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>By default, the node finds the index.js file in that folder and loads
it. Otherwise, we can also create a package.json file in that folder
where we can define the node module name which we want to load by
default.</p>
<h2 id="import-in-node.js">Import in Node.js</h2>
<p>As required works in the CommonJs modules system, similarly, import
is used for including modules in ES6 (version 6 of the ECMA Script)
module system. Which means import is used to include an ES module. At
present Node.js doesn’t support ES6 import directly. So if we try to use
the import keyword for importing modules directly in node js it will
throw out the error. So how can we use import for including modules then
you can do so in the following ways:</p>
<p><strong>Using ".mjs" extension</strong></p>
<p>The first way to use the ES6 import statement in Node.js is to save
the JavaScript file with the ".mjs" extension, instead of using the
typical ".js" extension.</p>
<p>As mentioned above the default module system for Node.js is CommonJs
which supports require function for importing modules. So if we want to
use the ECMAScript module system then the ".mjs" extension helps us
achieve that.</p>
<p><strong>Using package.json file</strong></p>
<p>By this method, we can use the ".js" extension while using the import
statement of ECMAScript. For this, we need to include a package.json
file in our project. And the content of package.json should be like
this:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node_import&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>The <strong>"type"</strong> property present in the above
package.json file helps in deciding the module system that the project
should use. The "type" can
be <strong>"module"</strong> or <strong>"commonjs"</strong>. If the type
is <strong>"module"</strong> then it enables the ECMAScript module
system, whereas if the type is <strong>"commonjs"</strong> then it is of
the CommonJS module system.</p>
<p>We can use import statements in the following ways:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Importing the entire module</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&#x27;module_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Importing the default export from the module</span></span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&#x27;module_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Importing a single export from the module:</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;module_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Importing multiple exports from the module:</span></span><br><span class="line"><span class="keyword">import</span> &#123; name1, name2 &#125; <span class="keyword">from</span> <span class="string">&#x27;module_name&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="difference-between-require-and-import">Difference between
Require and Import</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>require</th>
<th>import</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>It is used in the CommonJS module system.</td>
<td>It is used in the ES6 (ECMAScript version 6) module system.</td>
</tr>
<tr class="even">
<td>Loading is synchronous in require (i.e., modules are imported
sequentially.)</td>
<td>Loading is asynchronous in import (i.e., modules are imported
without waiting for previous module import to complete.)</td>
</tr>
<tr class="odd">
<td>Because of synchronous loading performance of require less efficient
than import.</td>
<td>Because the Asynchronous loading performance of import is better
than required.</td>
</tr>
<tr class="even">
<td>If we import a module using require then the complete module is
imported. So, memory usage is more.</td>
<td>Using import we can selectively load pieces of code in the module.
So, memory usage is less compared to require.</td>
</tr>
<tr class="odd">
<td>require imports of the components exported by module. exports in the
module.</td>
<td>import includes components exported by export in the module.</td>
</tr>
<tr class="even">
<td>require can be called directly as it is the default way of
importing.</td>
<td>To use import in our project we need to enable ES6 or ECMAScript
module in our project.</td>
</tr>
<tr class="odd">
<td>require can be called anywhere in the program</td>
<td>import works only at the top of the program</td>
</tr>
</tbody>
</table>
<figure>
<img
src="https://www.scaler.com/topics/images/difference-between-require-and-importdifference-between-require-and-import.webp"
alt="difference-between-require-and-import" />
<figcaption
aria-hidden="true">difference-between-require-and-import</figcaption>
</figure>
<p><em><strong>Become a coding wizard with our <a
href="https://www.scaler.com/topics/course/nodejs/">Free Node JS
course</a>. Join now and master the art of server-side
programming.</strong></em></p>
<h2 id="conclusion">Conclusion</h2>
<ul>
<li><strong>Modules</strong> are encapsulated blocks of code that are
used in the external application based on its related
functionality.<br />
</li>
<li>Modules can be included in the project using two ways: require or
import.<br />
</li>
<li>require is a built-in function to import modules provided by
the CommonJS module system.<br />
</li>
<li>import statements are used in ES6 or ECMAScript module system to
include modules.<br />
</li>
<li>require includes the complete file whereas by import we can include
specific export components only.<br />
</li>
<li>To use The ES6 module system in the project, follow any of these two
steps:
<ul>
<li>Use the ".mjs" extension in place of the default ".js" extension in
the project.<br />
</li>
<li>Edit the value of the "type" property in the package.json file
to "module".</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>multiprocessing的subroutine不要在主进程中</title>
    <url>/blog/2023/10/11/data/languages/Python/multiprocessing%E7%9A%84subroutine%E4%B8%8D%E8%A6%81%E5%9C%A8%E4%B8%BB%E8%BF%9B%E7%A8%8B%E4%B8%AD/</url>
    <content><![CDATA[<p>multiprocessing必须获得subroutine的定义才能开启子进程执行subroutine函数进行并行化任务处理，如果subroutine函数定义在
if <strong>name</strong> ==
"<strong>main</strong>"里面的话，子进程是拿不到主进程的subroutine函数定义的，也就是会报错
no attribute &lt;subroutine&gt;<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subroutine</span>(<span class="params">ent</span>):</span><br><span class="line">        response = requests.request(url=<span class="string">f&quot;http://47.92.27.174:9190/ndival_seg2?code=<span class="subst">&#123;ent[<span class="string">&#x27;code&#x27;</span>]&#125;</span>&quot;</span>, method=<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = json.loads(<span class="built_in">str</span>(response.content)[<span class="number">3</span>:-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(ent[<span class="string">&quot;code&quot;</span>], <span class="string">&quot;received empty json response&quot;</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        retlist = []</span><br><span class="line">        retlist.append(ent[<span class="string">&quot;code&quot;</span>])</span><br><span class="line">        retlist.append(ent[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;market_cap&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;pe_ad&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;net_profit_sos_predict_q&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;pe_predict_q&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;value_space_predict_q&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;value_space_com_predict_q&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;value_space_q&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;value_space_com_q&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;value_space_y&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;value_space_com_y&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;value_space_y_1&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;value_space_com_y_1&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;v2_min&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;v1_max&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;v_min&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;v_max&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;vs_min&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;vs_max&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;vc_min&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;vc_max&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;target_space&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;growth_rate&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;net_profit_yoy&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;revenue_yoy&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;svs_max&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;svs_min&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;value_cap&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;revenue_growth&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;profit_growth&quot;</span>])</span><br><span class="line">        retlist.append(data[<span class="string">&quot;growth_cap&quot;</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(retlist)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    workbook = openpyxl.load_workbook(<span class="string">&quot;./data/230511/源数据_新1段_230511.xlsx&quot;</span>)</span><br><span class="line">    workshet = workbook.active</span><br><span class="line">    enterprises = [&#123;<span class="string">&quot;code&quot;</span>: cellA.value, <span class="string">&quot;name&quot;</span>: cellB.value&#125; <span class="keyword">for</span> (cellA, cellB) <span class="keyword">in</span> <span class="built_in">zip</span>(workshet[<span class="string">&quot;A&quot;</span>], workshet[<span class="string">&quot;B&quot;</span>])][<span class="number">5150</span>:]</span><br><span class="line">    workbook.close()</span><br><span class="line">    workbook = openpyxl.Workbook()</span><br><span class="line">    workshet = workbook.create_sheet(<span class="string">&quot;二次数据核查汇总&quot;</span>)</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="keyword">with</span> mp.Pool(<span class="number">12</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        results = pool.<span class="built_in">map</span>(subroutine, enterprises)</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;parallel processing cost <span class="subst">&#123;t2 - t1&#125;</span>s&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="keyword">for</span> rowidx, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(results):</span><br><span class="line">        <span class="keyword">for</span> validx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>(line)):</span><br><span class="line">            cell = workshet.cell(row=rowidx + <span class="number">2</span>, column=validx + <span class="number">1</span>)</span><br><span class="line">            cell.value = val</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;serial processing cost <span class="subst">&#123;t2 - t1&#125;</span>s&quot;</span>)</span><br><span class="line">    workbook.save(<span class="string">&quot;./output2.xlsx&quot;</span>)</span><br><span class="line">    workbook.close()</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>np.array 和 np.ndarray 区别是什么？</title>
    <url>/blog/2023/10/11/data/languages/Python/np.array%20%E5%92%8C%20np.ndarray%20%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><code>numpy.ndarray()</code> is a class,
while <code>numpy.array()</code> is a method / function to
create <code>ndarray</code>.</p>
<p>In numpy docs if you want to create an array
from <code>ndarray</code> class you can do it with 2 ways as quoted:</p>
<p>1-
using <code>array()</code>, <code>zeros()</code> or <code>empty()</code> methods: <em>Arrays
should be constructed using array, zeros or empty (refer to the See Also
section below). The parameters given here refer to a low-level method
(<code>ndarray(…)</code>) for instantiating an array.</em></p>
<p>2- from <code>ndarray</code> class directly: <em>There are two modes
of creating an array using <code>__new__</code>: If buffer is None, then
only shape, dtype, and order are used. If buffer is an object exposing
the buffer interface, then all keywords are interpreted.</em></p>
<p>The example below gives a random array because we didn't assign
buffer value:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ndarray(shape=(<span class="number">2</span>,<span class="number">2</span>), dtype=<span class="built_in">float</span>, order=<span class="string">&#x27;F&#x27;</span>, buffer=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">array([[ -<span class="number">1.13698227e+002</span>,   <span class="number">4.25087011e-303</span>],</span><br><span class="line">       [  <span class="number">2.88528414e-306</span>,   <span class="number">3.27025015e-309</span>]])         <span class="comment">#random</span></span><br></pre></td></tr></table></figure>
<p>another example is to assign array object to the buffer example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.ndarray((<span class="number">2</span>,), buffer=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]),</span><br><span class="line"><span class="meta">... </span>    offset=np.int_().itemsize,</span><br><span class="line"><span class="meta">... </span>    dtype=<span class="built_in">int</span></span><br><span class="line"><span class="meta">... </span>) <span class="comment"># offset = 1*itemsize, i.e. skip first element</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array([<span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>from above example we notice that we can't assign a list to "buffer"
and we had to use numpy.array() to return ndarray object for the
buffer</p>
<p>Conclusion: use <code>numpy.array()</code> if you want to make
a <code>numpy.ndarray()</code> object"</p>
<p>所以需要注意的点还有，不要使用<code>np.array</code>来进行类型判断，它是一个用于构造<code>np.ndarray</code>的工厂函数</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>strftime 格式化时间日期</title>
    <url>/blog/2023/10/11/data/languages/Python/strftime%20%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="描述">描述</h2>
<p>Python time strftime()
函数用于格式化时间，返回以可读字符串表示的当地时间，格式由参数 format
决定。</p>
<h2 id="语法">语法</h2>
<p>strftime()方法语法：</p>
<p>time.strftime(format[, t])</p>
<h2 id="参数">参数</h2>
<ul>
<li>format -- 格式字符串。<br />
</li>
<li>t -- 可选的参数 t 是一个 struct_time 对象。</li>
</ul>
<h2 id="返回值">返回值</h2>
<p>返回以可读字符串表示的当地时间。</p>
<h2 id="说明">说明</h2>
<p>python中时间日期格式化符号：</p>
<ul>
<li>%y 两位数的年份表示（00-99）<br />
</li>
<li>%Y 四位数的年份表示（000-9999）<br />
</li>
<li>%m 月份（01-12）<br />
</li>
<li>%d 月内中的一天（0-31）<br />
</li>
<li>%H 24小时制小时数（0-23）<br />
</li>
<li>%I 12小时制小时数（01-12）<br />
</li>
<li>%M 分钟数（00=59）<br />
</li>
<li>%S 秒（00-59）<br />
</li>
<li>%a 本地简化星期名称<br />
</li>
<li>%A 本地完整星期名称<br />
</li>
<li>%b 本地简化的月份名称<br />
</li>
<li>%B 本地完整的月份名称<br />
</li>
<li>%c 本地相应的日期表示和时间表示<br />
</li>
<li>%j 年内的一天（001-366）<br />
</li>
<li>%p 本地A.M.或P.M.的等价符<br />
</li>
<li>%U 一年中的星期数（00-53）星期天为星期的开始<br />
</li>
<li>%w 星期（0-6），星期天为星期的开始<br />
</li>
<li>%W 一年中的星期数（00-53）星期一为星期的开始<br />
</li>
<li>%x 本地相应的日期表示<br />
</li>
<li>%X 本地相应的时间表示<br />
</li>
<li>%Z 当前时区的名称<br />
</li>
<li>%% %号本身</li>
</ul>
<h2 id="实例">实例</h2>
<p>以下实例展示了 strftime() 函数的使用方法：<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python  </span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 通过导入 __future__ 包来兼容 Python3.x print  </span></span><br><span class="line"><span class="comment"># 如果使用了 Python3.x 可以删除此行引入  </span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">now = datetime.now() <span class="comment"># current date and time  </span></span><br><span class="line">  </span><br><span class="line">year = now.strftime(<span class="string">&quot;%Y&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;year:&quot;</span>, year)  </span><br><span class="line">  </span><br><span class="line">month = now.strftime(<span class="string">&quot;%m&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;month:&quot;</span>, month)  </span><br><span class="line">  </span><br><span class="line">day = now.strftime(<span class="string">&quot;%d&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;day:&quot;</span>, day)  </span><br><span class="line">  </span><br><span class="line">time = now.strftime(<span class="string">&quot;%H:%M:%S&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time:&quot;</span>, time)  </span><br><span class="line">  </span><br><span class="line">date_time = now.strftime(<span class="string">&quot;%Y-%m-%d, %H:%M:%S&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;date and time:&quot;</span>,date_time)  </span><br></pre></td></tr></table></figure></p>
<p>以上实例输出结果为：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">year: 2020</span><br><span class="line">month: 09</span><br><span class="line">day: 25</span><br><span class="line">time: 10:24:28</span><br><span class="line">date and time: 2020-09-25, 10:24:28</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 parse 包做正则表达式分析</title>
    <url>/blog/2023/10/11/data/languages/Python/%E4%BD%BF%E7%94%A8%20parse%20%E5%8C%85%E5%81%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>从一段指定的字符串中，取得期望的数据，正常人都会想到正则表达式吧？</p>
<p>写过正则表达式的人都知道，正则表达式入门不难，写起来也容易。</p>
<p>但是正则表达式几乎没有可读性可言，维护起来，真的会让人抓狂，别以为这段正则是你写的就可以驾驭它，过个一个月你可能就不认识它了。</p>
<p>完全可以说，天下苦正则久矣。</p>
<p>今天给你介绍一个好东西，可以让你摆脱正则的噩梦，那就是 Python
中一个非常冷门的库 – parse 。</p>
<p>PS：如有需要Python学习资料的小伙伴可以加点击下方链接自行获取</p>
<p><a
href="https://link.zhihu.com/?target=https%3A//jq.qq.com/%3F_wv%3D1027%26k%3DrwkJ1Qtr">python免费学习资料以及群交流解答点击即可加入</a></p>
<h2 id="真实案例">1. 真实案例</h2>
<p>拿一个最近使用 parse 的真实案例来举例说明。</p>
<p>下面是 ovs
一个条流表，现在我需要收集提取一个虚拟机（网口）里有多少流量、多少包流经了这条流表。也就是每个
in_port 对应的 n_bytes、n_packets 的值 。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cookie=0x9816da8e872d717d, duration=298506.364s, table=0, n_packets=480, n_bytes=20160, priority=10,ip,in_port=&quot;tapbbdf080b-c2&quot; actions=NORMAL</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>如果是你，你会怎么做呢？</p>
<p>先以逗号分隔开来，再以等号分隔取出值来？</p>
<p>你不防可以尝试一下，写出来的代码应该和我想象的一样，没有一丝美感而言。</p>
<p>我来给你展示一下，我是怎么做的？</p>
<p><img
src="https://pic4.zhimg.com/80/v2-3df93bc44f632d243f378dfe0150be4f_720w.webp" /></p>
<p>可以看到，我使用了一个叫做 parse 的第三方包，是需要自行安装的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ python -m pip install parse</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>从上面这个案例中，你应该能感受到 parse
对于解析规范的字符串，是非常强大的。</p>
<h2 id="parse-的结果">2. parse 的结果</h2>
<p>parse 的结果只有两种结果：</p>
<ol type="1">
<li>没有匹配上，parse 的值为None</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&quot;halo&quot;, &quot;hello&quot;) is None</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>如果匹配上，parse 的值则 为 Result 实例</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&quot;hello&quot;, &quot;hello world&quot;)</span><br><span class="line">&gt;&gt;&gt; parse(&quot;hello&quot;, &quot;hello&quot;)</span><br><span class="line">&lt;Result () &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>如果你编写的解析规则，没有为字段定义字段名，也就是匿名字段， Result
将是一个 类似 list 的实例，演示如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; profile = parse(&quot;I am &#123;&#125;, &#123;&#125; years old, &#123;&#125;&quot;, &quot;I am Jack, 27 years old, male&quot;)</span><br><span class="line">&gt;&gt;&gt; profile</span><br><span class="line">&lt;Result (&#x27;Jack&#x27;, &#x27;27&#x27;, &#x27;male&#x27;) &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; profile[0]</span><br><span class="line">&#x27;Jack&#x27;</span><br><span class="line">&gt;&gt;&gt; profile[1]</span><br><span class="line">&#x27;27&#x27;</span><br><span class="line">&gt;&gt;&gt; profile[2]</span><br><span class="line">&#x27;male&#x27;</span><br></pre></td></tr></table></figure>
<p>而如果你编写的解析规则，为字段定义了字段名， Result 将是一个 类似
字典 的实例，演示如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; profile = parse(&quot;I am &#123;name&#125;, &#123;age&#125; years old, &#123;gender&#125;&quot;, &quot;I am Jack, 27 years old, male&quot;)</span><br><span class="line">&gt;&gt;&gt; profile</span><br><span class="line">&lt;Result () &#123;&#x27;gender&#x27;: &#x27;male&#x27;, &#x27;age&#x27;: &#x27;27&#x27;, &#x27;name&#x27;: &#x27;Jack&#x27;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; profile[&#x27;name&#x27;]</span><br><span class="line">&#x27;Jack&#x27;</span><br><span class="line">&gt;&gt;&gt; profile[&#x27;age&#x27;]</span><br><span class="line">&#x27;27&#x27;</span><br><span class="line">&gt;&gt;&gt; profile[&#x27;gender&#x27;]</span><br><span class="line">&#x27;male&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="重复利用-pattern">3. 重复利用 pattern</h2>
<p>和使用 re 一样，parse 同样支持 pattern 复用。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from parse import compile</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; pattern = compile(&quot;I am &#123;&#125;, &#123;&#125; years old, &#123;&#125;&quot;)</span><br><span class="line">&gt;&gt;&gt; pattern.parse(&quot;I am Jack, 27 years old, male&quot;)</span><br><span class="line">&lt;Result (&#x27;Jack&#x27;, &#x27;27&#x27;, &#x27;male&#x27;) &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; pattern.parse(&quot;I am Tom, 26 years old, male&quot;)</span><br><span class="line">&lt;Result (&#x27;Tom&#x27;, &#x27;26&#x27;, &#x27;male&#x27;) &#123;&#125;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="类型转化">4. 类型转化</h2>
<p>从上面的例子中，你应该能注意到，parse
在获取年龄的时候，变成了一个"27"
，这是一个字符串，有没有一种办法，可以在提取的时候就按照我们的类型进行转换呢？</p>
<p>你可以这样写。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from parse import parse</span><br><span class="line">&gt;&gt;&gt; profile = parse(&quot;I am &#123;name&#125;, &#123;age:d&#125; years old, &#123;gender&#125;&quot;, &quot;I am Jack, 27 years old, male&quot;)</span><br><span class="line">&gt;&gt;&gt; profile</span><br><span class="line">&lt;Result () &#123;&#x27;gender&#x27;: &#x27;male&#x27;, &#x27;age&#x27;: 27, &#x27;name&#x27;: &#x27;Jack&#x27;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; type(profile[&quot;age&quot;])</span><br><span class="line">&lt;type &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>除了将其转为 整型，还有其他格式吗？</p>
<p>内置的格式还有很多，比如</p>
<p>匹配时间</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&#x27;Meet at &#123;:tg&#125;&#x27;, &#x27;Meet at 1/2/2011 11:00 PM&#x27;)</span><br><span class="line">&lt;Result (datetime.datetime(2011, 2, 1, 23, 0),) &#123;&#125;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="提取时去除空格">5. 提取时去除空格</h2>
<p>去除两边空格</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&#x27;hello &#123;&#125; , hello python&#x27;, &#x27;hello     world    , hello python&#x27;)</span><br><span class="line">&lt;Result (&#x27;    world   &#x27;,) &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; parse(&#x27;hello &#123;:^&#125; , hello python&#x27;, &#x27;hello     world    , hello python&#x27;)</span><br><span class="line">&lt;Result (&#x27;world&#x27;,) &#123;&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>去除左边空格</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&#x27;hello &#123;:&gt;&#125; , hello python&#x27;, &#x27;hello     world    , hello python&#x27;)</span><br><span class="line">&lt;Result (&#x27;world   &#x27;,) &#123;&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>去除右边空格</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&#x27;hello &#123;:&lt;&#125; , hello python&#x27;, &#x27;hello     world    , hello python&#x27;)</span><br><span class="line">&lt;Result (&#x27;    world&#x27;,) &#123;&#125;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="大小写敏感开关">6. 大小写敏感开关</h2>
<p>Parse 默认是大小写不敏感的，你写 hello 和 HELLO 是一样的。</p>
<p>如果你需要区分大小写，那可以加个参数，演示如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&#x27;SPAM&#x27;, &#x27;spam&#x27;)</span><br><span class="line">&lt;Result () &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; parse(&#x27;SPAM&#x27;, &#x27;spam&#x27;) is None</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; parse(&#x27;SPAM&#x27;, &#x27;spam&#x27;, case_sensitive=True) is None</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h2 id="匹配字符数">7. 匹配字符数</h2>
<p>精确匹配：指定最大字符数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&#x27;&#123;:.2&#125;&#123;:.2&#125;&#x27;, &#x27;hello&#x27;)  # 字符数不符</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; parse(&#x27;&#123;:.2&#125;&#123;:.2&#125;&#x27;, &#x27;hell&#x27;)   # 字符数相符</span><br><span class="line">&lt;Result (&#x27;he&#x27;, &#x27;ll&#x27;) &#123;&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>模糊匹配：指定最小字符数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&#x27;&#123;:.2&#125;&#123;:2&#125;&#x27;, &#x27;hello&#x27;) </span><br><span class="line">&lt;Result (&#x27;h&#x27;, &#x27;ello&#x27;) &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; parse(&#x27;&#123;:2&#125;&#123;:2&#125;&#x27;, &#x27;hello&#x27;) </span><br><span class="line">&lt;Result (&#x27;he&#x27;, &#x27;llo&#x27;) &#123;&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>若要在精准/模糊匹配的模式下，再进行格式转换，可以这样写</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&#x27;&#123;:2&#125;&#123;:2&#125;&#x27;, &#x27;1024&#x27;) </span><br><span class="line">&lt;Result (&#x27;10&#x27;, &#x27;24&#x27;) &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; parse(&#x27;&#123;:2d&#125;&#123;:2d&#125;&#x27;, &#x27;1024&#x27;) </span><br><span class="line">&lt;Result (10, 24) &#123;&#125;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="三个重要属性">8. 三个重要属性</h2>
<p>Parse 里有三个非常重要的属性</p>
<ul>
<li>fixed：利用位置提取的匿名字段的元组<br />
</li>
<li>named：存放有命名的字段的字典<br />
</li>
<li>spans：存放匹配到字段的位置</li>
</ul>
<p>下面这段代码，带你了解他们之间有什么不同</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; profile = parse(&quot;I am &#123;name&#125;, &#123;age:d&#125; years old, &#123;&#125;&quot;, &quot;I am Jack, 27 years old, male&quot;)</span><br><span class="line">&gt;&gt;&gt; profile.fixed</span><br><span class="line">(&#x27;male&#x27;,)</span><br><span class="line">&gt;&gt;&gt; profile.named</span><br><span class="line">&#123;&#x27;age&#x27;: 27, &#x27;name&#x27;: &#x27;Jack&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; profile.spans</span><br><span class="line">&#123;0: (25, 29), &#x27;age&#x27;: (11, 13), &#x27;name&#x27;: (5, 9)&#125;</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<h2 id="自定义类型的转换">9. 自定义类型的转换</h2>
<p>匹配到的字符串，会做为参数传入对应的函数</p>
<p>比如我们之前讲过的，将字符串转整型</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parse(&quot;I am &#123;:d&#125;&quot;, &quot;I am 27&quot;)</span><br><span class="line">&lt;Result (27,) &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; type(_[0])</span><br><span class="line">&lt;type &#x27;int&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>其等价于</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def myint(string):</span><br><span class="line">...     return int(string)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; parse(&quot;I am &#123;:myint&#125;&quot;, &quot;I am 27&quot;, dict(myint=myint))</span><br><span class="line">&lt;Result (27,) &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt; type(_[0])</span><br><span class="line">&lt;type &#x27;int&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>利用它，我们可以定制很多的功能，比如我想把匹配的字符串弄成全大写</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def shouty(string):</span><br><span class="line">...    return string.upper()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; parse(&#x27;&#123;:shouty&#125; world&#x27;, &#x27;hello world&#x27;, dict(shouty=shouty))</span><br><span class="line">&lt;Result (&#x27;HELLO&#x27;,) &#123;&#125;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>包的概念</title>
    <url>/blog/2023/10/11/data/languages/Python/%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>如果使用VScode作为编辑器，并且装了pylance做pythonitellisense，可能会对子文件夹下用户自定义的文件夹内的其他工程使用(包)无法识别，pylance最多识别到当前工作区的一级目录，虽然会有警告但实际上不会有问题</p>
<h2 id="python包及其定义和引用详解">Python包及其定义和引用详解</h2>
<p>对于一个需要实际应用的模块而言，往往会具有很多程序单元，包括变量、函数和类等，如果将整个模块的所有内容都定义在同一个
<a href="http://c.biancheng.net/python/">Python</a>
源文件中，这个文件将会变得非常庞大，显然并不利于模块化开发。</p>
<h2 id="什么是包">什么是包</h2>
<p>为了更好地管理多个模块源文件，Python
提供了包的概念。那么问题来了，什么是包呢？</p>
<p>从物理上看，包就是一个文件夹，在该文件夹下包含了一个
<strong>init</strong>.py
文件，该文件夹可用于包含多个模块源文件；从逻辑上看，包的本质依然是模块。</p>
<p>根据上面介绍可以得到一个推论，包的作用是包含多个模块，但包的本质依然是模块，因此包也可用于包含包。典型地，当我们为
Python 安装了 numpy 模块之后，可以在 Python 安装目录的 Lib-packages
目录下找到一个 numpy 文件夹，它就是前面安装的 numpy
模块（其实是一个包）。该文件夹的内容如图 1 所示：<br />
![[Pasted image 20230908210150.png]]</p>
<p>从图 1 可以看出，在 numpy 包（也是模块）下既包含了 matlib.py
等模块源文件，也包含了 core
等子包（也是模块）。这正对应了我们刚刚介绍的：包的本质依然是模块，因此包又可以包含包。</p>
<h2 id="定义包">定义包</h2>
<p>掌握了包是什么之后，接下来学习如何定义包。定义包更简单，主要有两步：</p>
<ol type="1">
<li>创建一个文件夹，该文件夹的名字就是该包的包名。<br />
</li>
<li>在该文件夹内添加一个 <strong>init</strong>.py 文件即可。</li>
</ol>
<p>下面定义一个非常简单的包。先新建一个 first_package
文件夹，然后在该文件夹中添加一个 <code>__init__.py</code>
文件，该文件内容如下：</p>
<ol type="1">
<li>'''<br />
</li>
<li>这是学习包的第一个示例<br />
</li>
<li>'''<br />
</li>
<li>print('this is first_package')</li>
</ol>
<p>上面的 Python
源文件非常简单，该文件开始部分的字符串是该包的说明文档，接下来是一条简单的输出语句。</p>
<p>下面通过如下程序来使用该包：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. # 导入first_package包（模块）</span><br><span class="line">2. import first_package</span><br><span class="line">3. print(&#x27;==========&#x27;)</span><br><span class="line">4. print(first_package.__doc__)</span><br><span class="line">5. print(type(first_package))</span><br><span class="line">6. print(first_package)</span><br></pre></td></tr></table></figure></p>
<p>再次强调，包的本质就是模块，因此导入包和导入模块的语法完全相同。因此，上面程序中第
2 行代码导入了 first_package
包。程序最后三行代码输出了包的说明文档、包的类型和包本身。</p>
<p>运行该程序，可以看到如下输出结果：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this is first package</span><br><span class="line">==========</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这是学习包的第一个示例</span><br><span class="line"></span><br><span class="line">&lt;class &#x27;module&#x27;&gt;</span><br><span class="line"></span><br><span class="line">&lt;module &#x27;first_package&#x27; from &#x27;G:\\publish\\codes\\09\\9.3\\first_package\\__init__.py&#x27;&gt;</span><br></pre></td></tr></table></figure></p>
<p>从上面的输出结果可以看出，在导入 first_package
包时，程序执行了该包所对应的文件夹下的
<strong>init</strong>.py；从倒数第二行输出可以看到，包的本质就是模块；从最后一行输出可以看到，使用
import</p>
<p>first_package 导入包的本质就是加载井执行该包下的
<strong>init</strong>.py
文件，然后将整个文件内容赋值给与包同名的变量，该变量的类型是
module。</p>
<p>与模块类似的是，包被导入之后，会在包目录下生成一个
<strong>pycache</strong> 文件夹，并在该文件夹内为包生成一个
<strong>init</strong>.cpython-36.pyc 文件。</p>
<p>由于导入包就相当于导入该包下的 <strong>init</strong>.py
文件，因此我们完全可以在 <strong>init</strong>.py
文件中定义变量、函数、类等程序单元，但实际上往往并不会这么做。想一想原因是什么？包的主要作用是包含多个模块，因此
<strong>init</strong>.py 文件的主要作用就是导入该包内的其他模块。</p>
<p>下面再定义一个更加复杂的包，在该包下将会包含多个模块，并使用
<strong>init</strong>.py 文件来加载这些模块。</p>
<p>新建一个 fk_package 包，并在该包下包含三个模块文件：<br />
- print_shape.py<br />
- billing.py<br />
- arithmetic_chart.py</p>
<p>fk_package 的文件结构如下：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fk_package</span><br><span class="line">┠──arithmetic_chart.py</span><br><span class="line">┠──billing.py</span><br><span class="line">┠──print_shape.py</span><br><span class="line">┗━━__init__.py</span><br></pre></td></tr></table></figure></p>
<p>其中，arithmetic_chart.py 模块文件的内容如下：<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">def</span> <span class="title function_">print_multiple_chart</span>(<span class="params">n</span>):</span><br><span class="line"><span class="number">2.</span> <span class="string">&#x27;打印乘法口角表的函数&#x27;</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"><span class="number">4.</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line"><span class="number">5.</span> <span class="built_in">print</span>(<span class="string">&#x27;%d * %d = %2d&#x27;</span> % ((j + <span class="number">1</span>) , (i + <span class="number">1</span>) , (j + <span class="number">1</span>)* (i + <span class="number">1</span>)), end=<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line"><span class="number">6.</span> <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面模块文件中定义了一个打印乘法口诀表的函数。</p>
<p>billing.py 模块文件的内容如下：<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">class</span> <span class="title class_">Item</span>:</span><br><span class="line"><span class="number">2.</span> <span class="string">&#x27;定义代表商品的Item类&#x27;</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, price</span>):</span><br><span class="line"><span class="number">4.</span> self.price = price</span><br><span class="line"><span class="number">5.</span> <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="number">6.</span> <span class="keyword">return</span> <span class="string">&#x27;Item[price=%g]&#x27;</span> % self.price</span><br></pre></td></tr></table></figure></p>
<p>print_shape.py 模块文件的内容如下：<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">def</span> <span class="title function_">print_blank_triangle</span>(<span class="params">n</span>):</span><br><span class="line"><span class="number">2.</span> <span class="string">&#x27;使用星号打印一个空心的三角形&#x27;</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line"><span class="number">4.</span> <span class="keyword">raise</span> ValueError(<span class="string">&#x27;n必须大于0&#x27;</span>)</span><br><span class="line"><span class="number">5.</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"><span class="number">6.</span> <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (n - i - <span class="number">1</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="number">7.</span> <span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="number">8.</span> <span class="keyword">if</span> i != n - <span class="number">1</span>:</span><br><span class="line"><span class="number">9.</span> <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="number">10.</span> <span class="keyword">else</span>:</span><br><span class="line"><span class="number">11.</span> <span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="number">12.</span> <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line"><span class="number">13.</span> <span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="number">14.</span> <span class="keyword">else</span>:</span><br><span class="line"><span class="number">15.</span> <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>tk_package 包下的 <strong>init</strong>.py
文件暂时为空，不用编写任何内容。</p>
<p>上面三个模块文件都位于 fk_package
包下，总共提供了两个函数和一个类。这意味着 fk_package
包（也是模块）总共包含 arithmetic_chart、 billing 和 print_shape
三个模块。在这种情况下，这三个模块就相当于 fk_package 包的成员。</p>
<p>导入包内成员</p>
<p>如果需要使用 arithmetic_chart、 billing 和 print_shape
这三个模块，则可以在程序中执行如下导入代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment"># 导入fk_package包，实际上就是导入包下__init__.py文件</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">import</span> fk_package</span><br><span class="line"><span class="number">3.</span> <span class="comment"># 导入fk_package包下的print_shape模块，</span></span><br><span class="line"><span class="number">4.</span> <span class="comment"># 实际上就是导入fk_package目录下的print_shape.py</span></span><br><span class="line"><span class="number">5.</span> <span class="keyword">import</span> fk_package.print_shape</span><br><span class="line"><span class="number">6.</span> <span class="comment"># 实际上就是导入fk_package包（模块）导入print_shape模块</span></span><br><span class="line"><span class="number">7.</span> <span class="keyword">from</span> fk_package <span class="keyword">import</span> billing</span><br><span class="line"><span class="number">8.</span> <span class="comment"># 导入fk_package包下的arithmetic_chart模块，</span></span><br><span class="line"><span class="number">9.</span> <span class="comment"># 实际上就是导入fk_package目录下的arithmetic_chart.py</span></span><br><span class="line"><span class="number">10.</span> <span class="keyword">import</span> fk_package.arithmetic_chart</span><br><span class="line"><span class="number">11.</span> fk_package.print_shape.print_blank_triangle(<span class="number">5</span>)</span><br><span class="line"><span class="number">12.</span> im = billing.Item(<span class="number">4.5</span>)</span><br><span class="line"><span class="number">13.</span> <span class="built_in">print</span>(im)</span><br><span class="line"><span class="number">14.</span> fk_package.arithmetic_chart.print_multiple_chart(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>上面程序中第 2 行代码是“import
fk_package”，由于导入包的本质只是加载并执行包里的
<strong>init</strong>.py 文件，因此执行这条导入语句之后，程序只能使用
fk_package 目录下的 <strong>init</strong>.py
文件中定义的程序单元。对于本例而言，由于 fk_package__init__.py
文件内容为空，因此这条导入语句没有任何作用。</p>
<p>第 5 行导入语句的本质就是加载并执行 fk_package 包下的 print_shape.py
文件，并将其赋值给 fk_package.print_shape
变量。因此执行这条导入语句之后，程序可访问 fk_package_shape.py
文件所定义的程序单元，但需要添加 fk_package.print_shape 前缀。</p>
<p>第 8 行导入语句的本质是导入 fk_package 包（也是模块）下的 billing
成员（其实是模块）。因此执行这条导入语句之后，程序可使用 fk_package.py
文件定义的程序单元，而且只需要添加 billing 前缀。</p>
<p>第 11 行代码与第 5 行代码的导入效果相同。</p>
<p>该程序后面分别测试了 fk_package 包下的
print_shape、billing、arithmetic_chart
这三个模块的功能。运行上面程序，可以看到三个模块的功能完全可以正常显示。</p>
<p>上面程序虽然可以正常运行，但此时存在两个问题：</p>
<ol type="1">
<li>为了调用包内模块中的程序单元，需要使用很长的前缀，这实在是太麻烦了。<br />
</li>
<li>包内 <strong>init</strong>.py 文件的功能完全被忽略了。</li>
</ol>
<p>想一想就知道，包内的 <strong>init</strong>.py
文件并不是用来定义程序单元的，而是用于导入该包内模块的成员，这样即可把模块中的成员导入变成包内成员，以后使用起来会更加方便。</p>
<p>将 fk_package 包下的 <strong>init</strong>.py
文件编辑成如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment"># 从当前包导入print_shape模块</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">from</span> . <span class="keyword">import</span> print_shape</span><br><span class="line"><span class="number">3.</span> <span class="comment"># 从.print_shape导入所有程序单元到fk_package中</span></span><br><span class="line"><span class="number">4.</span> <span class="keyword">from</span> .print_shape <span class="keyword">import</span> *</span><br><span class="line"><span class="number">5.</span> <span class="comment"># 从当前包导入billing模块</span></span><br><span class="line"><span class="number">6.</span> <span class="keyword">from</span> . <span class="keyword">import</span> billing</span><br><span class="line"><span class="number">7.</span> <span class="comment"># 从.billing导入所有程序单元到fk_package中</span></span><br><span class="line"><span class="number">8.</span> <span class="keyword">from</span> .billing <span class="keyword">import</span> *</span><br><span class="line"><span class="number">9.</span> <span class="comment"># 从当前包导入arithmetic_chart模块</span></span><br><span class="line"><span class="number">10.</span> <span class="keyword">from</span> . <span class="keyword">import</span> arithmetic_chart</span><br><span class="line"><span class="number">11.</span> <span class="comment"># 从.arithmetic_chart导入所有程序单元到fk_package中</span></span><br><span class="line"><span class="number">12.</span> <span class="keyword">from</span> .arithmetic_chart <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>该程序的代码基本上差不多，都是通过如下两行代码来处理导入的：<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment"># 从当前包导入print_shape模块</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">from</span> . <span class="keyword">import</span> print_shape</span><br><span class="line"><span class="number">3.</span> <span class="comment"># 从.print_shape导入所有程序单元到fk_package中</span></span><br><span class="line"><span class="number">4.</span> <span class="keyword">from</span> .print_shape <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></p>
<p>上面第一行 from...import 用于导入当前包（模块）中的
print_shape（模块），这样即可在 tk_package 中使用 print_shape
模块。但这种导入方式是将 print_shape 模块导入了 fk_package
包中，因此当其他程序使用 print_shape 内的成员时，依然需要通过
fk_package.print_shape 前缀进行调用。</p>
<p>第二行导入语句用于将 print_shape 模块内的所有程序单元导入 fk_package
模块中，这样以后只要使用
fk_package.前缀就可以使用三个模块内的程序单元。例如如下程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment"># 导入fk_package包，实际上就是导入包下__init__.py文件</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">import</span> fk_package</span><br><span class="line"><span class="number">3.</span> <span class="comment"># 直接使用fk_package前缀即可调用它所包含的模块内的程序单元。</span></span><br><span class="line"><span class="number">4.</span> fk_package.print_blank_triangle(<span class="number">5</span>)</span><br><span class="line"><span class="number">5.</span> im = fk_package.Item(<span class="number">4.5</span>)</span><br><span class="line"><span class="number">6.</span> <span class="built_in">print</span>(im)</span><br><span class="line"><span class="number">7.</span> fk_package.print_multiple_chart(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>上面第 2 行代码是导入 fk_package 包，导入该包的本质就是导入该包下的
<strong>init</strong>.py 文件。而 <strong>init</strong>.py
文件又执行了导入，它们会把三个模块内的程序单元导入 fk_package
包中，因此程序的下面代码可使用
fk_package.前缀来访问三个模块内的程序单元。</p>
<p>运行上面程序，同样可以看到正常的运行结果。</p>
<p>来自 &lt;<a
href="http://c.biancheng.net/view/2402.html">http://c.biancheng.net/view/2402.html</a>&gt;</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程化任务处理</title>
    <url>/blog/2023/10/11/data/languages/Python/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%8C%96%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>就算是单核心的任务，也可以多线程化处理，因为对于数据量大的任务来说，内存IO和磁盘IO是很耗时的，因此使用异步处理是非常重要的方法。</p>
<p>对于多核心的机器来说，可以使用 concurrent.futures 包中的
ProcessPoolExecutor
创建进程池，并向每个进程提交任务异步处理。如下是一个计算大量点云，分区的协方差矩阵特征值和特征向量的例子，每个进程可以分配一定的数量的点云去计算，这样原本可能需要花费30分钟的任务，多进程处理之后只需要1~2分钟。<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多进程处理子空间坐标几何特征计算</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, as_completed</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&quot;./data/checkpoint/line_feat_mat.pkl&quot;</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./data/checkpoint/line_feat_mat.pkl&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        line_feat_mat = pickle.load(f)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    num_workers = <span class="number">4</span></span><br><span class="line">    batch_size = voxels_filteredby_height.shape[<span class="number">0</span>] // num_workers</span><br><span class="line">    line_feat_mat_list = [<span class="literal">None</span>] * num_workers</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(max_workers=num_workers) <span class="keyword">as</span> executor:</span><br><span class="line">        futures_dict = &#123;</span><br><span class="line">            executor.submit(</span><br><span class="line">                utils.eigval_radius,</span><br><span class="line">                voxels_filteredby_height[i * batch_size : (i + <span class="number">1</span>) * batch_size],</span><br><span class="line">                voxel_size * <span class="number">75.0</span></span><br><span class="line">            ) : i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_workers)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures_dict):</span><br><span class="line">            feat_mat, _ = future.result()</span><br><span class="line">            line_feat_mat_list[futures_dict[future]] = feat_mat</span><br><span class="line">    line_feat_mat = np.concatenate(line_feat_mat_list, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./data/checkpoint/line_feat_mat.pkl&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(line_feat_mat, f)</span><br></pre></td></tr></table></figure>
上述例子除了多进程处理化之外，还使用了pickle库序列化已经计算好的结果，对于一些原始数据变化不大的任务，我们可以利用序列化将结果保存下来，特别是在notebook这种实验性场景中，一些中间结果的计算还是比较耗费时间的。</p>
<p>一个常见的多进程处理模板如下：<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_function</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="comment"># 每个任务的具体内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;os.getpid()&#125;</span> is processing argument: <span class="subst">&#123;arg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> arg * arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个ProcessPoolExecutor实例</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 要执行的任务列表</span></span><br><span class="line">        tasks = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用executor.submit提交任务到进程池</span></span><br><span class="line">        futures = [executor.submit(task_function, task) <span class="keyword">for</span> task <span class="keyword">in</span> tasks]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 收集任务结果</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">            result = future.result()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Result: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
但是这个模板有一个问题，就是提交的任务并行处理之后，完成的顺序是未知的，每个核心进程分配到任务之后，可能由于核心的调度处理去处理其他任务导致虽然分配给进程的任务数据量是基本一致的但完成时间可能有很大差别。我们希望提交给进程池的任务，最后取出结果的时候也是提交时的顺序。因此我们可以使用
<code>as_completed()</code>
遍历futures可迭代对象，按照迭代对象放入的顺序取出结果，缺点就是可能对于一些完成比较慢的进程需要阻塞等待。</p>
<p><code>as_completed</code>方法会遍历可迭代对象，list或者dict都是可以接受的迭代对象。上述第一段代码中，使用dict字典类型将future对象和放入的顺序号码联系起来，这样去除结果的时候可以直接根据顺序作为索引放入结果list中。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>打印堆栈信息</title>
    <url>/blog/2023/10/11/data/languages/Python/%E6%89%93%E5%8D%B0%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cur_info</span>():</span><br><span class="line">    <span class="built_in">print</span>(sys._getframe().f_code.co_filename)  <span class="comment"># 当前文件名，可以通过__file__获得</span></span><br><span class="line">    <span class="built_in">print</span>(sys._getframe(<span class="number">0</span>).f_code.co_name) <span class="comment"># 当前函数名</span></span><br><span class="line">    <span class="built_in">print</span>(sys._getframe(<span class="number">1</span>).f_code.co_name)  <span class="comment"># 调用该函数的函数名字，如果没有被调用，则返回&lt;module&gt;</span></span><br><span class="line">    <span class="built_in">print</span>(sys._getframe(<span class="number">0</span>).f_lineno) <span class="comment">#当前函数的行号</span></span><br><span class="line">    <span class="built_in">print</span>(sys._getframe(<span class="number">1</span>).f_lineno) <span class="comment"># 调用该函数的行号</span></span><br></pre></td></tr></table></figure>
<p>其中sys._getframe(back_step:int)，代表获得当前运行程序的栈帧（运行中的程序就是一个进程，进程的存储分区可以分为堆区、栈区、未使用内存），通过back_step指定获取前多少层的栈帧（或者说PC，Program
Counter 程序计数器指针所指向的函数位置）</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>查找包的安装位置</title>
    <url>/blog/2023/10/11/data/languages/Python/%E6%9F%A5%E6%89%BE%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(module.__file__)</span><br></pre></td></tr></table></figure>
<p>引入包之后，使用上述方法查看包所在的位置，因为包本身就可以是一个文件</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/blog/2023/10/11/data/languages/Python/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>Python的MRO即Method Resolution
Order（方法解析顺序），即在调用方法时，会对当前类以及所有的基类进行一个搜索，以确定该方法之所在，而这个搜索的顺序就是MRO。在Python2.3之前，MRO的实现是基于DFS的，而在Python2.3以后MRO的实现是基于C3算法（我这里两种算法的具体实现都不详述）。C3算法最早被提出是用于Lisp的，应用在Python中是为了解决原来基于深度优先搜索算法不满足本地优先级，和单调性的问题。本地优先级：指声明时父类的顺序，比如C(A,B)，如果访问C类对象属性时，应该根据声明顺序，优先查找A类，然后再查找B类。单调性：如果在C的解析顺序中，A排在B的前面，那么在C的所有子类里，也必须满足这个顺序。</p>
<p>总的来说，一个类的 MRO 列表就是合并所有父类的 MRO
列表，并遵循以下三条原则：</p>
<p>子类永远在父类前面</p>
<p>如果有多个父类，会根据它们在列表中的顺序被检查</p>
<p>如果对下一个类存在两个合法的选择，选择第一个父类</p>
<p>说到 super，
大家可能觉得很简单呀，不就是用来调用父类方法的嘛。如果真的这么简单的话也就不会有这篇文章了，且听我细细道来。</p>
<h2 id="约定">约定</h2>
<p>在开始之前我们来约定一下本文所使用的 Python 版本。默认用的是 Python
3，也就是说：本文所定义的类都是新式类。如果你用到是 Python 2
的话，记得继承 object:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认， Python 3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># Python 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">Python <span class="number">3</span> 和 Python <span class="number">2</span> 的另一个区别是: Python <span class="number">3</span> 可以使用直接使用 <span class="built_in">super</span>().xxx 代替 <span class="built_in">super</span>(Class, self).xxx :</span><br><span class="line"><span class="comment"># 默认，Python 3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="built_in">super</span>().add(x)</span><br><span class="line"><span class="comment"># Python 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="built_in">super</span>(B, self).add(x)</span><br></pre></td></tr></table></figure>
<p>所以，你如果用的是 Python 2
的话，记得将本文的 super() 替换为 suepr(Class, self) 。</p>
<p>如果还有其他不兼容 Python 2 的情况，我会在文中注明的。</p>
<h2 id="单继承">单继承</h2>
<p>在单继承中 super 就像大家所想的那样，主要是用来调用父类的方法的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, m</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self is &#123;0&#125; @A.add&#x27;</span>.<span class="built_in">format</span>(self))</span><br><span class="line">        self.n += m</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, m</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self is &#123;0&#125; @B.add&#x27;</span>.<span class="built_in">format</span>(self))</span><br><span class="line">        <span class="built_in">super</span>().add(m)</span><br><span class="line">        self.n += <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>你觉得执行下面代码后， b.n 的值是多少呢？<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = B()  </span><br><span class="line">b.add(<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(b.n)</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self is &lt;__main__.B object at 0x106c49b38&gt; @B.add  </span><br><span class="line">self is &lt;__main__.B object at 0x106c49b38&gt; @A.add  </span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>这个结果说明了两个问题:</p>
<ul>
<li>1、super().add(m) 确实调用了父类 A 的 add 方法。<br />
</li>
<li>2、super().add(m) 调用父类方法 def add(self, m) 时,
此时父类中 self 并不是父类的实例而是子类的实例,
所以 b.add(2) 之后的结果是 5 而不是 4 。</li>
</ul>
<p>不知道这个结果是否和你想到一样呢？下面我们来看一个多继承的例子。</p>
<h2 id="多继承">多继承</h2>
<p>这次我们再定义一个 class C，一个 class D:<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">4</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, m</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self is &#123;0&#125; @C.add&#x27;</span>.<span class="built_in">format</span>(self))</span><br><span class="line">        <span class="built_in">super</span>().add(m)</span><br><span class="line">        self.n += <span class="number">4</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">5</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, m</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self is &#123;0&#125; @D.add&#x27;</span>.<span class="built_in">format</span>(self))</span><br><span class="line">        <span class="built_in">super</span>().add(m)</span><br><span class="line">        self.n += <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>下面的代码又输出啥呢？<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = D()  </span><br><span class="line">d.add(<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(d.n)</span><br></pre></td></tr></table></figure></p>
<p>这次的输出如下:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @D.add  </span><br><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @B.add  </span><br><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @C.add  </span><br><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @A.add  </span><br><span class="line">19</span><br></pre></td></tr></table></figure></p>
<p>你说对了吗？你可能会认为上面代码的输出类似:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @D.add  </span><br><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @B.add  </span><br><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @A.add  </span><br><span class="line">15</span><br></pre></td></tr></table></figure></p>
<p>为什么会跟预期的不一样呢？下面我们将一起来看看 super 的奥秘。</p>
<p>super 是个类</p>
<p>当我们调用 super() 的时候，实际上是实例化了一个 super 类。你没看错， super 是个类，既不是关键字也不是函数等其他数据结构:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class A: pass  </span><br><span class="line">...  </span><br><span class="line">&gt;&gt;&gt; s = super(A)  </span><br><span class="line">&gt;&gt;&gt; type(s)  </span><br><span class="line">&lt;class &#x27;super&#x27;&gt;  </span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>在大多数情况下， super 包含了两个非常重要的信息: 一个 MRO 以及 MRO
中的一个类。当以如下方式调用 super 时:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">super(a_type, obj)</span><br></pre></td></tr></table></figure></p>
<p>MRO 指的是 type(obj) 的 MRO, MRO 中的那个类就是 a_type ,
同时 isinstance(obj, a_type) == True 。</p>
<p>当这样调用时:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">super(type1, type2)</span><br></pre></td></tr></table></figure></p>
<p>MRO
指的是 type2 的 MRO, MRO 中的那个类就是 type1 ，同时 issubclass(type2,
type1) == True 。</p>
<p>那么， super() 实际上做了啥呢？简单来说就是：提供一个 MRO 以及一个 MRO 中的类 C ， super() 将返回一个从 MRO 中 C 之后的类中查找方法的对象。</p>
<p>也就是说，查找方式时不是像常规方法一样从所有的 MRO 类中查找，而是从 MRO 的
tail 中查找。</p>
<p>举个例子, 有个 MRO:<code>[A, B, C, D, E, object]</code></p>
<p>下面的调用:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">super(C, A).foo()</span><br></pre></td></tr></table></figure></p>
<p>super 只会从 C 之后查找，即:
只会在 D 或 E 或 object 中查找 foo 方法。</p>
<p>多继承中 super 的工作方式</p>
<p>再回到前面的<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = D()  </span><br><span class="line">d.add(2)  </span><br><span class="line">print(d.n)</span><br></pre></td></tr></table></figure></p>
<p>现在你可能已经有点眉目，为什么输出会是了吧 ;)<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @D.add  </span><br><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @B.add  </span><br><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @C.add  </span><br><span class="line">self is &lt;__main__.D object at 0x10ce10e48&gt; @A.add  </span><br><span class="line">19</span><br></pre></td></tr></table></figure></p>
<p>下面我们来具体分析一下:</p>
<ul>
<li><p>D 的 MRO 是: <code>[D, B, C, A, object]</code> 。 备注: 可以通过 D.mro() (Python
2 使用 D.__mro__ ) 来查看 D 的 MRO 信息</p></li>
<li><p>详细的代码分析如下:<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, m</span>):</span><br><span class="line">        <span class="comment"># 第四步</span></span><br><span class="line">        <span class="comment"># 来自 D.add 中的 super</span></span><br><span class="line">        <span class="comment"># self == d, self.n == d.n == 5</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self is &#123;0&#125; @A.add&#x27;</span>.<span class="built_in">format</span>(self))</span><br><span class="line">        self.n += m</span><br><span class="line">        <span class="comment"># d.n == 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, m</span>):</span><br><span class="line">        <span class="comment"># 第二步</span></span><br><span class="line">        <span class="comment"># 来自 D.add 中的 super</span></span><br><span class="line">        <span class="comment"># self == d, self.n == d.n == 5</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self is &#123;0&#125; @B.add&#x27;</span>.<span class="built_in">format</span>(self))</span><br><span class="line">        <span class="comment"># 等价于 suepr(B, self).add(m)</span></span><br><span class="line">        <span class="comment"># self 的 MRO 是 [D, B, C, A, object]</span></span><br><span class="line">        <span class="comment"># 从 B 之后的 [C, A, object] 中查找 add 方法</span></span><br><span class="line">        <span class="built_in">super</span>().add(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第六步</span></span><br><span class="line">        <span class="comment"># d.n = 11</span></span><br><span class="line">        self.n += <span class="number">3</span></span><br><span class="line">        <span class="comment"># d.n = 14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, m</span>):</span><br><span class="line">        <span class="comment"># 第三步</span></span><br><span class="line">        <span class="comment"># 来自 B.add 中的 super</span></span><br><span class="line">        <span class="comment"># self == d, self.n == d.n == 5</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self is &#123;0&#125; @C.add&#x27;</span>.<span class="built_in">format</span>(self))</span><br><span class="line">        <span class="comment"># 等价于 suepr(C, self).add(m)</span></span><br><span class="line">        <span class="comment"># self 的 MRO 是 [D, B, C, A, object]</span></span><br><span class="line">        <span class="comment"># 从 C 之后的 [A, object] 中查找 add 方法</span></span><br><span class="line">        <span class="built_in">super</span>().add(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步</span></span><br><span class="line">        <span class="comment"># d.n = 7</span></span><br><span class="line">        self.n += <span class="number">4</span></span><br><span class="line">        <span class="comment"># d.n = 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, m</span>):</span><br><span class="line">        <span class="comment"># 第一步</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self is &#123;0&#125; @D.add&#x27;</span>.<span class="built_in">format</span>(self))</span><br><span class="line">        <span class="comment"># 等价于 super(D, self).add(m)</span></span><br><span class="line">        <span class="comment"># self 的 MRO 是 [D, B, C, A, object]</span></span><br><span class="line">        <span class="comment"># 从 D 之后的 [B, C, A, object] 中查找 add 方法</span></span><br><span class="line">        <span class="built_in">super</span>().add(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第七步</span></span><br><span class="line">        <span class="comment"># d.n = 14</span></span><br><span class="line">        self.n += <span class="number">5</span></span><br><span class="line">        <span class="comment"># self.n = 19</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>调用过程图如下:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D.mro() == [D, B, C, A, object]</span><br><span class="line">d = D()</span><br><span class="line">d.n == 5</span><br><span class="line">d.add(2)</span><br><span class="line"></span><br><span class="line">class D(B, C):          class B(A):            class C(A):             class A:</span><br><span class="line">    def add(self, m):       def add(self, m):      def add(self, m):       def add(self, m):</span><br><span class="line">        super().add(m)  1.---&gt;  super().add(m) 2.---&gt;  super().add(m)  3.---&gt;  self.n += m</span><br><span class="line">        self.n += 5   &lt;------6. self.n += 3    &lt;----5. self.n += 4     &lt;----4. &lt;--|</span><br><span class="line">        (14+5=19)               (11+3=14)              (7+4=11)                (5+2=7)</span><br></pre></td></tr></table></figure> <img
src="https://www.runoob.com/wp-content/uploads/2018/02/superdetail.png" /><br />
现在你知道为什么 d.add(2) 后 d.n 的值是 19 了吧 ;)</p>
<p>来自 &lt;<a
href="https://www.runoob.com/w3cnote/python-super-detail-intro.html">https://www.runoob.com/w3cnote/python-super-detail-intro.html</a>&gt;</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环读取通道不关闭会阻塞</title>
    <url>/blog/2023/10/11/data/languages/golang/for%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96%E9%80%9A%E9%81%93%E4%B8%8D%E5%85%B3%E9%97%AD%E4%BC%9A%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<p>起因是我希望在读取配置文件的时候，给每个配置文件的读取开一个协程去读取，然后通过通道返回读取的键值对到主函数所在的协程中，然后再写入到哈希表，因为golang的哈希表不是并发写入安全的，所以必须开一个类似信号量的同步机制让各个协程有顺序的写入，而不是开了多个协程之后就不管了让各个协程自己并发写入。</p>
<p>但是最开始的这个实现会阻塞在for循环读取完通道中缓存队列的值，然后一直卡住。<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">itemChan := <span class="built_in">make</span>(<span class="keyword">chan</span> confItem)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> dirItems &#123;</span><br><span class="line">	<span class="keyword">if</span> item.IsDir() &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !strings.HasSuffix(item.Name(), <span class="string">&quot;.json&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filePath := filepath.Join(confDir, item.Name())</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(filePath <span class="type">string</span>, ch <span class="keyword">chan</span> confItem)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> utils.CatchPanic()</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">		jsonData, fileReadErr := os.ReadFile(filePath)</span><br><span class="line">		<span class="keyword">if</span> fileReadErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fileReadErr.Error())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> tmpConf <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">		unmarshalErr := json.Unmarshal([]<span class="type">byte</span>(jsonData), &amp;tmpConf)</span><br><span class="line">		<span class="keyword">if</span> unmarshalErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(unmarshalErr.Error())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> key, val := <span class="keyword">range</span> tmpConf &#123;</span><br><span class="line">			ch &lt;- confItem&#123;key, val&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		utils.Log(utils.INFO, fmt.Sprintf(<span class="string">&quot;load config: %s&quot;</span>, filePath))</span><br><span class="line">	&#125;(filePath, itemChan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> itemChan &#123;</span><br><span class="line">	confMap[item.key] = item.val</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(itemChan) <span class="comment">// don&#x27;t forget to close the channel</span></span><br></pre></td></tr></table></figure></p>
<p>因为 <code>close(itemChan)</code>
在for循环读取通道值的后面，所以这是典型的死锁问题：环路等待（死锁的四个条件是：资源互斥、不可剥夺、环路等待、请求保持，不幸的是channel恰好都符合这四个条件）。</p>
<p>解决办法是将for循环读取channel的操作移至一个单独的协程内，这样主协程就可以通过
<code>wg.Wait()</code>
确保所有的通道发送协程已经完成发送，然后关闭通道的发送端。那个专用于读取通道的协程可以慢慢读取，因为通道的发送端已经被关闭，只要读取完了就可以结束for循环而不会阻塞了。也就是说，就算通道里还有值，通道也是可以被关闭的，里面的值仍然可以被for循环取出，然后由于通道已经关闭了，for循环就不会阻塞。</p>
<p>在 Go
语言中，即使通道（channel）被关闭，仍然可以从通道中接收数据，直到通道中的所有数据都被接收完毕。一旦通道被关闭，并且通道中的数据都被接收完毕，任何后续的接收操作将立即完成，并返回该通道元素类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utils.CatchPanic()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> confMap == <span class="literal">nil</span> &#123;</span><br><span class="line">		utils.Log(utils.INFO, <span class="string">&quot;scanning configuration jsons...&quot;</span>)</span><br><span class="line">		confMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, fileName, _, ok := runtime.Caller(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;error acquiring current conf.go file path&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	confDir := filepath.Dir(fileName)</span><br><span class="line"></span><br><span class="line">	dirItems, dirReadErr := os.ReadDir(confDir)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dirReadErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(dirReadErr.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> confItem <span class="keyword">struct</span> &#123;</span><br><span class="line">		key <span class="type">string</span></span><br><span class="line">		val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	itemChan := <span class="built_in">make</span>(<span class="keyword">chan</span> confItem)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> dirItems &#123;</span><br><span class="line">		<span class="keyword">if</span> item.IsDir() &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !strings.HasSuffix(item.Name(), <span class="string">&quot;.json&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		filePath := filepath.Join(confDir, item.Name())</span><br><span class="line"></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(filePath <span class="type">string</span>, ch <span class="keyword">chan</span> confItem)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> utils.CatchPanic()</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">			jsonData, fileReadErr := os.ReadFile(filePath)</span><br><span class="line">			<span class="keyword">if</span> fileReadErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(fileReadErr.Error())</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> tmpConf <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">			unmarshalErr := json.Unmarshal([]<span class="type">byte</span>(jsonData), &amp;tmpConf)</span><br><span class="line">			<span class="keyword">if</span> unmarshalErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(unmarshalErr.Error())</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> key, val := <span class="keyword">range</span> tmpConf &#123;</span><br><span class="line">				ch &lt;- confItem&#123;key, val&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			utils.Log(utils.INFO, fmt.Sprintf(<span class="string">&quot;load config: %s&quot;</span>, filePath))</span><br><span class="line">		&#125;(filePath, itemChan)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// create a routine to accept values  from  channel</span></span><br><span class="line">	<span class="comment">// or else it will wait until the channel is closed</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> item := <span class="keyword">range</span> itemChan &#123;</span><br><span class="line">		confMap[item.key] = item.val</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(itemChan) <span class="comment">// don&#x27;t forget to close the channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go env 配置脚本</title>
    <url>/blog/2023/10/11/data/languages/golang/go%20env%20%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.io,direct</span><br><span class="line"><span class="comment"># Set environment variable allow bypassing the proxy for selected modules</span></span><br><span class="line">go <span class="built_in">env</span> -w GOPRIVATE=*.corp.example.com</span><br><span class="line">go <span class="built_in">env</span> -w GO111MODULE=on</span><br><span class="line"></span><br><span class="line">gohome=$(<span class="built_in">cd</span> $(<span class="built_in">dirname</span> $(<span class="built_in">readlink</span> -f $(<span class="built_in">command</span> -v go)))/..; <span class="built_in">pwd</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOENV=<span class="variable">$&#123;gohome&#125;</span>/go.env</span><br><span class="line">go <span class="built_in">env</span> -w GOPATH=<span class="variable">$&#123;gohome&#125;</span>/gohome</span><br></pre></td></tr></table></figure>
<p>但前提是已经下载并将go的可执行程序的目录软链接到了系统路径下，bash可以直接找到go这个命令，如果还没有安装，可以使用如下脚本自动安装最新版本的golang（仅限Linux下，这个脚本只做了对Linux下的情况处理）<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">script_dir=$(<span class="built_in">cd</span> $(<span class="built_in">dirname</span> <span class="variable">$&#123;BASH_SOURCE[0]&#125;</span>); <span class="built_in">pwd</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">command</span> -v go &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">    erro <span class="string">&quot;golang has been installed already...&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shopt</span> -s nocasematch</span><br><span class="line"></span><br><span class="line">host_os=$(<span class="built_in">uname</span> -s)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;host_os&#125;</span>&quot;</span> == <span class="string">&quot;darwin&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    host_os=<span class="string">&quot;darwin&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;host_os&#125;</span>&quot;</span> == <span class="string">&quot;linux&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    host_os=<span class="string">&quot;linux&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">host_arch=$(<span class="built_in">uname</span> -m)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;host_arch&#125;</span>&quot;</span> == <span class="string">&quot;x86_64&quot;</span>* ]]; <span class="keyword">then</span></span><br><span class="line">    host_arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;host_arch&#125;</span>&quot;</span> == <span class="string">&quot;arm&quot;</span>* || <span class="string">&quot;<span class="variable">$&#123;host_arch&#125;</span>&quot;</span> == <span class="string">&quot;aarch&quot;</span>* ]]; <span class="keyword">then</span></span><br><span class="line">    host_arch=<span class="string">&quot;arm64&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">latest_ver=$(curl https://go.dev/dl/ | grep -oP <span class="string">&quot;go[0-9]+\.[0-9]+(\.[0-9]+)?\.<span class="variable">$&#123;host_os&#125;</span>-<span class="variable">$&#123;host_arch&#125;</span>\.tar\.gz&quot;</span> | <span class="built_in">head</span> -n 1 | grep -oP <span class="string">&#x27;[0-9]+\.[0-9]+(\.[0-9]+)?&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">shopt</span> -u nocasematch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! <span class="string">&quot;<span class="variable">$&#123;latest_ver&#125;</span>&quot;</span> =~ [0-9]+\.[0-9]+(\.[0-9]+)? ]]; <span class="keyword">then</span></span><br><span class="line">    erro <span class="string">&quot;failed to fetch the latest version of golang, exit...&quot;</span></span><br><span class="line">    <span class="built_in">return</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">pkg_suffix=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;host_os&#125;</span>&quot;</span> == <span class="string">&quot;linux&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    pkg_suffix=<span class="string">&quot;tar.gz&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;host_os&#125;</span>&quot;</span> == <span class="string">&quot;darwin&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    pkg_suffix=<span class="string">&quot;pkg&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">download_target=<span class="string">&quot;go<span class="variable">$&#123;latest_ver&#125;</span>.<span class="variable">$&#123;host_os&#125;</span>-<span class="variable">$&#123;host_arch&#125;</span>.<span class="variable">$&#123;pkg_suffix&#125;</span>&quot;</span></span><br><span class="line">info <span class="string">&quot;<span class="variable">$&#123;download_target&#125;</span>  will be download and install&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;specify the dir prefix to download and install go:&quot;</span> install_prefix</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;install_prefix&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    warn <span class="string">&quot;no dir is specified, using user&#x27;s home dir...&quot;</span></span><br><span class="line">    install_prefix=<span class="variable">$&#123;HOME&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    install_prefix=$(<span class="built_in">cd</span> <span class="variable">$&#123;install_prefix&#125;</span>; <span class="built_in">pwd</span>)</span><br><span class="line">    info <span class="string">&quot;golang will be installed to `<span class="variable">$&#123;install_prefix&#125;</span>`&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">wget https://go.dev/dl/<span class="variable">$&#123;download_target&#125;</span> -O <span class="variable">$&#123;install_prefix&#125;</span>/<span class="variable">$&#123;download_target&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;install_prefix&#125;</span> <span class="comment"># as gunzip seems not providing a parameter to specify unzip location?</span></span><br><span class="line">express_dir=<span class="string">&quot;go<span class="variable">$&#123;latest_ver&#125;</span>.<span class="variable">$&#123;host_os&#125;</span>-<span class="variable">$&#123;host_arch&#125;</span>&quot;</span></span><br><span class="line">tar -xvzf <span class="variable">$&#123;download_target&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;specify the location of symbolic link: &quot;</span> link_target</span><br><span class="line"><span class="keyword">if</span> [ ! -d $(<span class="built_in">dirname</span> <span class="variable">$&#123;link_target&#125;</span>) ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p $(<span class="built_in">dirname</span> <span class="variable">$&#123;link_target&#125;</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">link_target=$(<span class="built_in">cd</span> $(<span class="built_in">dirname</span> <span class="variable">$&#123;link_target&#125;</span>); <span class="built_in">pwd</span>)/$(<span class="built_in">basename</span> <span class="variable">$&#123;link_target&#125;</span>)</span><br><span class="line"><span class="built_in">ln</span> -s $(<span class="built_in">cd</span> ./go/bin; <span class="built_in">pwd</span>) <span class="variable">$&#123;link_target&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这个脚本的工作就是确定系统和硬件架构，然后去golang的官网下载最新本版的golang到指定目录并解压缩包，然后将golang目录下的bin目录软链接到用户指定的位置（一般是系统路径下）。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>一个配置文件解析模板</title>
    <url>/blog/2023/10/11/data/languages/golang/%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>这是一个配置文件的读取和解析模板，但是使用的是json文件，不过实际使用的时候可以自己根据配置文件的类型来修改解析方法，这里只是因为json比较方便所以选用了json。</p>
<p>运用Go1.18之后支持的泛型技术，我们可以使得获取配置项的函数不局限于某个类型的返回值，而是让用户决定将要返回的配置项的类型，然后做一次强制转换。这样做的优点是无需为每个配置项类型都写一遍函数，或者使用
<code>reflect.Type</code>
反射类型来给用户提供选择余地（因为反射通常不是很安全并且运行速度会比较慢）。</p>
<p>往常读取json文件或者yaml文件都需要预定义一个对应的配置结构体，这样很不方便，因为我们的配置文件可能是很多的，不可能每次添加配置文件都手动添加对应的结构体用于json解析。但是使用
<code>map[string]interface&#123;&#125;</code>
就很好的满足了我们的需求，因为任意json配置文件都可以解析到这个类型的临时变量里，然后我们再根据用户提供的类型做强制转换map的键值类型就可以了，因为用户既然知道需要使用这个配置项，那么用户应该知道该配置项的类型是字符串还是整型又或者是浮点数之类的。配置解析模块应该是通用的而不应该假定用户的配置项类型，因为用户的类型是永远无法预测的，可能是各种嵌套的结构体之类的，配置解析模块应该只负责读取和存储键值对，实际的类型转换交由用户自身完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> conf</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;aliyun-oss/utils&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> confMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utils.ErrorRecover()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> confMap == <span class="literal">nil</span> &#123;</span><br><span class="line">		utils.Log(utils.INFO, <span class="string">&quot;scanning configuration jsons...&quot;</span>)</span><br><span class="line">		confMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, fileName, _, ok := runtime.Caller(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;error acquiring current conf.go file path&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	confDir := filepath.Dir(fileName)</span><br><span class="line"></span><br><span class="line">	dirItems, dirReadErr := os.ReadDir(confDir)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dirReadErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(dirReadErr.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> confItem <span class="keyword">struct</span> &#123;</span><br><span class="line">		key <span class="type">string</span></span><br><span class="line">		val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	itemChan := <span class="built_in">make</span>(<span class="keyword">chan</span> confItem)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> dirItems &#123;</span><br><span class="line">		<span class="keyword">if</span> item.IsDir() &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !strings.HasSuffix(item.Name(), <span class="string">&quot;.json&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		filePath := filepath.Join(confDir, item.Name())</span><br><span class="line"></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(filePath <span class="type">string</span>, ch <span class="keyword">chan</span> confItem)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> utils.ErrorRecover()</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">			jsonData, fileReadErr := os.ReadFile(filePath)</span><br><span class="line">			<span class="keyword">if</span> fileReadErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(fileReadErr.Error())</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> tmpConf <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">			unmarshalErr := json.Unmarshal([]<span class="type">byte</span>(jsonData), &amp;tmpConf)</span><br><span class="line">			<span class="keyword">if</span> unmarshalErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(unmarshalErr.Error())</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> key, val := <span class="keyword">range</span> tmpConf &#123;</span><br><span class="line">				ch &lt;- confItem&#123;key, val&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			utils.Log(utils.INFO, fmt.Sprintf(<span class="string">&quot;load config: %s&quot;</span>, filePath))</span><br><span class="line">		&#125;(filePath, itemChan)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// create a routine to accept values  from  channel</span></span><br><span class="line">	<span class="comment">// or else it will wait until the channel is closed</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> item := <span class="keyword">range</span> itemChan &#123;</span><br><span class="line">			confMap[item.key] = item.val</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(itemChan) <span class="comment">// don&#x27;t forget to close the channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConfEntryKeys</span><span class="params">()</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	keys := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> confMap &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConfEntry</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(key <span class="type">string</span>)</span></span> T &#123;</span><br><span class="line">	<span class="keyword">if</span> _, exist := confMap[key]; !exist &#123;</span><br><span class="line">		<span class="keyword">var</span> zero T</span><br><span class="line">		<span class="keyword">return</span> zero</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> confMap[key].(T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是随后我又意识到一个问题，那就是这个代码读取配置文件依赖于conf.go这个文件自己去定位文件所在的目录然后再扫描，但如果把项目编译为二进制文件之后，conf.go是不存在的，而且这个二进制文件可能放到docker容器里面去运行，这个时候就不能依赖于文件查找自身的位置了。</p>
<p>这个时候就需要手动指定命令行参数来让二进制程序解析，这样用户可以自己指定配置项所在的目录。<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> confPath <span class="type">string</span></span><br><span class="line">	flag.StringVar(&amp;confPath, <span class="string">&quot;confpath&quot;</span>, <span class="string">&quot;./conf&quot;</span>, <span class="string">&quot;path to the configuration directory&quot;</span>)</span><br><span class="line">	flag.Parse() <span class="comment">// don&#x27;t forget to parse</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	conf.InitConf(confPath)</span><br><span class="line">	utils.InitLogFile(conf.ConfEntry[<span class="type">string</span>](<span class="string">&quot;logDirName&quot;</span>))</span><br><span class="line">	utils.DumpToFile = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>使用具名返回值巧妙解决泛型函数返回零值的问题</title>
    <url>/blog/2023/10/11/data/languages/golang/%E4%BD%BF%E7%94%A8%E5%85%B7%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E5%B7%A7%E5%A6%99%E8%A7%A3%E5%86%B3%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%9B%B6%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Go语言泛型语法特性在<a
href="https://tonybai.com/2022/04/20/some-changes-in-go-1-18">Go
1.18版本</a>落地后，不出所料，在github上看到大量的基础容器类型数据结构被用泛型重写。这种重写我觉得是很正常、很自然的，并且实现良好的通用数据结构改为泛型其实也不难，有些简单的结构可能分分钟就能搞定。</p>
<p>Go 1.18发布后，我一直没机会写泛型，今天在做<a
href="https://tonybai.com/2022/05/10/introduction-of-implement-dsl-using-antlr-and-go">DSL</a>语义模型提取时，多处用到Stack结构，于是想到使用泛型简单实现了一个通用的Stack结构。</p>
<p>在Go中，我们可以用一个切片来定义Stack。泛型Stack类型的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Stack[T any] []T</span><br></pre></td></tr></table></figure>
<p>这里的Stack类型就是一个带有类型参数(type
parameter)的泛型类型，它的类型参数的约束(constraints)为<a
href="https://tonybai.com/2021/12/18/replace-empty-interface-with-any-first-after-switching-to-go-1-18">any</a>，即允许任何类型作为Stack的元素类型。</p>
<p>Stack是最基础的数据结构，一般来说它具有的操作方法包括：</p>
<ul>
<li>Push：压栈；<br />
</li>
<li>Pop：弹栈；<br />
</li>
<li>Top：获取栈顶元素；<br />
</li>
<li>Len：获取栈内元素个数。</li>
</ul>
<p>对于以切片为底层存储的Stack而言，压栈Push操作就相当于对切片的追加(append)操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (s *Stack[T]) Push(v T) &#123;</span><br><span class="line">    (*s) = append((*s), v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，这里有两点要注意：</p>
<ul>
<li>泛型类型的方法原型中，receiver部分的类型要带上类型参数，比如这里的*Stack[T]；<br />
</li>
<li>这里务必要用*Stack[T]，而不要像下面代码这样用Stack[T]，否则append方法改变的仅仅是Stack[T]的拷贝，而不是原Stack[T]类型的实例。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (s Stack[T]) Push(v T) &#123;</span><br><span class="line">    s = append(s, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看看*Stack[T]的弹栈Pop方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (s *Stack[T]) Pop() T &#123;</span><br><span class="line">    if len(*s) == 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    // Get the last element from the stack.</span><br><span class="line">    t := (*s)[len(*s)-1]</span><br><span class="line"></span><br><span class="line">    // Remove the last element from the stack.</span><br><span class="line">    *s = (*s)[:len(*s)-1]</span><br><span class="line">    return t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样实现的Pop方法会提示return nil一行有错误：<strong>cannot use nil
as T value in return
statement</strong>。Go编译器错误信息提示我们：<strong>nil不能作为T类型的值返回</strong>。</p>
<p>Stack的类型参数的约束为any，即Stack的元素可以是任意类型，即可以是切片、map等复合类型，亦可以是int、string等值类型。如果将nil作为所有这些类型的零值的确不恰当。</p>
<p>那么当Stack为空时，应该如何返回呢？多亏<a
href="https://www.imooc.com/read/87/article/2381">Go原生支持类型零值</a>，我们可以声明一个类型零值并将其作为返回值返回：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (s *Stack[T]) Pop() T &#123;</span><br><span class="line">    if len(*s) == 0 &#123;</span><br><span class="line">        var zero T</span><br><span class="line">        return zero // 模拟类型零值</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    // Get the last element from the stack.</span><br><span class="line">    t := (*s)[len(*s)-1]</span><br><span class="line"></span><br><span class="line">    // Remove the last element from the stack.</span><br><span class="line">    *s = (*s)[:len(*s)-1]</span><br><span class="line">    return t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这种方法有效，但你是不是和我有一样的感觉：<strong>不够优雅</strong>。下面我们就来看一个更为优雅的小技巧：<strong>利用函数的具名返回值</strong>，看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (s *Stack[T]) Pop() (t T) &#123;</span><br><span class="line">    if len(*s) == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // Get the last element from the stack.</span><br><span class="line">    t = (*s)[len(*s)-1]</span><br><span class="line"></span><br><span class="line">    // Remove the last element from the stack.</span><br><span class="line">    *s = (*s)[:len(*s)-1]</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到：具名返回值(named return
value)一出马，一切都变得自然而然了。当然这也要归功于Go的类型零值特性。</p>
<p>具名返回值日常使用的不多，从使用的频度来看，Go标准库以及多数项目的代码默认选择非具名返回值(unamed
return
value)。当函数使用defer且在deferred函数中修改外部函数返回值时，应用具名返回值可以让代码显得更清晰一些：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func Foo() (a int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        a = 5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a = 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他情况，看项目编码规范一致性要求以及个人喜好了。不过，Go引入泛型后，针对上述的泛型函数返回零值的情况，相信<strong>具名返回值</strong>将得到更多的“出镜”的机会。</p>
<p>转载：<a
href="https://tonybai.com/2022/05/20/solving-problems-in-generic-function-implementation-using-named-return-values">使用具名返回值巧妙解决泛型函数返回零值的问题</a></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>使用空结构体作为map的值来创建高效哈希表集合</title>
    <url>/blog/2023/10/11/data/languages/golang/%E4%BD%BF%E7%94%A8%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BAmap%E7%9A%84%E5%80%BC%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%AB%98%E6%95%88%E5%93%88%E5%B8%8C%E8%A1%A8%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>如果我用interface{}作为map的值，反而会占用空间？</p>
<p>是的，你的理解是正确的。在 Go 语言中，如果你使用
<code>interface&#123;&#125;</code> 类型作为 <code>map</code> 的值，即使你将
<code>nil</code> 存储为值，它仍然会占用一定的内存空间。这是因为
<code>interface&#123;&#125;</code> 在 Go
中是一个复杂类型，它包含了两个指针：一个指向值的类型信息，另一个指向值本身的数据。</p>
<p>下面是一个简单的例子来说明这一点：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用 struct&#123;&#125; 作为值</span></span><br><span class="line">	set1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	set1[<span class="string">&quot;apple&quot;</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 interface&#123;&#125; 作为值</span></span><br><span class="line">	set2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	set2[<span class="string">&quot;apple&quot;</span>] = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Size of empty struct: %d byte(s)\n&quot;</span>, sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Size of interface&#123;&#125;: %d byte(s)\n&quot;</span>, sizeof(set2[<span class="string">&quot;apple&quot;</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof returns the size of v in bytes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sizeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(unsafe.Sizeof(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>set1</code> 使用 <code>struct&#123;&#125;</code> 作为值，而
<code>set2</code> 使用 <code>interface&#123;&#125;</code> 作为值。即使我们将
<code>nil</code> 存储在 <code>set2</code> 中，<code>interface&#123;&#125;</code>
仍然会占用内存空间，因为它需要存储类型信息和数据指针。</p>
<p>因此，如果你想要创建一个内存高效的集合（或哈希 set），使用
<code>struct&#123;&#125;</code> 作为 <code>map</code>
的值通常是一个更好的选择，因为它不占用额外的内存空间。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用sort快排包</title>
    <url>/blog/2023/10/11/data/languages/golang/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8sort%E5%BF%AB%E6%8E%92%E5%8C%85/</url>
    <content><![CDATA[<p>在 Go 语言中，你可以使用标准库 <code>sort</code>
包来对数组或切片进行排序。以下是使用 <code>sort</code>
包对不同类型的数组或切片进行排序的一些例子。</p>
<h3 id="排序整数切片">排序整数切片</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ints := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;</span><br><span class="line">	sort.Ints(ints)</span><br><span class="line">	fmt.Println(ints) <span class="comment">// 输出：[1 1 3 4 5 9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序字符串切片">排序字符串切片</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	strs := []<span class="type">string</span>&#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;kiwi&quot;</span>&#125;</span><br><span class="line">	sort.Strings(strs)</span><br><span class="line">	fmt.Println(strs) <span class="comment">// 输出：[apple banana kiwi]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义排序">自定义排序</h3>
<p>你也可以自定义排序的规则。为了这样做，你需要定义一个满足
<code>sort.Interface</code>
的类型，并实现它的三个方法：<code>Len()</code>,
<code>Less(i, j int) bool</code> 和 <code>Swap(i, j int)</code>。</p>
<p>以下是一个例子，它演示了如何对一组自定义结构体根据其某个字段进行排序：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := []Person&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">22</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">33</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort.Sort(ByAge(people))</span><br><span class="line">	fmt.Println(people) <span class="comment">// 输出：[&#123;Alice 22&#125; &#123;Bob 31&#125; &#123;Charlie 33&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们创建了一个 <code>ByAge</code> 类型（它只是一个
<code>Person</code> 切片的别名），并为它实现了
<code>sort.Interface</code> 接口的三个方法。这样我们就可以使用
<code>sort.Sort</code>
函数对其进行排序。同样的，你可以根据不同的字段或者多个字段组合实现多种排序逻辑。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>学习路线</title>
    <url>/blog/2023/10/11/data/languages/golang/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>作者：马丸子<br />
链接：https://www.zhihu.com/question/369863905/answer/2444168149<br />
来源：知乎<br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>首先我表示，go语言的练手项目不应该是K8s、Docker这种，K8s现有代码接近50万行！！<strong>这怎么练手？？？？？蹭流量也不应该这么不负责任吧</strong></p>
<p>我还是推荐一些500行至3000行的项目用来练手，比如<strong><em><a
href="https://www.zhihu.com/search?q=%E6%9E%81%E5%AE%A2%E5%85%94%E5%85%94&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">极客兔兔</a></em></strong>那个系列就是很好的例子！</p>
<blockquote>
<p>同时，作者推出一个tiny系列：tinyrpc、tinybalancer、redis-tools等。每个系列的代码约1千行左右，可以帮助gopher深入学习go语言，之后会陆续发链接和地址</p>
</blockquote>
<h2 id="redis-tools">Redis-Tools</h2>
<p>redis-tools聚合了后端小伙伴常见的工具集，它有以下特性：</p>
<ul>
<li>分布式锁、<a
href="https://www.zhihu.com/search?q=%E8%87%AA%E6%97%8B%E9%94%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">自旋锁</a><br />
</li>
<li><a
href="https://www.zhihu.com/search?q=%E5%8E%9F%E5%AD%90%E5%91%BD%E4%BB%A4&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">原子命令</a>
compare and swap<br />
</li>
<li>原子命令 compare and delete</li>
</ul>
<p>redis-tools 代码量极少，学习它，开发者可以得到以下收获：</p>
<ul>
<li>代码简洁规范<br />
</li>
<li>redis lua脚本实现<br />
</li>
<li>redis <a
href="https://www.zhihu.com/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">分布式锁</a>的正确实现</li>
</ul>
<p><a
href="https://link.zhihu.com/?target=https%3A//github.com/zehuamama/redis-tools">redis-tools​github.com/zehuamama/redis-tools</a></p>
<h2 id="tinyrpc">TinyRPC</h2>
<p><a
href="https://link.zhihu.com/?target=https%3A//github.com/zehuamama/tinyrpc">TinyRPC</a>
是基于Go语言<a
href="https://www.zhihu.com/search?q=%E6%A0%87%E5%87%86%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">标准库</a>
<strong>net/rpc</strong> 扩展的<a
href="https://www.zhihu.com/search?q=%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">远程过程调用</a>框架，它具有以下特性：</p>
<ul>
<li>基于TCP<a
href="https://www.zhihu.com/search?q=%E4%BC%A0%E8%BE%93%E5%B1%82&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">传输层</a>协议<br />
</li>
<li>支持多种<strong>压缩格式</strong>：gzip、snappy、<a
href="https://www.zhihu.com/search?q=zlib&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">zlib</a>；<br />
</li>
<li>基于<a
href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">二进制的</a>
<strong>Protocol Buffer</strong> <a
href="https://www.zhihu.com/search?q=%E5%BA%8F%E5%88%97%E5%8C%96&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">序列化</a>协议：具有协议编码小及高扩展性和<a
href="https://www.zhihu.com/search?q=%E8%B7%A8%E5%B9%B3%E5%8F%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">跨平台</a>性；<br />
</li>
<li>支持生成工具：TinyRPC提供的 <strong><a
href="https://www.zhihu.com/search?q=protoc-gen-tinyrpc&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">protoc-gen-tinyrpc</a></strong>
插件可以帮助开发者快速定义自己的服务；</li>
</ul>
<p><a
href="https://link.zhihu.com/?target=https%3A//github.com/zehuamama/tinyrpc">TinyRPC</a>
的<a
href="https://www.zhihu.com/search?q=%E6%BA%90%E4%BB%A3%E7%A0%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">源代码</a>仅有一千行左右，通过学习
<strong>TinyRPC</strong> ，开发者可以得到以下收获：</p>
<ul>
<li>代码简洁规范<br />
</li>
<li>涵盖大多数 Go 语言基础用法和高级特性<br />
</li>
<li><a
href="https://www.zhihu.com/search?q=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2432490626%7D">单元测试</a>编写技巧<br />
</li>
<li>TCP流中处理数据包的技巧<br />
</li>
<li>RPC框架的<a
href="https://www.zhihu.com/search?q=%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">设计理念</a></li>
</ul>
<p><a
href="https://link.zhihu.com/?target=https%3A//github.com/zehuamama/tinyrpc">GitHub
- zehuamama/tinyrpc​github.com/zehuamama/tinyrpc</a></p>
<p><a
href="https://zhuanlan.zhihu.com/p/499098284">用Go轻松实现一个高性能RPC188
赞同 · 39 评论文章<img
src="https://pic4.zhimg.com/v2-64d8112e5773faa9e95116fac4b0c9eb_ipico.jpg" /></a></p>
<h2 id="tinybalancer"><strong>TinyBalancer</strong></h2>
<p>TinyBalancer 是基于Go语言标准库 <strong>net/http/httputil</strong>
扩展的<a
href="https://www.zhihu.com/search?q=%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">反向代理负载均衡器</a>，它支持以下特性：</p>
<ul>
<li>支持http以及https协议<br />
</li>
<li>支持七种<a
href="https://www.zhihu.com/search?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">负载均衡算法</a>，分别是：round-robin、random、power
of 2 random choice、consistent hash、consistent hash with
bounded、ip-hash、<a
href="https://www.zhihu.com/search?q=least-load&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">least-load</a>。<br />
</li>
<li>支持心跳检测，故障恢复</li>
</ul>
<p>TinyBalancer 的源代码仅有一千行左右，<strong>通过学习
TinyBalancer</strong> ，开发者可以得到以下收获：</p>
<ul>
<li>深入理解负载均衡算法<br />
</li>
<li>代码简洁规范<br />
</li>
<li>用Go语言设计反向代理的技巧<br />
</li>
<li><a
href="https://www.zhihu.com/search?q=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2432490626%7D">单元测试</a>编写技巧<br />
</li>
<li>工厂设计模式在go语言中的应用</li>
</ul>
<p><a
href="https://zhuanlan.zhihu.com/p/506415782">马丸子：用Go轻松实现高性能负载均衡器131
赞同 · 32 评论文章<img
src="https://pic3.zhimg.com/v2-ba6bb80025b9e6e0de7449872658b05a_180x120.jpg" /></a></p>
<p><a
href="https://link.zhihu.com/?target=https%3A//github.com/zehuamama/balancer">GitHub
- zehuamama/balancer​github.com/zehuamama/balancer</a></p>
<h2
id="tinyweb开发中后续会更新"><strong>TinyWeb（</strong>开发中，后续会更新）</h2>
<p>除了<a
href="https://www.zhihu.com/search?q=%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">开源项目</a>，作者对Go语言进阶的同学有以下一些小指点！</p>
<h2 id="牛客网题库入门">牛客网题库入门</h2>
<p>建议刚入门Go语言的同学多刷一些基础题，牛客网上有go语言的练习题库，里面有很多适合新手做的Go语言入门题,多刷刷练练手，提升更快~</p>
<p><img
src="https://pica.zhimg.com/80/v2-ec07721971029d906a2e9714102f15ed_720w.webp?source=1940ef5c" /></p>
<p><a
href="https://link.zhihu.com/?target=https%3A//www.nowcoder.com/link/pc_rkzh_mwz1">牛客网在线编程_编程学习|练习题_数据结构|系统设计题库​www.nowcoder.com/link/pc_rkzh_mwz1<img
src="https://pic2.zhimg.com/v2-f93c8ff4f9fef667e491300a2cf0391d_ipico.jpg" /></a></p>
<h2
id="单元测试重点在用有兴趣看看源码很短">单元测试（重点在用，有兴趣看看源码，很短）</h2>
<p>作为一名合格的开发者，当然少不了单元测试的编写，一般在工作中，对<a
href="https://www.zhihu.com/search?q=Go%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">Go语言代码</a>进行<strong>单元测试</strong>时通常会使用的两个框架：</p>
<p>Go<a
href="https://www.zhihu.com/search?q=%E8%AF%AD%E8%A8%80%E6%96%AD%E8%A8%80%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">语言断言库</a>：</p>
<p><a
href="https://link.zhihu.com/?target=https%3A//github.com/stretchr/testify">testify​github.com/stretchr/testify</a></p>
<p>Go语言<a
href="https://www.zhihu.com/search?q=%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">接口测试</a>库：</p>
<p><a
href="https://link.zhihu.com/?target=https%3A//github.com/golang/mock">gomock​github.com/golang/mock</a></p>
<p><strong>这两个库会在工作中经常遇到！对单元测试很重要！<a
href="https://www.zhihu.com/search?q=%E9%87%8D%E8%A6%81%E7%9A%84%E8%AF%9D%E8%AF%B4%E4%B8%89%E9%81%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">重要的话说三遍</a>！！！</strong></p>
<hr />
<h3 id="http">HTTP</h3>
<p>Go语言本身提供的标准库非常强大！通过标准库也可以写出优美的Restful接口。官方推荐的web学习教程：<a
href="https://link.zhihu.com/?target=https%3A//gowebexamples.com/">Learn
Web Programming in Go by
Examples</a>，很短很短，<strong>一个小时就能看完</strong>！</p>
<p>其中这个教程中的<strong>路由、Session会话</strong>相关的库选择了Google开发的</p>
<p><a
href="https://link.zhihu.com/?target=https%3A//github.com/gorilla/mux">gorilla/mux​github.com/gorilla/mux</a></p>
<p><a
href="https://link.zhihu.com/?target=https%3A//github.com/gorilla/sessions">gorilla/sessions​github.com/gorilla/sessions</a></p>
<p>，这两个库都非常迷你精巧，也符合Go语言的初衷。</p>
<p><strong>（重点在用，有兴趣看看源码，mux和sessions的源码都在一两千行左右）</strong></p>
<h3 id="关系型数据库会用即可"><a
href="https://www.zhihu.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">关系型数据库</a>（会用即可）</h3>
<p>如果开发者在实际开发过程中，比较喜欢写纯SQL语句或者对性能敏感度较高的话，作者建议选择<a
href="https://link.zhihu.com/?target=https%3A//github.com/jmoiron/sqlx">sqlx</a>库，这个库对Go语言标准库中的sql进行了二次封装。</p>
<p>如果比较喜欢使用ORM框架，作者推荐选择<a
href="https://link.zhihu.com/?target=https%3A//gorm.io/">GORM</a>库。</p>
<p>gorm的文章非常详细，有兴趣的可以看看：<a
href="https://link.zhihu.com/?target=https%3A//gorm.io/docs/">GORM
Guides</a>。</p>
<hr />
<h3 id="rpc会用即可">RPC（会用即可）</h3>
<p>这时，你还想学点<a
href="https://www.zhihu.com/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">微服务</a>相关的，首先强烈推荐<strong>grpc-go</strong>！！<a
href="https://link.zhihu.com/?target=https%3A//grpc.io/">gRPC</a></p>
<p>grpc是google推出的，基于http2.0和protocol
buffer协议的远程过程调用框架</p>
<p>其次，有兴趣的话你可以看看它的生态，<a
href="https://link.zhihu.com/?target=https%3A//github.com/grpc-ecosystem">https://github.com/grpc-ecosystem</a>
，这个生态合辑包含监控、限流、日志等等，堪比<a
href="https://www.zhihu.com/search?q=%E5%93%86%E5%95%A6A%E6%A2%A6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">哆啦A梦</a>的<strong>小肚兜</strong>！！</p>
<h3
id="序列化协议有兴趣可以看看protocol-buffer的编码原理">序列化协议（有兴趣可以看看Protocol
buffer的编码原理）</h3>
<p>关于<strong>序列化协议</strong>，web常用的文本序列化协议就是JSON了，二进制序列化协议多数为Protocol
buffer</p>
<p>Protocol buffer的指南：<a
href="https://link.zhihu.com/?target=https%3A//developers.google.com/protocol-buffers/docs/proto3">Language
Guide (proto3)</a></p>
<p>API官方文档：<a
href="https://link.zhihu.com/?target=https%3A//developers.google.com/protocol-buffers/docs/gotutorial">Protocol
Buffer Basics: Go</a></p>
<hr />
<h2
id="go语言代码规也是非常非常重要的东西">Go语言代码规也是非常非常重要的东西！！！！</h2>
<p>uber的Go语言的代码规范：<a
href="https://link.zhihu.com/?target=https%3A//github.com/uber-go/guide">uber-go/guide</a>，至今是很多Go语言开发团队的典范！强烈推荐熟读一遍</p>
<p>中文翻译版：<a
href="https://link.zhihu.com/?target=https%3A//github.com/xxjwxc/uber_go_guide_cn">uber_go_guide_cn</a></p>
<h2 id="深入原理不喜欢八股文的可以跳过"><strong>深入原理（不喜欢<a
href="https://www.zhihu.com/search?q=%E5%85%AB%E8%82%A1%E6%96%87&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2444168149%7D">八股文</a>的可以跳过）</strong></h2>
<p><strong>如果你想面试来BAT上班</strong>，除了后端必备的东西，<strong>Go语言的八股文</strong>给大家来一打！！</p>
<p>可以看看左老师的：<a
href="https://link.zhihu.com/?target=https%3A//draveness.me/golang/">https://draveness.me/golang/</a></p>
<p><strong><em>敲重点！！！！！</em></strong></p>
<p><a
href="https://link.zhihu.com/?target=https%3A//draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">Slice原理</a></p>
<p><a
href="https://link.zhihu.com/?target=https%3A//draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">Map原理</a></p>
<p><a
href="https://link.zhihu.com/?target=https%3A//draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">Channel原理</a></p>
<p><a
href="https://link.zhihu.com/?target=https%3A//draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">Go
语言调度器与 Goroutine 实现原理</a></p>
<p><a
href="https://link.zhihu.com/?target=https%3A//draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">Go语言内存分配模型</a></p>
<p><a
href="https://link.zhihu.com/?target=https%3A//draveness.me/golang/doc">Go语言垃圾回收原理</a></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>希望单个项目目录下使用多个main函数</title>
    <url>/blog/2023/10/11/data/languages/golang/%E5%B8%8C%E6%9C%9B%E5%8D%95%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="真实需求场景">真实需求场景</h2>
<p>例如，我在写一个分析百度统计实时访客历史记录的系统，其包含的基本模块：</p>
<ul>
<li>一个 GoAdmin 写的 Web 管理后台服务<br />
</li>
<li>一个 CSV 数据文件导入 MySQL 的命令</li>
</ul>
<h2
id="测试项目根目录下是否可以共存两个-main-入口程序">测试项目根目录下是否可以共存两个
main 入口程序</h2>
<p>先不管网上的那些 golang
代码组织策略，单纯的测试一下是否可以在项目根目录下共存两个 main
入口程序。</p>
<p>测试方法：</p>
<ul>
<li>既有的 import_log.go 中已经有一个 main 函数了<br />
</li>
<li>新建一个 main.go 文件，与 import_log.go 同属 package
main，包含一个简单的 main 函数，输出 Hello world</li>
</ul>
<p>运行 go build，果然报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; go build</span><br><span class="line"># golog</span><br><span class="line">./main.go:7:6: main redeclared in this block</span><br><span class="line">        previous declaration at ./import_log.go:19:6</span><br></pre></td></tr></table></figure>
<p>这说明同一个目录下只能有一个 main 函数。</p>
<h2 id="在不同目录下新建两个-main-函数呢">在不同目录下新建两个 main
函数呢</h2>
<p>我的几个疑问：</p>
<ul>
<li>不同目录下的 go 代码文件，是否可以同属于 package main?<br />
</li>
<li>不同目录下的 main 函数，是否可以 go build
一键生成多个二进制文件?<br />
</li>
<li>多个 main 入口文件，是否需要多个 go.mod?</li>
</ul>
<p>测试方法：</p>
<ul>
<li>新建一个目录，例如 cmd，将 main.go 移动到 cmd 目录下</li>
</ul>
<p>这种方法确实可行。</p>
<p>测试结果：</p>
<ul>
<li>在根目录下执行 go build, 只会生成根目录下 main
函数对应的二进制文件。cmd 目录下的 main.go 没有被编译。<br />
</li>
<li>到 cmd 下执行 go build，可以成功编译，并运行。<br />
</li>
<li>两个不同的入口文件确实可以同属于 package main.</li>
</ul>
<p>到目前为止，独立一个 cmd 目录已经满足了我当前项目的需求。</p>
<p>但是，需要再发散一下。</p>
<h2 id="golang-项目中包含多个工具命令呢">golang
项目中包含多个工具命令呢</h2>
<p>如果多个工具命令都包含在一个 cmd 中，还是会出现最初的 main redeclared
问题。</p>
<p>那就需要在 cmd 下再建子目录。</p>
<p>转载：<a
href="https://www.sunzhongwei.com/how-to-organize-golang-project-directory-make-a-project-contains-multiple-main-entrance-to-program">如何组织
Golang 项目目录，使一个项目包含多个 main 入口程序 - golang - 大象笔记
(sunzhongwei.com)</a></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配换行符</title>
    <url>/blog/2023/10/11/data/languages/golang/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%8D%A2%E8%A1%8C%E7%AC%A6/</url>
    <content><![CDATA[<p>golang中，用re正则表达式库以及这个模式<code>(?m)([^\s])\n</code>会匹配到什么？</p>
<p>在 Go 语言中使用正则表达式库（通过 <code>regexp</code> 包）和模式
<code>(?m)([^\s])\n</code>，这个正则表达式会匹配到什么呢？</p>
<p>首先，让我们分解这个正则表达式的各个部分来理解它的工作方式：</p>
<ul>
<li><p><code>(?m)</code>:
这是一个模式修饰符，它使正则表达式变为多行模式。在多行模式下，<code>^</code>
和 <code>$</code>
分别匹配字符串的开始和一个换行符之后的位置，以及一个换行符之前和字符串的结束的位置。</p></li>
<li><p><code>([^\s])</code>:
这个部分是一个字符类，它匹配任何非空白字符（<code>\s</code>
是一个空白字符的简写，所以 <code>[^\s]</code>
匹配任何非空白字符）。这个部分还被包含在括号中，所以它形成了一个捕获组，这意味着匹配到的字符将被捕获，以便稍后使用。</p></li>
<li><p><code>\n</code>: 这个部分匹配一个换行符。</p></li>
</ul>
<p>所以，整个正则表达式 <code>(?m)([^\s])\n</code>
将会匹配到一个非空白字符，后面紧跟着一个换行符，并且由于使用了多行模式修饰符，它将在整个字符串中进行这种匹配，而不仅仅是在字符串的开始和结束。</p>
<p>下面是一个简单的 Go 代码示例，演示了如何使用这个正则表达式：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	re := regexp.MustCompile(<span class="string">`(?m)([^\s])\n`</span>)</span><br><span class="line">	s := <span class="string">&quot;Hello\nWorld\n\nGo\nProgramming\n&quot;</span></span><br><span class="line">	matches := re.FindAllStringSubmatch(s, <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span> _, match := <span class="keyword">range</span> matches &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Matched: %v\n&quot;</span>, match[<span class="number">1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>测试的时候会编译整个项目包吗？</title>
    <url>/blog/2023/10/11/data/languages/golang/%E6%B5%8B%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E7%BC%96%E8%AF%91%E6%95%B4%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%8C%85%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>golang进入test目录执行<code>go test</code>的时候，会先编译好整个包再来执行测试文件吗？</p>
<p>ChatGPT</p>
<p>当你在 Go 语言（Golang）的一个项目中进入 <code>test</code> 目录并执行
<code>go test</code> 命令时，Go
测试工具会进行一系列的步骤来运行测试。以下是一般的步骤：</p>
<ol type="1">
<li><p><strong>编译包</strong>：首先，<code>go test</code>
会编译包含测试文件的包。这意味着它会编译包内的所有 Go
文件（包括测试文件和非测试文件）。</p></li>
<li><p><strong>编译测试文件</strong>：接着，它会编译测试文件。测试文件通常是以
<code>_test.go</code> 结尾的文件，它们包含了测试函数（以
<code>Test</code> 开头的函数）。</p></li>
<li><p><strong>运行测试</strong>：最后，<code>go test</code>
会运行编译后的测试二进制文件，执行所有的测试函数，并输出测试结果。</p></li>
</ol>
<p>这些步骤确保在运行测试之前，整个包（包括测试文件和被测试的源代码文件）都被正确编译。这样做的一个原因是为了检查包和测试文件中是否存在编译错误。另一个原因是为了生成一个可执行的测试二进制文件，该文件可以单独运行测试，而无需再次编译。</p>
<p>如果你有一个具体的 PDF 文档或在线资源，我可以帮助你检索更多关于 Go
测试的详细信息。请提供文档的 URL，我将为你提供更多的帮助。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>获取目录名和文件名</title>
    <url>/blog/2023/10/11/data/languages/golang/%E8%8E%B7%E5%8F%96%E7%9B%AE%E5%BD%95%E5%90%8D%E5%92%8C%E6%96%87%E4%BB%B6%E5%90%8D/</url>
    <content><![CDATA[<p>golang获取一个路径的目录名和文件名的函数分别是什么？</p>
<p>在 Go 语言（通常被称为 Golang）中，你可以使用
<code>path/filepath</code>
包来获取一个路径的目录名和文件名。下面是两个常用的函数：</p>
<ol type="1">
<li><p><strong>获取目录名</strong>： 使用
<code>filepath.Dir(path string) string</code> 函数。这个函数返回
<code>path</code> 的目录名。例如：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path := <span class="string">&quot;/example/path/file.txt&quot;</span></span><br><span class="line">	dir := filepath.Dir(path)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Directory:&quot;</span>, dir)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>获取文件名</strong>： 使用
<code>filepath.Base(path string) string</code> 函数。这个函数返回
<code>path</code> 的文件名。例如：<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path := <span class="string">&quot;/example/path/file.txt&quot;</span></span><br><span class="line">	filename := filepath.Base(path)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Filename:&quot;</span>, filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>读取配置目录下的所有配置文件</title>
    <url>/blog/2023/10/11/data/languages/golang/%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>我的配置目录下有一个conf.go，那我希望这个项目的包被运行的时候，这个conf.go中的函数能定位到自己这个文件所在的配置目录，然后扫描其下的所有json配置文件，这能做到吗？</p>
<p>是的，你可以在 <code>conf.go</code>
中编写代码来定位该文件所在的目录，并扫描该目录下的所有 JSON
配置文件。下面是一个简单的示例，展示了如何实现这一点：</p>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> conf</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取 conf.go 文件的路径</span></span><br><span class="line">	_, filename, _, ok := runtime.Caller(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Error getting current file path&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 conf.go 所在的目录</span></span><br><span class="line">	confDir := filepath.Dir(filename)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取目录下的所有文件</span></span><br><span class="line">	files, err := ioutil.ReadDir(confDir)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Error reading conf directory: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历文件，查找 JSON 文件</span></span><br><span class="line">	<span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">		<span class="keyword">if</span> file.IsDir() &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> strings.HasSuffix(file.Name(), <span class="string">&quot;.json&quot;</span>) &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Found JSON config file: %s\n&quot;</span>, file.Name())</span><br><span class="line">			<span class="comment">// 这里你可以添加代码来读取和解析 JSON 文件</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>转换格林尼治时间为当前时区时间</title>
    <url>/blog/2023/10/11/data/languages/golang/%E8%BD%AC%E6%8D%A2%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E6%97%B6%E9%97%B4%E4%B8%BA%E5%BD%93%E5%89%8D%E6%97%B6%E5%8C%BA%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// GMT 时间字符串</span></span><br><span class="line">	gmtTimeStr := <span class="string">&quot;Wed, 04 Jan 2023 21:00:57 GMT&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 GMT 时间字符串</span></span><br><span class="line">	gmtTime, err := time.Parse(time.RFC1123, gmtTimeStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error parsing time:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取本地时区</span></span><br><span class="line">	localLocation := time.Now().Location()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 转换到本地时区</span></span><br><span class="line">	localTime := gmtTime.In(localLocation)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;GMT Time: %v\n&quot;</span>, gmtTime)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Local Time: %v\n&quot;</span>, localTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云存储桶 oss-bucket 接口示例</title>
    <url>/blog/2023/10/11/data/languages/golang/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AD%98%E5%82%A8%E6%A1%B6%20oss-bucket%20%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="创建存储空间">创建存储空间</h2>
<p>存储空间是OSS全局命名空间，相当于数据的容器，可以存储若干文件。
以下代码用于新建一个存储空间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/aliyun/aliyun-oss-go-sdk/oss&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">   os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">   endpoint := <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span></span><br><span class="line">   <span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span></span><br><span class="line">   accessKeyId := <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span></span><br><span class="line">   accessKeySecret := <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span></span><br><span class="line">   bucketName := <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span></span><br><span class="line">   <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">   client, err := oss.New(endpoint, accessKeyId, accessKeySecret)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建存储空间。</span></span><br><span class="line">   err = client.CreateBucket(bucketName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储空间的命名规范，请参见基本概念中的命名规范。创建存储空间详情，请参见创建存储空间。</p>
<p>获取endpoint信息，请参见访问域名和数据中心文档。</p>
<h2 id="上传文件">上传文件</h2>
<p>以下代码用于上传文件至OSS：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/aliyun/aliyun-oss-go-sdk/oss&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">   os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">   endpoint := <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span></span><br><span class="line">   <span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span></span><br><span class="line">   accessKeyId := <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span></span><br><span class="line">   accessKeySecret := <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span></span><br><span class="line">   bucketName := <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span></span><br><span class="line">   <span class="comment">// &lt;yourObjectName&gt;上传文件到OSS时需要指定包含文件后缀在内的完整路径，例如abc/efg/123.jpg。</span></span><br><span class="line">   objectName := <span class="string">&quot;&lt;yourObjectName&gt;&quot;</span></span><br><span class="line">   <span class="comment">// &lt;yourLocalFileName&gt;由本地文件路径加文件名包括后缀组成，例如/users/local/myfile.txt。</span></span><br><span class="line">   localFileName := <span class="string">&quot;&lt;yourLocalFileName&gt;&quot;</span></span><br><span class="line">   <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">   client, err := oss.New(endpoint, accessKeyId, accessKeySecret)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取存储空间。</span></span><br><span class="line">   bucket, err := client.Bucket(bucketName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 上传文件。</span></span><br><span class="line">   err = bucket.PutObjectFromFile(objectName, localFileName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下载文件">下载文件</h2>
<p>以下代码用于下载文件到本地：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/aliyun/aliyun-oss-go-sdk/oss&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">   os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">   endpoint := <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span></span><br><span class="line">   <span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span></span><br><span class="line">   accessKeyId := <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span></span><br><span class="line">   accessKeySecret := <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span></span><br><span class="line">   bucketName := <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span></span><br><span class="line">   <span class="comment">// &lt;yourObjectName&gt;从OSS下载文件时需要指定包含文件后缀在内的完整路径，例如abc/efg/123.jpg。</span></span><br><span class="line">   objectName := <span class="string">&quot;&lt;yourObjectName&gt;&quot;</span></span><br><span class="line">   downloadedFileName := <span class="string">&quot;&lt;yourDownloadedFileName&gt;&quot;</span></span><br><span class="line">   <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">   client, err := oss.New(endpoint, accessKeyId, accessKeySecret)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取存储空间。</span></span><br><span class="line">   bucket, err := client.Bucket(bucketName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 下载文件。</span></span><br><span class="line">   err = bucket.GetObjectToFile(objectName, downloadedFileName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="列举文件">列举文件</h2>
<p>以下代码用于列举指定存储空间下的文件。默认列举100个文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/aliyun/aliyun-oss-go-sdk/oss&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">   os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">   client, err := oss.New(<span class="string">&quot;&lt;yourEndpoint&gt;&quot;</span>, <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span>, <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       HandleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取存储空间。</span></span><br><span class="line">   bucketName := <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span></span><br><span class="line">   bucket, err := client.Bucket(bucketName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       HandleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 列举文件。</span></span><br><span class="line">   marker := <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">       lsRes, err := bucket.ListObjects(oss.Marker(marker))</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           HandleError(err)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 打印列举文件，默认情况下一次返回100条记录。 </span></span><br><span class="line">       <span class="keyword">for</span> _, object := <span class="keyword">range</span> lsRes.Objects &#123;</span><br><span class="line">           fmt.Println(<span class="string">&quot;Bucket: &quot;</span>, object.Key)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> lsRes.IsTruncated &#123;</span><br><span class="line">           marker = lsRes.NextMarker</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除文件">删除文件</h2>
<p>以下代码用于删除指定文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/aliyun/aliyun-oss-go-sdk/oss&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">   os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">   endpoint := <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span></span><br><span class="line">   <span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。</span></span><br><span class="line">   accessKeyId := <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span></span><br><span class="line">   accessKeySecret := <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span></span><br><span class="line">   bucketName := <span class="string">&quot;&lt;yourBucketName&gt;&quot;</span></span><br><span class="line">   <span class="comment">// &lt;yourObjectName&gt;表示删除OSS文件时需要指定包含文件后缀在内的完整路径，例如abc/efg/123.jpg。</span></span><br><span class="line">   objectName := <span class="string">&quot;&lt;yourObjectName&gt;&quot;</span></span><br><span class="line">   <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">   client, err := oss.New(endpoint, accessKeyId, accessKeySecret)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取存储空间。</span></span><br><span class="line">   bucket, err := client.Bucket(bucketName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 删除文件。</span></span><br><span class="line">   err = bucket.DeleteObject(objectName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       handleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除文件详情请参见管理文件中的删除文件。</p>
<h2 id="参考">参考</h2>
<p><a
href="https://www.alibabacloud.com/help/zh/doc-detail/31959.htm?spm=a2c63.p38356.b99.785.2b9319dehWDKtr">阿里云对象存储OSS对接文档</a></p>
<p>转载：<a
href="https://www.cnblogs.com/liabio/p/11946281.html">golang操作阿里云对象存储</a></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云存储桶确定文件修改时间</title>
    <url>/blog/2023/10/11/data/languages/golang/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AD%98%E5%82%A8%E6%A1%B6%E7%A1%AE%E5%AE%9A%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/aliyun/aliyun-oss-go-sdk/oss&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建OSS Client</span></span><br><span class="line">	client, err := oss.New(<span class="string">&quot;&lt;Your Endpoint&gt;&quot;</span>, <span class="string">&quot;&lt;Your AccessKeyId&gt;&quot;</span>, <span class="string">&quot;&lt;Your AccessKeySecret&gt;&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取存储桶</span></span><br><span class="line">	bucket, err := client.Bucket(<span class="string">&quot;&lt;Your Bucket Name&gt;&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取文件元数据</span></span><br><span class="line">	props, err := bucket.GetObjectDetailedMeta(<span class="string">&quot;&lt;Your Object Key&gt;&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取最后修改时间</span></span><br><span class="line">	lastModifiedStr := props.Get(<span class="string">&quot;Last-Modified&quot;</span>)</span><br><span class="line">	lastModified, err := time.Parse(time.RFC1123, lastModifiedStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Last Modified Time of the Object: %v\n&quot;</span>, lastModified)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这里，你可以将lastModified与你本地文件的最后修改时间进行比较，以决定是否下载文件。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>正交矩阵的几何意义</title>
    <url>/blog/2023/10/11/data/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>作者：Roger Rogers</p>
<p>链接：https://www.zhihu.com/question/304059390/answer/552179956</p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>正交矩阵是方块矩阵，<a
href="https://www.zhihu.com/search?q=%E8%A1%8C%E5%90%91%E9%87%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A552179956%7D">行向量</a>和列向量皆为正交的单位向量。</p>
<p>行向量皆为正交的单位向量，任意两行正交就是两行点乘结果为0，而因为是单位向量，所以任意行点乘自己结果为1。</p>
<p>对于3x3正交矩阵，每行是一个3维向量，两个<a
href="https://www.zhihu.com/search?q=3%E7%BB%B4%E5%90%91%E9%87%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A552179956%7D">3维向量</a>正交的几何意义就是这两个向量相互垂直。</p>
<p>所以3x3正交矩阵的三行可以理解为一个3D坐标系里的三个坐标轴，下面是3*3正交矩阵M，<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x1,x2,x3 // x轴  </span><br><span class="line">y1,y2,y3 // y轴  </span><br><span class="line">z1,z2,z3 // z轴</span><br></pre></td></tr></table></figure></p>
<p><a
href="https://www.zhihu.com/search?q=%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A552179956%7D">单位矩阵</a>表示的三个坐标轴就是<a
href="https://www.zhihu.com/search?q=%E7%AC%9B%E5%8D%A1%E5%B0%94%E5%9D%90%E6%A0%87%E7%B3%BB&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A552179956%7D">笛卡尔坐标系</a>里的x,y,z轴：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1, 0, 0, // x轴  </span><br><span class="line">0, 1, 0, // y轴  </span><br><span class="line">0, 0, 1, // z轴</span><br></pre></td></tr></table></figure></p>
<p>一个向量乘以3x3正交矩阵的几何意义就是把这个向量从当前坐标系变换到这个矩阵所表示的坐标系里，比如下面的矩阵M1，<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0, 1, 0,  </span><br><span class="line">1, 0, 0,  </span><br><span class="line">0, 0, 1,</span><br></pre></td></tr></table></figure></p>
<p>一个向量(1, 2, 3)右乘这个矩阵M1得到新的向量(2, 1,
3)，就是把原向量从原坐标系变换到一个新的坐标系。</p>
<p>新坐标系的x轴在原坐标系里是(0,1,0)，即落在原坐标系的y轴上，</p>
<p>新坐标系就是把原坐标系的x和y轴对调，所以这个正交矩阵M1作用于向量(1,2,3)后把向量的x和y分量对调了。</p>
<hr />
<p>正交矩阵的定义“行向量和列向量皆为正交的单位向量”带来了另一个好处：正交矩阵的转置就是正交矩阵的逆，比普通矩阵求<a
href="https://www.zhihu.com/search?q=%E9%80%86%E7%9F%A9%E9%98%B5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A552179956%7D">逆矩阵</a>简单多了。</p>
<p>下面解释一下 为什么正交矩阵的转置就是正交矩阵的逆：</p>
<p>还是开头说的正交矩阵M：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x1, x2, x3, //rowx  </span><br><span class="line">y1, y2, y3, //rowy  </span><br><span class="line">z1, z2, z3, //rowz</span><br></pre></td></tr></table></figure></p>
<p>每行都是单位<a
href="https://www.zhihu.com/search?q=%E9%95%BF%E5%BA%A6%E5%90%91%E9%87%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A552179956%7D">长度向量</a>，所以每行点乘自己的结果为1。</p>
<p>任意两行正交就是两行点乘结果为0。</p>
<p>矩阵M的转置矩阵MT是：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x1, y1, z1,  </span><br><span class="line">x2, y2, z2,  </span><br><span class="line">x3, y3, z3,</span><br></pre></td></tr></table></figure></p>
<p>两个矩阵相乘 Mmul = M * MT：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rowx * rowx,  rowx * rowy, rowx * rowz,  </span><br><span class="line">rowy * rowx,  rowy * rowy, rowy * rowz,  </span><br><span class="line">rowz * rowx,  rowz * rowy, rowz * rowz,</span><br></pre></td></tr></table></figure></p>
<p>点乘自己结果为1，点乘别的行结果为0，所以Mmul等于单位矩阵<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1, 0, 0,  </span><br><span class="line">0, 1, 0,  </span><br><span class="line">0, 0, 1,</span><br></pre></td></tr></table></figure></p>
<p>逆矩阵的定义就是逆矩阵乘以原矩阵等于单位矩阵，所以，</p>
<p>正交矩阵的转置就是正交矩阵的逆。</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>谱定理和瑞利商</title>
    <url>/blog/2023/10/11/data/math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E8%B0%B1%E5%AE%9A%E7%90%86%E5%92%8C%E7%91%9E%E5%88%A9%E5%95%86/</url>
    <content><![CDATA[<h2 id="谱定理">谱定理</h2>
<p>首先要分清楚矩阵左乘和矩阵右乘具体是写了什么</p>
<p>在大学阶段，线性代数中，矩阵的左乘和右乘可以简记为：“左乘行变换，右乘列变换”。
设A为m<em>s的矩阵，B为s</em>n的矩阵，那么称<code>m*n</code>的矩阵C为矩阵A与B的乘积，记作<span
class="math inline">\(C=AB\)</span>，称为A右乘B，也即为B左乘A。</p>
<p>谱定理简单来说是一个应用矩阵的特征值和特征向量的定理，但是对被分解的矩阵有约束，那就是它是一个对称矩阵。一个对称矩阵可以被分解为一对正交矩阵和一个对角阵，然后有下面的定理。</p>
<p>![[Pasted image 20230922175233.png]]</p>
<h2 id="瑞利商">瑞利商</h2>
<p>![[Pasted image 20230922175307.png]]<br />
瑞利商的几何意义比较容易理解，瑞利商是对谱定理（Spectral
Theorem）的一个应用，它本质上是说仿射变换矩阵（假设我们是在三维空间的话，变换矩阵就叫做仿射变化，高维空间就简单称为变换矩阵了），对向量的模长改变的倍数范围在这个变换矩阵的最大和最小特征值之间。</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>ADD 和 COPY命令什么区别，分别在什么时候使用？</title>
    <url>/blog/2023/10/11/data/linux/docker/ADD%20%E5%92%8C%20COPY%E5%91%BD%E4%BB%A4%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="introduction">1. Introduction</h2>
<p>When creating Dockerfiles, it's often necessary to transfer files
from the host system into the Docker image. These could be property
files, native libraries, or other static content that our applications
will require at runtime.</p>
<p>The Dockerfile specification provides two ways to copy files from the
source system into an image: the COPY and ADD directives.</p>
<p>In this article, we'll look at the differences between them and when
it makes sense to use each one.</p>
<h2 id="difference-between-copy-and-add">2. Difference Between COPY and
ADD</h2>
<p>At first glance, the COPY and ADD directives look the same. They have
the same syntax:</p>
<p>COPY <source> <destination><br />
ADD <source> <destination>Copy</p>
<p>And both copy files from the host system to the <a
href="https://www.baeldung.com/ops/efficient-docker-images">Docker
image</a>.</p>
<p>So what's the difference? In short, the ADD directive is more capable
than COPY.</p>
<p>While functionally similar, the ADD directive is more powerful in two
ways:</p>
<ul>
<li>It can handle remote URLs<br />
</li>
<li>It can auto-extract <a
href="https://www.baeldung.com/linux/tar-command">tar files</a></li>
</ul>
<p>Let's look at these more closely.</p>
<p>First, the ADD directive can accept a remote URL for its source
argument. The COPY directive, on the other hand, can only accept local
files.</p>
<p>Note that using ADD to fetch remote files and copying is not
typically ideal. This is because the file will increase the overall
Docker image size. Instead, we should use <a
href="https://www.baeldung.com/linux/curl-wget">curl or wget</a> to
fetch remote files and remove them when no longer needed.</p>
<p>Second, the ADD directive will automatically expand tar files into
the image file system. While this can reduce the number of Dockerfile
steps required to build an image, it may not be desired in all
cases.</p>
<p>Note that the auto-expansion only occurs when the source file is
local to the host system.</p>
<h2 id="when-to-use-add-or-copy">3. When to Use ADD or COPY</h2>
<p>According to the <a
href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy">Dockerfile
best practices guide</a>, we should always prefer COPY over ADD unless
we specifically need one of the two additional features of ADD.</p>
<p>As noted above, using ADD to copy remote files into a Docker image
creates an extra layer and increases the file size. If we use wget or
curl instead, we can remove the files afterward, and they don't remain a
permanent part of the Docker image.</p>
<p>Additionally, since the ADD command automatically expands tar files
and certain compressed formats, it can lead to unexpected files being
written to the file system in our images.</p>
<h2 id="conclusion">4. Conclusion</h2>
<p>In this quick tutorial, we've seen the two primary ways to copy files
into a Docker image: ADD and COPY. While functionally similar, the COPY
directive is preferred for most cases. This is because the ADD directive
provides additional functionality that should be used with caution and
only when needed.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础-AUFS</title>
    <url>/blog/2023/10/11/data/linux/docker/Docker%E5%9F%BA%E7%A1%80-AUFS/</url>
    <content><![CDATA[<p>AUFS是一种Union File
System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合
mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。</p>
<p>AUFS又叫Another UnionFS，后来叫Alternative
UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS。是个叫Junjiro
Okajima（岡島順治郎）在2006年开发的，AUFS完全重写了早期的UnionFS
1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS
2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union
mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。</p>
<p>不过，好在有很多发行版都用了AUFS，比如：Ubuntu 10.04，Debian6.0,
Gentoo Live CD支持AUFS，所以，也OK了。</p>
<p>好了，扯完这些闲话，我们还是看一个示例吧（环境：Ubuntu 14.04）</p>
<p>首先，我们建上两个目录（水果和蔬菜），并在这两个目录中放上一些文件，水果中有苹果和蕃茄，蔬菜有胡萝卜和蕃茄。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── fruits</span><br><span class="line">│   ├── apple</span><br><span class="line">│   └── tomato</span><br><span class="line">└── vegetables</span><br><span class="line">    ├── carrots</span><br><span class="line">    └── tomato</span><br></pre></td></tr></table></figure> 然后，我们输入以下命令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个mount目录</span><br><span class="line">$ mkdir mnt</span><br><span class="line"></span><br><span class="line"># 把水果目录和蔬菜目录union mount到 ./mnt目录中</span><br><span class="line">$ sudo mount -t aufs -o dirs=./fruits:./vegetables none ./mnt</span><br><span class="line"></span><br><span class="line">#  查看./mnt目录</span><br><span class="line">$ tree ./mnt</span><br><span class="line">./mnt</span><br><span class="line">├── apple</span><br><span class="line">├── carrots</span><br><span class="line">└── tomato</span><br></pre></td></tr></table></figure>
我们可以看到在./mnt目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了./mnt目录下了。</p>
<p>我们来修改一下其中的文件内容：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo mnt &gt; ./mnt/apple</span><br><span class="line">$ cat ./mnt/apple</span><br><span class="line">mnt</span><br><span class="line">$ cat ./fruits/apple</span><br><span class="line">mnt</span><br></pre></td></tr></table></figure>
上面的示例，我们可以看到./mnt/apple的内容改了，./fruits/apple的内容也改了。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo mnt_carrots &gt; ./mnt/carrots</span><br><span class="line">$ cat ./vegetables/carrots </span><br><span class="line"></span><br><span class="line">$ cat ./fruits/carrots</span><br><span class="line">mnt_carrots</span><br></pre></td></tr></table></figure>
上面的示例，我们可以看到，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits/carrots的目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容。</p>
<p>也就是说，我们在mount
aufs命令中，我们没有指它vegetables和fruits的目录权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）</p>
<p>所以，如果我们像下面这样指定权限来mount
aufs，你就会发现有不一样的效果（记得先把上面./fruits/carrots的文件删除了）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt</span><br><span class="line"></span><br><span class="line">$ echo &quot;mnt_carrots&quot; &gt; ./mnt/carrots </span><br><span class="line"></span><br><span class="line">$ cat ./vegetables/carrots</span><br><span class="line">mnt_carrots</span><br><span class="line"></span><br><span class="line">$ cat ./fruits/carrots</span><br><span class="line">cat: ./fruits/carrots: No such file or directory</span><br></pre></td></tr></table></figure>
现在，在这情况下，如果我们要修改./mnt/tomato这个文件，那么究竟是哪个文件会被改写？<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;mnt_tomato&quot; &gt; ./mnt/tomato </span><br><span class="line"></span><br><span class="line">$ cat ./fruits/tomato</span><br><span class="line">mnt_tomato</span><br><span class="line"></span><br><span class="line">$ cat ./vegetables/tomato</span><br><span class="line">I am a vegetable</span><br></pre></td></tr></table></figure>
可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高。</p>
<p>你可以用这个例子做一些各种各样的试验，我这里主要是给大家一个感性认识，就不展开试验下去了。</p>
<p>那么，这种UnionFS有什么用？</p>
<p>历史上，有一个叫<a
href="https://zh.wikipedia.org/wiki/Knoppix">Knoppix的Linux发行版</a>，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把CD/DVD上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把CD/DVD这个文件系统和USB这个可写的系统给联合mount起来，这样你对CD/DVD上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对CD/DVD上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西。</p>
<p>我们可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working
directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad
hoc snapshot。</p>
<p>Docker把UnionFS的想像力发挥到了容器的镜像。你是否还记得我在<a
href="https://coolshell.cn/articles/17010.html"
title="Docker基础技术：Linux Namespace（上）">介绍Linux
Namespace上篇</a>中用mount
namespace和chroot山寨了一镜像。现在当你看过了这个UnionFS的技术后，你是不是就明白了，你完全可以用UnionFS这样的技术做出分层的镜像来。</p>
<p>下图来自Docker的官方文档<a
href="http://docs.docker.com/terms/layer/">Layer</a>，其很好的展示了Docker用UnionFS搭建的分层镜像。</p>
<figure>
<img
src="https://coolshell.cn/wp-content/uploads/2015/04/docker-filesystems-multilayer.png"
alt="docker-filesystems-multilayer" />
<figcaption
aria-hidden="true">docker-filesystems-multilayer</figcaption>
</figure>
<p>关于docker的分层镜像，除了aufs，docker还支持btrfs,
devicemapper和vfs，你可以使用 -s 或 –storage-driver=
选项来指定相关的镜像存储。在Ubuntu 14.04下，docker默认Ubuntu的
aufs（在CentOS7下，用的是devicemapper，关于devicemapper，我会以以后的文章中讲解）你可以在下面的目录中查看相关的每个层的镜像：<br />
/var/lib/docker/aufs/diff/&lt;id&gt;</p>
<p>在docker执行起来后（比如：docker run -it ubuntu /bin/bash
），你可以从/sys/fs/aufs/si_[id]目录下查看aufs的mount的情况，下面是个示例：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ls /sys/fs/aufs/si_b71b209f85ff8e75/</span><br><span class="line">br0      br2      br4      br6      brid1    brid3    brid5    xi_path</span><br><span class="line">br1      br3      br5      brid0    brid2    brid4    brid6 </span><br><span class="line"></span><br><span class="line"># cat /sys/fs/aufs/si_b71b209f85ff8e75/*</span><br><span class="line">/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7=rw</span><br><span class="line">/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7-init=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/d0955f21bf24f5bfffd32d2d0bb669d0564701c271bc3dfc64cfc5adfdec2d07=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/9fec74352904baf5ab5237caa39a84b0af5c593dc7cc08839e2ba65193024507=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/a1a958a248181c9aa6413848cd67646e5afb9797f1a3da5995c7a636f050f537=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/f3c84ac3a0533f691c9fea4cc2ceaaf43baec22bf8d6a479e069f6d814be9b86=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158=ro+wh</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">/run/shm/aufs.xino</span><br></pre></td></tr></table></figure></p>
<p>你会看到只有最顶上的层（branch）是rw权限，其它的都是ro+wh权限只读的。</p>
<p>关于docker的aufs的配置，你可以在/var/lib/docker/repositories-aufs这个文件中看到。</p>
<p>目录</p>
<ul>
<li><a
href="https://coolshell.cn/articles/17061.html#AUFS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7"
title="AUFS的一些特性">AUFS的一些特性</a>
<ul>
<li><a
href="https://coolshell.cn/articles/17061.html#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"
title="相关术语">相关术语</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17061.html#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"
title="相关问题">相关问题</a><br />
</li>
</ul></li>
<li><a
href="https://coolshell.cn/articles/17061.html#AUFS%E7%9A%84%E6%80%A7%E8%83%BD"
title="AUFS的性能">AUFS的性能</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17061.html#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"
title="延伸阅读">延伸阅读</a></li>
</ul>
<h4 id="aufs的一些特性">AUFS的一些特性</h4>
<p>AUFS有所有Union
FS的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被mount好的目录。而且，他还能在多个可写的branch/dir间进行负载均衡。</p>
<p>上面的例子，我们已经看到AUFS的mount的示例了。下面我们来看一看被union的目录（分支）的相关权限：</p>
<ul>
<li>rw表示可写可读read-write。<br />
</li>
<li>ro表示read-only，如果你不指权限，那么除了第一个外ro是默认值，对于ro分支，其永远不会收到写操作，也不会收到查找whiteout的操作。<br />
</li>
<li>rr表示real-read-only，与read-only不同的是，rr标记的是天生就是只读的分支，这样，AUFS可以提高性能，比如不再设置inotify来检查文件变动通知。</li>
</ul>
<p>权限中，我们看到了一个术语：whiteout，下面我来解释一下这个术语。</p>
<p>一般来说ro的分支都会有wh的属性，比如
“[dir]=ro+wh”。所谓whiteout的意思，如果在union中删除的某个文件，实际上是位于一个readonly的分支（目录）上，那么，在mount的union这个目录中你将看不到这个文件，但是read-only这个层上我们无法做任何的修改，所以，我们就需要对这个readonly目录里的文件作whiteout。AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。</p>
<p>看个例子：</p>
<p>假设我们有三个目录和文件如下所示（test是个空目录）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tree</span><br><span class="line">.</span><br><span class="line">├── fruits</span><br><span class="line">│   ├── apple</span><br><span class="line">│   └── tomato</span><br><span class="line">├── test</span><br><span class="line">└── vegetables</span><br><span class="line">    ├── carrots</span><br><span class="line">    └── tomato</span><br></pre></td></tr></table></figure> 我们如下mount：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mkdir mnt</span><br><span class="line"></span><br><span class="line"># mount -t aufs -o dirs=./test=rw:./fruits=ro:./vegetables=ro none ./mnt</span><br><span class="line"></span><br><span class="line"># # ls ./mnt/</span><br><span class="line">apple  carrots  tomato</span><br></pre></td></tr></table></figure>
现在我们在权限为rw的test目录下建个whiteout的隐藏文件.wh.apple，你就会发现./mnt/apple这个文件就消失了:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # touch ./test/.wh.apple</span><br><span class="line"></span><br><span class="line"># ls ./mnt</span><br><span class="line">carrots  tomato</span><br></pre></td></tr></table></figure> 上面这个操作和 rm ./mnt/apple是一样的。</p>
<h5 id="相关术语">相关术语</h5>
<p><strong>Branch</strong> –
就是各个要被union起来的目录（就是我在上面使用的dirs的命令行参数）</p>
<ul>
<li>Branch根据被union的顺序形成一个stack，一般来说最上面的是可写的，下面的都是只读的。<br />
</li>
<li>Branch的stack可以在被mount后进行修改，比如：修改顺序，加入新的branch，或是删除其中的branch，或是直接修改branch的权限</li>
</ul>
<p><strong>Whiteout</strong> 和 <strong>Opaque</strong></p>
<ul>
<li><p>如果UnionFS中的某个目录被删除了，那么就应该不可见了，就算是在底层的branch中还有这个目录，那也应该不可见了。</p></li>
<li><p>Whiteout就是某个上层目录覆盖了下层的相同名字的目录。用于隐藏低层分支的文件，也用于阻止readdir进入低层分支。</p></li>
<li><p>Opaque的意思就是不允许任何下层的某个目录显示出来。</p></li>
<li><p>在隐藏低层档的情况下，whiteout的名字是’.wh.&lt;filename&gt;’。</p></li>
<li><p>在阻止readdir的情况下，名字是’.wh..wh..opq’或者
’.wh.__dir_opaque’。</p></li>
</ul>
<h5 id="相关问题">相关问题</h5>
<p>看到上面这些，你一定会有几个问题：</p>
<p><strong>其一、你可能会问，要有文件在原来的地方被修改了会怎么样？</strong>mount的目录会一起改变吗？答案是会的，也可以是不会的。因为你可以指定一个叫udba的参数（全称：User’s
Direct Branch Access），这个参数有三个取值：</p>
<ul>
<li><strong>udba=none</strong> –
设置上这个参数后，AUFS会运转的更快，因为那些不在mount目录里发生的修改，aufs不会同步过来了，所以会有数据出错的问题。<br />
</li>
<li><strong>udba=reval</strong> –
设置上这个参数后，AUFS会去查文件有没有被更新，如果有的话，就会把修改拉到mount目录内。<br />
</li>
<li><strong>udba=notify</strong> –
这个参数会让AUFS为所有的branch注册inotify，这样可以让AUFS在更新文件修改的性能更高一些。</li>
</ul>
<p><strong>其二、如果有多个rw的branch（目录）被union起来了，那么，当我创建文件的时候，aufs会创建在哪里呢？</strong> aufs提供了一个叫create的参数可以供你来配置相当的创建策略，下面有几个例子。</p>
<p><strong>create=rr |
round−robin</strong> 轮询。下面的示例可以看到，新创建的文件轮流写到三个目录中<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen$ sudo mount -t aufs  -o dirs=./1=rw:./2=rw:./3=rw -o create=rr none ./mnt</span><br><span class="line">hchen$ touch ./mnt/a ./mnt/b ./mnt/c</span><br><span class="line">hchen$ tree</span><br><span class="line">.</span><br><span class="line">├── 1</span><br><span class="line">│   └── a</span><br><span class="line">├── 2</span><br><span class="line">│   └── c</span><br><span class="line">└── 3</span><br><span class="line">    └── b</span><br></pre></td></tr></table></figure> <strong>create=mfs[:second] |
most−free−space[:second]</strong> 选一个可用空间最好的分支。可以指定一个检查可用磁盘空间的时间。</p>
<p><strong>create=mfsrr:low[:second]</strong> 选一个空间大于low的branch，如果空间小于low了，那么aufs会使用
round-robin 方式。</p>
<p>更多的关于AUFS的细节使用参数，大家可以直接在Ubuntu 14.04下通过 <a
href="http://aufs.sourceforge.net/aufs3/man.html">man
aufs</a> 来看一下其中的各种参数和命令。</p>
<h4 id="aufs的性能">AUFS的性能</h4>
<p>AUFS的性能慢吗？也慢也不慢。因为AUFS会把所有的分支mount起来，所以，在查找文件上是比较慢了。因为它要遍历所有的branch。是个O(n)的算法（很明显，这个算法有很大的改进空间的）所以，branch越多，查找文件的性能也就越慢。但是，一旦AUFS找到了这个文件的inode，那后以后的读写和操作原文件基本上是一样的。</p>
<p>所以，如果你的程序跑在在AUFS下，open和stat操作会有明显的性能下降，branch越多，性能越差，但是在write/read操作上，性能没有什么变化。</p>
<p>IBM的研究中心对Docker的性能给了一份非常不错的性能报告（PDF）《<a
href="http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/$File/rc25482.pdf">An
Updated Performance Comparison of Virtual Machinesand Linux
Containers</a>》</p>
<p>我截了两张图出来，第一张是顺序读写，第二张是随机读写。基本没有什么性能损失的问题。而KVM在随机读写的情况也就有点慢了（但是，如果硬盘是SSD的呢？）</p>
<p><a
href="https://coolshell.cn/wp-content/uploads/2015/08/docker.seq_.jpg"><img
src="https://coolshell.cn/wp-content/uploads/2015/08/docker.seq_.jpg" /></a></p>
<p><strong>顺序读写</strong></p>
<p><a
href="https://coolshell.cn/wp-content/uploads/2015/08/docker.rand_.jpg"><img
src="https://coolshell.cn/wp-content/uploads/2015/08/docker.rand_.jpg" /></a></p>
<p><strong>随机读写</strong></p>
<h4 id="延伸阅读">延伸阅读</h4>
<ul>
<li><a href="http://www.linuxjournal.com/article/7714">Introduce
UnionFS</a><br />
</li>
<li><a href="http://lwn.net/Articles/325369/">Union file systems:
Implementations, part I</a><br />
</li>
<li><a href="http://lwn.net/Articles/327738/">Union file systems:
Implementations, part 2</a><br />
</li>
<li><a href="http://lwn.net/Articles/403012/">Another union filesystem
approach</a><br />
</li>
<li><a href="http://lwn.net/Articles/324291/">Unioning file systems:
Architecture, features, and design choices</a></li>
</ul>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础-CGROUP</title>
    <url>/blog/2023/10/11/data/linux/docker/Docker%E5%9F%BA%E7%A1%80-CGROUP/</url>
    <content><![CDATA[<p>前面，我们介绍了<a href="https://coolshell.cn/articles/17010.html"
title="Docker基础技术：Linux Namespace">Linux
Namespace</a>，但是Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux
CGroup出来了的原因。</p>
<p>Linux CGroup全称Linux Control Group，
是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul
Menage和Rohit Seth），最早的名称为进程容器（process
containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。</p>
<p>Linux CGroupCgroup
可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU
时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​
cgroup，拒​​​绝​​​ cgroup 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​
cgroup。</p>
<p>主要提供了如下功能：</p>
<ul>
<li><strong>Resource limitation</strong>:
限制资源使用，比如内存使用上限以及文件系统的缓存限制。<br />
</li>
<li><strong>Prioritization</strong>:
优先级控制，比如：CPU利用和磁盘IO吞吐。<br />
</li>
<li><strong>Accounting</strong>:
一些审计或一些统计，主要目的是为了计费。<br />
</li>
<li><strong>Control</strong>: 挂起进程，恢复执行进程。</li>
</ul>
<p>使​​​用​​​
cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。</p>
<p>在实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：</p>
<ul>
<li>隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。<br />
</li>
<li>为这组进程 分配其足够使用的内存<br />
</li>
<li>为这组进程分配相应的网络带宽和磁盘存储限制<br />
</li>
<li>限制访问某些设备（通过设置设备的白名单）</li>
</ul>
<p>那么CGroup是怎么干的呢？我们先来点感性认识吧。</p>
<p>首先，Linux把CGroup这个事实现成了一个file
system，你可以mount。在我的Ubuntu
14.04下，你输入以下命令你就可以看到cgroup已为你mount好了。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)</span><br></pre></td></tr></table></figure> 或者使用lssubsys命令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lssubsys  -m</span><br><span class="line">cpuset /sys/fs/cgroup/cpuset</span><br><span class="line">cpu /sys/fs/cgroup/cpu</span><br><span class="line">cpuacct /sys/fs/cgroup/cpuacct</span><br><span class="line">memory /sys/fs/cgroup/memory</span><br><span class="line">devices /sys/fs/cgroup/devices</span><br><span class="line">freezer /sys/fs/cgroup/freezer</span><br><span class="line">blkio /sys/fs/cgroup/blkio</span><br><span class="line">net_cls /sys/fs/cgroup/net_cls</span><br><span class="line">net_prio /sys/fs/cgroup/net_prio</span><br><span class="line">perf_event /sys/fs/cgroup/perf_event</span><br><span class="line">hugetlb /sys/fs/cgroup/hugetlb</span><br></pre></td></tr></table></figure>
我们可以看到，在/sys/fs下有一个cgroup的目录，这个目录下还有很多子目录，比如：
cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。</p>
<p>如果你没有看到上述的目录，你可以自己mount，下面给了一个示例：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir cgroup</span><br><span class="line">mount -t tmpfs cgroup_root ./cgroup</span><br><span class="line">mkdir cgroup/cpuset</span><br><span class="line">mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/</span><br><span class="line">mkdir cgroup/cpu</span><br><span class="line">mount -t cgroup -ocpu cpu ./cgroup/cpu/</span><br><span class="line">mkdir cgroup/memory</span><br><span class="line">mount -t cgroup -omemory memory ./cgroup/memory/</span><br></pre></td></tr></table></figure>
一旦mount成功，你就会看到这些目录下就有好文件了，比如，如下所示的cpu和cpuset的子系统：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/ </span><br><span class="line">/sys/fs/cgroup/cpu:</span><br><span class="line">cgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent</span><br><span class="line">cgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks</span><br><span class="line">cgroup.procs           cpu.cfs_quota_us      notify_on_release  user</span><br><span class="line"></span><br><span class="line">/sys/fs/cgroup/cpuset/:</span><br><span class="line">cgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance</span><br><span class="line">cgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level</span><br><span class="line">cgroup.procs           cpuset.memory_pressure          notify_on_release</span><br><span class="line">cgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent</span><br><span class="line">cpuset.cpu_exclusive   cpuset.memory_spread_page       tasks</span><br><span class="line">cpuset.cpus            cpuset.memory_spread_slab       user</span><br><span class="line">cpuset.mem_exclusive   cpuset.mems</span><br></pre></td></tr></table></figure>
你可以到/sys/fs/cgroup的各个子目录下去make个dir，你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel</span><br><span class="line">[sudo] password for hchen: </span><br><span class="line">hchen@ubuntu:/sys/fs/cgroup/cpu$ ls ./haoel</span><br><span class="line">cgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks</span><br><span class="line">cgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release</span><br></pre></td></tr></table></figure></p>
<p>好了，我们来看几个示例。</p>
<p>目录</p>
<ul>
<li><a
href="https://coolshell.cn/articles/17049.html#CPU_%E9%99%90%E5%88%B6"
title="CPU 限制">CPU 限制</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6"
title="内存使用限制">内存使用限制</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#%E7%A3%81%E7%9B%98IO%E9%99%90%E5%88%B6"
title="磁盘I/O限制">磁盘I/O限制</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#CGroup%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F"
title="CGroup的子系统">CGroup的子系统</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#CGroup%E7%9A%84%E6%9C%AF%E8%AF%AD"
title="CGroup的术语">CGroup的术语</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84CGroup"
title="下一代的CGroup">下一代的CGroup</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17049.html#%E5%8F%82%E8%80%83"
title="参考">参考</a></li>
</ul>
<h4 id="cpu-限制">CPU 限制</h4>
<p>假设，我们有一个非常吃CPU的程序，叫deadloop，其源码如下：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;) i++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
用sudo执行起来后，毫无疑问，CPU被干到了100%（下面是top命令的输出）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     </span><br><span class="line">3529 root      20   0    4196    736    656 R 99.6  0.1   0:23.13 deadloop</span><br></pre></td></tr></table></figure>
然后，我们这前不是在/sys/fs/cgroup/cpu下创建了一个haoel的group。我们先设置一下这个group的cpu利用的限制：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~# cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us </span><br><span class="line">-1</span><br><span class="line">root@ubuntu:~# echo 20000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>
我们看到，这个进程的PID是3529，我们把这个进程加到这个cgroup中：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo 3529 &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks</span><br></pre></td></tr></table></figure>
然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     </span><br><span class="line">3529 root      20   0    4196    736    656 R 19.9  0.1   8:06.11 deadloop</span><br></pre></td></tr></table></figure> 下面的代码是一个线程的示例：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_main</span><span class="params">(<span class="type">void</span> *threadid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 把自己加入cgroup中（syscall(SYS_gettid)为得到线程的系统tid） */</span></span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo %ld &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks&quot;</span>, syscall(SYS_gettid));</span><br><span class="line">    system(cmd); </span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo %ld &gt;&gt; /sys/fs/cgroup/cpuset/haoel/tasks&quot;</span>, syscall(SYS_gettid));</span><br><span class="line">    system(cmd);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> tid;</span><br><span class="line">    tid = (<span class="type">long</span>)threadid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World! It&#x27;s me, thread #%ld, pid #%ld!\n&quot;</span>, tid, syscall(SYS_gettid));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num_threads;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        num_threads = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num_threads&lt;=<span class="number">0</span> || num_threads&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">        num_threads = NUM_THREADS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置CPU利用率为50% */</span></span><br><span class="line">    mkdir(<span class="string">&quot;/sys/fs/cgroup/cpu/haoel&quot;</span>, <span class="number">755</span>);</span><br><span class="line">    system(<span class="string">&quot;echo 50000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mkdir(<span class="string">&quot;/sys/fs/cgroup/cpuset/haoel&quot;</span>, <span class="number">755</span>);</span><br><span class="line">    <span class="comment">/* 限制CPU只能使用#2核和#3核 */</span></span><br><span class="line">    system(<span class="string">&quot;echo \&quot;2,3\&quot; &gt; /sys/fs/cgroup/cpuset/haoel/cpuset.cpus&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span>* threads = (<span class="type">pthread_t</span>*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*num_threads);</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">long</span> t;</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;num_threads; t++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In main: creating thread %ld\n&quot;</span>, t);</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, thread_main, (<span class="type">void</span> *)t);</span><br><span class="line">        <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR; return code from pthread_create() is %d\n&quot;</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last thing that main() should do */</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">free</span>(threads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="内存使用限制">内存使用限制</h4>
<p>我们再来看一个限制内存的例子（下面的代码是个死循环，其它不断的分配内存，每次512个字节，每次休息一秒）：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chunk_size = <span class="number">512</span>;</span><br><span class="line">    <span class="type">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(p, chunk_size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;out of memory!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">1</span>, chunk_size);</span><br><span class="line">        size += chunk_size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] - memory is allocated [%8d] bytes \n&quot;</span>, getpid(), size);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后，在我们另外一边：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建memory cgroup</span><br><span class="line">$ mkdir /sys/fs/cgroup/memory/haoel</span><br><span class="line">$ echo 64k &gt; /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes</span><br><span class="line"></span><br><span class="line"># 把上面的进程的pid加入这个cgroup</span><br><span class="line">$ echo [pid] &gt; /sys/fs/cgroup/memory/haoel/tasks</span><br></pre></td></tr></table></figure> 你会看到，一会上面的进程就会因为内存问题被kill掉了。</p>
<h4 id="磁盘io限制">磁盘I/O限制</h4>
<p>我们先看一下我们的硬盘IO，我们的模拟命令如下：（从/dev/sda1上读入数据，输出到/dev/null上）</p>
<p>sudo dd if=/dev/sda1 of=/dev/null</p>
<p>我们通过iotop命令我们可以看到相关的IO速度是55MB/s（虚拟机内）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          </span><br><span class="line">8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd if=/de~=/dev/null...</span><br></pre></td></tr></table></figure> 然后，我们先创建一个blkio（块设备IO）的cgroup<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/blkio/haoel</span><br></pre></td></tr></table></figure>
并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0
是设备号，你可以通过ls -l /dev/sda1获得）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# echo &#x27;8:0 1048576&#x27;  &gt; /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device </span><br><span class="line">root@ubuntu:~# echo 8128 &gt; /sys/fs/cgroup/blkio/haoel/tasks</span><br></pre></td></tr></table></figure></p>
<p>再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          </span><br><span class="line">8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd if=/de~=/dev/null...</span><br></pre></td></tr></table></figure></p>
<h4 id="cgroup的子系统">CGroup的子系统</h4>
<p>好了，有了以上的感性认识我们来，我们来看看control
group有哪些子系统：</p>
<ul>
<li>blkio —
这​​​个​​​子​​​系​​​统​​​为​​​块​​​设​​​备​​​设​​​定​​​输​​​入​​​/输​​​出​​​限​​​制​​​，比​​​如​​​物​​​理​​​设​​​备​​​（磁​​​盘​​​，固​​​态​​​硬​​​盘​​​，USB
等​​​等​​​）。<br />
</li>
<li>cpu — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​调​​​度​​​程​​​序​​​提​​​供​​​对​​​ CPU 的​​​ cgroup 任​​​务​​​访​​​问​​​。​​​<br />
</li>
<li>cpuacct — 这​​​个​​​子​​​系​​​统​​​自​​​动​​​生​​​成​​​ cgroup 中​​​任​​​务​​​所​​​使​​​用​​​的​​​ CPU 报​​​告​​​。​​​<br />
</li>
<li>cpuset — 这​​​个​​​子​​​系​​​统​​​为​​​ cgroup 中​​​的​​​任​​​务​​​分​​​配​​​独​​​立​​​
CPU（在​​​多​​​核​​​系​​​统​​​）和​​​内​​​存​​​节​​​点​​​。​​​<br />
</li>
<li>devices — 这​​​个​​​子​​​系​​​统​​​可​​​允​​​许​​​或​​​者​​​拒​​​绝​​​ cgroup 中​​​的​​​任​​​务​​​访​​​问​​​设​​​备​​​。​​​<br />
</li>
<li>freezer — 这​​​个​​​子​​​系​​​统​​​挂​​​起​​​或​​​者​​​恢​​​复​​​ cgroup 中​​​的​​​任​​​务​​​。​​​<br />
</li>
<li>memory — 这​​​个​​​子​​​系​​​统​​​设​​​定​​​ cgroup
中​​​任​​​务​​​使​​​用​​​的​​​内​​​存​​​限​​​制​​​，并​​​自​​​动​​​生​​​成​​​​​内​​​存​​​资​​​源使用​​​报​​​告​​​。​​​<br />
</li>
<li>net_cls — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​等​​​级​​​识​​​别​​​符​​​（classid）标​​​记​​​网​​​络​​​数​​​据​​​包​​​，可​​​允​​​许​​​
Linux 流​​​量​​​控​​​制​​​程​​​序​​​（tc）识​​​别​​​从​​​具​​​体​​​ cgroup 中​​​生​​​成​​​的​​​数​​​据​​​包​​​。​​​<br />
</li>
<li>net_prio — 这个子系统用来设计网络流量的优先级<br />
</li>
<li>hugetlb —
这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。</li>
</ul>
<p>​​​</p>
<p>注意，你可能在Ubuntu
14.04下看不到net_cls和net_prio这两个cgroup，你需要手动mount一下： 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo modprobe cls_cgroup</span><br><span class="line">$ sudo mkdir /sys/fs/cgroup/net_cls</span><br><span class="line">$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls</span><br><span class="line"></span><br><span class="line">$ sudo modprobe netprio_cgroup</span><br><span class="line">$ sudo mkdir /sys/fs/cgroup/net_prio</span><br><span class="line">$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio</span><br></pre></td></tr></table></figure> 关于各个子系统的参数细节，以及更多的Linux
CGroup的文档，你可以看看下面的文档：</p>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/">Linux
Kernel的官方文档</a><br />
</li>
<li><a
href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html#ch-Subsystems_and_Tunable_Parameters">Redhat的官方文档</a></li>
</ul>
<h4 id="cgroup的术语">CGroup的术语</h4>
<p>CGroup有下述术语：</p>
<ul>
<li><strong>任务（Tasks）</strong>：就是系统的一个进程。<br />
</li>
<li><strong>控制组（Control
Group）</strong>：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。<br />
</li>
<li><strong>层级（Hierarchy）</strong>：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。<br />
</li>
<li><strong>子系统（Subsystem）</strong>：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。</li>
</ul>
<h4 id="下一代的cgroup">下一代的CGroup</h4>
<p>上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。</p>
<p>不过，对此，有个叫Tejun Heo的同学非常不爽，他在Linux社区里<a
href="https://lwn.net/Articles/484254/">对cgroup吐了一把槽</a>，还引发了内核组的各种讨论。</p>
<p>对于Tejun
Heo同学来说，cgroup设计的相当糟糕。他给出了些例子，大意就是说，如果有多种层级关系，也就是说有多种对进程的分类方式，比如，我们可以按用户来分，分成Professor和Student，同时，也有按应用类似来分的，比如WWW和NFS等。那么，当一个进程即是Professor的，也是WWW的，那么就会出现多层级正交的情况，从而出现对进程上管理的混乱。另外，一个case是，如果有一个层级A绑定cpu，而层级B绑定memory，还有一个层级C绑定cputset，而有一些进程有的需要AB，有的需要AC，有的需要ABC，管理起来就相当不易。</p>
<p>层级操作起来比较麻烦，而且如果层级变多，更不易于操作和管理，虽然那种方式很好实现，但是在使用上有很多的复杂度。你可以想像一个图书馆的图书分类问题，你可以有各种不同的分类，分类和图书就是一种多对多的关系。</p>
<p>所以，在Kernel 3.16后，引入了<a
href="http://lwn.net/Articles/601840/">unified
hierarchy</a>的新的设计，这个东西引入了一个叫**__DEVEL__sane_behavior**的特性（这个名字很明显意味目前还在开发试验阶段），它可以把所有子系统都挂载到根层级下，只有叶子节点可以存在tasks，非叶子节点只进行资源控制。</p>
<p>我们mount一下看看：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mount -t cgroup -o __DEVEL__sane_behavior cgroup ./cgroup</span><br><span class="line"></span><br><span class="line">$ ls ./cgroup</span><br><span class="line">cgroup.controllers  cgroup.procs  cgroup.sane_behavior  cgroup.subtree_control </span><br><span class="line"></span><br><span class="line">$ cat ./cgroup/cgroup.controllers</span><br><span class="line">cpuset cpu cpuacct memory devices freezer net_cls blkio perf_event net_prio hugetlb</span><br></pre></td></tr></table></figure>
我们可以看到有四个文件，然后，你在这里mkdir一个子目录，里面也会有这四个文件。<strong>上级的cgroup.subtree_control控制下级的cgroup.controllers。</strong></p>
<p>举个例子：假设我们有以下的目录结构，b代表blkio，m代码memory，其中，A是root，包括所有的子系统（）。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># A(b,m) - B(b,m) - C (b)</span><br><span class="line">#               \ - D (b) - E</span><br><span class="line"></span><br><span class="line"># 下面的命令中， +表示enable， -表示disable</span><br><span class="line"></span><br><span class="line"># 在B上的enable blkio</span><br><span class="line"># echo +blkio &gt; A/cgroup.subtree_control</span><br><span class="line"></span><br><span class="line"># 在C和D上enable blkio </span><br><span class="line"># echo +blkio &gt; A/B/cgroup.subtree_control</span><br><span class="line"></span><br><span class="line"># 在B上enable memory  </span><br><span class="line"># echo +memory &gt; A/cgroup.subtree_control</span><br></pre></td></tr></table></figure> 在上述的结构中，</p>
<ul>
<li>cgroup只有上线控制下级，无法传递到下下级。所以，C和D中没有memory的限制，E中没有blkio和memory的限制。而本层的cgroup.controllers文件是个只读的，其中的内容就看上级的subtree_control里有什么了。<br />
</li>
<li><strong>任何被配置过subtree_control的目录都不能绑定进程，根结点除外</strong>。所以，A,C,D,E可以绑上进程，但是B不行。</li>
</ul>
<p>我们可以看到，<strong>这种方式干净的区分开了两个事，一个是进程的分组，一个是对分组的资源控制</strong>（以前这两个事完全混在一起），在目录继承上增加了些限制，这样可以避免一些模棱两可的情况。</p>
<p>当然，这个事还在演化中，cgroup的这些问题这个事目前由cgroup的吐槽人Tejun
Heo和华为的Li
Zefan同学负责解决中。总之，这是一个系统管理上的问题，而且改变会影响很多东西，但一旦方案确定，老的cgroup方式将一去不复返。</p>
<h4 id="参考">参考</h4>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/">Linux
Kernel Cgroup Documents</a><br />
</li>
<li><a
href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html">Reahat
Resource Management Guide</a><br />
</li>
<li><a href="https://lwn.net/Articles/484251/">Fixing control
groups</a><br />
</li>
<li><a href="http://lwn.net/Articles/601840/">The unified control group
hierarchy in 3.16</a><br />
</li>
<li><a
href="http://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf">Cgroup
v2(PDF)</a></li>
</ul>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础-DEVICEMAPPER</title>
    <url>/blog/2023/10/11/data/linux/docker/Docker%E5%9F%BA%E7%A1%80-DEVICEMAPPER/</url>
    <content><![CDATA[<p>在上一篇<a
href="https://coolshell.cn/articles/17061.html">介绍AUFS的文章</a>中，大家可以看到，Docker的分层镜像是怎么通过UnionFS这种文件系统做到的，但是，因为Docker首选的AUFS并不在Linux的内核主干里，所以，对于非Ubuntu的Linux分发包，比如CentOS，就无法使用AUFS作为Docker的文件系统了。于是作为第二优先级的DeviceMapper就被拿出来做分层镜像的一个实现。</p>
<p>目录</p>
<ul>
<li><a
href="https://coolshell.cn/articles/17200.html#Device_Mapper_%E7%AE%80%E4%BB%8B"
title="Device Mapper 简介">Device Mapper 简介</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17200.html#Thin_Provisioning_%E7%AE%80%E4%BB%8B"
title="Thin Provisioning 简介">Thin Provisioning 简介</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17200.html#Thin_Provisioning_Snapshot_%E6%BC%94%E7%A4%BA"
title="Thin Provisioning Snapshot 演示">Thin Provisioning Snapshot
演示</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17200.html#Docker%E7%9A%84DeviceMapper"
title="Docker的DeviceMapper">Docker的DeviceMapper</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17200.html#Device_Mapper_%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F"
title="Device Mapper 行不行？">Device Mapper 行不行？</a></li>
</ul>
<h4 id="device-mapper-简介">Device Mapper 简介</h4>
<p>DeviceMapper自Linux
2.6被引入成为了Linux最重要的一个技术。它在内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包含三个重要的对象概念，Mapped
Device、Mapping Table、Target device。</p>
<p>Mapped Device
是一个逻辑抽象，可以理解成为内核向外提供的逻辑设备，它通过Mapping
Table描述的映射关系和 Target Device 建立映射。Target device 表示的是
Mapped Device 所映射的物理空间段，对 Mapped Device
所表示的逻辑设备来说，就是该逻辑设备映射到的一个物理设备。</p>
<p>Mapping Table里有 Mapped Device 逻辑的起始地址、范围、和表示在 Target
Device 所在物理设备的地址偏移量以及Target
类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512
个字节大小，所以，当你看到128的时候，其实表示的是128*512=64K）。</p>
<p>DeviceMapper 中的逻辑设备Mapped
Device不但可以映射一个或多个物理设备Target
Device，还可以映射另一个Mapped
Device，于是，就是构成了一个迭代或递归的情况，就像文件系统中的目录里除了文件还可以有目录，理论上可以无限嵌套下去。</p>
<p>DeviceMapper在内核中通过一个一个模块化的 Target Driver 插件实现对 IO
请求的过滤或者重新定向等工作，当前已经实现的插件包括软
Raid、加密、多路径、镜像、快照等，这体现了在 Linux
内核设计中策略和机制分离的原则。如下图所示。从图中，我们可以<strong>看到DeviceMapper只是一个框架，在这个框架上，我们可以插入各种各样的策略</strong>（让我不自然地想到了面向对象中的策略模式），在这诸多“插件”中，<strong>有一个东西叫Thin
Provisioning
Snapshot，这是Docker使用DeviceMapper中最重要的模块</strong>。</p>
<figure>
<img
src="https://coolshell.cn/wp-content/uploads/2015/08/device.mapper.2.gif"
alt="图片来源：http://people.redhat.com/agk/talks/FOSDEM_2005/" />
<figcaption
aria-hidden="true">图片来源：http://people.redhat.com/agk/talks/FOSDEM_2005/</figcaption>
</figure>
<p>图片来源：<a
href="http://people.redhat.com/agk/talks/FOSDEM_2005/">http://people.redhat.com/agk/talks/FOSDEM_2005/</a></p>
<h4 id="thin-provisioning-简介"><strong>Thin Provisioning
简介</strong></h4>
<p>Thin
Provisioning要怎么翻译成中文，真是一件令人头痛的事，我就不翻译了。这个技术是虚拟化技术中的一种。它是什么意思呢？<strong>你可以联想一下我们计算机中的内存管理中用到的——“虚拟内存技术”</strong>——操作系统给每个进程N多N多用不完的内址地址（32位下，每个进程可以有最多2GB的内存空间），但是呢，我们知道，物理内存是没有那么多的，如果按照进程内存和物理内存一一映射来玩的话，那么，我们得要多少的物理内存啊。所以，操作系统引入了虚拟内存的设计，<strong>意思是，我逻辑上给你无限多的内存，但是实际上是实报实销</strong>，因为我知道你一定用不了那么多，于是，达到了内存使用率提高的效果。（今天云计算中很多所谓的虚拟化其实完全都是在用和“虚拟内存”相似的Thin
Provisioning的技术，所谓的超配，或是超卖）</p>
<p>好了，话题拉回来，我们这里说的是存储。看下面两个图（<a
href="http://www.architecting.it/2009/06/04/enterprise-computing-why-thin-provisioning-is-not-the-holy-grail-for-utilisation/">图片来源</a>），第一个是Fat
Provisioning，第二个是Thin
Provisioning，其很好的说明了是个怎么一回事（和虚拟内存是一个概念）</p>
<p><img
src="https://coolshell.cn/wp-content/uploads/2015/08/thin-provisioning-1.jpg"
alt="thin-provisioning-1" /><img
src="https://coolshell.cn/wp-content/uploads/2015/08/thin-provisioning-2.jpg"
alt="thin-provisioning-2" /></p>
<p>那么，Docker是怎么使用Thin
Provisioning这个技术做到像UnionFS那样的分层镜像的呢？答案是，Docker使用了Thin
Provisioning的Snapshot的技术。下面我们来介绍一下Thin
Provisioning的Snapshot。</p>
<h4 id="thin-provisioning-snapshot-演示">Thin Provisioning Snapshot
演示</h4>
<p>下面，我们用一系列的命令来演示一下Device Mapper的Thin Provisioning
Snapshot是怎么玩的。</p>
<p>首先，我们需要先建两个文件，一个是data.img，一个是meta.data.img：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dd if=/dev/zero of=/tmp/data.img bs=1K count=1 seek=10M</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">1024 bytes (1.0 kB) copied, 0.000621428 s, 1.6 MB/s</span><br><span class="line"></span><br><span class="line">~hchen$ sudo dd if=/dev/zero of=/tmp/meta.data.img bs=1K count=1 seek=1G</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">1024 bytes (1.0 kB) copied, 0.000140858 s, 7.3 MB/s</span><br></pre></td></tr></table></figure>
注意命令中<code>seek</code>选项，其表示为略过<code>of</code>选项指定的输出文件的前10G个output的bloksize的空间后再写入内容。因为bs是1个字节，所以也就是10G的尺寸，但其实在硬盘上是没有占有空间的，占有空间只有1k的内容。当向其写入内容时，才会在硬盘上为其分配空间。我们可以用ls命令看一下，实际分配了12K和4K。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo ls -lsh /tmp/data.img</span><br><span class="line">12K -rw-r--r--. 1 root root 11G Aug 25 23:01 /tmp/data.img</span><br><span class="line"></span><br><span class="line">~hchen$ sudo ls -slh /tmp/meta.data.img</span><br><span class="line">4.0K -rw-r--r--. 1 root root 101M Aug 25 23:17 /tmp/meta.data.img</span><br></pre></td></tr></table></figure>
然后，我们为这个文件创建一个loopback设备。（loop2015和loop2016是我乱取的两个名字）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo losetup /dev/loop2015 /tmp/data.img</span><br><span class="line">~hchen$ sudo losetup /dev/loop2016 /tmp/meta.data.img</span><br><span class="line"></span><br><span class="line">~hchen$ sudo losetup -a</span><br><span class="line">/dev/loop2015: [64768]:103991768 (/tmp/data.img)</span><br><span class="line">/dev/loop2016: [64768]:103991765 (/tmp/meta.data.img)</span><br></pre></td></tr></table></figure> 现在，我们为这个设备建一个Thin
Provisioning的Pool，用dmsetup命令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup create hchen-thin-pool \</span><br><span class="line">                  --table &quot;0 20971522 thin-pool /dev/loop2016 /dev/loop2015 \</span><br><span class="line">                           128 65536 1 skip_block_zeroing&quot;</span><br></pre></td></tr></table></figure> 其中的参数解释如下（更多信息可参看<a
href="https://github.com/torvalds/linux/blob/master/Documentation/device-mapper/thin-provisioning.txt">Thin
Provisioning的man page</a>）：</p>
<ul>
<li>dmsetup create是用来创建thin pool的命令<br />
</li>
<li>hchen-thin-pool 是自定义的一个pool名，不冲突就好。<br />
</li>
<li>–table是这个pool的参数设置
<ul>
<li>0代表起的sector位置<br />
</li>
<li>20971522代码结句的sector号，前面说过，一个sector是512字节，所以，20971522个正好是10GB<br />
</li>
<li>/dev/loop2016是meta文件的设备（前面我们建好了）<br />
</li>
<li>/dev/loop2015是data文件的设备（前面我们建好了）<br />
</li>
<li>128是最小的可分配的sector数<br />
</li>
<li>65536是最少可用sector的water mark，也就是一个threshold<br />
</li>
<li>1 代表有一个附加参数<br />
</li>
<li>skip_block_zeroing是个附加参数，表示略过用0填充的块</li>
</ul></li>
</ul>
<p>然后，我们就可以看到一个Device Mapper的设备了：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo ll /dev/mapper/hchen-thin-pool</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 23:24 /dev/mapper/hchen-thin-pool -&gt; ../dm-4</span><br></pre></td></tr></table></figure> 接下来，我们的初始还没有完成，还要创建一个Thin
Provisioning 的 Volume：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_thin 0&quot;</span><br><span class="line">~hchen$ sudo dmsetup create hchen-thin-volumn-001 \</span><br><span class="line">            --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 0&quot;</span><br></pre></td></tr></table></figure> 其中：</p>
<ul>
<li>第一个命令中的create_thin是关键字，后面的0表示这个Volume的device 的
id<br />
</li>
<li>第二个命令，是真正的为这个Volumn创建一个可以mount的设备，名字叫hchen-thin-volumn-001。2097152只有1GB</li>
</ul>
<p>好了，在mount前，我们还要格式化一下：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo mkfs.ext4 /dev/mapper/hchen-thin-volumn-001</span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Discarding device blocks: done</span><br><span class="line">Filesystem label=</span><br><span class="line">OS type: Linux</span><br><span class="line">Block size=4096 (log=2)</span><br><span class="line">Fragment size=4096 (log=2)</span><br><span class="line">Stride=16 blocks, Stripe width=16 blocks</span><br><span class="line">65536 inodes, 262144 blocks</span><br><span class="line">13107 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=268435456</span><br><span class="line">8 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">32768, 98304, 163840, 229376</span><br><span class="line"></span><br><span class="line">Allocating group tables: done</span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (8192 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br></pre></td></tr></table></figure>
好了，我们可以mount了（下面的命令中，我还创建了一个文件）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo mkdir -p /mnt/base</span><br><span class="line">~hchen$ sudo mount /dev/mapper/hchen-thin-volumn-001 /mnt/base</span><br><span class="line">~hchen$ sudo echo &quot;hello world, I am a base&quot; &gt; /mnt/base/id.txt</span><br><span class="line">~hchen$ sudo cat /mnt/base/id.txt</span><br><span class="line">hello world, I am a base</span><br></pre></td></tr></table></figure> 好了，接下来，我们来看看snapshot怎么搞：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 1 0&quot;</span><br><span class="line">~hchen$ sudo dmsetup create mysnap1 \</span><br><span class="line">                   --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 1&quot;</span><br><span class="line"></span><br><span class="line">~hchen$ sudo ll /dev/mapper/mysnap1</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 23:49 /dev/mapper/mysnap1 -&gt; ../dm-5</span><br></pre></td></tr></table></figure> 上面的命令中：</p>
<ul>
<li><p>第一条命令是向hchen-thin-pool发一个create_snap的消息，后面跟两个id，第一个是新的dev
id，第二个是要从哪个已有的dev id上做snapshot（0这个dev
id是我们前面就创建了了）</p></li>
<li><p>第二条命令是创建一个mysnap1的device，并可以被mount。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo mkdir -p /mnt/mysnap1</span><br><span class="line">~hchen$ sudo mount /dev/mapper/mysnap1 /mnt/mysnap1</span><br><span class="line"></span><br><span class="line">~hchen$ sudo ll /mnt/mysnap1/</span><br><span class="line">total 20</span><br><span class="line">-rw-r--r--. 1 root root 25 Aug 25 23:46 id.txt</span><br><span class="line">drwx------. 2 root root 16384 Aug 25 23:43 lost+found</span><br><span class="line"></span><br><span class="line">~hchen$ sudo cat /mnt/mysnap1/id.txt</span><br><span class="line">hello world, I am a base</span><br></pre></td></tr></table></figure>
我们来修改一下/mnt/mysnap1/id.txt，并加上一个snap1.txt的文件：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo echo &quot;I am snap1&quot; &gt;&gt; /mnt/mysnap1/id.txt</span><br><span class="line">~hchen$ sudo echo &quot;I am snap1&quot; &gt; /mnt/mysnap1/snap1.txt</span><br><span class="line"></span><br><span class="line">~hchen$ sudo cat /mnt/mysnap1/id.txt</span><br><span class="line">hello world, I am a base</span><br><span class="line">I am snap1</span><br><span class="line"></span><br><span class="line">~hchen$ sudo cat /mnt/mysnap1/snap1.txt</span><br><span class="line">I am snap1</span><br></pre></td></tr></table></figure> 我们再看一下/mnt/base，你会发现没有什么变化：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo ls /mnt/base</span><br><span class="line">id.txt      lost+found</span><br><span class="line">~hchen$ sudo cat /mnt/base/id.txt</span><br><span class="line">hello world, I am a base</span><br></pre></td></tr></table></figure> 你是不是已经看到了分层镜像的样子了？</p></li>
</ul>
<p>你还要吧继续在刚才的snapshot上再建一个snapshot<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 2 1&quot;</span><br><span class="line">~hchen$ sudo dmsetup create mysnap2 \</span><br><span class="line">                   --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 2&quot;</span><br><span class="line"></span><br><span class="line">~hchen$ sudo ll /dev/mapper/mysnap2</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 23:52 /dev/mapper/mysnap1 -&gt; ../dm-7</span><br><span class="line"></span><br><span class="line">~hchen$ sudo mkdir -p /mnt/mysnap2</span><br><span class="line">~hchen$ sudo mount /dev/mapper/mysnap2 /mnt/mysnap2</span><br><span class="line">~hchen$ sudo  ls /mnt/mysnap2</span><br><span class="line">id.txt  lost+found  snap1.txt</span><br></pre></td></tr></table></figure> 好了，我相信你看到了分层镜像的样子了。</p>
<p>看完演示，我们再来补点理论知识吧：</p>
<ul>
<li>Snapshot来自LVM（Logic Volumn
Manager），它可以在不中断服务的情况下为某个device打一个快照。<br />
</li>
<li>Snapshot是Copy-On-Write的，也就是说，只有发生了修改，才会对对应的内存进行拷贝。</li>
</ul>
<p>另外，这里有篇文章<a
href="http://searchstorage.techtarget.com/tip/Storage-thin-provisioning-benefits-and-challenges">Storage
thin provisioning benefits and challenges</a>可以前往一读。</p>
<h4 id="docker的devicemapper">Docker的DeviceMapper</h4>
<p>上面基本上就是Docker的玩法了，我们可以看一下docker的loopback设备：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen $ sudo losetup -a</span><br><span class="line">/dev/loop0: [64768]:38050288 (/var/lib/docker/devicemapper/devicemapper/data)</span><br><span class="line">/dev/loop1: [64768]:38050289 (/var/lib/docker/devicemapper/devicemapper/metadata)</span><br></pre></td></tr></table></figure> 其中data 100GB，metadata 2.0GB<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen $ sudo ls -alhs /var/lib/docker/devicemapper/devicemapper</span><br><span class="line">506M -rw-------. 1 root root 100G Sep 10 20:15 data</span><br><span class="line">1.1M -rw-------. 1 root root 2.0G Sep 10 20:15 metadata</span><br></pre></td></tr></table></figure>
下面是相关的thin-pool。其中，有个当一大串hash串的device是正在启动的容器：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen $ sudo ll /dev/mapper/dock*</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 07:57 /dev/mapper/docker-253:0-104108535-pool -&gt; ../dm-2</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 25 11:13 /dev/mapper/docker-253:0-104108535-deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf -&gt; ../dm-3</span><br></pre></td></tr></table></figure> 我们可以看一下它的device
id（Docker都把它们记下来了）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen $ sudo cat /var/lib/docker/devicemapper/metadata/deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf</span><br><span class="line">&#123;&quot;device_id&quot;:24,&quot;size&quot;:10737418240,&quot;transaction_id&quot;:26,&quot;initialized&quot;:false&#125;</span><br></pre></td></tr></table></figure> device_id是24，size是10737418240，除以512，就是20971520
个 sector，我们用这些信息来做个snapshot看看（注：我用了一个比较大的dev
id – 1024）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~hchen$ sudo dmsetup message &quot;/dev/mapper/docker-253:0-104108535-pool&quot; 0 \</span><br><span class="line">                                    &quot;create_snap 1024 24&quot;</span><br><span class="line">~hchen$ sudo dmsetup create dockersnap --table \</span><br><span class="line">                    &quot;0 20971520 thin /dev/mapper/docker-253:0-104108535-pool 1024&quot;</span><br><span class="line">~hchen$ sudo mkdir /mnt/docker</span><br><span class="line">~hchen$ sudo mount /dev/mapper/dockersnap /mnt/docker/</span><br><span class="line">~hchen$ sudo ls /mnt/docker/</span><br><span class="line">id lost+found rootfs</span><br><span class="line">~hchen$ sudo ls /mnt/docker/rootfs/</span><br><span class="line">bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>
我们在docker的容器里用findmnt命令也可以看到相关的mount的情况（因为太长，下面只是摘要）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># findmnt</span><br><span class="line">TARGET                SOURCE               </span><br><span class="line">/                 /dev/mapper/docker-253:0-104108535-deefcd630a60[/rootfs]</span><br><span class="line">/etc/resolv.conf  /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/resolv.conf]</span><br><span class="line">/etc/hostname     /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hostname]</span><br><span class="line">/etc/hosts        /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hosts]</span><br></pre></td></tr></table></figure></p>
<h4 id="device-mapper-行不行">Device Mapper 行不行？</h4>
<p>Thin Provisioning的文档中说，这还处理实验阶段，不要上Production.</p>
<blockquote>
<p>These targets are very much still in the EXPERIMENTAL state. Please
do not yet rely on them in production.</p>
</blockquote>
<p>另外，Jeff Atwood在Twitter上发过这样的一推</p>
<p><a
href="https://twitter.com/codinghorror/status/604096348682485760"><img
src="https://coolshell.cn/wp-content/uploads/2015/08/Jeff.Atwood.DeviceMapper.png"
alt="Jeff.Atwood.DeviceMapper" /></a></p>
<p>这个推指向的<a
href="https://forums.docker.com/t/rmi-not-freeing-disk-space-in-devicemapper-sparse-file-centos-6-6/1640/3">这个讨论</a>中，其中指向了这个<a
href="https://github.com/discourse/discourse_docker/commit/48f22d14f39496c8df446cbc65ee04b258c5a1a0">code
diff</a>，基本上就是说，DeviceMapper这种东西问题太多了，我们应该把其加入黑名单。Doker的Founder也这样回复到：</p>
<p><a
href="https://twitter.com/solomonstre/status/604055267303636992"><img
src="https://coolshell.cn/wp-content/uploads/2015/08/Solomon.Hykeys.DeviceMapper.png" /></a></p>
<p>所以，如果你在使用loopback的devicemapper的话，当你的存储出现了问题后，正确的解决方案是：</p>
<p>rm -rf /var/lib/docker</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础上</title>
    <url>/blog/2023/10/11/data/linux/docker/Docker%E5%9F%BA%E7%A1%80%E4%B8%8A/</url>
    <content><![CDATA[<p>目录</p>
<ul>
<li> <a
href="https://coolshell.cn/articles/17010.html#_%E7%AE%80%E4%BB%8B"
title="简介">简介</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17010.html#clone%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"
title="clone()系统调用">clone()系统调用</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17010.html#UTS_Namespace"
title="UTS Namespace">UTS Namespace</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17010.html#IPC_Namespace"
title="IPC Namespace">IPC Namespace</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17010.html#PID_Namespace"
title="PID Namespace">PID Namespace</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17010.html#Mount_Namespace"
title="Mount Namespace">Mount Namespace</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17010.html#Docker%E7%9A%84_Mount_Namespace"
title="Docker的 Mount Namespace">Docker的 Mount Namespace</a></li>
</ul>
<h4 id="简介"> 简介</h4>
<p>Linux
Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux
Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。</p>
<p>举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程
看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID
namespace中的进程无法看到彼此）</p>
<p><strong>Linux Namespace 有如下种类</strong>，官方文档在这里《<a
href="http://lwn.net/Articles/531114/">Namespace in Operation</a>》</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>分类</th>
<th>系统调用参数</th>
<th>相关内核版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Mount namespaces</strong></td>
<td>CLONE_NEWNS</td>
<td><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux
2.4.19</a></td>
</tr>
<tr class="even">
<td><strong>UTS namespaces</strong></td>
<td>CLONE_NEWUTS</td>
<td><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td>
</tr>
<tr class="odd">
<td><strong>IPC namespaces</strong></td>
<td>CLONE_NEWIPC</td>
<td><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td>
</tr>
<tr class="even">
<td><strong>PID namespaces</strong></td>
<td>CLONE_NEWPID</td>
<td><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td>
</tr>
<tr class="odd">
<td><strong>Network namespaces</strong></td>
<td>CLONE_NEWNET</td>
<td><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于
Linux 2.6.29</a></td>
</tr>
<tr class="even">
<td><strong>User namespaces</strong></td>
<td>CLONE_NEWUSER</td>
<td><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于
Linux 3.8)</a></td>
</tr>
</tbody>
</table>
<p>主要是三个系统调用</p>
<ul>
<li><strong><code>clone</code>()</strong> –
实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。<br />
</li>
<li><strong><code>unshare</code>()</strong> –
使某进程脱离某个namespace<br />
</li>
<li><strong><code>setns</code>()</strong> –
把某进程加入到某个namespace</li>
</ul>
<p>unshare() 和 setns() 都比较简单，大家可以自己man，我这里不说了。</p>
<p>下面还是让我们来看一些示例（以下的测试程序最好在Linux
内核为3.8以上的版本中运行，我用的是ubuntu 14.04）。</p>
<h4 id="clone系统调用">clone()系统调用</h4>
<p>首先，我们来看一下一个最简单的clone()系统调用的示例，（后面，我们的程序都会基于这个程序做修改）：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个给 clone 用的栈，栈大小1M */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span></span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。</p>
<p>下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。</p>
<h4 id="uts-namespace">UTS Namespace</h4>
<p>下面的代码，我略去了上面那些头文件和数据结构的定义，只有最重要的部分。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>); <span class="comment">/*启用CLONE_NEWUTS Namespace隔离 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container。</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./uts</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">root@container:~# hostname</span><br><span class="line">container</span><br><span class="line">root@container:~# uname -n</span><br><span class="line">container</span><br></pre></td></tr></table></figure></p>
<h4 id="ipc-namespace">IPC Namespace</h4>
<p>IPC全称 Inter-Process
Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。</p>
<p>要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure> 首先，我们先创建一个IPC的Queue（如下所示，全局的Queue
ID是0）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ ipcmk -Q </span><br><span class="line">Message queue id: 0</span><br><span class="line"></span><br><span class="line">hchen@ubuntu:~$ ipcs -q</span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line">0xd0d56eb2 0          hchen      644        0            0</span><br></pre></td></tr></table></figure>
如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC
Queue。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./uts </span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line"></span><br><span class="line">root@container:~# ipcs -q</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line">0xd0d56eb2 0          hchen      644        0            0</span><br></pre></td></tr></table></figure>
但是，如果我们运行加上了CLONE_NEWIPC的程序，我们就会下面的结果：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~$ sudo./ipc</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line"></span><br><span class="line">root@container:~/linux_namespace# ipcs -q</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br></pre></td></tr></table></figure> 我们可以看到IPC已经被隔离了。</p>
<h4 id="pid-namespace">PID Namespace</h4>
<p>我们继续修改上面的程序：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="comment">/*启用PID namespace - CLONE_NEWPID*/</span></span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, <span class="literal">NULL</span>); </span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行结果如下（我们可以看到，子进程的pid是1了）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./pid</span><br><span class="line">Parent [ 3474] - start a container!</span><br><span class="line">Container [ 1] - inside the container!</span><br><span class="line">root@container:~# echo $$</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>你可能会问，PID为1有个毛用啊？我们知道，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。</p>
<p><strong>但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程</strong>。说明并没有完全隔离。这是因为，像ps,
top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。</p>
<p>所以，我们还需要对文件系统进行隔离。</p>
<h4 id="mount-namespace">Mount Namespace</h4>
<p>下面的例程中，我们在启用了mount
namespace并在子进程中重新mount了/proc文件系统。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* 重新mount proc文件系统到 /proc下 */</span></span><br><span class="line">    system(<span class="string">&quot;mount -t proc proc /proc&quot;</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="comment">/* 启用Mount Namespace - 增加CLONE_NEWNS参数 */</span></span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行结果如下：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./pid.mnt</span><br><span class="line">Parent [ 3502] - start a container!</span><br><span class="line">Container [    1] - inside the container!</span><br><span class="line">root@container:~# ps -elf </span><br><span class="line">F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD</span><br><span class="line">4 S root         1     0  0  80   0 -  6917 wait   19:55 pts/2    00:00:00 /bin/bash</span><br><span class="line">0 R root        14     1  0  80   0 -  5671 -      19:56 pts/2    00:00:00 ps -elf</span><br></pre></td></tr></table></figure> 上面，我们可以看到只有两个进程
，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@container:~# ls /proc</span><br><span class="line">1          dma          key-users   net            sysvipc</span><br><span class="line">16         driver       kmsg        pagetypeinfo   timer_list</span><br><span class="line">acpi       execdomains  kpagecount  partitions     timer_stats</span><br><span class="line">asound     fb           kpageflags  sched_debug    tty</span><br><span class="line">buddyinfo  filesystems  loadavg     schedstat      uptime</span><br><span class="line">bus        fs           locks       scsi           version</span><br><span class="line">cgroups    interrupts   mdstat      self           version_signature</span><br><span class="line">cmdline    iomem        meminfo     slabinfo       vmallocinfo</span><br><span class="line">consoles   ioports      misc        softirqs       vmstat</span><br><span class="line">cpuinfo    irq          modules     stat           zoneinfo</span><br><span class="line">crypto     kallsyms     mounts      swaps</span><br><span class="line">devices    kcore        mpt         sys</span><br><span class="line">diskstats  keys         mtrr        sysrq-trigger</span><br></pre></td></tr></table></figure>
下图，我们也可以看到在子进程中的top命令只看得到两个进程了。<br />
<img
src="https://coolshell.cn/wp-content/uploads/2015/04/mount.namespace.jpg"
alt="子进程top结果" /></p>
<p>这里，多说一下。在通过CLONE_NEWNS创建mount
namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。</p>
<p>你可能会问，我们是不是还有别的一些文件系统也需要这样mount? 是的。</p>
<h4 id="docker的-mount-namespace">Docker的 Mount Namespace</h4>
<p>下面我将向演示一个“山寨镜像”，其模仿了Docker的Mount Namespace。</p>
<p>首先，我们需要一个rootfs，也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs$ ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var</span><br></pre></td></tr></table></figure> 然后，我们把一些我们需要的命令copy到
rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin</span><br><span class="line"> </span><br><span class="line">./bin:</span><br><span class="line">bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty</span><br><span class="line">cat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount</span><br><span class="line">chgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname</span><br><span class="line">chmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which</span><br><span class="line"></span><br><span class="line">./usr/bin:</span><br><span class="line">awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs</span><br></pre></td></tr></table></figure>
注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs/bin$ ldd bash</span><br><span class="line">  linux-vdso.so.1 =&gt;  (0x00007fffd33fc000)</span><br><span class="line">  libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000)</span><br><span class="line">  libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000)</span><br><span class="line">  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000)</span><br><span class="line">  /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000)</span><br></pre></td></tr></table></figure> 下面是我的rootfs中的一些so文件：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/</span><br><span class="line"></span><br><span class="line">./lib64:</span><br><span class="line">ld-linux-x86-64.so.2</span><br><span class="line"></span><br><span class="line">./lib/x86_64-linux-gnu/:</span><br><span class="line">libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1</span><br><span class="line">libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0</span><br><span class="line">libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so</span><br><span class="line">libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2</span><br><span class="line">libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1</span><br><span class="line">libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5</span><br><span class="line">libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9</span><br><span class="line">libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so</span><br><span class="line">libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1</span><br><span class="line">libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1</span><br><span class="line">libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1</span><br><span class="line">libdl.so.2       libnss_compat.so.2     libpthread.so.0</span><br><span class="line">libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1</span><br><span class="line">libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0</span><br></pre></td></tr></table></figure> 包括这些命令依赖的一些配置文件：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~/rootfs$ ls ./etc</span><br><span class="line">bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  </span><br><span class="line">resolv.conf  shadow</span><br></pre></td></tr></table></figure>
你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard
code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ ls ./conf</span><br><span class="line">hostname     hosts     resolv.conf</span><br></pre></td></tr></table></figure>
这样，我们的父进程就可以动态地设置容器需要的这些文件的配置，
然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。</p>
<p>好了，终于到了我们的程序。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys types.h=&quot;&quot;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys wait.h=&quot;&quot;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys mount.h=&quot;&quot;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-l&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set hostname</span></span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information</span></span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;rootfs/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>) !=<span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;proc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;rootfs/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sys&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;none&quot;</span>, <span class="string">&quot;rootfs/tmp&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;tmp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;udev&quot;</span>, <span class="string">&quot;rootfs/dev&quot;</span>, <span class="string">&quot;devtmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dev&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;rootfs/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dev/pts&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;shm&quot;</span>, <span class="string">&quot;rootfs/dev/shm&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dev/shm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;rootfs/run&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 模仿Docker的从外向容器里mount相关的配置文件 </span></span><br><span class="line"><span class="comment">     * 你可以查看：/var/lib/docker/containers/&lt;container_id&gt;/目录，</span></span><br><span class="line"><span class="comment">     * 你会看到docker的这些文件的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;conf/hosts&quot;</span>, <span class="string">&quot;rootfs/etc/hosts&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span> ||</span><br><span class="line">          mount(<span class="string">&quot;conf/hostname&quot;</span>, <span class="string">&quot;rootfs/etc/hostname&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span> ||</span><br><span class="line">          mount(<span class="string">&quot;conf/resolv.conf&quot;</span>, <span class="string">&quot;rootfs/etc/resolv.conf&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;conf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */</span></span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;/tmp/t1&quot;</span>, <span class="string">&quot;rootfs/mnt&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mnt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* chroot 隔离目录 */</span></span><br><span class="line">    <span class="keyword">if</span> ( chdir(<span class="string">&quot;./rootfs&quot;</span>) != <span class="number">0</span> || chroot(<span class="string">&quot;./&quot;</span>) != <span class="number">0</span> )&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir/chroot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    perror(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/container_id&gt;&lt;/unistd.h&gt;&lt;/signal.h&gt;&lt;/sched.h&gt;&lt;/stdio.h&gt;&lt;/sys&gt;&lt;/sys&gt;&lt;/sys&gt;</span><br></pre></td></tr></table></figure>
sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ./mount </span><br><span class="line">Parent [ 4517] - start a container!</span><br><span class="line">Container [    1] - inside the container!</span><br><span class="line">root@container:/# mount</span><br><span class="line">proc on /proc type proc (rw,relatime)</span><br><span class="line">sysfs on /sys type sysfs (rw,relatime)</span><br><span class="line">none on /tmp type tmpfs (rw,relatime)</span><br><span class="line">udev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755)</span><br><span class="line">devpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000)</span><br><span class="line">tmpfs on /run type tmpfs (rw,relatime)</span><br><span class="line">/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line">/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line">/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line"></span><br><span class="line">root@container:/# ls /bin /usr/bin</span><br><span class="line">/bin:</span><br><span class="line">bash   chmod  echo  hostname  less  more  mv   ping  rm   sleep  tail  test    top   truncate  uname</span><br><span class="line">cat    chown  grep  ip        ln    mount  nc   ps    sed  tabs   tar   timeout  touch  tty     which</span><br><span class="line">chgrp  cp     gzip  kill      ls    mountpoint  netstat  pwd   sh   tac    tee   toe    tr   umount</span><br><span class="line"></span><br><span class="line">/usr/bin:</span><br><span class="line">awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs</span><br></pre></td></tr></table></figure></p>
<p>关于如何做一个chroot的目录，这里有个工具叫<a
href="https://wiki.ubuntu.com/DebootstrapChroot">DebootstrapChroot</a>，你可以顺着链接去看看（英文的哦）</p>
<p>接下来的事情，你可以自己玩了，我相信你的想像力 。：）</p>
<p>在下一篇，我将向你介绍User Namespace、Network
Namespace以及Namespace的其它东西。</p>
<p><strong><a href="https://coolshell.cn/articles/17029.html"
title="Docker基础技术：Linux Namespace（下）">&lt;&lt;&lt;&lt;
Docker基础技术：Linux Namespace（下）&gt;&gt;&gt;&gt;</a></strong></p>
<p>（上篇完，<a href="https://coolshell.cn/articles/17029.html"
title="Docker基础技术：Linux Namespace（下）">请参看下篇</a>）</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础下</title>
    <url>/blog/2023/10/11/data/linux/docker/Docker%E5%9F%BA%E7%A1%80%E4%B8%8B/</url>
    <content><![CDATA[<p>在 <strong><a href="https://coolshell.cn/articles/17010.html"
title="Docker基础技术：Linux Namespace（上）">Docker基础技术：Linux
Namespace（上篇）</a></strong>中我们了解了，UTD、IPC、PID、Mount
四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。</p>
<p>好，下面我们就介绍一下还剩下的这两个Namespace。</p>
<p>目录</p>
<ul>
<li><a href="https://coolshell.cn/articles/17029.html#User_Namespace"
title="User Namespace">User Namespace</a><br />
</li>
<li><a href="https://coolshell.cn/articles/17029.html#Network_Namespace"
title="Network Namespace">Network Namespace</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17029.html#Namespace%E6%96%87%E4%BB%B6"
title="Namespace文件">Namespace文件</a><br />
</li>
<li><a
href="https://coolshell.cn/articles/17029.html#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"
title="参考文档">参考文档</a></li>
</ul>
<h4 id="user-namespace">User Namespace</h4>
<p>User
Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。</p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改 <strong>/proc/&lt;pid&gt;/uid_map</strong> 和 <strong>/proc/&lt;pid&gt;/gid_map</strong> 这两个文件。这两个文件的格式为：</p>
<p><strong>ID-inside-ns ID-outside-ns length</strong></p>
<p>其中：</p>
<ul>
<li>第一个字段ID-inside-ns表示在容器显示的UID或GID，<br />
</li>
<li>第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。<br />
</li>
<li>第三个字段表示映射的范围，一般填1，表示一一对应。</li>
</ul>
<p>比如，把真实的uid=1000映射成容器内的uid=0<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/2465/uid_map</span><br><span class="line">         0       1000          1</span><br></pre></td></tr></table></figure>
再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/$$/uid_map</span><br><span class="line">         0          0          4294967295</span><br></pre></td></tr></table></figure> 另外，需要注意的是：</p>
<ul>
<li>写这两个文件的进程需要这个namespace中的CAP_SETUID
(CAP_SETGID)权限（可参看<a
href="http://man7.org/linux/man-pages/man7/capabilities.7.html">Capabilities</a>）<br />
</li>
<li>写入的进程必须是此user namespace的父或子的user namespace进程。<br />
</li>
<li>另外需要满如下条件之一：1）父进程将effective
uid/gid映射到子进程的user
namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。</li>
</ul>
<p>这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂）：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/capability.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_map</span><span class="params">(<span class="type">char</span>* file, <span class="type">int</span> inside_id, <span class="type">int</span> outside_id, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    FILE* mapfd = fopen(file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == mapfd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(mapfd, <span class="string">&quot;%d %d %d&quot;</span>, inside_id, outside_id, len);</span><br><span class="line">    fclose(mapfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_uid_map</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> inside_id, <span class="type">int</span> outside_id, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> file[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;/proc/%d/uid_map&quot;</span>, pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_gid_map</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> inside_id, <span class="type">int</span> outside_id, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> file[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;/proc/%d/gid_map&quot;</span>, pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">            (<span class="type">long</span>) geteuid(), (<span class="type">long</span>) getegid(), (<span class="type">long</span>) getuid(), (<span class="type">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待父进程通知后再往下执行（进程间的同步） */</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    read(pipefd[<span class="number">0</span>], &amp;ch, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - setup hostname!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="comment">//set hostname</span></span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information</span></span><br><span class="line">    mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> gid=getgid(), uid=getuid();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">            (<span class="type">long</span>) geteuid(), (<span class="type">long</span>) getegid(), (<span class="type">long</span>) getuid(), (<span class="type">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">    pipe(pipefd);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - Container [%5d]!\n&quot;</span>, getpid(), container_pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//To map the uid/gid, </span></span><br><span class="line">    <span class="comment">//   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span></span><br><span class="line">    <span class="comment">//The file format is</span></span><br><span class="line">    <span class="comment">//   ID-inside-ns   ID-outside-ns   length</span></span><br><span class="line">    <span class="comment">//if no mapping, </span></span><br><span class="line">    <span class="comment">//   the uid will be taken from /proc/sys/kernel/overflowuid</span></span><br><span class="line">    <span class="comment">//   the gid will be taken from /proc/sys/kernel/overflowgid</span></span><br><span class="line">    set_uid_map(container_pid, <span class="number">0</span>, uid, <span class="number">1</span>);</span><br><span class="line">    set_gid_map(container_pid, <span class="number">0</span>, gid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - user/group mapping done!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知子进程 */</span></span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user
namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。</p>
<p>整个程序的运行效果如下：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ id</span><br><span class="line">uid=1000(hchen) gid=1000(hchen) groups=1000(hchen)</span><br><span class="line"></span><br><span class="line">hchen@ubuntu:~$ ./user #&lt;--以hchen用户运行</span><br><span class="line">Parent: eUID = 1000;  eGID = 1000, UID=1000, GID=1000 </span><br><span class="line">Parent [ 3262] - start a container!</span><br><span class="line">Parent [ 3262] - Container [ 3263]!</span><br><span class="line">Parent [ 3262] - user/group mapping done!</span><br><span class="line">Container [    1] - inside the container!</span><br><span class="line">Container: eUID = 0;  eGID = 0, UID=0, GID=0 #&lt;---Container里的UID/GID都为0了</span><br><span class="line">Container [    1] - setup hostname!</span><br><span class="line"></span><br><span class="line">root@container:~# id #&lt;----我们可以看到容器里的用户和命令行提示符是root用户了</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),65534(nogroup)</span><br></pre></td></tr></table></figure>
虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，我们容器的安全性会得到提高。</p>
<p>我们注意到，User
Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User
Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。</p>
<h4 id="network-namespace">Network Namespace</h4>
<p>Network的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network
Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw
Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。</p>
<p>首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）</p>
<figure>
<img
src="https://coolshell.cn/wp-content/uploads/2015/04/network.namespace.jpg"
alt="network.namespace" />
<figcaption aria-hidden="true">network.namespace</figcaption>
</figure>
<p>上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。</p>
<p>当你启动一个Docker容器后，你可以使用ip link show或ip addr
show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state ... </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...</span><br><span class="line">    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: veth22a38e6: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...</span><br><span class="line">    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure> 那么，要做成这个样子应该怎么办呢？我们来看一组命令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 首先，我们先增加一个网桥lxcbr0，模仿docker0</span><br><span class="line">brctl addbr lxcbr0</span><br><span class="line">brctl stp lxcbr0 off</span><br><span class="line">ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址</span><br><span class="line"></span><br><span class="line">## 接下来，我们要创建一个network namespace - ns1</span><br><span class="line"></span><br><span class="line"># 增加一个namesapce 命令为 ns1 （使用ip netns add命令）</span><br><span class="line">ip netns add ns1 </span><br><span class="line"></span><br><span class="line"># 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）</span><br><span class="line">ip netns exec ns1   ip link set dev lo up </span><br><span class="line"></span><br><span class="line">## 然后，我们需要增加一对虚拟网卡</span><br><span class="line"></span><br><span class="line"># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span><br><span class="line">ip link add veth-ns1 type veth peer name lxcbr0.1</span><br><span class="line"></span><br><span class="line"># 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了</span><br><span class="line">ip link set veth-ns1 netns ns1</span><br><span class="line"></span><br><span class="line"># 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）</span><br><span class="line">ip netns exec ns1  ip link set dev veth-ns1 name eth0 </span><br><span class="line"></span><br><span class="line"># 为容器中的网卡分配一个IP地址，并激活它</span><br><span class="line">ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span><br><span class="line">brctl addif lxcbr0 lxcbr0.1</span><br><span class="line"></span><br><span class="line"># 为容器增加一个路由规则，让容器可以访问外面的网络</span><br><span class="line">ip netns exec ns1     ip route add default via 192.168.10.1</span><br><span class="line"></span><br><span class="line"># 在/etc/netns下创建network namespce名称为ns1的目录，</span><br><span class="line"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span><br><span class="line">mkdir -p /etc/netns/ns1</span><br><span class="line">echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure> 上面基本上就是docker网络的原理了，只不过，</p>
<ul>
<li>Docker的resolv.conf没有用这样的方式，而是用了<a
href="https://coolshell.cn/articles/17010.html"
title="Docker基础技术：Linux Namespace（上）">上篇中的Mount
Namesapce的那种方式</a><br />
</li>
<li>另外，docker是用进程的PID来做Network Namespace的名称的。</li>
</ul>
<p>了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link add peerA type veth peer name peerB </span><br><span class="line">brctl addif docker0 peerA </span><br><span class="line">ip link set peerA up </span><br><span class="line">ip link set peerB netns $&#123;container-pid&#125; </span><br><span class="line">ip netns exec $&#123;container-pid&#125; ip link set dev peerB name eth1 </span><br><span class="line">ip netns exec $&#123;container-pid&#125; ip link set eth1 up ; </span><br><span class="line">ip netns exec $&#123;container-pid&#125; ip addr add $&#123;ROUTEABLE_IP&#125; dev eth1 ;</span><br></pre></td></tr></table></figure>
上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。</p>
<p>这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。</p>
<p>当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。</p>
<p>这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个<a
href="https://lwn.net/Articles/620087/">IPVLAN的驱动</a>，这基本上就是为Docker量身定制的。</p>
<h4 id="namespace文件">Namespace文件</h4>
<p>上面就是目前Linux Namespace的玩法。
现在，我来看一下其它的相关东西。</p>
<p>让我们运行一下上篇中的那个pid.mnt的程序（也就是PID
Namespace中那个mount proc的程序），然后不要退出。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ./pid.mnt </span><br><span class="line">[sudo] password for hchen: </span><br><span class="line">Parent [ 4599] - start a container!</span><br><span class="line">Container [    1] - inside the container!</span><br></pre></td></tr></table></figure> 我们到另一个shell中查看一下父子进程的PID：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ pstree -p 4599</span><br><span class="line">pid.mnt(4599)───bash(4600)</span><br></pre></td></tr></table></figure> 下面是父进程的：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ls -l /proc/4599/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure> 下面是子进程的：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hchen@ubuntu:~$ sudo ls -l /proc/4600/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026532520]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026532522]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026532521]</span><br></pre></td></tr></table></figure>
我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。</p>
<p>这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount
–bind /proc/4600/ns/uts ~/uts 来hold这个namespace。</p>
<p>另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setns</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> nstype)</span>;</span><br></pre></td></tr></table></figure>
其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/proc/4600/ns/nts&quot;</span>, O_RDONLY);  <span class="comment">// 获取namespace文件描述符</span></span><br><span class="line">setns(fd, <span class="number">0</span>); <span class="comment">// 加入新的namespace</span></span><br></pre></td></tr></table></figure> #### 参考文档</p>
<ul>
<li><ul>
<li><a href="http://lwn.net/Articles/531114/">Namespaces in
operation</a>
<ul>
<li><a
href="http://man7.org/linux/man-pages/man7/namespaces.7.html">Linux
Namespace Man Page</a><br />
</li>
<li><a
href="http://crosbymichael.com/creating-containers-part-1.html">Creat
Containers – Part 1</a><br />
</li>
<li><a
href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/">Introduction
to Linux namespaces</a></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>golang镜像dockerfile示例</title>
    <url>/blog/2023/10/11/data/linux/docker/golang%E9%95%9C%E5%83%8Fdockerfile%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FROM golang:<span class="number">1.19</span> as builder</span><br><span class="line">ARG TARGETOS</span><br><span class="line">ARG TARGETARCH</span><br><span class="line"></span><br><span class="line"># entering workspace</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># <span class="built_in">copy</span> the whole project</span><br><span class="line">COPY . .</span><br><span class="line">COPY conf ./common/conf</span><br><span class="line">COPY misc ./common/misc</span><br><span class="line"># cache dependencies so that source changes won<span class="string">&#x27;t break the download layer</span></span><br><span class="line"><span class="string">RUN go env -w GOPROXY=https://goproxy.cn,direct \</span></span><br><span class="line"><span class="string"> &amp;&amp; go env -w GO111MODULE=on \</span></span><br><span class="line"><span class="string"> &amp;&amp; go mod download \</span></span><br><span class="line"><span class="string"> &amp;&amp; CGO_ENABLE=0 GOOS=$&#123;TARGETOS:-linux&#125; GOARCH=$&#123;TARGETARCH&#125; go build -a -o main .</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FROM gcr.io/distroless/base:nonroot</span></span><br><span class="line"><span class="string">WORKDIR /app</span></span><br><span class="line"><span class="string">COPY --from=builder /app/main .</span></span><br><span class="line"><span class="string">COPY --from=builder /app/common .</span></span><br><span class="line"><span class="string">USER 65532:65532</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CMD [&quot;./main&quot;]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Clash作为docker daemon的代理</title>
    <url>/blog/2023/10/11/data/linux/docker/%E4%BD%BF%E7%94%A8Clash%E4%BD%9C%E4%B8%BAdocker%20daemon%E7%9A%84%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="docker-daemon">docker daemon</h2>
<p>docker向各个仓库拉取镜像的时候默认是不走代理的，并且拉取镜像的操作由docker
daemon来完成，因此如果是公司内部网络或者需要翻墙的外网仓库，往往就需要配置docker
daemon这个systemd
service服务启动时的环境变量了（==注意，环境变量是相对于进程而言的，每个进程有自己的环境变量，我们平时ssh登录的终端进程环境变量，systemd中的服务是不知道的，因为很多systemd管理的服务比连接进来的终端先启动，它们并没有什么特殊的环境变量==），通过在<code>/etc/systemd/system</code>目录下创建<code>docker.service.d</code>目录，并在其中存放docker服务相关的配置文件（.conf），这样docker相关的服务在启动时会读取这些配置文件。</p>
<p>在配置目录中新建任意名称的配置文件.conf，在其中填入如下内容：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/systemd/system/docker.service.d/proxy.conf</span> </span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://127.0.0.1:7890&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7890/&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=localhost,127.0.0.1&quot;</span><br></pre></td></tr></table></figure></p>
<p>启动docker后，在使用docker拉取其他仓库的镜像时，只要仓库网址解析出的IP地址不在<code>NO_PROXY</code>列表中，则分流使用HTTP和HTTPS的代理发送请求。</p>
<p>如果还没有安装docker程序，请参考<a
href="https://docs.docker.com/engine/install/">docker官方网站</a>的教程安装，或者尝试使用以下脚本安装（适用于Debian系列Linux发行版）：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">	curl \</span><br><span class="line">	gnupg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo mkdir -m 0755 -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line">echo \</span><br><span class="line">	&quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \</span><br><span class="line">	&quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \</span><br><span class="line">	  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line">sudo docker run hello-world</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add current use to docker group</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">so that sudo is not  needed  at</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">each time</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $&#123;USER&#125;</span><br><span class="line">sudo newgrp docker</span><br></pre></td></tr></table></figure></p>
<h2 id="clash">Clash</h2>
<p>Clash是一款基于Golang编写的，可以试用规则分流的代理终端，在win下具有图形界面，在Linux下具有良好的终端输出（方便我们直接将输出重定向到日志文件中进行后处理）。</p>
<p>安装Clash可以直接在<a
href="https://github.com/Dreamacro/clash">Clash的GitHub仓库</a>下载Linux
amd64
v3版本的二进制文件，就是单个文件，非常方便使用，不用安装，因此就不会污染系统目录了。</p>
<p>至于clash的订阅文件，只能各显神通了，毕竟这是一个先有鸡还是先有蛋的问题，没有梯子就没办法获取到订阅文件（有时候运气好可以穿墙），可以直接bing或者baidu搜索便宜的一两块钱的机场，或者找其他人的代理服务器先白嫖代理一下，下载完代理文件之后就可以用自己的梯子一直续费了。clash的一个比较优质的机场是<a
href="https://dogess.work/user">dogess</a>。可以拿到订阅URL之后，使用<code>wget &lt;url&gt; -O config.yaml</code>
来下载配置文件到yaml文件中，然后就可以和Country.mmdb文件一起作为Clash的依赖配置项使用了。</p>
<p>Clash运行需要两个文件，其一是<a
href="https://github.com/Dreamacro/maxmind-geoip/releases/download/20230812/Country.mmdb">Country.mmdb</a>，用来定义路由网络，分流导向等。还有就是各个代理服务器节点信息的配置文件，这个需要去各个机场购买才有，并且也必须是clash能够解析的yaml格式文件，如果是其他类型的解析协议比如shadowsocks（SS），shadowsocksR（SSR），可以在网上找一些订阅链接转换器转换成clash的yaml订阅节点配置文件。<br />
&gt; <code>Country.mmdb</code> 文件利用 GeoIP2
服务能识别互联网用户的地点位置，以供规则分流时使用。</p>
<p>把clash下载下来之后，使用<code>./clash -d .</code>来运行clash，其中<code>-d</code>参数指的是两个依赖文件的存放目录路径，成功运行，没有接收到代理请求之前，应该会输出如下内容：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat programfiles/clash/clash.log </span><br><span class="line">nohup: ignoring input</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Start initial compatible provider 🍃 Proxies&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Start initial compatible provider ☁️ Others&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Start initial compatible provider 🍂 Domestic&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Start initial compatible provider ⭐️ Auto&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;Mixed(http+socks) proxy listening at: [::]:7890&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;DNS server listening at: [::]:5353&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:03+08:00&quot; level=info msg=&quot;RESTful API listening at: [::]:9090&quot;</span><br></pre></td></tr></table></figure>
如果从端口监听到了转发请求，一样会输出信息，主要是本地ip:port和目的ip:port：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time=&quot;2023-07-27T10:52:10+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:39466 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:11+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:39482 --&gt; auth.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:44+08:00&quot; level=warning msg=&quot;[TCP] dial ☁️ Others (match Match/) 127.0.0.1:47064 --&gt; registry-1.docker.io:443 error: a1jexzshnphscpcr.wudaki972.me:9011 connect error: dial tcp4 112.47.7.133:9011: i/o timeout&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:47+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47432 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:47+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47448 --&gt; auth.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:48+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47464 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:49+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47480 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:50+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47494 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:50+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47510 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:50+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47518 --&gt; registry-1.docker.io:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:51+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47542 --&gt; production.cloudflare.docker.com:443 match Match() using ☁️ Others[香港-03]&quot;</span><br><span class="line">time=&quot;2023-07-27T10:52:51+08:00&quot; level=info msg=&quot;[TCP] 127.0.0.1:47530 --&gt; production.cloudflare.docker.com:443 match Match() using ☁️ Others[香港-03]&quot;</span><br></pre></td></tr></table></figure></p>
<p>为了让clash的启动和关闭更加便捷，我写了两个简单的启动和关闭脚本，如下所示</p>
<p>启动脚本：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy mode <span class="string">&#x27;manual&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http port 7890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http host <span class="string">&#x27;127.0.0.1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https port 7890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https host <span class="string">&#x27;127.0.0.1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.socks port 7891</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy.socks host <span class="string">&#x27;127.0.0.1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gsettings <span class="built_in">set</span> org.gnome.system.proxy ignore-hosts <span class="string">&quot;[&#x27;localhost&#x27;, &#x27;127.0.0.0/8&#x27;, &#x27;::1&#x27;]&quot;</span></span></span><br><span class="line"></span><br><span class="line">clash_home=$(dirname $(command -v clash))</span><br><span class="line"></span><br><span class="line">read -p &quot;specify a configure directory under the clash root: &quot; confdir</span><br><span class="line">if [ ! -n &quot;$&#123;confdir&#125;&quot; ]; then</span><br><span class="line">	echo &quot;no dir specified, use clash root as conf dir&quot;</span><br><span class="line">	confdir=$&#123;clash_home&#125;</span><br><span class="line">else</span><br><span class="line">	if [ ! -d $&#123;confdir&#125; ]; then</span><br><span class="line">		echo &quot;specified confdir not exists, use clash root as conf dir&quot;</span><br><span class="line">		confdir=$&#123;clash_home&#125;</span><br><span class="line">	fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">nohup $&#123;clash_home&#125;/clash -d $&#123;confdir&#125; &gt; $&#123;clash_home&#125;/clash.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$&#123;clash_home&#125;</span>/clash -d <span class="variable">$&#123;confdir&#125;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export HTTP_PROXY=http://127.0.0.1:7890</span><br><span class="line">export HTTPS_PROXY=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure> 关闭脚本：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clash_procid=$(ps -ef | grep clash | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">if [ -n &quot;$&#123;clash_procid&#125;&quot; ]; then</span><br><span class="line">	echo &quot;$&#123;clash_procid&#125;&quot; | xargs kill -SIGKILL</span><br><span class="line">	unset HTTP_PROXY</span><br><span class="line">	unset HTTPS_PROXY</span><br><span class="line">	unset FTP_PROXY</span><br><span class="line">	unset ALL_PROXY</span><br><span class="line">else</span><br><span class="line">	echo &quot;no clash process found...&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>以后在使用docker前就必须打开clash代理才能让docker正常拉取仓库镜像，因为已经配置了docker
daemon的代理环境变量了，如果不需要代理可以把docker.service.d下的代理配置文件删除或者注释内容后重启docker服务。开启clash代理后，docker往clash监听代理请求的端口发送拉取镜像请求，然后clash安排这些请求去能穿墙的节点服务器帮忙获取http
response。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>前台运行和后台运行区别</title>
    <url>/blog/2023/10/11/data/linux/docker/%E5%89%8D%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%92%8C%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="docker-容器后台运行和前台运行的区别">Docker
容器后台运行和前台运行的区别</h1>
<h2 id="后台运行vs前台运行">后台运行vs前台运行</h2>
<p>当你启动一个docker
容器的时候，第一件事就是要确认你要在前台运行还是在后台运行：</p>
<p>-d=false:Detached mode:Run container in the background,printnew
container id</p>
<h3 id="后台运行--d">后台运行 (-d)</h3>
<p>后台运行直接指定 (-d=true or just
-d),这样的话所有的操作类似网络连接，共享操作等等都不会再接受命令行的命令控制。你就要使用attach命令
来进入一个容器，再管理它，注意当你attach链接到一个容器的时候，你就不能再使用
rm 来删除这个容器。</p>
<h3 id="前台运行">前台运行</h3>
<p>当你不指定-d时，就是在前台运行， docker run
可以启动一个进程，并且通过console 连接进程的标准输入
输出和标准错误。它甚至可以伪装成一个TTY，发送信号量。所有这一切都是可以配置的。</p>
<p>-a=[]:Attach to
<code>STDIN</code>,<code>STDOUT</code>and/or<code>STDERR</code>-t=false:Allocate
a pseudo-tty</p>
<p>--sig-proxy=true:Proxify all received signal to the process (even in
non-tty mode)-i=false:Keep STDIN open even ifnot attached</p>
<p>如果你不想使用 -a
来连接容器的所有输入输出，那么你可以指定你希望接受的流STDIN, STDOUT,
STDERR)：</p>
<p>$ docker run -a stdin -a stdout -i -t ubuntu /bin/bash</p>
<p>在交互式的情况下，你最希望得到一个类似TTY那样的shell，你可以 指定 -i
-t</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>挂载目录和文件</title>
    <url>/blog/2023/10/11/data/linux/docker/%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="作用">作用</h2>
<p>docker挂载就是用本机文件或文件夹覆盖容器内的文件或文件夹</p>
<p>注：docker
挂载配置文件时，一定要注意不要把要挂载的配置文件的内容写错，否则创建容器之后，启动不了</p>
<h2 id="背景介绍">背景介绍</h2>
<p>docker volume
可以使我们在启动docker容器时，动态的挂载一些文件（如配置文件）,
以覆盖镜像中原有的文件</p>
<h2 id="目录挂载">目录挂载</h2>
<p>host上文件夹一定会覆盖container中文件夹：</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td>host</td>
<td>container</td>
<td>mount result</td>
</tr>
<tr class="even">
<td>文件夹不存在/文件夹存在但为空</td>
<td>文件夹不存在/存在但为空/存在且不为空</td>
<td>container中文件被覆盖（清空）</td>
</tr>
<tr class="odd">
<td>文件夹存在且不为空</td>
<td>文件夹不存在/存在但为空/存在且不为空</td>
<td>container中文件夹内容被覆盖（原内容清空，
覆盖为host上文件夹内容）</td>
</tr>
</tbody>
</table>
<p>允许不存在的文件夹或者存在的空文件夹挂载进container,
container中对应的文件夹将被清空</p>
<p>非空文件夹挂载进container将会覆盖container中原有文件夹</p>
<h2 id="文件挂载">文件挂载</h2>
<p>文件挂载与文件夹挂载最大的不同点在于：<br />
docker
禁止用主机上不存在的文件挂载到container中已经存在的文件文件挂载不会对同一文件夹下的其他文件产生任何影响存在的文件挂载进container中将会覆盖container中对应的文件，
若文件不存在则新建</p>
<h2 id="总结">总结</h2>
<p>host上文件一定会覆盖container中文件</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td>host</td>
<td>container</td>
<td>mount result</td>
</tr>
<tr class="even">
<td>不存在的文件</td>
<td>已经存在的文件</td>
<td>禁止行为</td>
</tr>
<tr class="odd">
<td>存在的文件</td>
<td>不存在的文件/已经存在的文件</td>
<td>新增/覆盖 （若目录不存在则会创建目录）</td>
</tr>
</tbody>
</table>
<h2 id="应用场景">应用场景</h2>
<p>从上面的分析可知，文件夹挂载以整个文件夹为单位进行文件覆盖，故可在需要将大量文件挂载进container时使用，另外，如果挂载一个空文件夹或者不存在的文件夹，一般是做逆向使用：
即容器启动后，可能会在容器内挂载点的文件夹下生成一些文件（如日志），此时，在对应的host上的文件夹内就能直接看到。</p>
<p>文件挂载由于只会覆盖单个文件而不会影响container中同一文件夹下的其他文件，常常被用来挂载配置文件，以在运行时，动态的修改默认配置。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>配置docker daemon代理来拉取国外镜像</title>
    <url>/blog/2023/10/11/data/linux/docker/%E9%85%8D%E7%BD%AEdocker%20daemon%E4%BB%A3%E7%90%86%E6%9D%A5%E6%8B%89%E5%8F%96%E5%9B%BD%E5%A4%96%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>如何配置docker通过代理服务器拉取镜像</p>
<p>2021-09-22</p>
<p>标签： <a href="https://www.lfhacks.com/tags/docker/">DOCKER</a></p>
<p>如果 docker
所在的环境是通过代理服务器和互联网连通的，那么需要一番配置才能让 docker
正常从外网正常拉取镜像。然而仅仅通过配置环境变量的方法是不够的。本文结合已有文档，介绍如何配置代理服务器能使docker正常拉取镜像。</p>
<p>本文使用的docker 版本是19.03</p>
<p>问题现象</p>
<p>如果不配置代理服务器就直接拉镜像，docker
会直接尝试连接镜像仓库，并且连接超时报错。如下所示：</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td>$ docker pull busybox</td>
</tr>
<tr class="even">
<td>Using default tag: latest</td>
</tr>
<tr class="odd">
<td>Error response from daemon: Get <a
href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>:
net/http: request canceled</td>
</tr>
<tr class="even">
<td>while waiting for connection (Client.Timeout exceeded while awaiting
headers)</td>
</tr>
</tbody>
</table>
<p>容易误导的官方文档</p>
<p>有这么一篇关于 docker 配置代理服务器的 <a
href="https://docs.docker.com/network/proxy/#configure-the-docker-client">官方文档</a> ，如果病急乱投医，直接按照这篇文章配置，是不能成功拉取镜像的。</p>
<p>我们来理解一下这篇文档，文档关键的原文摘录如下：</p>
<p>If your container needs to use an HTTP, HTTPS, or FTP proxy server,
you can configure it in different ways: Configure the Docker client On
the Docker client, create or edit the file ~/.docker/config.json in the
home directory of the user that starts containers.</p>
<p>…</p>
<p>When you create or start new containers, the environment variables
are set automatically within the container.</p>
<p>这篇文档说：如果你的容器需要使用代理服务器，那么可以以如下方式配置：
在运行容器的用户 home
目录下，配置 ~/.docker/config.json 文件。重新启动容器后，这些环境变量将自动设置进容器，从而容器内的进程可以使用代理服务。</p>
<p>所以这篇文章是讲如何配置运行容器的环境，与如何拉取镜像无关。如果按照这篇文档的指导，如同南辕北辙。</p>
<p>要解决问题，我们首先来看一般情况下命令行如何使用代理。</p>
<p>环境变量</p>
<p>常规的命令行程序如果要使用代理，需要设置两个环境变量：HTTP_PROXY 和 HTTPS_PROXY ，设置环境变量的方法见 <a
href="https://www.lfhacks.com/test/cypress-download-failure#env">这篇文章</a> 。但是仅仅这样设置环境变量，也不能让
docker 成功拉取镜像。</p>
<p>我们仔细观察 <a
href="https://www.lfhacks.com/tech/pull-docker-images-behind-proxy/#problem">上面的报错信息</a>，有一句说明了报错的来源：</p>
<p>Error response from daemon:</p>
<p>因为镜像的拉取和管理都是 docker daemon 的职责，所以我们要让 docker
daemon 知道代理服务器的存在。而 docker daemon 是由 systemd
管理的，所以我们要从 systemd 配置入手。</p>
<p>正确的官方文档</p>
<p>关于 systemd 配置代理服务器的 <a
href="https://docs.docker.com/config/daemon/systemd/#httphttps-proxy">官方文档在这里</a>，原文说：</p>
<p>The Docker daemon uses the HTTP_PROXY, HTTPS_PROXY, and NO_PROXY
environmental variables in its start-up environment to configure HTTP or
HTTPS proxy behavior. You cannot configure these environment variables
using the daemon.json file.</p>
<p>This example overrides the default docker.service file.</p>
<p>If you are behind an HTTP or HTTPS proxy server, for example in
corporate settings, you need to add this configuration in the Docker
systemd service file.</p>
<p>这段话的意思是，docker daemon 使用 HTTP_PROXY, HTTPS_PROXY,
和 NO_PROXY 三个环境变量配置代理服务器，但是你需要在 systemd
的文件里配置环境变量，而不能配置在 daemon.json 里。</p>
<p>具体操作</p>
<p>下面是来自 <a
href="https://www.lfhacks.com/tech/pull-docker-images-behind-proxy/#correct">官方文档</a> 的操作步骤和详细解释：</p>
<ol type="1">
<li>创建 dockerd 相关的 systemd 目录，这个目录下的配置将覆盖 dockerd
的默认配置</li>
</ol>
<p>$ sudo mkdir -p /etc/systemd/system/docker.service.d</p>
<ol type="1">
<li>新建配置文件 /etc/systemd/system/docker.service.d/http-proxy.conf，这个文件中将包含环境变量</li>
</ol>
<table>
<tbody>
<tr class="odd">
<td>[Service]</td>
</tr>
<tr class="even">
<td>Environment="HTTP_PROXY=http://proxy.example.com:80"</td>
</tr>
<tr class="odd">
<td>Environment="HTTPS_PROXY=https://proxy.example.com:443"</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>如果你自己建了私有的镜像仓库，需要 dockerd
绕过代理服务器直连，那么配置 NO_PROXY 变量：</li>
</ol>
<table>
<tbody>
<tr class="odd">
<td>[Service]</td>
</tr>
<tr class="even">
<td>Environment="HTTP_PROXY=http://proxy.example.com:80"</td>
</tr>
<tr class="odd">
<td>Environment="HTTPS_PROXY=https://proxy.example.com:443"</td>
</tr>
<tr class="even">
<td>Environment="NO_PROXY=your-registry.com,10.10.10.10,*.example.com"</td>
</tr>
</tbody>
</table>
<p>多个 NO_PROXY 变量的值用逗号分隔，而且可以使用通配符（<em>），极端情况下，如果 NO_PROXY=</em>，那么所有请求都将不通过代理服务器。</p>
<ol type="1">
<li>重新加载配置文件，重启 dockerd</li>
</ol>
<table>
<tbody>
<tr class="odd">
<td>$ sudo systemctl daemon-reload</td>
</tr>
<tr class="even">
<td>$ sudo systemctl restart docker</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>检查确认环境变量已经正确配置：</li>
</ol>
<p>$ sudo systemctl show --property=Environment docker</p>
<ol type="1">
<li>从 docker info 的结果中查看配置项。</li>
</ol>
<figure>
<img
src="data:image/png;base64,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"
alt="Docker Root Debug Mode: HTTP Proxy: HTTPS Proxy: Dir: /var/lib/docker false No Proxy: localhost, 127.0.0. 1 , dockeé-regi: Registry: https://index.docker.io/vl/" />
<figcaption aria-hidden="true">Docker Root Debug Mode: HTTP Proxy: HTTPS
Proxy: Dir: /var/lib/docker false No Proxy: localhost, 127.0.0. 1 ,
dockeé-regi: Registry: https://index.docker.io/vl/</figcaption>
</figure>
<p>这样配置后，应该可以正常拉取 docker 镜像。</p>
<p>结论</p>
<p>docker 镜像由 docker daemon 管理，所以不能用修改 shell
环境变量的方法使用代理服务，而是从 systemd 角度设置环境变量。</p>
<p>来自 &lt;<a
href="https://www.lfhacks.com/tech/pull-docker-images-behind-proxy/">https://www.lfhacks.com/tech/pull-docker-images-behind-proxy/</a>&gt;</p>
<p>需要注意的是，如果你的代理服务器并不支持https，那么https的代理同样要走http协议，也就是HTTPS_PROXY的值，必须是以http://开头的代理服务器，而不是https://，否则无法联通，关于这个问题，可以看<a
href="https://stackoverflow.com/questions/51890390/docker-not-able-to-pull-images-behind-proxy-tls-handshake-timeout">这篇StackOverflow</a></p>
<p>16</p>
<p>The config file is:</p>
<p>[Service]<br />
Environment=“HTTP_PROXY=http://pqr.corp.xxx.com:8080”<br />
Environment=“HTTPS_PROXY=https://pqr.corp.xxx.com:8080”<br />
Environment=“NO_PROXY=localhost,127.0.0.1”</p>
<p>Notice that 3rd line: HTTPS_PROXY=https</p>
<p>Is the proxy server support HTTPS? Or there should be an error.</p>
<p>Maybe HTTPS_PROXY=http is correct.</p>
<p>By the way, a similar error is Get <a
href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>:
proxyconnect tcp: EOF</p>
<p>来自 &lt;<a
href="https://stackoverflow.com/questions/51890390/docker-not-able-to-pull-images-behind-proxy-tls-handshake-timeout">https://stackoverflow.com/questions/51890390/docker-not-able-to-pull-images-behind-proxy-tls-handshake-timeout</a>&gt;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>sh脚本和bash脚本的区别</title>
    <url>/blog/2023/10/11/data/linux/shell/sh%E8%84%9A%E6%9C%AC%E5%92%8Cbash%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>bash脚本和sh脚本有什么不同吗</p>
<p>Bash脚本和Sh脚本都是用于编写shell脚本的语言。它们之间的主要区别在于它们使用的不同的shell解释器。</p>
<p>Bash脚本使用Bash shell解释器，而Sh脚本使用Bourne
shell解释器。Bash是Bourne
shell的扩展，它包含了更多的功能和命令，因此Bash脚本比Sh脚本更强大和灵活。</p>
<p>如果您使用的是Linux系统，则Bash通常是默认的shell解释器。如果您想编写更复杂和强大的脚本，则建议使用Bash脚本。但是，如果您只需要编写简单的脚本，则使用Sh脚本可能更容易。</p>
<p>这两种脚本在编写的语法上有什么不同？</p>
<p>Bash脚本和Sh脚本在语法上有些微的不同，因为Bash脚本是Bourne
shell的扩展，它增加了许多新的特性和命令。以下是一些Bash脚本和Sh脚本之间的主要区别：</p>
<ol type="1">
<li>命令替换：在Bash中，可以使用$(command)或<br />
command<br />
来执行命令替换，而在Sh中，只能使用<br />
command<br />
。<br />
</li>
<li>数组：Bash支持数组，可以使用数组变量，而Sh不支持数组。<br />
</li>
<li>条件语句：在Bash中，可以使用[[ ]]或[
]来编写条件语句，而在Sh中，只能使用[ ]。<br />
</li>
<li>函数：Bash支持函数，可以使用function关键字来定义函数，而Sh不支持函数。<br />
</li>
<li>通配符：Bash支持更多的通配符，如{a,b}来表示a或b，而Sh只支持*和?。<br />
</li>
<li>算术运算：Bash支持算术运算，可以使用(( ))或$((
))来进行算术运算，而Sh不支持算术运算。</li>
</ol>
<p>总的来说，Bash脚本更加强大和灵活，语法上也更加丰富，但如果您只需要编写简单的脚本，Sh脚本可能更加适合。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的询问函数</title>
    <url>/blog/2023/10/11/data/linux/shell/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>它会在接收到有效输入前无限循环，知道用户给出合法的回应之后结束。<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ask() &#123;</span><br><span class="line">  while true; do</span><br><span class="line">    read -p &quot;$1 ([y]/n) &quot; -r</span><br><span class="line">    REPLY=$&#123;REPLY:-&quot;y&quot;&#125;</span><br><span class="line">    if [[ $REPLY =~ ^[Yy]$ ]]; then</span><br><span class="line">      return 1</span><br><span class="line">    elif [[ $REPLY =~ ^[Nn]$ ]]; then</span><br><span class="line">      return 0</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用bash的正则表达式</title>
    <url>/blog/2023/10/11/data/linux/shell/%E4%BD%BF%E7%94%A8bash%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>bash中怎么使用 <code>[[]]</code>
来判断某个字符串不匹配我规定的正则表达式模式？</p>
<p>在 Bash 中，你可以使用 <code>[[ ... ]]</code>
结构来进行模式匹配和正则表达式匹配。如果你想要检查一个字符串是否<strong>不匹配</strong>一个正则表达式模式，你可以使用
<code>!</code> 符号来进行否定。</p>
<p>下面是一个基本的例子，展示了如何使用 <code>[[ ... ]]</code>
来检查一个字符串是否不匹配一个正则表达式模式：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">string=<span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check if the string does NOT match the regular expression pattern</span></span><br><span class="line"><span class="keyword">if</span> [[ ! <span class="string">&quot;<span class="variable">$string</span>&quot;</span> =~ [0-9]+ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The string does NOT contain numbers.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The string contains numbers.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中：</p>
<ul>
<li><code>[[ ... ]]</code> 是 Bash 中的条件表达式结构。<br />
</li>
<li><code>"$string" =~ [0-9]+</code> 这部分检查 <code>$string</code>
是否匹配正则表达式
<code>[0-9]+</code>，这个正则表达式匹配一个或多个数字。<br />
</li>
<li><code>!</code>
符号用于否定条件，即它会反转条件的结果。如果字符串匹配正则表达式，<code>!</code>
会使整个条件变为假，反之亦然。</li>
</ul>
<p>所以，<code>if [[ ! "$string" =~ [0-9]+ ]]; then</code> 这行代码检查
<code>$string</code>
是否<strong>不包含</strong>一个或多个数字。如果不包含，它将输出 "The
string does NOT contain numbers."，否则输出 "The string contains
numbers."。</p>
<p><code>=~</code> 是什么符号？ 我可以用<code>==</code>吗？</p>
<p>在 Bash 脚本中，<code>=~</code> 是一个正则表达式匹配运算符，用于在
<code>[[ ... ]]</code>
结构中检查一个字符串是否匹配一个正则表达式。例如：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;abc123&quot;</span> =~ [0-9]+ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The string contains numbers.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure> 这段代码会检查字符串 <code>"abc123"</code>
是否包含一个或多个数字，并在条件为真时输出 "The string contains
numbers."。</p>
<p>而 <code>==</code>
运算符用于检查两个字符串是否相等，或者一个字符串是否匹配一个模式（注意，这里的模式不是正则表达式，而是通配符表达式）。例如：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;abc123&quot;</span> == <span class="string">&quot;abc123&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The strings are equal.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;abc123&quot;</span> == abc* ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The string matches the pattern.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>第一个 <code>if</code> 语句检查两个字符串是否相等，第二个
<code>if</code> 语句检查字符串 <code>"abc123"</code> 是否匹配模式
<code>abc*</code>（即任何以 "abc" 开头的字符串）。</p>
<p>总结一下：</p>
<ul>
<li><code>=~</code> 用于正则表达式匹配。<br />
</li>
<li><code>==</code> 用于字符串比较或模式匹配（使用通配符）。</li>
</ul>
<p>两者用途不同，不可以互换。</p>
<p>我可以用双引号把正则表达式模板括起来吗？</p>
<p>在 Bash 中，当你使用 <code>=~</code>
运算符进行正则表达式匹配时，你通常<strong>不应该</strong>用双引号来括起正则表达式。使用双引号会导致正则表达式被当作字符串字面量处理，而不是正则表达式。这里有一个例子来解释这一点：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">string=<span class="string">&quot;abc123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using quotes around the regular expression</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$string</span>&quot;</span> =~ <span class="string">&quot;[0-9]+&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Quoted regex: The string contains numbers.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Quoted regex: The string does NOT contain numbers.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Not using quotes around the regular expression</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$string</span>&quot;</span> =~ [0-9]+ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Unquoted regex: The string contains numbers.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Unquoted regex: The string does NOT contain numbers.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure> 输出将会是：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Quoted regex: The string does NOT contain numbers.</span><br><span class="line">Unquoted regex: The string contains numbers.</span><br></pre></td></tr></table></figure>
你可以看到，当正则表达式被双引号括起来时，它不会按预期工作。所以，当使用
<code>=~</code>
运算符时，你应该确保正则表达式没有被引号括起来，以确保它被正确解释。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>单引号、双引号、反引号的展开区别</title>
    <url>/blog/2023/10/11/data/linux/shell/%E5%8D%95%E5%BC%95%E5%8F%B7%E3%80%81%E5%8F%8C%E5%BC%95%E5%8F%B7%E3%80%81%E5%8F%8D%E5%BC%95%E5%8F%B7%E7%9A%84%E5%B1%95%E5%BC%80%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>单引号和双引号用于变量值出现空格时，比如 name=zhang san
这样执行就会出现问题，而必须用引号括起来，比如 name="zhang san"。</p>
<p>不过，引号有单引号和双引号之分，二者的主要区别在于，被单引号括起来的字符都是普通字符，就算特殊字符也不再有特殊含义；而被双引号括起来的字符中，"<span
class="math inline">\(&quot;、&quot;\&quot;和反引号是拥有特殊含义的，&quot;\)</span>"代表引用变量的值，而反引号代表引用命令。还是来看例子吧：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# name=sc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义变量name的值是sc</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo &#x27;$name&#x27;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">name</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果输出时使用单引号，则<span class="variable">$name</span>原封不动地输出</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo &quot;$name&quot;</span><br><span class="line">sc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果输出时使用双引号，则会输出变量name的值sc</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo `date`</span><br><span class="line">2013 10月 21 日星期一 18:16:33 CST</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反引号的命令会正常执行</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo &#x27;`date`&#x27;</span><br><span class="line">&#x27;date&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但是如果反引号括起来的命令又被单引号括起来，那么这条命令不会执行，`<span class="built_in">date</span>`会被当成普通字符</span></span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">[root@localhost ~]# echo &quot;`date`&quot;</span><br><span class="line">2013年 10月 21 日星期一 18:14:21 CST</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果被双引号括起来，那么这条命令又会正常执行</span></span><br></pre></td></tr></table></figure></p>
<p>所以，如果需要在双引号中间输出"$"和反引号，则要在符号前加入转义符""。</p>
<p><strong>反引号</strong><br />
如果需要调用命令的输出，或把命令的输出赋予变量，则命令必须使用反引号包含，这条命令才会执行，反引号的作用和
$(命令) 是一样的，但是反引号非常容易和单引号搞混，所以推荐大家使用
$(命令) 的方式引用命令的输出。命令如下：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo ls</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">如果命令不用反引号包含，那么命令不会执行，而是直接输出</span><br><span class="line">[root@localhost -]# echo `ls`</span><br><span class="line">anaconda-ks.cfg install.log install.log.syslog sh test testfile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只有用反引号包含命令，这条命令才会执行</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo $(date)</span><br><span class="line"></span><br><span class="line">2013年 10月 21 日 星期一 18:25:09 CST</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用用$(命令)的方式也是可以的</span></span><br></pre></td></tr></table></figure> 还是这句话，不管是从容易混淆的角度，还是从 POSIX
规范的角度来说，尽量使用 $(命令)
的方式来引用命令的输出，而不要使用反引号。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>常见判断条件</title>
    <url>/blog/2023/10/11/data/linux/shell/%E5%B8%B8%E8%A7%81%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<p>IF使用基础</p>
<p>单分支语句结构</p>
<p>双分支语句结构</p>
<p>多分支语句结构</p>
<p>条件表达式</p>
<p>文件表达式</p>
<p>数字表达式</p>
<p>字符串表达式</p>
<p>&amp;&amp;  || 使用</p>
<p>test与[  ]</p>
<p>[  ]  与[[  ]]</p>
<p>IF使用基础</p>
<p>单分支语句结构<br />
    if [ 条件表达式 ]; then<br />
        指令<br />
    fi</p>
<p>双分支语句结构<br />
    if [ 条件表达式 ]; then<br />
        指令一<br />
    else<br />
        指令二<br />
    fi</p>
<p>多分支语句结构<br />
    if [ -f file ]; then<br />
       echo "yes yes yes"<br />
    elif [ -z file ]; then<br />
       echo "yes yes"<br />
    else<br />
       echo "nonono"<br />
    fi</p>
<p>注意 if 的结构为 if then  else  fi<br />
从上面三个结构中可以看出，条件表达式的左右，以及[
]的左右都要有空格。</p>
<p>条件表达式</p>
<p>文件表达式</p>
<p>文件属性</p>
<p>-a file 如果file存在则为真</p>
<p>-b file 如果file存在且为块文件则为真</p>
<p>-c file 如果file存在且为字符文件则为真</p>
<p>-d file 如果file存在且是目录则为真</p>
<p>-e file 如果file存在则为真</p>
<p>-f file 如果file存在且为普通文件则为真</p>
<p>-g file
如果file存在且置位设置-组ID则为真，见参考【1】第4.4、12.3节</p>
<p>-h file 如果file存在且为符号连接则为真</p>
<p>-k file 如果file存在且其粘性位置位则为真，参考man chmod</p>
<p>-p file 如果file存在且为命令管道（FIFO）则为真</p>
<p>-r file 如果file存在且可读则为真</p>
<p>-s file 如果file存在且文件长度大于0则为真</p>
<p>-t fd 如果文件描述符fd打开且指向为终端则为真</p>
<p>-u file 如果file存在且设置-用户-ID置位则为真，见参考【1】第4.4节</p>
<p>-w file 如果file存在且可写则为真</p>
<p>-x file 如果file存在且可执行</p>
<p>-G file 如果file存在且由有效组ID拥有则为真，见参考【1】第4.4节</p>
<p>-L file 如果file存在且为符号连接则为真</p>
<p>-N file 如果file存在且在上次读后有修改（modified）则为真</p>
<p>-O file 如果file存在且由有效用户ID拥有则为真，见参考【1】第4.4节</p>
<p>-S file 如果file存在且是一个套接字则为真</p>
<p>file1 -ef file2 如果file1和file2指向同一个设备的inode则为真</p>
<p>file1 -nt file2
如果file1比file新（modified），或者file1存在file2不存在在为真</p>
<p>file1 -ot file2
如果file1比file旧（modified），或者file1存在file2不存在在为真</p>
<p>   -r file　　　　　用户可读为真<br />
   -w file　　　　　用户可写为真<br />
   -x file　　　　　用户可执行为真<br />
   -f file　　　　　文件为正规文件为真<br />
   -d file　　　　　文件为目录为真<br />
   -c file　　　　　文件为字符特殊文件为真<br />
   -b file　　　　　文件为块特殊文件为真<br />
   -s file　　　　　文件大小非0时为真<br />
   -t file　　　　　当文件描述符(默认为1)指定的设备为终端时为真</p>
<p>数字表达式</p>
<p>   int1 -eq int2　　　　两数相等为真<br />
   int1 -ne int2　　　　两数不等为真<br />
   int1 -gt int2　　　　int1大于int2为真<br />
   int1 -ge int2　　　　int1大于等于int2为真<br />
   int1 -lt int2　　　　int1小于int2为真<br />
   int1 -le int2　　　　int1小于等于int2为真</p>
<p>不要用=&lt;&gt;符号，如果要用的话</p>
<p>   整数比较<br />
   -eq       等于,如:if [ "$a" -eq "$b" ]<br />
   -ne       不等于,如:if [ "$a" -ne "$b" ]<br />
   -gt       大于,如:if [ "$a" -gt "$b" ]<br />
   -ge       大于等于,如:if [ "$a" -ge "$b" ]<br />
   -lt       小于,如:if [ "$a" -lt "$b" ]<br />
   -le       小于等于,如:if [ "$a" -le "$b" ]<br />
   &lt;       小于(需要双括号),如:(("$a" &lt; "$b"))<br />
   &lt;=       小于等于(需要双括号),如:(("$a" &lt;= "$b"))<br />
   &gt;       大于(需要双括号),如:(("$a" &gt; "$b"))<br />
   &gt;=       大于等于(需要双括号),如:(("$a" &gt;= "$b"))</p>
<p>字符串表达式</p>
<p>字符串测试</p>
<p>-z string</p>
<p>如果string长度为0则为真</p>
<p>string</p>
<p>-n string</p>
<p>如果string长度不为0则为真</p>
<p>string1 == string2</p>
<p>string1 = string2</p>
<p>如果string1和string2相等则为真，=只应由test使用</p>
<p>string1 != string2</p>
<p>如果字符串不相等则为真</p>
<p>string1 &lt; string2</p>
<p>如果按字典序string1在string2之前则为真</p>
<p>string1 &gt; string2</p>
<p>如果按字典序string1在string2之后则为真</p>
<p>    str1 = str2　　　　　　当两个串有相同内容、长度时为真</p>
<p>    str1 != str2　　　　　 当串str1和str2不等时为真</p>
<p>    -n str1　　　　　　　 当串的长度大于0时为真(串非空)</p>
<p>    -z str1　　　　　　　 当串的长度为0时为真(空串)</p>
<p>    str1　　　　　　　　 当串str1为非空时为真</p>
<p>&amp;&amp;  ||使用</p>
<p>在[  ]中不能用 &amp;&amp;  ||</p>
<p>要用</p>
<p>    -a 　 　　　　　 与</p>
<p>    -o　　　　　　　 或</p>
<p>    !　　　　　　　　非</p>
<p>如</p>
<p>    if [ $score -ge 0 -a $score -lt 60 ];</p>
<p>    then echo "sorry,you are lost!"</p>
<p>    elif [ $score -ge 60 -a $score -lt 85 ];</p>
<p>    then echo "just soso!"</p>
<p>    elif [ $score -le 100 -a $score -ge 85 ];</p>
<p>    then echo "good job!"</p>
<p>    else echo "input score is wrong , the range is [0-100]!"</p>
<p>    fi</p>
<p>如果一定要用&amp;&amp; ||则要到[[  ]]中使用，</p>
<p>test与[  ]</p>
<p>格式1：test <测试表达式></p>
<p>格式2：[<条件表达式>]</p>
<p>格式1和格式2是等价的。</p>
<p>test 一般在linux界面用，[   ]一般在if表达式用</p>
<p>如</p>
<p>    1、测试文件是否存在</p>
<p>    [root@node01 ~]# test -f file&amp;&amp; echo 1||echo 0</p>
<p>    0</p>
<p>    [root@node01 ~]# touch file</p>
<p>    [root@node01 ~]# test -f file&amp;&amp; echo 1||echo 0</p>
<p>    1</p>
<p>    [root@node01 ~]# test ! -f file&amp;&amp; echo 1||echo 0 取反</p>
<p>    0</p>
<p>    2、中括号</p>
<p>    [root@node01 ~]# [ -f file ]&amp;&amp; echo 1||echo 0</p>
<p>    1</p>
<p>    [root@node01 ~]# rm file</p>
<p>    [root@node01 ~]# [ -f file ]&amp;&amp; echo 1||echo 0</p>
<p>    0</p>
<p>    [root@node01 ~]# [ ! -f file ]&amp;&amp; echo 1||echo 0</p>
<p>    1</p>
<p>[  ]  与[[  ]]</p>
<p>[[ ]]，这是内置在shell中的一个命令，它就比刚才说的[
]强大的多了。支持字符串的模式匹配（使用=~操作符时甚至支持shell的正则表达式）。简直强大的令人发指！逻辑组合可以不使用test的-a,-o而使用&amp;&amp;,||这样更亲切的形式(针对c、Java程序员)。</p>
<ol type="1">
<li>首先，尽管很相似，但是从概念上讲，二者是不同层次的东西。</li>
</ol>
<p>"[["，是关键字，许多shell(如ash bsh)并不支持这种方式。ksh,
bash(据说从2.02起引入对[[的支持)等支持。</p>
<p>"["是一条命令，
与test等价，大多数shell都支持。在现代的大多数sh实现中，"["与"test"是内部(builtin)命令，换句话说执行"test"/"["时不会调用/some/path/to/test这样的外部命令(如果有这样的命令的话)。</p>
<p>2.[[]]结构比Bash版本的[]更通用。在[[和]]之间的所有的字符都不会被文件扩展或是标记分割，但是会有参数引用和命令替换。</p>
<p>用[[ ... ]]结构比用[ ...
]更能防止脚本里的许多逻辑错误。比如说，&amp;&amp;,||,<和>操作符能在一个[[]]测试里通过，但在[]结构会发生错误。</p>
<p>3.[ ...
]为shell命令，所以在其中的表达式应是它的命令行参数，所以串比较操作符"&gt;"
与"&lt;"必须转义，否则就变成IO改向操作符了(请参看上面2中的例子)。在[[中"\\&lt;"与"&gt;"不需转义；</p>
<p>由于"[["是关键字，不会做命令行扩展，因而相对的语法就稍严格些。例如</p>
<p>在[ ...
]中可以用引号括起操作符，因为在做命令行扩展时会去掉这些引号，而在[[ ...
]]则不允许这样做。</p>
<p>4.[[ ... ]]进行算术扩展，而[ ... ]不做</p>
<p>5.[[ ... &amp;&amp; ... &amp;&amp; ...  ]] 和 [ ... -a ... -a ...]
不一样，[[ ]] 是逻辑短路操作，而 [ ] 不会进行逻辑短路</p>
<p>————————————————</p>
<p>版权声明：本文为CSDN博主「xushiyu1996818」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：https://blog.csdn.net/xushiyu1996818/article/details/84545103</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>常见控制流程</title>
    <url>/blog/2023/10/11/data/linux/shell/%E5%B8%B8%E8%A7%81%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>Shell 流程控制</p>
<p>和 Java、PHP 等语言不一样，sh 的流程控制不可为空，如(以下为 PHP
流程控制写法)：</p>
<p>实例<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure> if (isset($_GET["q"])) {<br />
    search(q);<br />
}</p>
<p>else {</p>
<p>    // 不做任何事情</p>
<p>}</p>
<p>在 sh/bash 里可不能这么写，如果 else 分支没有语句执行，就不要写这个
else。</p>
<p>if else</p>
<p>fi</p>
<p>if 语句语法格式：</p>
<p>if conditionthen    command1<br />
    command2    ...    commandNfi</p>
<p>写成一行（适用于终端命令提示符）：</p>
<p>if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi</p>
<p>末尾的 fi 就是 if 倒过来拼写，后面还会遇到类似的。</p>
<p>if else</p>
<p>if else 语法格式：</p>
<p>if conditionthen    command1<br />
    command2    ...    commandNelse    commandfi</p>
<p>if else-if else</p>
<p>if else-if else 语法格式：</p>
<p>if condition1then    command1elif condition2then    command2else   
commandNfi</p>
<p>if else 的 [...] 判断语句中大于使用 -gt，小于使用 -lt。</p>
<p>if [ "<span class="math inline">\(a&quot; -gt &quot;\)</span>b" ];
then    ...<br />
fi</p>
<p>如果使用 ((...)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;。</p>
<p>if (( a &gt; b )); then    ...<br />
fi</p>
<p>以下实例判断两个变量是否相等：</p>
<p>实例</p>
<p>a=10</p>
<p>b=20</p>
<p>if [ <span class="math inline">\(a == \)</span>b ]</p>
<p>then</p>
<p>   echo "a 等于 b"</p>
<p>elif [ <span class="math inline">\(a -gt \)</span>b ]</p>
<p>then</p>
<p>   echo "a 大于 b"</p>
<p>elif [ <span class="math inline">\(a -lt \)</span>b ]</p>
<p>then</p>
<p>   echo "a 小于 b"</p>
<p>else</p>
<p>   echo "没有符合的条件"</p>
<p>fi</p>
<p>输出结果：</p>
<p>a 小于 b</p>
<p>使用 ((...)) 作为判断语句:</p>
<p>实例</p>
<p>a=10</p>
<p>b=20</p>
<p>if (( <span class="math inline">\(a == \)</span>b ))</p>
<p>then</p>
<p>   echo "a 等于 b"</p>
<p>elif (( <span class="math inline">\(a &gt; \)</span>b ))</p>
<p>then</p>
<p>   echo "a 大于 b"</p>
<p>elif (( <span class="math inline">\(a &lt; \)</span>b ))</p>
<p>then</p>
<p>   echo "a 小于 b"</p>
<p>else</p>
<p>   echo "没有符合的条件"</p>
<p>fi</p>
<p>输出结果：</p>
<p>a 小于 b</p>
<p>if else 语句经常与 test 命令结合使用，如下所示：</p>
<p>实例</p>
<p>num1=$[2*3]</p>
<p>num2=$[1+5]</p>
<p>if test <span class="math inline">\([num1] -eq \)</span>[num2]</p>
<p>then</p>
<p>    echo '两个数字相等!'</p>
<p>else</p>
<p>    echo '两个数字不相等!'</p>
<p>fi</p>
<p>输出结果：</p>
<p>两个数字相等!</p>
<p>for 循环</p>
<p>与其他编程语言类似，Shell支持for循环。</p>
<p>for循环一般格式为：</p>
<p>for var in item1 item2 ... itemNdo    command1<br />
    command2    ...    commandNdone</p>
<p>写成一行：</p>
<p>for var in item1 item2 ... itemN; do command1; command2… done;</p>
<p>当变量值在列表里，for
循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的
shell 命令和语句。in 列表可以包含替换、字符串和文件名。</p>
<p>in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p>
<p>例如，顺序输出当前列表中的数字：</p>
<p>实例</p>
<p>for loop in 1 2 3 4 5</p>
<p>do</p>
<p>    echo "The value is: $loop"</p>
<p>done</p>
<p>输出结果：</p>
<p>The value is: 1<br />
The value is: 2<br />
The value is: 3<br />
The value is: 4<br />
The value is: 5</p>
<p>顺序输出字符串中的字符：</p>
<p>#!/bin/bash</p>
<p>for str in This is a string<br />
do    echo $strdone</p>
<p>输出结果：</p>
<p>This<br />
is<br />
a<br />
string</p>
<p>while 语句</p>
<p>while
循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为：</p>
<p>while conditiondo    commanddone</p>
<p>以下是一个基本的 while 循环，测试条件是：如果 int 小于等于
5，那么条件返回真。int 从 1 开始，每次循环处理时，int 加
1。运行上述脚本，返回数字 1 到 5，然后终止。</p>
<p>实例</p>
<p>#!/bin/bash</p>
<p>int=1</p>
<p>while(( $int&lt;=5 ))</p>
<p>do</p>
<p>    echo $int</p>
<p>    let "int++"</p>
<p>done</p>
<p>以上实例使用了 Bash let
命令，它用于执行一个或多个表达式，变量计算中不需要加上 $
来表示变量，具体可查阅：<a
href="https://www.runoob.com/linux/linux-comm-let.html">Bash let
命令</a></p>
<p>。</p>
<p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<Ctrl-D>结束循环。</p>
<p>实例</p>
<p>echo '按下 <CTRL-D> 退出'</p>
<p>echo -n '输入你最喜欢的网站名: '</p>
<p>while read FILM</p>
<p>do</p>
<p>    echo "是的！$FILM 是一个好网站"</p>
<p>done</p>
<p>运行脚本，输出类似下面：</p>
<p>按下 <CTRL-D> 退出<br />
输入你最喜欢的网站名:菜鸟教程<br />
是的！菜鸟教程 是一个好网站</p>
<p>无限循环</p>
<p>无限循环语法格式：</p>
<p>while :<br />
do    commanddone</p>
<p>或者</p>
<p>while true<br />
do    commanddone</p>
<p>或者</p>
<p>for (( ; ; ))</p>
<p>until 循环</p>
<p>until 循环执行一系列命令直至条件为 true 时停止。</p>
<p>until 循环与 while 循环在处理方式上刚好相反。</p>
<p>一般 while 循环优于 until
循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p>
<p>until 语法格式:</p>
<p>until conditiondo    commanddone</p>
<p>condition 一般为条件表达式，如果返回值为
false，则继续执行循环体内的语句，否则跳出循环。</p>
<p>以下实例我们使用 until 命令来输出 0 ~ 9 的数字：</p>
<p>实例</p>
<p>#!/bin/bash</p>
<p>a=0</p>
<p>until [ ! $a -lt 10 ]</p>
<p>do</p>
<p>   echo $a</p>
<p>   a=<code>expr $a + 1</code></p>
<p>done</p>
<p>case ... esac<br />
case ... esac 为多选择语句，与其他语言中的 switch ... case
语句类似，是一种多分支选择结构，每个 case
分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case
... esac 语句，esac（就是 case 反过来）作为结束标记。</p>
<p>可以用 case
语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。</p>
<p>case ... esac 语法格式如下：</p>
<p>case 值 in<br />
模式1)    command1<br />
    command2    ...    commandN    ;;<br />
模式2)    command1<br />
    command2    ...    commandN    ;;<br />
esac</p>
<p>case
工作方式如上所示，取值后面必须为单词 in，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。</p>
<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号
* 捕获该值，再执行后面的命令。</p>
<p>下面的脚本提示输入 1 到 4，与每一种模式进行匹配：</p>
<p>实例</p>
<p>echo '输入 1 到 4 之间的数字:'</p>
<p>echo '你输入的数字为:'</p>
<p>read aNum</p>
<p>case $aNum in</p>
<p>    1)  echo '你选择了 1'</p>
<p>    ;;</p>
<p>    2)  echo '你选择了 2'</p>
<p>    ;;</p>
<p>    3)  echo '你选择了 3'</p>
<p>    ;;</p>
<p>    4)  echo '你选择了 4'</p>
<p>    ;;</p>
<p>    *)  echo '你没有输入 1 到 4 之间的数字'</p>
<p>    ;;</p>
<p>esac</p>
<p>输入不同的内容，会有不同的结果，例如：</p>
<p>输入 1 到 4 之间的数字:<br />
你输入的数字为:<br />
3<br />
你选择了 3</p>
<p>下面的脚本匹配字符串：</p>
<p>实例</p>
<p>#!/bin/sh</p>
<p>site="runoob"</p>
<p>case "$site" in</p>
<p>   "runoob") echo "菜鸟教程"</p>
<p>   ;;</p>
<p>   "google") echo "Google 搜索"</p>
<p>   ;;</p>
<p>   "taobao") echo "淘宝网"</p>
<p>   ;;</p>
<p>esac</p>
<p>输出结果为：</p>
<p>菜鸟教程</p>
<p>跳出循环</p>
<p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell
使用两个命令来实现该功能：break 和 continue。</p>
<p>break 命令</p>
<p>break 命令允许跳出所有循环（终止执行后面的所有循环）。</p>
<p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。</p>
<p>实例</p>
<p>#!/bin/bash</p>
<p>while :</p>
<p>do</p>
<p>    echo -n "输入 1 到 5 之间的数字:"</p>
<p>    read aNum</p>
<p>    case $aNum in</p>
<p>        1|2|3|4|5) echo "你输入的数字为 $aNum!"</p>
<p>        ;;</p>
<p>        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"</p>
<p>            break</p>
<p>        ;;</p>
<p>    esac</p>
<p>done</p>
<p>执行以上代码，输出结果为：</p>
<p>输入 1 到 5 之间的数字:3<br />
你输入的数字为 3!<br />
输入 1 到 5 之间的数字:7<br />
你输入的数字不是 1 到 5 之间的! 游戏结束</p>
<p>continue</p>
<p>continue 命令与 break
命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>
<p>对上面的例子进行修改：</p>
<p>实例</p>
<p>#!/bin/bash</p>
<p>while :</p>
<p>do</p>
<p>    echo -n "输入 1 到 5 之间的数字: "</p>
<p>    read aNum</p>
<p>    case $aNum in</p>
<p>        1|2|3|4|5) echo "你输入的数字为 $aNum!"</p>
<p>        ;;</p>
<p>        *) echo "你输入的数字不是 1 到 5 之间的!"</p>
<p>            continue</p>
<p>            echo "游戏结束"</p>
<p>        ;;</p>
<p>    esac</p>
<p>done</p>
<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo
"游戏结束" 永远不会被执行。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>检查上一条命令的退出码</title>
    <url>/blog/2023/10/11/data/linux/shell/%E6%A3%80%E6%9F%A5%E4%B8%8A%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%9A%84%E9%80%80%E5%87%BA%E7%A0%81/</url>
    <content><![CDATA[<p>Linux下每个程序都会有退出码，如果代码中没有写exit或者return没有显示地指明退出码，那默认就是0，遇到了系统调用的错误会返回系统错误码，如果是因为用户导致的错误退出了程序，那此时也只能是0，无法判断程序是正常结束还是因为遇到错误而结束。</p>
<p>shell中判断刚结束的程序退出码的代码可以如下：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">	echo &quot;Error: $output&quot;</span><br><span class="line">    binary_error=&quot;Invalid binary&quot;</span><br><span class="line">else</span><br><span class="line">    output=$&#123;output/ */&#125;</span><br><span class="line">    if [ &quot;$version&quot; != &quot;$output&quot; ]; then</span><br><span class="line">		echo &quot;$output != $version&quot;</span><br><span class="line">		binary_error=&quot;Invalid version&quot;</span><br><span class="line">    else</span><br><span class="line">	    echo &quot;$output&quot;</span><br><span class="line">		binary_error=&quot;&quot;</span><br><span class="line">	    return 0</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>检查系统中命令是否存在（已安装）</title>
    <url>/blog/2023/10/11/data/linux/shell/%E6%A3%80%E6%9F%A5%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%91%BD%E4%BB%A4%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%88%E5%B7%B2%E5%AE%89%E8%A3%85%EF%BC%89/</url>
    <content><![CDATA[<p>这段代码使用了条件语句和重定向操作符来检查系统中是否安装了curl命令。如果curl命令存在，则执行后续操作。</p>
<p>让我们来解释一下这段代码的具体含义：<br />
1. command -v curl<br />
用于检查curl命令是否存在。<br />
command -v<br />
命令会搜索系统的PATH环境变量中的目录，并输出找到的命令的完整路径。如果找不到命令，则不会有输出。<br />
2. &gt; /dev/null<br />
是重定向操作符，用于将命令的输出重定向到特殊设备文件/dev/null中。/dev/null是一个空设备文件，所有写入它的数据都会被丢弃，而无法读取。<br />
3. &amp;&amp;<br />
是逻辑与运算符，用于连接两个命令，当第一个命令成功执行后才执行第二个命令。</p>
<p>因此，整个代码的意思是，如果系统中安装了curl命令，则执行后续操作。<br />
以下是一个示例，演示如何使用这段代码：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查系统中是否安装了curl命令</span>  </span><br><span class="line">command -v curl &gt; /dev/null &amp;&amp; &#123;  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">如果curl命令存在，则执行后续操作</span>  </span><br><span class="line">  echo &quot;curl command is available&quot;  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">在这里可以编写针对curl命令的操作</span>  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>比较字符串变量</title>
    <url>/blog/2023/10/11/data/linux/shell/%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>7/27/2023, 12:08:09 PM</p>
<p>在 shell
脚本中，你可以使用条件语句来比较字符串变量是否等于某个字符串。常用的方法有以下两种：</p>
<ol type="1">
<li>使用双等号（==）==进行比较==：</li>
</ol>
<p>shellCopy Code</p>
<p><code>if [ "$variable" == "string" ]; then     # 字符串相等时要执行的命令 else     # 字符串不相等时要执行的命令 fi</code></p>
<p>注意，在双等号的两边都要留有空格。此方法对于大多数 shell
可以工作，但在某些 shell 中可能会有一些差异。</p>
<ol start="2" type="1">
<li>使用单等号（=）进行比较：</li>
</ol>
<p>shellCopy Code</p>
<p><code>if [ "$variable" = "string" ]; then     # 字符串相等时要执行的命令 else     # 字符串不相等时要执行的命令 fi</code></p>
<p>这种方法在所有 POSIX 兼容的 shell 中都有效。</p>
<p>在这两种方法中，<code>$variable</code>
是要比较的字符串变量，<code>"string"</code>
是你想要比较的字符串。需要注意的是，<code>$variable</code> 和
<code>"string"</code>
周围的引号是必需的，以避免由于空格或特殊字符而导致比较出错。</p>
<p>根据实际需求，你可以在 <code>if</code>
语句块中编写要在字符串相等或不相等时执行的命令。</p>
<p>7/27/2023, 12:09:42 PM</p>
<p>如果字符串本身没有空格等特殊字符，那引号就不是必须的？</p>
<p>7/27/2023, 12:09:57 PM</p>
<p>是的，如果字符串本身没有空格或其他特殊字符，引号在比较过程中通常不是必需的。在这种情况下，你可以直接进行比较，如下所示：</p>
<p>shellCopy Code</p>
<p><code>if [ $variable = string ]; then     # 字符串相等时要执行的命令 else     # 字符串不相等时要执行的命令 fi</code></p>
<p>注意，在这种情况下，变量和字符串的周围不需要放置引号。但是，如果字符串包含特殊字符（例如空格、通配符等），则必须使用引号来确保正确的比较。因此，在编写脚本时最好养成在变量和字符串周围使用引号的习惯，以处理各种情况并避免潜在的问题。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>解析命令行参数</title>
    <url>/blog/2023/10/11/data/linux/shell/%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>以下是一个示例，演示如何根据命令行参数执行不同的操作：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for opt in &quot;$@&quot;; do  </span><br><span class="line">  case $opt in  </span><br><span class="line">    -a)  </span><br><span class="line">      echo &quot;选项 -a 被指定&quot;  </span><br><span class="line">      # 在这里执行选项 -a 的相关操作  </span><br><span class="line">      ;;  </span><br><span class="line">    -b)  </span><br><span class="line">      echo &quot;选项 -b 被指定&quot;  </span><br><span class="line">      # 在这里执行选项 -b 的相关操作  </span><br><span class="line">      ;;  </span><br><span class="line">    *)  </span><br><span class="line">      echo &quot;未知选项: $opt&quot;  </span><br><span class="line">      ;;  </span><br><span class="line">  esac  </span><br><span class="line">done  </span><br></pre></td></tr></table></figure> 在上面的示例中，如果命令行参数包含-a，则输出选项 -a
被指定，并执行与选项-a<br />
相关的操作。如果命令行参数包含-b，则输出选项 -b
被指定，并执行与选项-b相关的操作。如果命令行参数不匹配任何已知选项，则输出未知选项:
$opt。请注意，$<span class="citation"
data-cites="表示所有的命令行参数">@表示所有的命令行参数</span>，"$@"用双引号括起来是为了确保参数中的空格和特殊字符不被解释为分隔符。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>输出脚本所在目录</title>
    <url>/blog/2023/10/11/data/linux/shell/%E8%BE%93%E5%87%BA%E8%84%9A%E6%9C%AC%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SCRIPT_PATH=$(<span class="built_in">cd</span> $(<span class="built_in">dirname</span> <span class="variable">$&#123;BASH_SOURCE[0]&#125;</span>); <span class="built_in">pwd</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\$&#123;SCRIPT_PATH&#125;=<span class="variable">$&#123;SCRIPT_PATH&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>vim7升级vim8</title>
    <url>/blog/2023/10/11/data/linux/vim/vim7%E5%8D%87%E7%BA%A7vim8/</url>
    <content><![CDATA[<p>参考<a
href="%5BCentos7%20升级vim7到vim8的两种方法_vim%207升级到8_eddie_k2的博客-CSDN博客%5D(https://blog.csdn.net/eddielee9217/article/details/113624794)">这篇博客</a></p>
<p>rpm 安装<br />
优缺点<br />
优点<br />
易于升级，易于卸载<br />
缺点<br />
不能指定python版本开启<br />
运行指令<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://mirror.ghettoforge.org/distributions/gf/gf-release-latest.gf.el7.noarch.rpm</span><br><span class="line">rpm --import http://mirror.ghettoforge.org/distributions/gf/RPM-GPG-KEY-gf.el7</span><br><span class="line">yum -y remove vim-minimal vim-common vim-enhanced sudo</span><br><span class="line">yum -y --enablerepo=gf-plus install vim-enhanced sudo</span><br></pre></td></tr></table></figure></p>
<p>编译安装<br />
优缺点<br />
优点<br />
扩展性强<br />
缺点<br />
安装难度对于初学者，不易上手<br />
卸载自带旧版 vim7.x<br />
yum remove vim*<br />
1<br />
下载源码<br />
## 推荐下载网址，Github上永世下载不了<br />
http://www.linuxfromscratch.org/blfs/view/stable-systemd/postlfs/vim.html</p>
<h2 id="下载-vim-8.2.0190.tar.gz">下载 vim-8.2.0190.tar.gz</h2>
<p>wget
http://anduin.linuxfromscratch.org/BLFS/vim/vim-8.2.0190.tar.gz</p>
<p>查看Vim是否支持python<br />
## 减号不支持 加号则是支持<br />
[root@m1 temp]# vim --version | grep python<br />
+cmdline_info +libcall -python +visual<br />
+comments +linebreak -python3 +visualextra</p>
<p>下载必须依赖<br />
yum install -y ruby ruby-devel lua lua-devel luajit luajit-devel ctags
git python python-devel python3 python3-devel tcl-devel perl perl-devel
perl-ExtUtils*<br />
1<br />
安装步骤<br />
1、下载<br />
链接：https://pan.baidu.com/s/1Lxg8A-RMLyP7Mjwo8CX0XA 提取码：wqoc</p>
<p>2、解压<br />
tar -zxf vim-8.2.0190.tar.gz<br />
cd vim-8.2.0190/<br />
cd src/</p>
<p>3、通过configure配置安装路径，并支持python2.7、python3<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --with-features=huge \</span><br><span class="line">        --enable-multibyte \</span><br><span class="line">        --enable-rubyinterp=yes \</span><br><span class="line">        --enable-python3interp=yes \</span><br><span class="line">        --with-python-config-dir=/usr/local/python3/lib/python3.8/config-3.8-x86_64-linux-gnu \</span><br><span class="line">	--with-python-config-dir=/usr/lib64/python2.7/config \</span><br><span class="line">        --enable-perlinterp=yes \</span><br><span class="line">        --enable-luainterp=yes \</span><br><span class="line">        --enable-gui=gtk2 \</span><br><span class="line">        --enable-cscope \</span><br><span class="line">        --prefix=/usr/local/vim</span><br></pre></td></tr></table></figure></p>
<p>4、编译安装<br />
make &amp;&amp; make install</p>
<p>5、验证<br />
/usr/local/vim/bin/vim -version</p>
<p>6、创建软连接<br />
ln -s /usr/local/vim/bin/vim /usr/bin/vim</p>
<p>问题汇总<br />
错误1<br />
## 例1：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objects/main.o: In function `getout&#x27;:</span><br><span class="line">/root/temp/vim-8.2.0190/src/main.c:1689: undefined reference to `perl_end&#x27;</span><br><span class="line">objects/buffer.o: In function `free_buffer&#x27;:</span><br><span class="line">/root/temp/vim-8.2.0190/src/buffer.c:901: undefined reference to `perl_buf_free&#x27;</span><br><span class="line">objects/evalfunc.o: In function `f_perleval&#x27;:</span><br><span class="line">/root/temp/vim-8.2.0190/src/evalfunc.c:5063: undefined reference to `do_perleval&#x27;</span><br><span class="line">objects/ex_docmd.o:(.rodata+0x46e8): undefined reference to `ex_perl&#x27;</span><br><span class="line">objects/ex_docmd.o:(.rodata+0x4708): undefined reference to `ex_perldo&#x27;</span><br><span class="line">objects/window.o: In function `win_free&#x27;:</span><br><span class="line">/root/temp/vim-8.2.0190/src/window.c:4899: undefined reference to `perl_win_free&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">link.sh: Linking failed</span><br><span class="line">make: *** [vim] Error 1</span><br></pre></td></tr></table></figure></p>
<p>出现上述问题解决办法：<br />
1. 查看依赖是否安装<br />
2. 创建 xsubpp 文件夹 cd /usr/share/perl5/ExtUtils &amp;&amp; mkdir
xsubpp<br />
3.
根据makefile或者第一个报错的指引，找到生成if_perl.c的命令，手动生成即可：</p>
<p>/bin/perl -e 'unless ( $] &gt;= 5.005 ) { for (qw(na defgv errgv)) {
print "#define PL_$_ $_" }}' &gt; auto/if_perl.c</p>
<p>/bin/perl /usr/share/perl5/ExtUtils/xsubpp -prototypes -typemap  
/usr/share/perl5/ExtUtils/typemap if_perl.xs &gt;&gt; auto/if_perl.c</p>
<ol start="4" type="1">
<li>回到Vim的 $PATH/src<br />
make clean<br />
make &amp;&amp; make install</li>
</ol>
<p>————————————————<br />
版权声明：本文为CSDN博主「eddie_k2」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：https://blog.csdn.net/eddielee9217/article/details/113624794</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim8文本处理实战节选</title>
    <url>/blog/2023/10/11/data/linux/vim/vim8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98%E8%8A%82%E9%80%89/</url>
    <content><![CDATA[<p>通过阅读本章，读者将能更加得心应手地在日常任务中使用Vim。本章使用一个<a
href="https://so.csdn.net/so/search?q=Python&amp;spm=1001.2101.3001.7020">Python</a>工程作为示例，模拟了一系列日常编码的场景。当然，读者完全可以拿自己手头的项目练手；只不过，本章中的使用场景不一定都适用于读者自己的代码。</p>
<p>本章包括如下主题。</p>
<ul>
<li>介绍一种粗暴但快捷的Vim插件安装方式。<br />
</li>
<li>介绍如何使用缓冲区、窗口、标签页和折叠来处理多个文件或长文件，从而使工作区更为整洁。<br />
</li>
<li>介绍插件Netrw、NERDTree、Vinegar和CtrlP，通过这些插件，读者可以在不退出Vim的情况下浏览复杂的文件树。<br />
</li>
<li>介绍文件中的高级文本浏览方式、极其高效的光标移动插件EasyMotion以及多种文本对象，介绍通过grep和ack实现跨文件的搜索。<br />
</li>
<li>介绍如何利用寄存器来复制和粘贴。</li>
</ul>
<h1 id="技术要求">1　技术要求</h1>
<p>本章将介绍如何用Vim在一个Python工程上作业。读者可以在异步社区中找到本章用到的代码。</p>
<h1 id="安装插件">2　安装插件</h1>
<p>本章会介绍几个Vim插件，但暂时不会涉及较为复杂的插件管理，相关的内容参见第3章。</p>
<p>首先，读者必须要做好准备工作。</p>
<p>1．创建一个存储插件的目录，执行下列命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p ~/.vim/pack/plugins/start</span><br></pre></td></tr></table></figure>
<p>如果在Windows系统中使用gVim，则需要在用户目录(通常是C:甥敳獲
)下创建vimfiles目录，然后在其中创建子目录pack plugins start。</p>
<p>2．使Vim能够自动加载每个插件的文档(Vim默认不会这么做)。在~/.vimrc文件(在Windows系统中为用户目录下的_vimrc文件)中添加下列代码。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">packloadall               <span class="string">&quot; 加载所有插件silent! helptags ALL      &quot;</span> 为所有插件加载帮助文档</span><br></pre></td></tr></table></figure>
<p>然后，每次安装插件都可按照下列步骤进行。</p>
<p>1．在 GitHub
上找到想要安装的插件。比如，读者想安装<code>scrooloose/nerdtree</code>(注意，这里的<code>scrooloose/nerdtree</code>为该GitHub仓库的唯一标识，实际地址为
https://github.com/scrooloose/nerdtree.git
)。假设读者已经安装了Git，则可以找到此Git仓库的克隆地址，然后运行如下命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/scrooloose/nerdtree.git ~/.vim/pack/plugins/start/nerdtree</span><br></pre></td></tr></table></figure>
<p>如果读者没有安装Git，或者在Windows系统中使用gVim，则可以在GitHub页面上找到
<strong>克隆或下载(Clone or download)</strong>
按钮，下载ZIP压缩包，然后将其解压到相应的插件目录中，比如在Linux系统中为目录<code>~/.vim/pack/ plugins/start/nerdtree</code>，而在Windows系统中为用户目录下的子目录<code>vimfiles/pack/plugins/start/nerdtree</code>。</p>
<p>2．重启Vim之后，即可使用插件进行相关操作。</p>
<h1 id="组织工作区">3　组织工作区</h1>
<p>到目前为止，本书还只是用Vim处理单个文件。但是在编写程序时，经常需要同时处理多个文件，涉及来回切换、跨文件编辑或到其他界面查询资料等操作。幸运的是，Vim提供了一个能够处理多个文件的插件。</p>
<ul>
<li>Vim内部用缓冲区来表示文件；通过缓冲区，读者可以在不同文件之间快速切换。<br />
</li>
<li>Vim用多个窗口在同一屏幕中显示多个文件。<br />
</li>
<li>Vim用标签页对窗口进行分组。<br />
</li>
<li>Vim用折叠效果来隐藏或展开一个文件的部分内容，从而让读者可以更容易地浏览文件的内容。</li>
</ul>
<p>图1中展示了上述要点，解释如下。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/ffd09a66fc89d4b124da5e8db84def86.png"
alt="ffd09a66fc89d4b124da5e8db84def86.png" />
<figcaption
aria-hidden="true">ffd09a66fc89d4b124da5e8db84def86.png</figcaption>
</figure>
<p>图1</p>
<ul>
<li>多个窗口用于同时打开多个文件(farm.py、animal/cat.py和animal_farm.py)。<br />
</li>
<li>顶部显示有两个标签页(3 farm.py和a/dog.py)。<br />
</li>
<li>以+--开头的行表示折叠，它隐藏了文件的部分内容。</li>
</ul>
<p>本节将详细介绍窗口、标签页和折叠，通过这些功能，读者可以在工作中同时处理任意多个文件。</p>
<h1 id="缓冲区">3.1　缓冲区</h1>
<p>缓冲区是文件的内部表示，每个打开的文件都有一个缓冲区。比如，通过命令行vim
animal_farm.py打开一个文件，然后可以用:ls命令看到现有的缓冲区列表。</p>
<p>很多命令都有别名或等价命令，:ls也不例外，它和:buffers及:files实现的是同样的功能，读者可以从中选择一个最容易记的命令。</p>
<p>图2所示为ls命令的执行结果(最下面的那3行)。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/90e48a55f0e640db6701c33b8349220a.png"
alt="90e48a55f0e640db6701c33b8349220a.png" />
<figcaption
aria-hidden="true">90e48a55f0e640db6701c33b8349220a.png</figcaption>
</figure>
<p>图2</p>
<p>图2.2中的状态栏显示了已经打开的缓冲区(这里只有一个)的相关信息，这些信息的含义如下。</p>
<ul>
<li>1为缓冲区编号，在整个Vim会话中，它的值保持不变。<br />
</li>
<li>% 表示该缓冲区位于当前窗口中。<br />
</li>
<li>a 表示该缓冲区处于活动状态，即它已被加载并可见。<br />
</li>
<li>"animal_farm.py"为文件名。<br />
</li>
<li>line 30表示当前光标位置。</li>
</ul>
<p>现在，用下列命令打开另一个文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:e animals/cat.py</span><br></pre></td></tr></table></figure>
<p>然后，可以看到之前打开的文件已经被当前文件所取代。不过，animal_farm.py仍然存储在某个缓冲区中，读者可以再次用:ls命令将其显示出来。</p>
<p>现在，可以看到两个文件名都被列出来了，如图3所示。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/2a54c10dd57094b7b09d2880a88787d7.png"
alt="2a54c10dd57094b7b09d2880a88787d7.png" />
<figcaption
aria-hidden="true">2a54c10dd57094b7b09d2880a88787d7.png</figcaption>
</figure>
<p>图3</p>
<p>那么怎样才能跳转到之前的文件呢？</p>
<p>Vim通过数字和名称来标识每个缓冲区，在同一个Vim会话中，它们都是唯一的(除非退出Vim)。为了在不同的缓冲区之间切换，可使用:b命令，其参数为缓冲区的编号数字。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">:<span class="selector-tag">b</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>:b 1命令中的空格可以省略，得到简化版的命令:b1。</p>
<p>通过一条很简单的命令就可以回到原来的文件。由于缓冲区还可以用文件名来标识，因此读者可以用文件名的一部分来切换缓冲区。下列命令将打开animals/cat.py的缓冲区。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">:<span class="selector-tag">b</span> <span class="selector-tag">cat</span></span><br></pre></td></tr></table></figure>
<p>不过，如果名称匹配了多个缓冲区，则Vim会报错。比如，用下面的命令查找所有文件名包含py的缓冲区。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">:<span class="selector-tag">b</span> <span class="selector-tag">py</span></span><br></pre></td></tr></table></figure>
<p>Vim的状态栏中会显示错误，如图4所示。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/e6419b42b1bce0be22764402f7e6db64.png"
alt="e6419b42b1bce0be22764402f7e6db64.png" />
<figcaption
aria-hidden="true">e6419b42b1bce0be22764402f7e6db64.png</figcaption>
</figure>
<p>图4</p>
<p>为解决这个问题，可以使用Tab键补全文件名，从而实现在不同缓冲区之间循环切换。输入:b
py(先不要按Enter键)，然后按Tab键，在所有匹配的结果之间循环遍历。</p>
<p>读者也可以使用:bn(:bnext)和:bp(:bprevious)命令循环遍历缓冲区。</p>
<p>当不再需要某缓冲区的时候(如不再需要编辑该文件)，可以将其删除。通过如下命令可以将一个缓冲区从打开的缓冲区列表中删除，而无须退出Vim。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:bd</span></span><br></pre></td></tr></table></figure>
<p>但如果没有保存当前缓冲区，则Vim会报错。因此，在不小心删除缓冲区之前，读者还有一次保存文件的机会。</p>
<h1 id="插件unimpaired">3.2　插件——unimpaired</h1>
<p>Tim
Pope的vim-unimpaired是一个Vim插件,它为很多内置命令(以及一些新的命令)添加映射。本书作者每天都会使用这个插件，因为它提供了更为直观的映射，比如]b和[b用于循环遍历缓冲区，]f和[f用于遍历目录中的文件。该插件可以在GitHub仓库tpope/vim-unimpaired中找到(安装方法参见本章2.2节)。</p>
<p>下面是vim-unimpaired提供的部分映射。</p>
<ul>
<li>]b和[b循环遍历缓冲区。<br />
</li>
<li>]f和[f循环遍历同一目录中的文件，并打开为当前缓冲区。<br />
</li>
<li>]l和[l遍历位置列表(参见第5章)。<br />
</li>
<li>]q和[q遍历快速修复列表(参见第5章)。<br />
</li>
<li>]t和[t遍历标签列表(参见第4章)。</li>
</ul>
<p>此插件还支持用少数几次按键来切换某些选项，比如yos切换拼写检查，或yoc切换光标行高亮显示。更多功能参见:help
unimpaired中vim-unimpaired所提供的完整映射和功能清单。</p>
<h1 id="窗口">3.3　窗口</h1>
<p>Vim将缓冲区加载到窗口中。一个屏幕上可以同时显示多个窗口，它们将屏幕分割成几块。</p>
<p><strong>1．窗口的创建、删除和跳转</strong></p>
<p>本节将介绍Vim窗口的使用方式。首先，打开animal_farm.py文件(在命令行中执行$
vim animal_farm.py或从Vim中执行:e animal_farm.py)。</p>
<p>然后，使用如下命令将窗口分割成两个，其中一个显示新的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">split</span> animals/cat.py</span><br></pre></td></tr></table></figure>
<p>:split命令可以简化为:sp。</p>
<p>可以看到animals/cat.py被打开，显示在原文件上方的窗口中，而且光标也出现在里面，如图5所示。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/9e390ff75df4bc5b6a5e1bae9f99593d.png"
alt="9e390ff75df4bc5b6a5e1bae9f99593d.png" />
<figcaption
aria-hidden="true">9e390ff75df4bc5b6a5e1bae9f99593d.png</figcaption>
</figure>
<p>图5</p>
<p>也可以使用下面的命令按水平方向分割窗口。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:vsplit</span> farm.py</span><br></pre></td></tr></table></figure>
<p>如图6所示，当前窗口又水平分隔出一个新的窗口(光标也随之移动到左边的新窗口中)。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/ad302e7b809816bb1fa99f857e921677.png"
alt="ad302e7b809816bb1fa99f857e921677.png" />
<figcaption
aria-hidden="true">ad302e7b809816bb1fa99f857e921677.png</figcaption>
</figure>
<p>图6</p>
<p>:vs是:vsplit的简化版。</p>
<p>通过组合:split和:vsplit，可以生成任意多个窗口。</p>
<p>目前本书提到的所有命令都适用于窗口，包括切换缓冲区。为了使光标能在不同窗口间移动，先按Ctrl
+ w组合键，然后输入一个方向键：h、j、k、l中的一个或键盘方向键。</p>
<p>按Ctrl + h组合键，之后再按Ctrl + j组合键(Ctrl键可以不松开，记为Ctrl +
w,j组合键)，光标会进入下面的窗口，而使用Ctrl +
w,k组合键则进入上面的窗口。</p>
<p>如果经常使用窗口，读者可以按照如下配置绑定快捷键。" 使用 +
hjkl快速在窗口间跳转 noremap noremap noremap noremap</p>
<p>然后，就可以用Ctrl + h组合键跳到左边的窗口，用Ctrl +
j组合键跳到底部的窗口，依此类推。</p>
<p>读者可以用下列方式来关闭窗口。</p>
<ul>
<li>使用Ctrl + w,q组合键关闭当前窗口。<br />
</li>
<li>使用:q命令关闭窗口并卸载缓冲区；不过，当只有一个窗口打开的时候，这会导致退出Vim。<br />
</li>
<li>使用:bd命令删除当前缓冲区，并关闭当前窗口。<br />
</li>
<li>使用Ctrl +
w,o组合键(或:only，或:on命令)关闭除当前窗口之外的所有窗口。</li>
</ul>
<p>当打开了多个窗口时，可通过:qa命令关闭所有窗口并退出。也可以结合:w命令，即:wqa，它会先保存所有打开的文件，再退出Vim。</p>
<p>如果只想关闭缓冲区，而保留它所在的窗口，则可以在.vimrc文件中加入如下配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; 关闭缓冲区而不关闭窗口command! Bd :bp | :sp | :bn | :bd</span><br></pre></td></tr></table></figure>
<p>然后，读者就可以使用:Bd来关闭缓冲区，而保留分割窗口。</p>
<p><strong>2．窗口的移动</strong></p>
<p>窗口也可以移动、交换或改变大小。因为Vim中没有鼠标拖曳的功能，所以只能记住一些命令了。</p>
<p>读者并不需要记住所有这些命令，只要知道Vim支持哪些窗口操作，剩下的操作可以通过查看文档。使用:help
window-moving和:help window-
resize打开Vim手册中相应的条目，即可找到所有相关的快捷键。</p>
<p>窗口命令的快捷键都要先按Ctrl +
w组合键，后面跟一个大写的方向键(H、J、K和L中的一个)，当前窗口会被移动到相应的位置。</p>
<ul>
<li>使用Ctrl + w,H组合键将当前窗口移动到屏幕的最左边。<br />
</li>
<li>使用Ctrl + w,J组合键将当前窗口移动到屏幕的底部。<br />
</li>
<li>使用Ctrl + w,K组合键将当前窗口移动到屏幕的顶部。<br />
</li>
<li>使用Ctrl + w,L组合键将当前窗口移动到屏幕的最右边。</li>
</ul>
<p>比如图 7 所示的窗口布局(先打开animal_farm.py，然后再依次运行:sp
animals/cat.py和:vs farm.py，可得到这个布局)。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/d9dac5d19679d31805b4eb1420aff38c.png"
alt="d9dac5d19679d31805b4eb1420aff38c.png" />
<figcaption
aria-hidden="true">d9dac5d19679d31805b4eb1420aff38c.png</figcaption>
</figure>
<p>图7</p>
<p>注意，图7中光标位于animals/cat.py文件所在的窗口中。通过前面介绍的几个快捷键，可以让这个窗口朝不同的方向移动。</p>
<ul>
<li>使用Ctrl +
w,H组合键将animals/cat.py移动到最左边，如图8(a)所示。<br />
</li>
<li>使用Ctrl +
w,J组合键将animals/cat.py移动到底部，而且左右分割变成了上下分割，如图8(b)所示。<br />
</li>
<li>使用Ctrl + w,K组合键将animals/cat.py移动到顶部，如图8(c)所示。<br />
</li>
<li>使用Ctrl +
w,L组合键将animals/cat.py移动到最右边，如图8(d)所示。</li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/af378d3237110a19eacccfe9ad676536.png"
alt="af378d3237110a19eacccfe9ad676536.png" />
<figcaption
aria-hidden="true">af378d3237110a19eacccfe9ad676536.png</figcaption>
</figure>
<ol type="a">
<li></li>
</ol>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/86c18600516b5a1680f5b17a3852eea2.png"
alt="86c18600516b5a1680f5b17a3852eea2.png" />
<figcaption
aria-hidden="true">86c18600516b5a1680f5b17a3852eea2.png</figcaption>
</figure>
<ol start="2" type="a">
<li></li>
</ol>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/7b3e70fc758439fedfac115696a2e464.png"
alt="7b3e70fc758439fedfac115696a2e464.png" />
<figcaption
aria-hidden="true">7b3e70fc758439fedfac115696a2e464.png</figcaption>
</figure>
<ol start="3" type="a">
<li></li>
</ol>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/f2e2feeff5b6950e1c1bd2221b73500b.png"
alt="f2e2feeff5b6950e1c1bd2221b73500b.png" />
<figcaption
aria-hidden="true">f2e2feeff5b6950e1c1bd2221b73500b.png</figcaption>
</figure>
<ol start="4" type="a">
<li></li>
</ol>
<p>图8</p>
<p>若想修改一个窗口的内容，则只需要跳转到这个窗口，然后用:b命令来选择所需的缓冲区。不过，也有一些快捷键可以用于交换两个窗口的内容。</p>
<ul>
<li>使用Ctrl +
w,r组合键将当前行或当前列(行优先于列)中的每个窗口的内容向右或向下移动。使用Ctrl
+ w,R组合键则以相反的方向执行类似的操作。<br />
</li>
<li>使用Ctrl +
w,x组合键将当前窗口与下一个窗口的内容交换(如果当前窗口是最后一个，则与前一个交换)。</li>
</ul>
<p>Vim内部用数字来标识窗口。不过，与缓冲区不同，窗口的编号是随着布局变化而改变的，而且并没有直接的方法来修改窗口编号。有些窗口管理命令以窗口编号为参数，但本书不会涉及这部分内容。有一条原则仅供参考，窗口编号顺序为由上至下、由左至右递增。</p>
<p><strong>3．改变窗口的大小</strong></p>
<p>Vim窗口默认的宽高比为50/50，这可能并不满足读者的需求，因此窗口的大小可以通过一些方法来改变。</p>
<p>快捷键Ctrl +
w,=(按Ctrl+w后再按=键)能够将所有打开窗口的宽和高调整为一致。如果不恰当地调整了窗口大小，这个命令将非常有用。</p>
<p>:resize命令会增加或减少当前窗口的高度，而:vertical
resize将调整窗口的宽度。读者还可以使用如下命令。</p>
<ul>
<li>:resize +N用于将当前窗口的高度增加N行。<br />
</li>
<li>:resize -N用于将当前窗口的高度减少N行。<br />
</li>
<li>:vertical resize +N用于将当前窗口的宽度增加N列。<br />
</li>
<li>:vertical resize -N用于将当前窗口的宽度减少N列。</li>
</ul>
<p>:resize和:vertical resize可分别简写为:res和:vert
res。另外，还有将窗口高度和宽度改变一行/列的快捷键：Ctrl + w,-和Ctrl +
w,+用于调整高度，而Ctrl+w,&gt;和Ctrl + w,</p>
<p>两种命令都可以将宽度/高度设置为具体的行数/列数。</p>
<ul>
<li>:resize N用于将窗口高度设置为N。<br />
</li>
<li>:vertical resize N用于将窗口宽度设置为N。</li>
</ul>
<h1 id="标签页">3.4　标签页</h1>
<p>在很多现代编辑器中，标签页(Tabs)用于表示不同的文件。在Vim中自然也是如此，但读者需要考虑其原始目的。</p>
<p>Vim用标签页来组织一个窗口的集合，进而支持在不同的窗口集合之间切换，这让用户方便地拥有了多个工作区。标签页通常用来在同一个Vim会话中区分不同的问题或者文件集合。标签页功能不一定是一个频繁使用的功能，但如果希望在不同项目或同一项目的不同上下文之间切换，那么标签页将是一个不错的选择。</p>
<p>用户愿意使用标签页的另一个原因可能与Vim的diff功能有关，因为diff作用于一个标签页内。更多详情请参考第5章中关于vimdiff的介绍。</p>
<p>在一个新标签页中打开一个空缓冲区的命令如下。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:tabnew</span></span><br></pre></td></tr></table></figure>
<p>在新标签页中打开一个已有文件的命令为:tabnew 。</p>
<p>如图9所示，标签页显示在屏幕的顶部。在标记为3
farm.py的标签页中打开了三个窗口及一个活动缓冲区farm.py。[No
Name]标签页则是刚才打开过的空缓冲区。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/1dec86ece1f794841956d1f8e8f8da14.png"
alt="1dec86ece1f794841956d1f8e8f8da14.png" />
<figcaption
aria-hidden="true">1dec86ece1f794841956d1f8e8f8da14.png</figcaption>
</figure>
<p>图9</p>
<p>在一个标签页中，可以通过常用的方式(:e
)来加载文件，也可以用:b命令在不同缓冲区之间切换。</p>
<p>为了在不同标签页之间跳转，可以使用如下命令。</p>
<ul>
<li>快捷键gt或:tabnext命令用于切换到下一个标签页。<br />
</li>
<li>快捷键gT或:tabprevious命令用于切换到上一个标签页。</li>
</ul>
<p>标签页可通过:tabclose命令来关闭，标签页关闭也会导致其中的窗口关闭(如果只剩一个标签页，则需要用:q来关闭)。</p>
<p>:tabmove
N命令将当前标签页移动到第N个标签页之后(如果N为0，则变成第一个标签页)。</p>
<h1 id="折叠">3.5　折叠</h1>
<p>Vim为浏览大型文件提供的一个强大工具是折叠。折叠功能支持文件部分内容的隐藏，隐藏的依据既可以是预定义的规则，也可以是手动添加的折叠标记。</p>
<p>如图10所示，animal_farm.py中的部分代码片断被折叠了，代码中每个方法的具体内容被隐藏了，从而可以在整体上来查看代码。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/e8a0250d571833a9fbc3ed37861e17ac.png"
alt="e8a0250d571833a9fbc3ed37861e17ac.png" />
<figcaption
aria-hidden="true">e8a0250d571833a9fbc3ed37861e17ac.png</figcaption>
</figure>
<p>图10</p>
<p><strong>1．折叠Python代码</strong></p>
<p>因为本书以Python编程为例，所以这里只介绍Python示例代码的折叠方式。首先，需要在.vimrc文件中将foldmethod设置为indent，设置代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set foldmethod=indent</span><br></pre></td></tr></table></figure>
<p>不要忘记重新加载~/.vimrc，方法是重启Vim或在Vim中执行:source
$MYVIMRC命令。</p>
<p>设置foldmethod为indent，使Vim基于缩进来折叠代码。</p>
<p>再次打开animal_farm.py，可以看到该文件中的部分代码已经被隐藏，如图11所示。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/e8a0250d571833a9fbc3ed37861e17ac.png"
alt="e8a0250d571833a9fbc3ed37861e17ac.png" />
<figcaption
aria-hidden="true">e8a0250d571833a9fbc3ed37861e17ac.png</figcaption>
</figure>
<p>图11</p>
<p>将光标移动到其中一个折叠行上，输入zo可以打开当前折叠，如图12所示。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/4f5a6f5ef1d7322215c6f57fdaf19949.png"
alt="4f5a6f5ef1d7322215c6f57fdaf19949.png" />
<figcaption
aria-hidden="true">4f5a6f5ef1d7322215c6f57fdaf19949.png</figcaption>
</figure>
<p>图12</p>
<p>只要光标在一个潜在的折叠文本中(本例中为缩进的代码块)，输入zc都会将此折叠关闭。</p>
<p>为了方便看清折叠的位置，可以使用:set
foldcolumn=N命令，其中N的取值为0～12。这会告诉Vim用从屏幕左边开始的N列来标记折叠，其中符号-表示一个打开的折叠，符号|表示打开的折叠的内容，符号+表示关闭的折叠。</p>
<p>输入za可切换折叠状态(打开关闭的折叠或关闭打开的折叠)。输入zR和zM分别用于同时打开和关闭所有折叠。</p>
<p>将foldmethod设置为自动类型(如indent)会默认将所有文件折叠。这只是一种偏好，读者也可能会选择在打开新文件时打开折叠。在.vimrc文件中添加autocmd
BufRead * normal
zR会在打开新文件时令折叠处于打开状态，即Vim在读取新的缓冲区时执行zR命令(打开所有折叠)。</p>
<p><strong>2．折叠的类型</strong></p>
<p>从某种意义上来说，Vim在折叠代码方面是比较智能的，而且支持多种折叠方式。折叠的方法由.vimrc文件中的foldmethod选项来指定。Vim支持如下折叠方式。</p>
<ul>
<li>manual：手动折叠，这种方法对于长文本而言并不适用。<br />
</li>
<li>indent：基于缩进的折叠，这对于依赖缩进的编程语言非常合适(不管哪种语言，标准的编码风格中总是会采用某种一致性的缩进。因此，当读者想要快速隐藏不关心的代码时，indent折叠方式不失为一种高效率的选择)。<br />
</li>
<li>expr：基于正则表达式的折叠。如果读者想要用复杂的规则来定义折叠，那么可以选择这种方式。<br />
</li>
<li>marker：使用文本中特殊的标记来定义折叠，比如<code>&#123;&#123;&#123;`和`&#125;&#125;&#125;</code>。这种方法对于管理很长的.vimrc文件非常有效，但是在Vim之外不常用，因为这种方式需要修改文件内容。<br />
</li>
<li>syntax提供了可识别语法的折叠，但它并非对所有语言都开箱即用(不支持Python)。<br />
</li>
<li>diff：当Vim处于diff模式时会自动采用这种折叠方式，diff模式下需要展示两个文件的不同之处，而相同之处往往需要隐藏起来(参见第5章)。</li>
</ul>
<p>设置折叠方式的方法为在.vimrc文件中加入set foldmethod=。</p>
<h1 id="文件树的浏览">4　文件树的浏览</h1>
<p>软件项目往往包含大量的文件和目录，能够利用Vim快速浏览和展示这些文件和目录将是一件很方便的事。本节介绍5种不同的文件浏览方式，它们分别是内置的Netrw文件管理器、启用了wildmenu的:e命令、NERDTree、Vinegar和CtrlP插件。这些方式都可用于处理文件，并可按需求组合使用。</p>
<h1 id="本文截选自vim-8文本处理实战">本文截选自《Vim
8文本处理实战》</h1>
<ul>
<li>Vim8文本处理技术指南，vim实用技巧<br />
</li>
<li>文本编辑器书籍<br />
</li>
<li>程序员编程开发技能，python语言结合</li>
</ul>
<p>作为全面介绍Vim使用方法的教程，本书介绍了各种常用的文本编辑方法和程序设计中的实用操作，深入Vim内部的数据结构和VimScript脚本编程，内容详实。本书基于Vim
8平台，介绍了前沿分支Neovim，还推荐了更先进的Oni编辑器，兼容并包，集Vim社区典型使用经验和发展趋势于一体。</p>
<p>本书面向的读者群体是所有使用Vim的程序员，书中的示例文本为Python代码，并详细介绍了Git和正则表达式。读者需要对操作系统和程序设计有基本的了解，特别是需要了解Linux操作系统的基本使用。虽然本书尝试兼顾三大操作系统，但毫无疑问书中内容以Linux为主。本书可以帮助读者完善Vim技能，增加程序设计的知识储备。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim终端切换滚屏</title>
    <url>/blog/2023/10/11/data/linux/vim/vim%E7%BB%88%E7%AB%AF%E5%88%87%E6%8D%A2%E6%BB%9A%E5%B1%8F/</url>
    <content><![CDATA[<p>在命令中键入term或者terminal来打开终端，终端模式的窗口也分插入/漫游模式。</p>
<p>补充：评论区说不知道内置终端如何滚屏，原来很多人还不知道内置终端也分
normal/insert 两种模式，正常终端操作，输入文字是 insert 模式，在 insert
模式中按 &lt;c-\&gt;<c-N> 就可以切换到终端 normal 模式了，然后你可以像
vim buffer 一样正常的 hjkl
漫游，正常的滚屏，复制内容。弄完了以后再按 i/a 回到 insert
模式中接着输入终端命令。</p>
<p>使用完终端之后，使用exit命令退出vim内置终端，其实用exit也可以退出其他创建的内置终端会话，比如bash创建的终端</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>使用4个空格替代tab制表符输入到文件中</title>
    <url>/blog/2023/10/11/data/linux/vim/%E4%BD%BF%E7%94%A84%E4%B8%AA%E7%A9%BA%E6%A0%BC%E6%9B%BF%E4%BB%A3tab%E5%88%B6%E8%A1%A8%E7%AC%A6%E8%BE%93%E5%85%A5%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD/</url>
    <content><![CDATA[<p>如果使用以下设置控制Tab键按下的行为：<br />
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span></span><br></pre></td></tr></table></figure>
则在vim编辑界面中虽然是使用4个字符替代tab的8个字符进行显示，但实际上保存文件时，内容中仍然使用的是
<code>\t</code> 字符，很多终端仍然会将 <code>\t</code>
解释为8个字符宽度，这样在终端打印文件内容时，容易出现文本对不整齐的情况，尽管在vim编辑界面中，文本是对齐的。</p>
<p>使用以下代码来真正替换 <code>\t</code>
为4个空格字符，保存到文件中：<br />
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> expandtab</span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>多标签页管理</title>
    <url>/blog/2023/10/11/data/linux/vim/%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><strong>新建标签页</strong></p>
<p>使用<code>:tabe</code>命令和文件名参数，可以在新标签页中打开指定的文件。也可以使用<code>:tabnew</code>命令，在新标签页中编辑新的文件。命令<code>:tab split</code>将在新标签页中，打开当前缓冲区中的文件。</p>
<p>命令<code>:tabf</code>允许你在当前目录搜索文件，并在新标签页中打开。比如我想打开当前目录下的img.txt文件，那么就可以使用<code>:tabf img.*</code>命令。请注意，此命令只能打开一个文件，如果搜索出多个匹配文件，将提示你“文件名过多”，这时你需要给出更精确的搜索条件以打开文件。</p>
<p>Vim默认最多只能打开10个标签页。你可以用<code>set tabpagemax=15</code>改变这个限制。</p>
<p><strong>列示标签页</strong></p>
<p>命令<code>:tabs</code>可以显示已打开标签页的列表，并用“&gt;”标识出当前页面，用“+”标识出已更改的页面。</p>
<p><strong>关闭标签页</strong></p>
<p>命令<code>:tabc</code>可以关闭当前标签页。而命令<code>:tabo</code>将关闭所有的标签页。</p>
<p><strong>切换标签页</strong></p>
<p>命令<code>:tabn</code>或<code>gt</code>可以移动到下一个标签页。而命令<code>:tabp</code>或<code>gT</code>将移动到上一个标签页。如果已经到达最后面或最前面的标签页，将会自动转向循环。</p>
<p>如果你打开了很多标签页，那么可以使用<code>:tabfirst</code>或<code>:tabr</code>命令，移动到第一个标签页。使用<code>:tablast</code>命令，移动到最后一个标签页。</p>
<p><strong>移动标签页</strong></p>
<p>如果你希望按照指定的次序排列标签页，那么你可以使用<code>:tabm</code>命令。请注意，标签页次序是从0开始计数的。比如命令<code>:tabm 1</code>将把当前标签页移动到第2的位置。如果你没有为<code>:tabm</code>命令指定参数，那么当前标签页将会被移动到最后。</p>
<p><strong>配置标签页</strong></p>
<p>默认情况下，只有用户新建了标签页才会在窗口上方显示标签栏，这是由选项<code>set showtabline=1</code>决定的。如果我们希望总是显示标签栏，那么可以用<code>set showtabline=2</code>命令来设置。如果我们希望完全不显示标签栏，那么可以使用<code>set showtabline=0</code>来设置。</p>
<p><strong>多标签页命令</strong></p>
<p>使用<code>:tabdo</code>命令，我们可以同时在多个标签页中执行命令。比如我们打开了多个标签页，需要把这些文件中的“food”都替换成“drink”，那么就可以使用<code>:tabdo %s/food/drink/g</code>命令，一次完成对所有文件的替换操作，而不用针对每个文件重复操作。</p>
<p><strong>图形界面</strong></p>
<p>如果你使用的是带有图形界面的gVim，那么新建、关闭和打开标签页的操作，都可以通过在标签页上右击鼠标完成。只需要点击相应标签，就可以在不同的标签页间切换。</p>
<p>通过<code>:help tab-page-intro</code>命令，可以获得关于标签页使用的更多信息。</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:tabnew</code></td>
<td>新建标签页</td>
</tr>
<tr class="even">
<td><code>:tabs</code></td>
<td>显示已打开标签页的列表</td>
</tr>
<tr class="odd">
<td><code>:tabc</code></td>
<td>关闭当前标签页</td>
</tr>
<tr class="even">
<td><code>:tabn</code></td>
<td>移动到下一个标签页</td>
</tr>
<tr class="odd">
<td><code>:tabp</code></td>
<td>移动到上一个标签页</td>
</tr>
<tr class="even">
<td><code>:tabfirst</code></td>
<td>移动到第一个标签页</td>
</tr>
<tr class="odd">
<td><code>:tablast</code></td>
<td>移动到最后一个标签页</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>我的VIM配置</title>
    <url>/blog/2023/10/11/data/linux/vim/%E6%88%91%E7%9A%84VIM%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; leader short cut</span></span><br><span class="line"><span class="keyword">let</span> mapleader=<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">wq</span> :<span class="keyword">wq</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>wc :<span class="keyword">close</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>wt :terminal<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span> :w!<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>q :q!<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">sp</span> :<span class="keyword">sp</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>vsp :vsp<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; enable status line</span></span><br><span class="line"><span class="keyword">source</span> ~/.<span class="keyword">vim</span>/statusbar.<span class="keyword">vim</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>nt :NERDTree<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; VScode dark theme</span></span><br><span class="line"><span class="keyword">set</span> t_Co=<span class="number">256</span></span><br><span class="line"><span class="keyword">set</span> t_ut=</span><br><span class="line"><span class="keyword">colorscheme</span> codedark</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="keyword">source</span> ~/.<span class="keyword">vim</span>/confplugins.<span class="keyword">vim</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">nu</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> autoindent</span><br><span class="line"><span class="keyword">set</span> hlsearch</span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"><span class="keyword">set</span> ignorecase</span><br><span class="line"><span class="keyword">set</span> ruler</span><br><span class="line"><span class="keyword">set</span> mouse=<span class="keyword">a</span></span><br><span class="line"><span class="keyword">set</span> cursorline</span><br><span class="line"><span class="keyword">set</span> showtabline=<span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> foldmethod=<span class="built_in">indent</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inoremap</span> <span class="string">&#x27; &#x27;</span><span class="string">&#x27;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap &#x27;</span><span class="string">&#x27; &#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inoremap &quot; &quot;&quot;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap &quot;&quot; &quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inoremap ( ()&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap () ()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inoremap [ []&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap [] []</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inoremap &#123; &#123;&#125;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap &#123;&#125; &#123;&#125;</span></span><br><span class="line"><span class="string">inoremap &#123;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O&lt;TAB&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inoremap &lt; &lt;&gt;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap &lt;&gt; &lt;&gt;</span></span><br><span class="line"><span class="string">inoremap &lt;&lt; &lt;&lt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码安装CMake</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/CMake/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85CMake/</url>
    <content><![CDATA[<p>源码安装只推荐Unix类系统（各Linux发行版），windows的话直接使用二进制预编译版本就好了，省心。</p>
<p>在CMake官网下载好源码之后，tar -xvzf解压到当前目录，然后./configure
--help查看有哪些可配置选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[fredom@ECS-Tencentyun 21:34:42] ~/programfiles/cmake-3.26.4</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --<span class="built_in">help</span></span></span><br><span class="line">Usage: /home/fredom/programfiles/cmake-3.26.4/bootstrap [&lt;options&gt;...] [-- &lt;cmake-options&gt;...]</span><br><span class="line">Options: [defaults in brackets after descriptions]</span><br><span class="line">Configuration:</span><br><span class="line">  --help                  print this message</span><br><span class="line">  --version               only print version information</span><br><span class="line">  --verbose               display more information</span><br><span class="line">  --parallel=n            bootstrap cmake in parallel, where n is</span><br><span class="line">                          number of nodes [1]</span><br><span class="line">  --generator=&lt;generator&gt; generator to use (MSYS Makefiles, Unix Makefiles,</span><br><span class="line">                          or Ninja)</span><br><span class="line">  --enable-ccache         Enable ccache when building cmake</span><br><span class="line">  --init=FILE             load FILE as script to populate cache</span><br><span class="line">  --system-libs           use all system-installed third-party libraries</span><br><span class="line">                          (for use only by package maintainers)</span><br><span class="line">  --no-system-libs        use all cmake-provided third-party libraries</span><br><span class="line">                          (default)</span><br><span class="line">  --system-curl           use system-installed curl library</span><br><span class="line">  --no-system-curl        use cmake-provided curl library (default)</span><br><span class="line">  --system-expat          use system-installed expat library</span><br><span class="line">  --no-system-expat       use cmake-provided expat library (default)</span><br><span class="line">  --system-jsoncpp        use system-installed jsoncpp library</span><br><span class="line">  --no-system-jsoncpp     use cmake-provided jsoncpp library (default)</span><br><span class="line">  --system-zlib           use system-installed zlib library</span><br><span class="line">  --no-system-zlib        use cmake-provided zlib library (default)</span><br><span class="line">  --system-bzip2          use system-installed bzip2 library</span><br><span class="line">  --no-system-bzip2       use cmake-provided bzip2 library (default)</span><br><span class="line">  --system-liblzma        use system-installed liblzma library</span><br><span class="line">  --no-system-liblzma     use cmake-provided liblzma library (default)</span><br><span class="line">  --system-nghttp2        use system-installed nghttp2 library</span><br><span class="line">  --no-system-nghttp2     use cmake-provided nghttp2 library (default)</span><br><span class="line">  --system-zstd           use system-installed zstd library</span><br><span class="line">  --no-system-zstd        use cmake-provided zstd library (default)</span><br><span class="line">  --system-libarchive     use system-installed libarchive library</span><br><span class="line">  --no-system-libarchive  use cmake-provided libarchive library (default)</span><br><span class="line">  --system-librhash       use system-installed librhash library</span><br><span class="line">  --no-system-librhash    use cmake-provided librhash library (default)</span><br><span class="line">  --system-libuv          use system-installed libuv library</span><br><span class="line">  --no-system-libuv       use cmake-provided libuv library (default)</span><br><span class="line">  --bootstrap-system-libuv use system-installed libuv library for bootstrap</span><br><span class="line">  --bootstrap-system-jsoncpp use system-installed jsoncpp library for bootstrap</span><br><span class="line">  --bootstrap-system-librhash use system-installed librhash library for bootstrap</span><br><span class="line">  --qt-gui                build the Qt-based GUI (requires Qt &gt;= 4.2)</span><br><span class="line">  --no-qt-gui             do not build the Qt-based GUI (default)</span><br><span class="line">  --qt-qmake=&lt;qmake&gt;      use &lt;qmake&gt; as the qmake executable to find Qt</span><br><span class="line">  --sphinx-info           build Info manual with Sphinx</span><br><span class="line">  --sphinx-man            build man pages with Sphinx</span><br><span class="line">  --sphinx-html           build html help with Sphinx</span><br><span class="line">  --sphinx-qthelp         build qch help with Sphinx</span><br><span class="line">  --sphinx-latexpdf       build PDF with Sphinx using LaTeX</span><br><span class="line">  --sphinx-build=&lt;sb&gt;     use &lt;sb&gt; as the sphinx-build executable</span><br><span class="line">  --sphinx-flags=&lt;flags&gt;  pass &lt;flags&gt; to sphinx-build executable</span><br><span class="line">Directory and file names:</span><br><span class="line">  --prefix=PREFIX         install files in tree rooted at PREFIX</span><br><span class="line">                          [/usr/local]</span><br><span class="line">  --bindir=DIR            install binaries in PREFIX/DIR</span><br><span class="line">                          [bin]</span><br><span class="line">  --datadir=DIR           install data files in PREFIX/DIR</span><br><span class="line">                          [share/cmake-3.26]</span><br><span class="line">  --docdir=DIR            install documentation files in PREFIX/DIR</span><br><span class="line">                          [doc/cmake-3.26]</span><br><span class="line">  --mandir=DIR            install man pages files in PREFIX/DIR/manN</span><br><span class="line">                          [man]</span><br><span class="line">  --xdgdatadir=DIR        install XDG specific files in PREFIX/DIR</span><br><span class="line">                          [share]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一般来说只需要配置prefix为自己要安装的目录位置就可以了，其他配置基本不需要动。执行：<br />
./configure --prefix=$PWD/build/install</p>
<p>然后就会开始配置，编译安装时所需的文件。然后执行make 以及 make
install
即可安装到自己指定的目录。然后把可执行文件所在目录bin软链接到一个已有的系统路径下就可以全局使用cmake了。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>生成makefile前指定安装路径</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/CMake/%E7%94%9F%E6%88%90makefile%E5%89%8D%E6%8C%87%E5%AE%9A%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>我可以在make install 的时候再指定 prefix吗？</p>
<p>ChatGPT</p>
<p>当您从源代码编译并安装软件时（通常使用 <code>configure</code>,
<code>make</code>, 和 <code>make install</code>
的序列），<code>prefix</code> 是在 <code>configure</code>
阶段指定的，而不是在 <code>make install</code> 阶段。</p>
<p><code>prefix</code> 定义了软件将被安装的位置。例如，使用
<code>--prefix=/usr/local</code> 会导致软件安装在
<code>/usr/local</code> 目录下。</p>
<p>如果您已经执行了 <code>configure</code> 并没有指定
<code>prefix</code>，默认的安装路径通常是
<code>/usr/local</code>。如果您希望改变安装路径，您需要在执行
<code>configure</code> 时重新指定 <code>prefix</code>。</p>
<p>例如：</p>
<p>bashCopy code</p>
<p><code>./configure --prefix=/desired/path make sudo make install</code></p>
<p>如果您已经运行了 <code>make</code>，但还没有执行
<code>make install</code>，并且希望改变安装目录，只需重新运行
<code>configure</code> 并指定新的 <code>prefix</code>，然后再执行
<code>make</code> 和 <code>make install</code>。</p>
<p>如果我使用的是cmake，我如何在命令行就指定 install prefix？</p>
<p>ChatGPT</p>
<p>当使用<code>cmake</code>来构建项目时，你可以使用<code>-DCMAKE_INSTALL_PREFIX</code>选项在命令行中指定安装前缀。例如：</p>
<p>bashCopy code</p>
<p><code>cmake -DCMAKE_INSTALL_PREFIX=/desired/install/path ..</code></p>
<p>上面的命令会配置项目以便在执行<code>make install</code>时，所有文件都会被安装到<code>/desired/install/path</code>指定的目录中。</p>
<p>如果你已经运行了<code>cmake</code>并希望更改安装前缀，你需要重新运行<code>cmake</code>并使用新的<code>-DCMAKE_INSTALL_PREFIX</code>值，或者你可以直接编辑<code>CMakeCache.txt</code>文件并手动更改<code>CMAKE_INSTALL_PREFIX</code>的值，然后再次运行<code>make</code>和<code>make install</code>。</p>
<p>比如我想安装到当前目录的install目录下，怎么指定<code>-DCMAKE_INSTALL_PREFIX</code>?</p>
<p>ChatGPT</p>
<p>如果你希望将安装目标放在当前目录的 <code>install</code>
子目录下，你可以使用相对路径来指定
<code>-DCMAKE_INSTALL_PREFIX</code>。以下是如何操作的示例：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=./install ..</span><br></pre></td></tr></table></figure></p>
<p>这将会把所有的安装目标文件放在你的当前目录的 <code>install</code>
子目录下。当然，在执行 <code>make install</code>
之后，这个子目录会被创建（如果之前不存在的话）。</p>
<p>如果你更喜欢使用绝对路径，你可以这样做：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=$(pwd)/install ..</span><br></pre></td></tr></table></figure></p>
<p>在这里，<code>$(pwd)</code> 是一个 shell
命令，它会返回当前目录的绝对路径。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>编写find_package</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/CMake/%E7%BC%96%E5%86%99find_package/</url>
    <content><![CDATA[<p>使用find_package引入外部依赖包</p>
<p>本章节通过示例演示Cmake中find_package的用法。</p>
<p>注：所有教程均在linux系统下测试通过，如果是windows和mac系统，可能会出现错误，需要自行调试修改</p>
<p>通过Cmake内置模块引入依赖包</p>
<p>为了方便我们在项目中引入外部依赖包，cmake官方为我们预定义了许多寻找依赖包的Module，他们存储在path_to_your_cmake/share/cmake-&lt;version&gt;/Modules目录下。每个以Find&lt;LibaryName&gt;.cmake命名的文件都可以帮我们找到一个包。我们也可以在官方文档中查看到哪些库官方已经为我们定义好了，我们可以直接使用find_package函数进行引用<a
href="https://link.zhihu.com/?target=https%3A//cmake.org/cmake/help/latest/manual/cmake-modules.7.html">官方文档：Find
Modules</a>。</p>
<p>我们以curl库为例，假设我们项目需要引入这个库，从网站中请求网页到本地，我们看到官方已经定义好了FindCURL.cmake。所以我们在CMakeLists.txt中可以直接用find_pakcage进行引用。</p>
<p>find_package(CURL)<br />
add_executable(curltestcurltest.cc)<br />
if(CURL_FOUND)<br />
target_include_directories(clibPRIVATE<span
class="math inline">\({CURL_INCLUDE_DIR})
target_link_libraries(curltest\)</span>{CURL_LIBRARY})<br />
else(CURL_FOUND)<br />
message(FATAL_ERROR”CURLlibrarynotfound”)<br />
endif(CURL_FOUND)</p>
<p>对于系统预定义的 Find&lt;LibaryName&gt;.cmake 模块，使用方法一般如上例所示。</p>
<p>每一个模块都会定义以下几个变量</p>
<p>&lt;LibaryName&gt;_FOUND</p>
<p>&lt;LibaryName_INCLUDE_DIR or &lt;LibaryName&gt;_INCLUDES </p>
<p>&lt;LibaryName&gt;_LIBRARY or &lt;LibaryName&gt;_LIBRARIES</p>
<p>你可以通过&lt;LibaryName&gt;_FOUND 来判断模块是否被找到，如果没有找到，按照工程的需要关闭
某些特性、给出提醒或者中止编译，上面的例子就是报出致命错误并终止构建。
如果&lt;LibaryName&gt;_FOUND 为真，则将&lt;LibaryName&gt;_INCLUDE_DIR 加入
INCLUDE_DIRECTORIES，</p>
<p>通过find_package引入非官方的库（该方式只对支持cmake编译安装的库有效）</p>
<p>假设此时我们需要引入glog库来进行日志的记录，我们在Module目录下并没有找到
FindGlog.cmake。所以我们需要自行安装glog库，再进行引用。</p>
<p>安装</p>
<p># clone该项目git clone <a
href="https://github.com/google/glog.git">https://github.com/google/glog.git</a><br />
# 切换到需要的版本 cd glog<br />
git checkout v0.40 </p>
<p># 根据官网的指南进行安装cmake -H. -Bbuild -G "Unix Makefiles"cmake
--build build<br />
cmake --build build --target install</p>
<p>此时我们便可以通过与引入curl库一样的方式引入glog库了</p>
<p>find_package(GLOG)<br />
add_executable(glogtest glogtest.cc)<br />
if(GLOG_FOUND)<br />
#
由于glog在连接时将头文件直接链接到了库里面，所以这里不用显示调用target_include_directories<br />
target_link_libraries(glogtest glog::glog)<br />
else(GLOG_FOUND)<br />
message(FATAL_ERROR”GLOGlibrarynotfound”)<br />
endif(GLOG_FOUND)</p>
<p>Module模式与Config模式</p>
<p>通过上文我们了解了通过Cmake引入依赖库的基本用法。知其然也要知其所以然，find_package对我们来说是一个黑盒子，那么它是具体通过什么方式来查找到我们依赖的库文件的路径的呢。到这里我们就不得不聊到find_package的两种模式，一种是Module模式，也就是我们引入curl库的方式。另一种叫做Config模式，也就是引入glog库的模式。下面我们来详细介绍着两种方式的运行机制。</p>
<p>在Module模式中，cmake需要找到一个叫做Find&lt;LibraryName&gt;.cmake的文件。这个文件负责找到库所在的路径，为我们的项目引入头文件路径和库文件路径。cmake搜索这个文件的路径有两个，一个是上文提到的cmake安装目录下的share/cmake-&lt;version&gt;/Modules目录，另一个使我们指定的CMAKE_MODULE_PATH的所在目录。</p>
<p>如果Module模式搜索失败，没有找到对应的Find&lt;LibraryName&gt;.cmake文件，则转入Config模式进行搜索。它主要通过&lt;LibraryName&gt;Config.cmake or &lt;lower-case-package-name&gt;-config.cmake这两个文件来引入我们需要的库。以我们刚刚安装的glog库为例，在我们安装之后，它在/usr/local/lib/cmake/glog/目录下生成了glog-config.cmake文件，而/usr/local/lib/cmake/&lt;LibraryName&gt;/正是find_package函数的搜索路径之一。（find_package的搜索路径是一系列的集合，而且在linux，windows，mac上都会有所区别，需要的可以参考官方文档<a
href="https://link.zhihu.com/?target=https%3A//cmake.org/cmake/help/latest/command/find_package.html">find_package</a>）</p>
<p>由以上的例子可以看到，对于原生支持Cmake编译和安装的库通常会安装Config模式的配置文件到对应目录，这个配置文件直接配置了头文件库文件的路径以及各种cmake变量供find_package使用。而对于非由cmake编译的项目，我们通常会编写一个Find&lt;LibraryName&gt;.cmake，通过脚本来获取头文件、库文件等信息。通常，原生支持cmake的项目库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。</p>
<p>编写自己的Find&lt;LibraryName&gt;.cmake模块</p>
<p>假设我们编写了一个新的函数库，我们希望别的项目可以通过find_package对它进行引用我们应该怎么办呢。</p>
<p>我们在当前目录下新建一个ModuleMode的文件夹，在里面我们编写一个计算两个整数之和的一个简单的函数库。库函数以手工编写Makefile的方式进行安装，库文件安装在/usr/lib目录下，头文件放在/usr/include目录下。其中的Makefile文件如下：</p>
<h1
id="准备工作编译方式目标文件名依赖库路径的定义">1、准备工作，编译方式、目标文件名、依赖库路径的定义。</h1>
<p>CC=g++<br />
CFLAGS:=-Wall -O3 -std=c++11</p>
<p>OBJS=libadd.o #.o文件与.cpp文件同名LIB=libadd.so #
目标文件名INCLUDE=./ # 头文件目录HEADER=libadd.h # 头文件all :$(LIB)# 2.
生成.o文件<br />
<span class="math inline">\((OBJS) :libadd.cc\)</span>(CC)$(CFLAGS)-I ./
-fpic -c $&lt; -o $@# 3. 生成动态库文件<br />
<span class="math inline">\((LIB) :\)</span>(OBJS)rm -f $<span
class="citation" data-cites="g">@g</span>++ $(OBJS)-shared -o $<span
class="citation" data-cites="rm">@rm</span> -f $(OBJS)# 4.
删除中间过程生成的文件<br />
clean:rm -f <span class="math inline">\((OBJS)\)</span>(TARGET)$(LIB)#
5.安装文件<br />
install:cp $(LIB)/usr/lib<br />
    cp $(HEADER)/usr/include</p>
<p>编译安装</p>
<p>make<br />
sudo make install</p>
<p>接下来我们回到我们的Cmake项目中来，在cmake文件夹下新建一个FindAdd.cmake的文件。我们的目标是找到库的头文件所在目录和共享库文件的所在位置。</p>
<h1
id="在指定目录下寻找头文件和动态库文件的位置可以指定多个目标路径">在指定目录下寻找头文件和动态库文件的位置，可以指定多个目标路径</h1>
<p>find_path(ADD_INCLUDE_DIR libadd.h /usr/include/
/usr/local/include<span
class="math inline">\({CMAKE_SOURCE_DIR}/ModuleMode)
find_library(ADD_LIBRARY NAMES add PATHS /usr/lib/add
/usr/local/lib/add\)</span>{CMAKE_SOURCE_DIR}/ModuleMode)</p>
<p>if(ADD_INCLUDE_DIR AND ADD_LIBRARY)<br />
set(ADD_FOUND TRUE)<br />
endif(ADD_INCLUDE_DIRANDADD_LIBRARY)</p>
<p>这时我们便可以像引用curl一样引入我们自定义的库了。</p>
<p>在CMakeLists.txt中添加</p>
<h1
id="将项目目录下的cmake文件夹加入到cmake_module_path中让find_pakcage能够找到我们自定义的函数库">将项目目录下的cmake文件夹加入到CMAKE_MODULE_PATH中，让find_pakcage能够找到我们自定义的函数库</h1>
<p>set(CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake;
${CMAKE_MODULE_PATH}")<br />
add_executable(addtest addtest.cc)<br />
find_package(ADD)<br />
if(ADD_FOUND)<br />
target_include_directories(addtest PRIVATE ${ADD_INCLUDE_DIR})<br />
target_link_libraries(addtest ${ADD_LIBRARY})<br />
else(ADD_FOUND)<br />
message(FATAL_ERROR "ADD library not found")<br />
endif(ADD_FOUND)</p>
<p>来自 &lt;<a
href="https://zhuanlan.zhihu.com/p/97369704">https://zhuanlan.zhihu.com/p/97369704</a>&gt;</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>DESTDIR 和 --prefix</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/GNU%20Make/DESTDIR%20%E5%92%8C%20--prefix/</url>
    <content><![CDATA[<p>CMake本身是为了根据指令生成一个Makefile给GNU
Make程序使用，CMake自身如果使用install()指令将编译产物复制到指定位置的话，Makefile中的复制路径前缀就会被赋值<CMAKE_INSTALL_PREFIX>，但是由于最后还是手动执行GNU
Make程序的，所以仍然可以在执行make的时候指定DESTDIR来无视从CMake传过来的CMAKE_INSTALL_PREFIX，当然前提是你的工程中的Makefile里要有install这个target，make才能通过'make
install'指令找到install这个target去执行</p>
<p>如果通过设置 DESTDIR
这个变量的值为我们想要的路径，最后会把文件复制到哪里呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hm@hm:~/fuguiduo/lib/flann/build$ make install DESTDIR=$PWD/install</span><br><span class="line">[ 33%] Built target flann_cpp</span><br><span class="line">[ 66%] Built target flann</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target flann_example_c</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target examples</span></span><br><span class="line">Install the project...</span><br><span class="line">-- Install configuration: &quot;RelWithDebInfo&quot;</span><br><span class="line">-- Up-to-date: /home/hm/fuguiduo/lib/flann/build/install/usr/local/lib/cmake/flann/flann-config.cmake</span><br></pre></td></tr></table></figure>
<p>可以看到，除了我们指定的路径外，还有额外的一串路径，这串红色的路径是在哪里定义的呢？直觉上来讲，由于这个Makefile是CMake生成的，所以这个值肯定存储在CMake里，在build目录下的CMakeCache.txt文件中找找这个值？</p>
<p>$ grep CMAKE_INSTALL_PREFIX CMakeCache.txt -n</p>
<p>133:CMAKE_INSTALL_PREFIX:PATH=/usr/local</p>
<p>可以看到在CMakeCache.txt文件中定义了这部分路径<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hm@hm:~/fuguiduo/lib/flann/build$ make install prefix=$PWD/install</span><br><span class="line">[ 33%] Built target flann_cpp</span><br><span class="line">[ 66%] Built target flann</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target flann_example_c</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target examples</span></span><br><span class="line">Install the project...</span><br><span class="line">-- Install configuration: &quot;RelWithDebInfo&quot;</span><br><span class="line">CMake Error at cmake_install.cmake:46 (file):</span><br><span class="line">  file cannot create directory: /usr/local/lib/cmake/flann.  Maybe need</span><br><span class="line">  administrative privileges.</span><br><span class="line">make: *** [Makefile:130: install] Error 1</span><br></pre></td></tr></table></figure></p>
<p>好险尝试该命令的时候没有使用sudo获取权限执行，不然就污染了/usr/local/lib了</p>
<p>当指定install的前缀为空之后<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hm@hm:~/fuguiduo/lib/flann/build$ cmake -DCMAKE_INSTALL_PREFIX=/ ..</span><br></pre></td></tr></table></figure></p>
<p>再执行make install并指定DESTDIR值，就是正常的目录了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hm@hm:~/fuguiduo/lib/flann/build$ make install DESTDIR=$PWD/install</span><br><span class="line">[ 33%] Built target flann_cpp</span><br><span class="line">[ 66%] Built target flann</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target flann_example_c</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target examples</span></span><br><span class="line">Install the project...</span><br><span class="line">-- Install configuration: &quot;RelWithDebInfo&quot;</span><br><span class="line">-- Installing: /home/hm/fuguiduo/lib/flann/build/install/lib/cmake/flann/flann-config.cmake</span><br><span class="line"></span><br><span class="line">hm@hm:~/fuguiduo/lib/flann/build/install$ lss</span><br><span class="line">total 16K</span><br><span class="line">drwxrwxr-x 2 hm hm 4.0K 2月   6 19:40 bin</span><br><span class="line">drwxrwxr-x 3 hm hm 4.0K 2月   6 19:40 include</span><br><span class="line">drwxrwxr-x 4 hm hm 4.0K 2月   6 19:40 lib</span><br><span class="line">drwxrwxr-x 4 hm hm 4.0K 2月   6 19:40 share</span><br></pre></td></tr></table></figure>
<p>make之后，如何变更make install的prefix？</p>
<p>2023/8/14 19:36:40</p>
<p>在使用 <code>make</code> 构建项目并使用 <code>make install</code>
安装时，你可以通过指定 <code>prefix</code>
变量来更改安装目录的路径。</p>
<p>一种常见的方法是在运行 <code>make install</code>
命令时，通过在命令中设置 <code>prefix</code>
变量来修改安装目录。例如：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make install prefix=/path/to/install/directory</span><br></pre></td></tr></table></figure></p>
<p>在上述命令中，将 <code>prefix</code> 设置为
<code>/path/to/install/directory</code>，即可将软件安装到指定的目录中。</p>
<p>另一种常见的方法是在运行 <code>configure</code>
脚本时，通过设置环境变量 <code>PREFIX</code>
来指定安装目录路径。例如：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/path/to/install/directory make make install</span><br></pre></td></tr></table></figure></p>
<p>上述命令中，在运行 <code>configure</code> 脚本时通过
<code>--prefix</code> 参数指定了安装目录路径，然后运行 <code>make</code>
和 <code>make install</code> 进行构建和安装。</p>
<p>请注意，修改 <code>prefix</code> 变量或使用 <code>--prefix</code>
参数时，确保指定的路径具有适当的权限，并且在指定的路径下创建了所需的目录结构。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>Make 是如何更新待编译文件的</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/GNU%20Make/Make%20%E6%98%AF%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E5%BE%85%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6%E7%9A%84/</url>
    <content><![CDATA[<p>2.3 How make Processes a Makefile</p>
<p>By default, make starts with the first target (not targets whose
names start with ‘.’ unless they also contain one or more ‘/’). This is
called the default goal. (Goals are the targets that make strives
ultimately to update. You can override this behavior using the command
line (see <a
href="https://www.gnu.org/software/make/manual/html_node/Goals.html">Arguments
to Specify the Goals</a>) or with the .DEFAULT_GOAL special variable
(see <a
href="https://www.gnu.org/software/make/manual/html_node/Special-Variables.html">Other
Special Variables</a>).</p>
<p>In the simple example of the previous section, the default goal is to
update the executable program edit; therefore, we put that rule
first.</p>
<p>Thus, when you give the command:</p>
<p>make</p>
<p>make reads the makefile in the current directory and begins by
processing the first rule. In the example, this rule is for
relinking edit; but before make can fully process this rule, it must
process the rules for the files that edit depends on, which in this case
are the object files. Each of these files is processed according to its
own rule. These rules say to update each ‘.o’ file by compiling its
source file. The recompilation must be done if the source file, or any
of the header files named as prerequisites, is more recent than the
object file, or if the object file does not exist.</p>
<p>The other rules are processed because their targets appear as
prerequisites of the goal. If some other rule is not depended on by the
goal (or anything it depends on, etc.), that rule is not processed,
unless you tell make to do so (with a command such as make clean).</p>
<p>Before recompiling an object file, make considers updating its
prerequisites, the source file and header files. This makefile does not
specify anything to be done for them—the ‘.c’ and ‘.h’ files are not the
targets of any rules—so make does nothing for these files.
But make would update automatically generated C programs, such as those
made by Bison or Yacc, by their own rules at this time.</p>
<p>After recompiling whichever object files need it, make decides
whether to relink edit. This must be done if the file edit does not
exist, or if any of the object files are newer than it. If an object
file was just recompiled, it is now newer than edit, so edit is
relinked.</p>
<p>Thus, if we change the file insert.c and run make, make will compile
that file to update insert.o, and then link edit. If we change the
file command.h and run make, make will recompile the object
files kbd.o, command.o and files.o and then link the file edit.</p>
<p>来自 &lt;<a
href="https://www.gnu.org/software/make/manual/html_node/How-Make-Works.html">https://www.gnu.org/software/make/manual/html_node/How-Make-Works.html</a>&gt;</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile 示例</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/GNU%20Make/Makefile%20%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>What is GNU Make?</p>
<p><a href="https://www.gnu.org/software/make/">GNU Make</a> is a
program that automates the running of shell commands and helps with
repetitive tasks. It is typically used to transform files into some
other form, e.g. compiling source code files into programs or
libraries.</p>
<p>It does this by tracking prerequisites and executing a hierarchy of
commands to produce targets.</p>
<p>Although the GNU Make manual is lengthy, I suggest giving it a read
as it is the best reference I’ve found:  <a
href="https://www.gnu.org/software/make/manual/html_node/index.html">https://www.gnu.org/software/make/manual/html_node/index.html</a></p>
<p>Let’s dive in!</p>
<p>When to choose Make</p>
<p>Make is suitable for building small C/C++ projects or libraries that
would be included in another project’s build system. Most build systems
will have a way to integrate Make-based sub-projects.</p>
<p>For larger projects, you will find a more modern build system easier
to work with.</p>
<p>I would suggest a build system other than Make in the following
situations:</p>
<ul>
<li>When the number of targets (or files) being built is (or will
eventually be) in the hundreds.<br />
</li>
<li>A “configure” step is desired, which sets up and persists variables,
target definitions, and environment configurations.<br />
</li>
<li>The project is going to remain internal or private and will not need
to be built by end users.<br />
</li>
<li>You find debugging a frustrating exercise.<br />
</li>
<li>You need the build to be cross platform that can build on macOS,
Linux, and Windows.</li>
</ul>
<p>In these situations, you might find using <a
href="https://cmake.org/">CMake</a>, <a
href="https://bazel.build/">Bazel</a>, <a
href="https://mesonbuild.com/">Meson</a>, or another modern build system
a more pleasurable experience.</p>
<p>Invoking Make</p>
<p>Running make will load a file named Makefile from the current
directory and attempt to update the default goal (more on goals
later).</p>
<p>Make will search for files named GNUmakefile, makefile, and Makefile,
in that order</p>
<p>You can specify a particular makefile with
the -f/--file argument:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make -ffoo.mk</span><br></pre></td></tr></table></figure>
<p>You can specify any number of goals by listing them as positional
arguments:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\# typical goals</span><br><span class="line">$ make clean all</span><br></pre></td></tr></table></figure>
<p>You can pass Make a directory with the -C argument, and this will run
Make as if it first cd‘d into that directory.<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make -Csome/sub/directory</span><br></pre></td></tr></table></figure> Fun fact: git also can be run with -C for the same
effect!</p>
<p>Parallel Invocation</p>
<p>Make can run jobs in parallel if you provide the -j or -l options. A
guideline I’ve been told is to set the job limit to 1.5 times the number
of processor cores you have:</p>
<h1 id="a-machine-with-4-cores-make--j6">a machine with 4 cores:$ make
-j6</h1>
<p>Anecdotally, I’ve seen slightly better CPU utilization with
the -l “load limit” option, vs. the -j “jobs” option. YMMV though!</p>
<p>There are a few ways to programmatically find the CPU count for the
current machine. One easy option is to use the
python multiprocessing.cpu_count() function to get the number of threads
supported by the system (note on a system with hyper-threading, this
will use up a lot of your machine’s resources, but is probably
preferable to letting Make spawn an unlimited number of jobs).</p>
<p># call the python cpu_count() function in a subshell$ make -l$(python
-c"import multiprocessing; print(multiprocessing.cpu_count())")</p>
<p>Output During Parallel Invocation</p>
<p>If you have a lot of output from the commands Make is executing in
parallel, you might see output interleaved on stdout. To handle this,
Make has the option <a
href="https://www.gnu.org/software/make/manual/html_node/Parallel-Output.html">--ouput-sync</a>.</p>
<p>I recommend using --output-sync=recurse, which will print the entire
output of each target’s recipe when it completes, without interspersing
other recipe output.</p>
<p>It also will output an entire recursive Make’s output together if
your recipe is using recursive make.</p>
<p>Anatomy of a Makefile</p>
<p>A Makefile contains rules used to produce targets. Some basic
components of a Makefile are shown below:</p>
<h1 id="comments-are-prefixed-with-the-symbol">Comments are prefixed
with the '#' symbol</h1>
<h1 id="a-variable-assignment">A variable assignment</h1>
<p>FOO="hello there!"# A rule creating target "test", with "test.c" as a
prerequisite<br />
test:test.c# The contents of a rule is called the "recipe", and is#
typically composed of one or more shell commands.# It must be indented
from the target name (historically with        # tabs, spaces are
permitted)# Using the variable "FOO"<br />
echo<span class="math inline">\((FOO)# Calling the C compiler using a
predefined variable naming \# the default C compiler,
&#39;\)</span>(CC)'<br />
$(CC)test.c-otest</p>
<p>Let’s take a look at each part of the example above.</p>
<p>Variables</p>
<p>Variables are used with the syntax $(FOO), where FOO is the variable
name.</p>
<p>Variables contain purely strings as Make does not have other data
types. Appending to a variable will add a space and the new content:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">FOO=one  </span><br><span class="line">FOO+=two  </span><br><span class="line"><span class="comment"># FOO is now &quot;one two&quot;  </span></span><br><span class="line">FOO=one  </span><br><span class="line">FOO=<span class="variable">$(FOO)</span>two  </span><br><span class="line"><span class="comment"># FOO is now &quot;onetwo&quot;</span></span><br></pre></td></tr></table></figure>
<p>Variable Assignment</p>
<p>In GNU Make syntax, variables are assigned with two “flavors”:</p>
<ol type="1">
<li>recursive expansion: variable = expression The expression on the
right hand side is assigned verbatim to the variable- this behaves much
like a macro in C/C++, where the expression is evaluated when the
variable is used:<br />
FOO=1<br />
BAR=$(FOO)FOO=2<br />
# prints BAR=2<br />
$(infoBAR=$(BAR))<br />
</li>
<li>simple expansion: variable := expression This assigns the result of
an expression to a variable; the expression is expanded at the time of
assignment:<br />
FOO=1<br />
BAR:=$(FOO)FOO=2<br />
# prints BAR=1<br />
$(infoBAR=$(BAR))</li>
</ol>
<p>Note: the $(info ...) function is being used above to print
expressions and can be handy when debugging makefiles!*`</p>
<p>Variables which are not explicitly, <a
href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">implicitly</a>,
nor <a
href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">automatically</a> set
will evaluate to an empty string.</p>
<p>Environment Variables</p>
<p>Environment variables are carried into the Make execution
environment. Consider the following makefile for example:</p>
<p><span class="math inline">\((infoYOLOvariable=\)</span>(YOLO))</p>
<p>If we set the variable YOLO in the shell command when running make,
we’ll set the value:</p>
<p>$ YOLO="hello there!"make<br />
YOLO variable =hello there!<br />
make: ***No targets.  Stop.</p>
<p>Note: Make prints the “No targets” error because our makefile had no
targets listed!</p>
<p>If you use the ?= assignment syntax, Make will only assign that value
if the variable doesn’t already have a value:</p>
<p>Makefile:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\# default CC to gcc  </span><br><span class="line">CC?=gcc</span><br></pre></td></tr></table></figure></p>
<p>We can then override $(CC) in that makefile:</p>
<p>$ CC=clang make</p>
<p>Another common pattern is to allow inserting additional flags. In the
makefile, we would append to the variable instead of directly assigning
to it.</p>
<p>CFLAGS+=-Wall</p>
<p>This permits passing extra flags in from the environment:</p>
<p>$ CFLAGS='-Werror=conversion -Werror=double-promotion'make</p>
<p>This can be very useful!</p>
<p>Overriding Variables</p>
<p>A special category of variable usage is called overriding variables.
Using this command-line option will override the value set ANYWHERE
ELSE in the environment or Makefile!</p>
<p>Makefile:</p>
<p># the value passed in the make command will override<br />
# any value set elsewhere<br />
YOLO="not overridden"<span
class="math inline">\((info\)</span>(YOLO))</p>
<p>Command:<br />
# setting "YOLO" to different values in the environment + makefile +
overriding# variable, yields the overriding value$ YOLO="environment
set"make YOLO='overridden!!'overridden!!<br />
make: ***No targets.  Stop.</p>
<p>Overriding variables can be confusing, and should be used with
caution!</p>
<p>Target-Specific Variables</p>
<p>These variables are only available in the recipe context. They also
apply to any prerequisite recipe!</p>
<p># set the -g value to CFLAGS<br />
# applies to the prog.o/foo.o/bar.o recipes too!<br />
prog :CFLAGS = -gprog :prog.o foo.o bar.oecho$(CFLAGS)# will print
'-g'</p>
<p>Implicit Variables</p>
<p>These are pre-defined by Make (unless overridden with any other
variable type of the same name). Some common examples:</p>
<ul>
<li>$(CC) - the C compiler (gcc)<br />
</li>
<li>$(AR) - archive program (ar)<br />
</li>
<li>$(CFLAGS) - flags for the C compiler</li>
</ul>
<p>Full list here:</p>
<p><a
href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html</a></p>
<p>Automatic Variables</p>
<p>These are special variables always set by Make and available in
recipe context. They can be useful to prevent duplicated names (Don’t
Repeat Yourself).</p>
<p>A few common automatic variables:</p>
<p># <span class="math inline">\(@ : the target name, here it would be
&quot;test.txt&quot; test.txt:echo HEYO &gt;\)</span>@# <span
class="math inline">\(^ : name of all the prerequisites all.zip:foo.txt
test.txt# run the gzip command with all the prerequisites
&quot;\$^&quot;, outputting to the# name of the target,
&quot;\$@&quot;gzip-c\)</span>^&gt;$@</p>
<p>See more at:  <a
href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html</a></p>
<p>Targets (Goals)</p>
<p>Targets are the left hand side in the rule syntax:</p>
<p>target:prerequisiterecipe</p>
<p>Targets almost always name files. This is because Make uses
last-modified time to track if a target is newer or older than its
prerequisites and whether it needs to be rebuilt!</p>
<p>When invoking Make, you can specify which target(s) you want to build
as the goals by specifying it as a positional argument:</p>
<p># make the 'test.txt' and 'all.zip' targetsmake test.txt all.zip</p>
<p>If you don’t specify a goal in the command, Make uses the first
target specified in the makefile, called the “default goal” (you can
also <a
href="https://www.gnu.org/software/make/manual/html_node/Goals.html">override</a> the
default goal if you need to).</p>
<p>Phony Targets</p>
<p>Sometimes it’s useful to have meta-targets like all, clean, test,
etc. In these cases, you don’t want Make to check for a file
named all/clean etc.</p>
<p>Make provides the .PHONY target syntax to mark a target as not
pointing to a file:</p>
<p># Say our project builds a program and a library 'foo' and 'foo.a';
if we want<br />
# to build both by default we might make an 'all' rule that builds
both<br />
.PHONY:allall:foo foo.a</p>
<p>If you have multiple phony targets, a good pattern might be to append
each to .PHONY where it’s defined:</p>
<p># the 'all' rule that builds and tests. Note that it's listed first
to make it<br />
# the default rule<br />
.PHONY:allall:build test# compile foo.c into a program 'foo'<br />
foo:foo.c$(CC)foo.c -ofoo</p>
<p># compile foo-lib.c into a library 'foo.a'<br />
foo.a:foo-lib.c# compile the object file$(CC)foo-lib.c
-cfoo-lib.o        # use ar to create a static library containing our
object file. using the# '$@' variable here to specify the rule target
'foo.a'$(AR)rcs $<span class="citation"
data-cites="foo-lib.o">@foo-lib.o</span></p>
<p># a phony rule that builds our project; just contains a prerequisite
of the<br />
# library + program<br />
.PHONY:buildbuild:foo foo.a# a phony rule that runs our test harness.
has the 'build' target as a<br />
# prerequisite! Make will make sure (pardon the pun) the build rule
executes<br />
# first<br />
.PHONY:testtest:build./run-tests.sh</p>
<p>NOTE!!! .PHONY targets are ALWAYS considered out-of-date, so Make
will ALWAYS run the recipe for those targets (and therfore any target
that has a .PHONY prerequisite!). Use with caution!!</p>
<p>Implicit Rules</p>
<p>Implicit rules are provided by Make. I find using them to be
confusing since there’s so much behavior happening behind the scenes.
You will occasionally encounter them in the wild, so be aware.</p>
<p>Here’s a quick example:</p>
<p># this will compile 'test.c' with the default $(CC), $(CFLAGS), into
the program<br />
# 'test'. it will handle prerequisite tracking on test.c<br />
test:test.o</p>
<p>Full list of implicit rules here:</p>
<p><a
href="https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html">https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html</a></p>
<p>Pattern Rules</p>
<p>Pattern rules let you write a generic rule that applies to multiple
targets via pattern-matching:</p>
<p># Note the use of the '<span class="math inline">\(&lt;&#39;
automatic variable, specifying the first \# prerequisite, which is the
.c file %.o:%.c\)</span>(CC)-c<span
class="math inline">\(&lt;-o\)</span>@</p>
<p>The rule will then be used to make any target matching the pattern,
which above would be any file matching %.o, e.g. foo.o, bar.o.</p>
<p>If you use those .o files mentioned above to build a program:</p>
<p>OBJ_FILES=foo.o bar.o</p>
<p># Use CC to link foo.o + bar.o into 'program'. Note the use of the
'<span class="math inline">\(^&#39; \# automatic variable, specifying
ALL the prerequisites (all the OBJ_FILES) \# should be part of the link
command program:\)</span>(OBJ_FILES)<span
class="math inline">\((CC)-o\)</span>@$^</p>
<p>Prerequisites</p>
<p>As seen above, these are targets that Make will check before running
a rule. They can be files or other targets.</p>
<p>If any prerequisite is newer (modified-time) than the target, Make
will run the target rule.</p>
<p>In C projects, you might have a rule that converts a C file to an
object file, and you want the object file to rebuild if the C file
changes:</p>
<p>foo.o:foo.c# use automatic variables for the input and output file
names<span class="math inline">\((CC)\)</span>^-c$@</p>
<p>Automatic Prerequisites</p>
<p>A very important consideration for C language projects is to trigger
recompilation if an #include header files change for a C file. This is
done with the -M compiler flag for gcc/clang, which will output
a .d file you will then import with the Make include directive.</p>
<p>The .d file will contain the necessary prerequisites for the .c file
so any header change causes a rebuild. See more details here:</p>
<p><a
href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html</a> 
<a
href="http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/">http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/</a></p>
<p>The basic form might be:</p>
<p># these are the compiler flags for emitting the dependency tracking
file. Note<br />
# the usage of the '<span class="math inline">\(&lt;&#39; automatic
variable DEPFLAGS=-MMD-MP-MF\)</span>&lt;.d</p>
<p>test.o:test.c<span class="math inline">\((CC)\)</span>(DEPFLAGS)<span
class="math inline">\(&lt;-c\)</span>@# bring in the prerequisites by
including all the .d files. prefix the line with<br />
# '-' to prevent an error if any of the files do not exist<br />
-include $(wildcard *.d)</p>
<p>Order-Only Prerequisites</p>
<p>These prerequisites will only be built if they don’t exist; if they
are newer than the target, they will not trigger a target re-build.</p>
<p>A typical use is to create a directory for output files; emitting
files to a directory will update its mtime attribute, but we don’t want
that to trigger a rebuild.</p>
<p>OUTPUT_DIR=build</p>
<p># output the .o to the build directory, which we add as an
order-only<br />
# prerequisite- anything right of the | pipe is considered
order-only<br />
$(OUTPUT_DIR)/test.o:test.c | <span
class="math inline">\((OUTPUT_DIR)\)</span>(CC)-c<span
class="math inline">\(^-o\)</span>@# rule to make the directory<br />
$(OUTPUT_DIR):mkdir-p$@</p>
<p>Recipe</p>
<p>The “recipe” is the list of shell commands to be executed to create
the target. They are passed into a sub-shell (/bin/sh by default). The
rule is considered successful if the target is updated after the recipe
runs (but is not an error if this doesn’t happen).</p>
<p>foo.txt:# a simple recipeecho HEYO &gt;$@</p>
<p>If any line of the recipe returns a non-zero exit code, Make will
terminate and print an error message. You can tell Make to ignore
non-zero exit codes by prefixing with the - character:</p>
<p>.PHONY:cleanclean:# we don't care if rm fails-rm-r./build</p>
<p>Prefixing a recipe line with @ will disable echoing that line before
executing:</p>
<p>clean:@# this recipe will just print 'About to clean everything!'@#
prefixing the shell comment lines '#' here also prevents them from@#
appearing during execution@echo About to clean everything!</p>
<p>Make will expand variable/function expressions in the recipe context
before running them, but will otherwise not process it. If you want to
access shell variables, escape them with $:</p>
<p>USER=linus</p>
<p>print-user:# print out the shell variable <span
class="math inline">\(USERecho\)</span>$USER</p>
<p># print out the make variable USER<br />
echo$(USER)</p>
<p>Advanced Topics</p>
<p>These features are less frequently encountered, but provide some
powerful functionality that can enable sophisticated behavior in your
build.</p>
<p>Functions</p>
<p>Make functions are called with the syntax:</p>
<p>$(function-namearguments)</p>
<p>where arguments is a comma-delimited list of arguments.</p>
<p>Built-in Functions</p>
<p>There are several functions provided by Make. The most common ones I
use are for text manipulation:  <a
href="https://www.gnu.org/software/make/manual/html_node/Text-Functions.html">https://www.gnu.org/software/make/manual/html_node/Text-Functions.html</a> 
<a
href="https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html">https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html</a></p>
<p>For example:</p>
<p>FILES=$(wildcard*.c)# you can combine function calls; here we strip
the suffix off of $(FILES) with<br />
# the <span class="math inline">\((basename) function, then add the .o
suffix O_FILES=\)</span>(addsuffix.o,<span
class="math inline">\((basename\)</span>(FILES)))# note that the GNU
Make Manual suggests an alternate form for this particular<br />
# operation:<br />
O_FILES=$(FILES:.c=.o)</p>
<p>User-Defined Functions</p>
<p>You can define your own functions as well:</p>
<p>reverse=<span
class="math inline">\((2)\)</span>(1)foo=$(callreverse,a,b)</p>
<p>A more complicated but quite useful example:</p>
<p># recursive wildcard (use it instead of $(shell find . -name
'*.c'))<br />
# taken from <a
href="https://stackoverflow.com/a/18258352">https://stackoverflow.com/a/18258352</a><br />
rwildcard=$(foreachd,$(wildcard<span
class="math inline">\(1*),\)</span>(callrwildcard,$d/,<span
class="math inline">\(2)\)</span>(filter$(subst<em>,%,<span
class="math inline">\(2),\)</span>d))C_FILES=$(callrwildcard,.,</em>.c)</p>
<p>Shell Function</p>
<p>You can have Make call a shell expression and capture the result:</p>
<p>TODAYS_DATE=$(shelldate--iso-8601)</p>
<p>I’m cautious when using this feature, though; it adds a dependency on
whatever programs you use, so if you’re calling more exotic programs,
make sure your build environment is controlled (e.g. in a container or
with <a
href="https://interrupt.memfault.com/blog/conda-developer-environments">Conda</a>).</p>
<p>Conditionals</p>
<p>Make has syntax for conditional expressions:</p>
<p>FOO=yolo<br />
ifeq(<span
class="math inline">\((FOO),yolo)\)</span>(infofooisyolo!)else<span
class="math inline">\((info foo is not yolo :( )endif# testing if a
variable is set; unset variables are empty ifneq(\)</span>(FOO),)  #
checking if FOO is blank<br />
$(infoFOOisunset)endif</p>
<p>The “complex conditional” syntax is just
the if-elseif-else combination:</p>
<p># "complex conditional"<br />
ifeq(<span
class="math inline">\((FOO),yolo)\)</span>(infofooisyolo)elseifeq(<span
class="math inline">\((FOO), heyo)\)</span>(infofooisheyo)else$(info foo
is not yolo or heyo :( )endif</p>
<p>include Directive</p>
<p>You can import other Makefile contents using
the include directive:</p>
<p>sources.mk:</p>
<p>SOURCE_FILES:=.c .c  </p>
<p>Makefile:</p>
<p>include
sources.mkOBJECT_FILES=$(SOURCE_FILES:.c=.o)%.o:%.c$(CC)-c$^-o$@</p>
<p>Sub-make</p>
<p>Invoking Make from a Makefile should be done with
the $(MAKE) variable:</p>
<p>somelib.a:$(MAKE)-Cpath/to/somelib/directory</p>
<p>This is often used when building external libraries. It’s also used
heavily in Kconfig builds (e.g. when building the Linux kernel).</p>
<p>Note that this approach has some pitfalls:</p>
<ul>
<li>Recursive invocation can result in slow builds.<br />
</li>
<li>Tracking prerequisites can be tricky; often you will
see .PHONY used.</li>
</ul>
<p>More details on the disadvantages here:</p>
<p><a
href="http://aegis.sourceforge.net/auug97.pdf">http://aegis.sourceforge.net/auug97.pdf</a></p>
<p>Metaprogramming with eval </p>
<p>Make’s eval directive allows us to generate Make syntax at
runtime:</p>
<p># generate rules for xml-&gt;json in some weird world<br />
FILES=<span class="math inline">\((wildcardinputfile/*.xml)# create a
user-defined function that generates rules
defineGENERATE_RULE=\)</span>(eval# prereq rule for creating output
directory<br />
<span class="math inline">\((1)_OUT_DIR=\)</span>(dir<span
class="math inline">\((1))/\)</span>(1)_out<br />
<span class="math inline">\((1)_OUT_DIR:mkdir-p\)</span>@# rule that
calls a script on the input file and produces $@ target<br />
<span class="math inline">\((1)_OUT_DIR/\)</span>(1).json:$(1) |
$(1)_OUT_DIR./convert-xml-to-json.sh <span
class="math inline">\((1)\)</span>@)# add the target to the all
rule<br />
all:<span class="math inline">\((1)_OUT_DIR/\)</span>(1).jsonendef</p>
<p># produce the rules<br />
.PHONY:allall:<span
class="math inline">\((foreachfile,\)</span>(FILES),<span
class="math inline">\((callGENERATE_RULE,\)</span>(file)))</p>
<p>Note that approaches using this feature of Make can be quite
confusing, adding helpful comments explaining what the intent is can be
useful for your future self!</p>
<p>VPATH</p>
<p>VPATH is a special Make variable that contains a list of directories
Make should search when looking for prerequisites and targets.</p>
<p>It can be used to emit object files or other derived files into
a ./build directory, instead of cluttering up the src directory:</p>
<p># This makefile should be invoked from the temporary build directory,
eg:<br />
# $ mkdir -p build &amp;&amp; cd ./build &amp;&amp; make -f
../Makefile<br />
# Derive the directory containing this Makefile<br />
MAKEFILE_DIR=<span
class="math inline">\((shelldirname\)</span>(realpath<span
class="math inline">\((firstword\)</span>(MAKEFILE_LIST))))# now inform
Make we should look for prerequisites from the root directory as<br />
# well as the cwd<br />
VPATH+=$(MAKEFILE_DIR)SRC_FILES=$(wildcard$(MAKEFILE_DIR)/src/*.c)# Set
the obj file paths to be relative to the cwd<br />
OBJ_FILES=$(subst$(MAKEFILE_DIR)/,,$(SRC_FILES:.c=.o))# now we can
continue as if Make was running from the root directory, and not a<br />
# subdirectory<br />
# $(OBJ_FILES) will be built by the pattern rule below<br />
foo.a:$(OBJ_FILES)$(AR)rcs <span
class="math inline">\(@\)</span>(OBJ_FILES)# pattern rule; since we
added ROOT_DIR to VPATH, Make can find prerequisites<br />
# like <code>src/test.c</code> when running from the build
directory!<br />
%.o:%.c# create the directory tree for the output file 👍echo<span
class="math inline">\(@mkdir-p\)</span>(dir<span
class="math inline">\(@)# compile\)</span>(CC)-c<span
class="math inline">\(^-o\)</span>@</p>
<p>I recommend avoiding use of VPATH. It’s usually simpler to achieve
the same out-of-tree behavior by outputting the generated files in a
build directory without needing VPATH.</p>
<p>touch</p>
<p>You may see the touch command used to track rules that seem difficult
to otherwise track; for example, when unpacking a toolchain:</p>
<p># our tools are stored in tools.tar.gz, and downloaded from a
server<br />
TOOLS_ARCHIVE=tools.tar.gz<br />
TOOLS_URL=https://httpbin.org/get</p>
<p># the rule to download the tools using wget<br />
$(TOOLS_ARCHIVE):wget <span
class="math inline">\((TOOLS_URL)-O\)</span>(TOOLS_ARCHIVE)# rule to
unpack them<br />
tools-unpacked.dummy:$(TOOLS_ARCHIVE)# running this command results in a
directory.. but how do we know it# completed, without a file to
track?tar xzvf $^# use the touch command to record completion in a dummy
filetouch$@</p>
<p>I recommend avoiding the use of touch. However there are some cases
where it might be unavoidable.</p>
<p>Debugging Makefiles</p>
<p>I typically use the Make equivalent of printf,
the $(info/warning/error) functions, for small problems, for example
when checking conditional paths that aren’t working:</p>
<p>ifeq(<span
class="math inline">\((CC),clang)\)</span>(errorwhoops,clangnotsupported!)endif</p>
<p>For debugging why a rule is running when it shouldn’t (or vice
versa), you can use the --debug options:  <a
href="https://www.gnu.org/software/make/manual/html_node/Options-Summary.html">https://www.gnu.org/software/make/manual/html_node/Options-Summary.html</a></p>
<p>I recommend redirecting stdout to a file when using this option, it
can produce a lot of output.</p>
<p>Profiling</p>
<p>For profiling a make invocation (e.g. for attempting to improve
compilation times), this tool can be useful:</p>
<p><a
href="https://github.com/rocky/remake">https://github.com/rocky/remake</a></p>
<p>Check out the tips here for compilation-related performance
improvements:</p>
<p><a
href="https://interrupt.memfault.com/blog/improving-compilation-times-c-cpp-projects">https://interrupt.memfault.com/blog/improving-compilation-times-c-cpp-projects</a></p>
<p>Using a Verbose Flag</p>
<p>If your project includes a lot of compiler flags (search paths, lots
of warning flags, etc.), then you may want to simplify the output of
Make rules. It can be useful to have a toggle to easily see the full
output, for example:</p>
<p>ifeq($(V),1)Q:=elseQ:=@<br />
endif%.o:%.c# prefix the compilation command with the
$(Q)variable        # use echo to print a simple "Compiling x.c" to show
progress@echo Compiling <span
class="math inline">\((notdir@^)\)</span>(Q)<span
class="math inline">\((CC)-c\)</span>^-o$@</p>
<p>To enable printing out the full compilation commands, set
the V environment variable like so:</p>
<p>$ V=1 make</p>
<p>Full Example</p>
<p>Here’s an annotated example of a complete build process for an
example C project. You can see this example and the source tree <a
href="https://github.com/memfault/interrupt/tree/master/example/gnu-make-guidelines">here</a>.</p>
<p># Makefile for building the 'example' binary from C sources<br />
# Verbose flag<br />
ifeq($(V),1)Q:=elseQ:=@<br />
endif# The build folder, for all generated output. This should normally
be included<br />
# in a .gitignore rule<br />
BUILD_FOLDER:=build</p>
<p># Default all rule will build the 'example' target, which here is an
executable<br />
.PHONY:all:$(BUILD_FOLDER)/example# List of C source files. Putting this
in a separate variable, with a file on<br />
# each line, makes it easy to add files later (and makes it easier to
see<br />
# additions in pull requests). Larger projects might use a wildcard to
locate<br />
# source files automatically.<br />
SRC_FILES=/example.c /main.c</p>
<h1
id="generate-a-list-of-.o-files-from-the-.c-files.-prefix-them-with-the-build">Generate
a list of .o files from the .c files. Prefix them with the build</h1>
<h1 id="folder-to-output-the-files-there">folder to output the files
there</h1>
<p>OBJ_FILES=<span
class="math inline">\((addprefix\)</span>(BUILD_FOLDER)/,<span
class="math inline">\((SRC_FILES:.c=.o))# Generate a list of depfiles,
used to track includes. The file name is the same # as the object files
with the .d extension added DEP_FILES=\)</span>(addsuffix.d,<span
class="math inline">\((OBJ_FILES))# Flags to generate the .d
dependency-tracking files when we compile.  It&#39;s # named the same as
the target file with the .d extension
DEPFLAGS=-MMD-MP-MF\)</span>@.d</p>
<h1 id="include-the-dependency-tracking-files">Include the dependency
tracking files</h1>
<p>-include $(DEP_FILES)# List of include dirs. These are put into
CFLAGS.<br />
INCLUDE_DIRS=/</p>
<h1
id="prefix-the-include-dirs-with--i-when-passing-them-to-the-compiler">Prefix
the include dirs with '-I' when passing them to the compiler</h1>
<p>CFLAGS+=<span
class="math inline">\((addprefix-I,\)</span>(INCLUDE_DIRS))# Set some
compiler flags we need. Note that we're appending to the CFLAGS<br />
# variable<br />
CFLAGS+=-std=c11 -Wall-Werror-ffunction-sections-fdata-sections-Og-g3#
Our project requires some linker flags: garbage collect sections, output
a<br />
# .map file<br />
LDFLAGS+=-Wl,--gc-sections,-Map,$@.map</p>
<h1 id="set-ldlibs-to-specify-linking-with-libm-the-math-library">Set
LDLIBS to specify linking with libm, the math library</h1>
<p>LDLIBS+=-lm# The rule for compiling the SRC_FILES into
OBJ_FILES<br />
$(BUILD_FOLDER)/%.o:%.c@echo Compiling <span
class="math inline">\((notdir\)</span>&lt;)@# Create the folder
structure for the output file@mkdir-p<span
class="math inline">\((dir\)</span>@)<span
class="math inline">\((Q)\)</span>(CC)<span
class="math inline">\((CFLAGS)\)</span>(DEPFLAGS)-c<span
class="math inline">\(&lt;-o\)</span>@# The rule for building the
executable "example", using OBJ_FILES as<br />
# prerequisites. Since we're not relying on an implicit rule, we need
to<br />
# explicity list CFLAGS, LDFLAGS, LDLIBS<br />
<span
class="math inline">\((BUILD_FOLDER)/example:\)</span>(OBJ_FILES)<span
class="citation" data-cites="echo">@echo</span> Linking <span
class="math inline">\((notdir\)</span>@)<span
class="math inline">\((Q)\)</span>(CC)<span
class="math inline">\((CFLAGS)\)</span>(LDFLAGS)<span
class="math inline">\(^\)</span>(LDLIBS)-o<span class="math inline">\(@#
Remove debug information for a smaller executable. An embedded project
might # instead using [arm-none-eabi-]objcopy to convert the ELF file to
a raw binary # suitable to be written to an embedded device
STRIPPED_OUTPUT=\)</span>(BUILD_FOLDER)/example-stripped</p>
<p><span
class="math inline">\((STRIPPED_OUTPUT):\)</span>(BUILD_FOLDER)/example@echo
Stripping <span class="math inline">\((notdir\)</span>@)<span
class="math inline">\((Q)objcopy --strip-debug\)</span>^<span
class="math inline">\(@# Since all our generated output is placed into
the build folder, our clean rule # is simple. Prefix the recipe line
with &#39;-&#39; to not error if the build folder # doesn&#39;t exist
(the -f flag for rm also has this effect)
.PHONY:cleanclean:-rm-rf\)</span>(BUILD_FOLDER)</p>
<p>Recommendations</p>
<p>A list of recommendations for getting the most of Make:</p>
<ol type="1">
<li>Targets should usually be real files.<br />
</li>
<li>Always use $(MAKE) when issuing sub-make commands.<br />
</li>
<li>Try to avoid using .PHONY targets. If the rule generates any file
artifact, consider using that as the target instead of a phony
name!<br />
</li>
<li>Try to avoid using implicit rules.<br />
</li>
<li>For C files, make sure to use .d automatic include tracking!<br />
</li>
<li>Use metaprogramming with caution.<br />
</li>
<li>Use automatic variables in rules. Always try to use $@ for a recipe
output path, so your rule and Make have the exact same path.<br />
</li>
<li>Use comments liberally in Makefiles, especially if there is
complicated behavior or subtle syntax used. Your co-workers (and future
self) will thank you.<br />
</li>
<li>Use the -j or -l options to run Make in parallel!<br />
</li>
<li>Try to avoid using the touch command to track rule completion</li>
</ol>
<p>来自 &lt;<a
href="https://interrupt.memfault.com/blog/gnu-make-guidelines">https://interrupt.memfault.com/blog/gnu-make-guidelines</a>&gt;</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile规则</title>
    <url>/blog/2023/10/11/data/CSAPP/compiler/GNU%20Make/Makefile%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>2.1 What a Rule Looks Like</p>
<p>A simple makefile consists of “rules” with the following shape:</p>
<p>target … : prerequisites …        recipe        …        …</p>
<p>A target is usually the name of a file that is generated by a
program; examples of targets are executable or object files. A target
can also be the name of an action to carry out, such as ‘clean’ (see <a
href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">Phony
Targets</a>).</p>
<p>A prerequisite is a file that is used as input to create the target.
A target often depends on several files.</p>
<p>A recipe is an action that make carries out. A recipe may have more
than one command, either on the same line or each on its own
line. Please note: you need to put a tab character at the beginning of
every recipe line! This is an obscurity that catches the unwary. If you
prefer to prefix your recipes with a character other than tab, you can
set the .RECIPEPREFIX variable to an alternate character (see <a
href="https://www.gnu.org/software/make/manual/html_node/Special-Variables.html">Special
Variables</a>).</p>
<p>Usually a recipe is in a rule with prerequisites and serves to create
a target file if any of the prerequisites change. However, the rule that
specifies a recipe for the target need not have prerequisites. For
example, the rule containing the delete command associated with the
target ‘clean’ does not have prerequisites.</p>
<p>A rule, then, explains how and when to remake certain files which are
the targets of the particular rule. make carries out the recipe on the
prerequisites to create or update the target. A rule can also explain
how and when to carry out an action. See <a
href="https://www.gnu.org/software/make/manual/html_node/Rules.html">Writing
Rules</a>.</p>
<p>A makefile may contain other text besides rules, but a simple
makefile need only contain rules. Rules may look somewhat more
complicated than shown in this template, but all fit the pattern more or
less.</p>
<p>来自 &lt;<a
href="https://www.gnu.org/software/make/manual/html_node/Rule-Introduction.html#Rule-Introduction">https://www.gnu.org/software/make/manual/html_node/Rule-Introduction.html#Rule-Introduction</a>&gt;</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>compiler</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>red_black_tree</title>
    <url>/blog/2023/10/11/data/CSAPP/data%20structure/Algorithm%20Tutor/red_black_tree/</url>
    <content><![CDATA[<h1 id="c">C++</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Red Black Tree implementation in C++</span></span><br><span class="line"><span class="comment">// Author: Algorithm Tutor</span></span><br><span class="line"><span class="comment">// Tutorial URL: https://algorithmtutor.com/Data-Structures/Tree/Red-Black-Trees/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data structure that represents a node in the tree</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data; <span class="comment">// holds the key</span></span><br><span class="line">	Node *parent; <span class="comment">// pointer to the parent</span></span><br><span class="line">	Node *left; <span class="comment">// pointer to left child</span></span><br><span class="line">	Node *right; <span class="comment">// pointer to right child</span></span><br><span class="line">	<span class="type">int</span> color; <span class="comment">// 1 -&gt; Red, 0 -&gt; Black</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Node *NodePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class RBTree implements the operations in Red Black Tree</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	NodePtr root;</span><br><span class="line">	NodePtr TNULL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initializes the nodes with appropirate values</span></span><br><span class="line">	<span class="comment">// all the pointers are set to point to the null pointer</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">initializeNULLNode</span><span class="params">(NodePtr node, NodePtr parent)</span> </span>&#123;</span><br><span class="line">		node-&gt;data = <span class="number">0</span>;</span><br><span class="line">		node-&gt;parent = parent;</span><br><span class="line">		node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">		node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">		node-&gt;color = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preOrderHelper</span><span class="params">(NodePtr node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != TNULL) &#123;</span><br><span class="line">			cout&lt;&lt;node-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="built_in">preOrderHelper</span>(node-&gt;left);</span><br><span class="line">			<span class="built_in">preOrderHelper</span>(node-&gt;right);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inOrderHelper</span><span class="params">(NodePtr node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != TNULL) &#123;</span><br><span class="line">			<span class="built_in">inOrderHelper</span>(node-&gt;left);</span><br><span class="line">			cout&lt;&lt;node-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="built_in">inOrderHelper</span>(node-&gt;right);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">postOrderHelper</span><span class="params">(NodePtr node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != TNULL) &#123;</span><br><span class="line">			<span class="built_in">postOrderHelper</span>(node-&gt;left);</span><br><span class="line">			<span class="built_in">postOrderHelper</span>(node-&gt;right);</span><br><span class="line">			cout&lt;&lt;node-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">NodePtr <span class="title">searchTreeHelper</span><span class="params">(NodePtr node, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == TNULL || key == node-&gt;data) &#123;</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (key &lt; node-&gt;data) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">searchTreeHelper</span>(node-&gt;left, key);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">searchTreeHelper</span>(node-&gt;right, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fix the rb tree modified by the delete operation</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fixDelete</span><span class="params">(NodePtr x)</span> </span>&#123;</span><br><span class="line">		NodePtr s;</span><br><span class="line">		<span class="keyword">while</span> (x != root &amp;&amp; x-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">				s = x-&gt;parent-&gt;right;</span><br><span class="line">				<span class="keyword">if</span> (s-&gt;color == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.1</span></span><br><span class="line">					s-&gt;color = <span class="number">0</span>;</span><br><span class="line">					x-&gt;parent-&gt;color = <span class="number">1</span>;</span><br><span class="line">					<span class="built_in">leftRotate</span>(x-&gt;parent);</span><br><span class="line">					s = x-&gt;parent-&gt;right;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (s-&gt;left-&gt;color == <span class="number">0</span> &amp;&amp; s-&gt;right-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.2</span></span><br><span class="line">					s-&gt;color = <span class="number">1</span>;</span><br><span class="line">					x = x-&gt;parent;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (s-&gt;right-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">// case 3.3</span></span><br><span class="line">						s-&gt;left-&gt;color = <span class="number">0</span>;</span><br><span class="line">						s-&gt;color = <span class="number">1</span>;</span><br><span class="line">						<span class="built_in">rightRotate</span>(s);</span><br><span class="line">						s = x-&gt;parent-&gt;right;</span><br><span class="line">					&#125; </span><br><span class="line"></span><br><span class="line">					<span class="comment">// case 3.4</span></span><br><span class="line">					s-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">					x-&gt;parent-&gt;color = <span class="number">0</span>;</span><br><span class="line">					s-&gt;right-&gt;color = <span class="number">0</span>;</span><br><span class="line">					<span class="built_in">leftRotate</span>(x-&gt;parent);</span><br><span class="line">					x = root;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s = x-&gt;parent-&gt;left;</span><br><span class="line">				<span class="keyword">if</span> (s-&gt;color == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.1</span></span><br><span class="line">					s-&gt;color = <span class="number">0</span>;</span><br><span class="line">					x-&gt;parent-&gt;color = <span class="number">1</span>;</span><br><span class="line">					<span class="built_in">rightRotate</span>(x-&gt;parent);</span><br><span class="line">					s = x-&gt;parent-&gt;left;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (s-&gt;right-&gt;color == <span class="number">0</span> &amp;&amp; s-&gt;right-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.2</span></span><br><span class="line">					s-&gt;color = <span class="number">1</span>;</span><br><span class="line">					x = x-&gt;parent;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (s-&gt;left-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">// case 3.3</span></span><br><span class="line">						s-&gt;right-&gt;color = <span class="number">0</span>;</span><br><span class="line">						s-&gt;color = <span class="number">1</span>;</span><br><span class="line">						<span class="built_in">leftRotate</span>(s);</span><br><span class="line">						s = x-&gt;parent-&gt;left;</span><br><span class="line">					&#125; </span><br><span class="line"></span><br><span class="line">					<span class="comment">// case 3.4</span></span><br><span class="line">					s-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">					x-&gt;parent-&gt;color = <span class="number">0</span>;</span><br><span class="line">					s-&gt;left-&gt;color = <span class="number">0</span>;</span><br><span class="line">					<span class="built_in">rightRotate</span>(x-&gt;parent);</span><br><span class="line">					x = root;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		x-&gt;color = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">rbTransplant</span><span class="params">(NodePtr u, NodePtr v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u-&gt;parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			root = v;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left)&#123;</span><br><span class="line">			u-&gt;parent-&gt;left = v;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			u-&gt;parent-&gt;right = v;</span><br><span class="line">		&#125;</span><br><span class="line">		v-&gt;parent = u-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deleteNodeHelper</span><span class="params">(NodePtr node, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// find the node containing key</span></span><br><span class="line">		NodePtr z = TNULL;</span><br><span class="line">		NodePtr x, y;</span><br><span class="line">		<span class="keyword">while</span> (node != TNULL)&#123;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;data == key) &#123;</span><br><span class="line">				z = node;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (node-&gt;data &lt;= key) &#123;</span><br><span class="line">				node = node-&gt;right;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (z == TNULL) &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Couldn&#x27;t find key in the tree&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		y = z;</span><br><span class="line">		<span class="type">int</span> y_original_color = y-&gt;color;</span><br><span class="line">		<span class="keyword">if</span> (z-&gt;left == TNULL) &#123;</span><br><span class="line">			x = z-&gt;right;</span><br><span class="line">			<span class="built_in">rbTransplant</span>(z, z-&gt;right);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;right == TNULL) &#123;</span><br><span class="line">			x = z-&gt;left;</span><br><span class="line">			<span class="built_in">rbTransplant</span>(z, z-&gt;left);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			y = <span class="built_in">minimum</span>(z-&gt;right);</span><br><span class="line">			y_original_color = y-&gt;color;</span><br><span class="line">			x = y-&gt;right;</span><br><span class="line">			<span class="keyword">if</span> (y-&gt;parent == z) &#123;</span><br><span class="line">				x-&gt;parent = y;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">rbTransplant</span>(y, y-&gt;right);</span><br><span class="line">				y-&gt;right = z-&gt;right;</span><br><span class="line">				y-&gt;right-&gt;parent = y;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">rbTransplant</span>(z, y);</span><br><span class="line">			y-&gt;left = z-&gt;left;</span><br><span class="line">			y-&gt;left-&gt;parent = y;</span><br><span class="line">			y-&gt;color = z-&gt;color;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">delete</span> z;</span><br><span class="line">		<span class="keyword">if</span> (y_original_color == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">fixDelete</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// fix the red-black tree</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fixInsert</span><span class="params">(NodePtr k)</span></span>&#123;</span><br><span class="line">		NodePtr u;</span><br><span class="line">		<span class="keyword">while</span> (k-&gt;parent-&gt;color == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k-&gt;parent == k-&gt;parent-&gt;parent-&gt;right) &#123;</span><br><span class="line">				u = k-&gt;parent-&gt;parent-&gt;left; <span class="comment">// uncle</span></span><br><span class="line">				<span class="keyword">if</span> (u-&gt;color == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.1</span></span><br><span class="line">					u-&gt;color = <span class="number">0</span>;</span><br><span class="line">					k-&gt;parent-&gt;color = <span class="number">0</span>;</span><br><span class="line">					k-&gt;parent-&gt;parent-&gt;color = <span class="number">1</span>;</span><br><span class="line">					k = k-&gt;parent-&gt;parent;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (k == k-&gt;parent-&gt;left) &#123;</span><br><span class="line">						<span class="comment">// case 3.2.2</span></span><br><span class="line">						k = k-&gt;parent;</span><br><span class="line">						<span class="built_in">rightRotate</span>(k);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// case 3.2.1</span></span><br><span class="line">					k-&gt;parent-&gt;color = <span class="number">0</span>;</span><br><span class="line">					k-&gt;parent-&gt;parent-&gt;color = <span class="number">1</span>;</span><br><span class="line">					<span class="built_in">leftRotate</span>(k-&gt;parent-&gt;parent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				u = k-&gt;parent-&gt;parent-&gt;right; <span class="comment">// uncle</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (u-&gt;color == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// mirror case 3.1</span></span><br><span class="line">					u-&gt;color = <span class="number">0</span>;</span><br><span class="line">					k-&gt;parent-&gt;color = <span class="number">0</span>;</span><br><span class="line">					k-&gt;parent-&gt;parent-&gt;color = <span class="number">1</span>;</span><br><span class="line">					k = k-&gt;parent-&gt;parent;	</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (k == k-&gt;parent-&gt;right) &#123;</span><br><span class="line">						<span class="comment">// mirror case 3.2.2</span></span><br><span class="line">						k = k-&gt;parent;</span><br><span class="line">						<span class="built_in">leftRotate</span>(k);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// mirror case 3.2.1</span></span><br><span class="line">					k-&gt;parent-&gt;color = <span class="number">0</span>;</span><br><span class="line">					k-&gt;parent-&gt;parent-&gt;color = <span class="number">1</span>;</span><br><span class="line">					<span class="built_in">rightRotate</span>(k-&gt;parent-&gt;parent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (k == root) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		root-&gt;color = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printHelper</span><span class="params">(NodePtr root, string indent, <span class="type">bool</span> last)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// print the tree structure on the screen</span></span><br><span class="line">	   	<span class="keyword">if</span> (root != TNULL) &#123;</span><br><span class="line">		   cout&lt;&lt;indent;</span><br><span class="line">		   <span class="keyword">if</span> (last) &#123;</span><br><span class="line">		      cout&lt;&lt;<span class="string">&quot;R----&quot;</span>;</span><br><span class="line">		      indent += <span class="string">&quot;     &quot;</span>;</span><br><span class="line">		   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		      cout&lt;&lt;<span class="string">&quot;L----&quot;</span>;</span><br><span class="line">		      indent += <span class="string">&quot;|    &quot;</span>;</span><br><span class="line">		   &#125;</span><br><span class="line">            </span><br><span class="line">           string sColor = root-&gt;color?<span class="string">&quot;RED&quot;</span>:<span class="string">&quot;BLACK&quot;</span>;</span><br><span class="line">		   cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;sColor&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;endl;</span><br><span class="line">		   <span class="built_in">printHelper</span>(root-&gt;left, indent, <span class="literal">false</span>);</span><br><span class="line">		   <span class="built_in">printHelper</span>(root-&gt;right, indent, <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// cout&lt;&lt;root-&gt;left-&gt;data&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RBTree</span>() &#123;</span><br><span class="line">		TNULL = <span class="keyword">new</span> Node;</span><br><span class="line">		TNULL-&gt;color = <span class="number">0</span>;</span><br><span class="line">		TNULL-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">		TNULL-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">		root = TNULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pre-Order traversal</span></span><br><span class="line">	<span class="comment">// Node-&gt;Left Subtree-&gt;Right Subtree</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">preOrderHelper</span>(<span class="keyword">this</span>-&gt;root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// In-Order traversal</span></span><br><span class="line">	<span class="comment">// Left Subtree -&gt; Node -&gt; Right Subtree</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">inOrderHelper</span>(<span class="keyword">this</span>-&gt;root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Post-Order traversal</span></span><br><span class="line">	<span class="comment">// Left Subtree -&gt; Right Subtree -&gt; Node</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">postOrderHelper</span>(<span class="keyword">this</span>-&gt;root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// search the tree for the key k</span></span><br><span class="line">	<span class="comment">// and return the corresponding node</span></span><br><span class="line">	<span class="function">NodePtr <span class="title">searchTree</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">searchTreeHelper</span>(<span class="keyword">this</span>-&gt;root, k);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the node with the minimum key</span></span><br><span class="line">	<span class="function">NodePtr <span class="title">minimum</span><span class="params">(NodePtr node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (node-&gt;left != TNULL) &#123;</span><br><span class="line">			node = node-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the node with the maximum key</span></span><br><span class="line">	<span class="function">NodePtr <span class="title">maximum</span><span class="params">(NodePtr node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (node-&gt;right != TNULL) &#123;</span><br><span class="line">			node = node-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the successor of a given node</span></span><br><span class="line">	<span class="function">NodePtr <span class="title">successor</span><span class="params">(NodePtr x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// if the right subtree is not null,</span></span><br><span class="line">		<span class="comment">// the successor is the leftmost node in the</span></span><br><span class="line">		<span class="comment">// right subtree</span></span><br><span class="line">		<span class="keyword">if</span> (x-&gt;right != TNULL) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">minimum</span>(x-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// else it is the lowest ancestor of x whose</span></span><br><span class="line">		<span class="comment">// left child is also an ancestor of x.</span></span><br><span class="line">		NodePtr y = x-&gt;parent;</span><br><span class="line">		<span class="keyword">while</span> (y != TNULL &amp;&amp; x == y-&gt;right) &#123;</span><br><span class="line">			x = y;</span><br><span class="line">			y = y-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the predecessor of a given node</span></span><br><span class="line">	<span class="function">NodePtr <span class="title">predecessor</span><span class="params">(NodePtr x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// if the left subtree is not null,</span></span><br><span class="line">		<span class="comment">// the predecessor is the rightmost node in the </span></span><br><span class="line">		<span class="comment">// left subtree</span></span><br><span class="line">		<span class="keyword">if</span> (x-&gt;left != TNULL) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">maximum</span>(x-&gt;left);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		NodePtr y = x-&gt;parent;</span><br><span class="line">		<span class="keyword">while</span> (y != TNULL &amp;&amp; x == y-&gt;left) &#123;</span><br><span class="line">			x = y;</span><br><span class="line">			y = y-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rotate left at node x</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">leftRotate</span><span class="params">(NodePtr x)</span> </span>&#123;</span><br><span class="line">		NodePtr y = x-&gt;right;</span><br><span class="line">		x-&gt;right = y-&gt;left;</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;left != TNULL) &#123;</span><br><span class="line">			y-&gt;left-&gt;parent = x;</span><br><span class="line">		&#125;</span><br><span class="line">		y-&gt;parent = x-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;root = y;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">			x-&gt;parent-&gt;left = y;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			x-&gt;parent-&gt;right = y;</span><br><span class="line">		&#125;</span><br><span class="line">		y-&gt;left = x;</span><br><span class="line">		x-&gt;parent = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rotate right at node x</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">rightRotate</span><span class="params">(NodePtr x)</span> </span>&#123;</span><br><span class="line">		NodePtr y = x-&gt;left;</span><br><span class="line">		x-&gt;left = y-&gt;right;</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;right != TNULL) &#123;</span><br><span class="line">			y-&gt;right-&gt;parent = x;</span><br><span class="line">		&#125;</span><br><span class="line">		y-&gt;parent = x-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;root = y;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right) &#123;</span><br><span class="line">			x-&gt;parent-&gt;right = y;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			x-&gt;parent-&gt;left = y;</span><br><span class="line">		&#125;</span><br><span class="line">		y-&gt;right = x;</span><br><span class="line">		x-&gt;parent = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert the key to the tree in its appropriate position</span></span><br><span class="line">	<span class="comment">// and fix the tree</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Ordinary Binary Search Insertion</span></span><br><span class="line">		NodePtr node = <span class="keyword">new</span> Node;</span><br><span class="line">		node-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">		node-&gt;data = key;</span><br><span class="line">		node-&gt;left = TNULL;</span><br><span class="line">		node-&gt;right = TNULL;</span><br><span class="line">		node-&gt;color = <span class="number">1</span>; <span class="comment">// new node must be red</span></span><br><span class="line"></span><br><span class="line">		NodePtr y = <span class="literal">nullptr</span>;</span><br><span class="line">		NodePtr x = <span class="keyword">this</span>-&gt;root;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (x != TNULL) &#123;</span><br><span class="line">			y = x;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;data &lt; x-&gt;data) &#123;</span><br><span class="line">				x = x-&gt;left;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				x = x-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// y is parent of x</span></span><br><span class="line">		node-&gt;parent = y;</span><br><span class="line">		<span class="keyword">if</span> (y == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			root = node;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;data &lt; y-&gt;data) &#123;</span><br><span class="line">			y-&gt;left = node;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			y-&gt;right = node;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if new node is a root node, simply return</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;parent == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">			node-&gt;color = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if the grandparent is null, simply return</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;parent-&gt;parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Fix the tree</span></span><br><span class="line">		<span class="built_in">fixInsert</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">NodePtr <span class="title">getRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// delete the node from the tree</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">deleteNodeHelper</span>(<span class="keyword">this</span>-&gt;root, data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print the tree structure on the screen</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">prettyPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    		<span class="built_in">printHelper</span>(<span class="keyword">this</span>-&gt;root, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	RBTree bst;</span><br><span class="line">	bst.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">	bst.<span class="built_in">insert</span>(<span class="number">18</span>);</span><br><span class="line">	bst.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">	bst.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">	bst.<span class="built_in">insert</span>(<span class="number">17</span>);</span><br><span class="line">	bst.<span class="built_in">insert</span>(<span class="number">25</span>);</span><br><span class="line">	bst.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	bst.<span class="built_in">insert</span>(<span class="number">80</span>);</span><br><span class="line">	bst.<span class="built_in">deleteNode</span>(<span class="number">25</span>);</span><br><span class="line">	bst.<span class="built_in">prettyPrint</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java">Java</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Red Black Tree implementation in Java</span></span><br><span class="line"><span class="comment">// Author: Algorithm Tutor</span></span><br><span class="line"><span class="comment">// Tutorial URL: https://algorithmtutor.com/Data-Structures/Tree/Red-Black-Trees/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// data structure that represents a node in the tree</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data; <span class="comment">// holds the key</span></span><br><span class="line">	Node parent; <span class="comment">// pointer to the parent</span></span><br><span class="line">	Node left; <span class="comment">// pointer to left child</span></span><br><span class="line">	Node right; <span class="comment">// pointer to right child</span></span><br><span class="line">	<span class="type">int</span> color; <span class="comment">// 1 . Red, 0 . Black</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// class RedBlackTree implements the operations in Red Black Tree</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBlackTree</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Node root;</span><br><span class="line">	<span class="keyword">private</span> Node TNULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrderHelper</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (node != TNULL) &#123;</span><br><span class="line">			System.out.print(node.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			preOrderHelper(node.left);</span><br><span class="line">			preOrderHelper(node.right);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrderHelper</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (node != TNULL) &#123;</span><br><span class="line">			inOrderHelper(node.left);</span><br><span class="line">			System.out.print(node.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			inOrderHelper(node.right);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrderHelper</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (node != TNULL) &#123;</span><br><span class="line">			postOrderHelper(node.left);</span><br><span class="line">			postOrderHelper(node.right);</span><br><span class="line">			System.out.print(node.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Node <span class="title function_">searchTreeHelper</span><span class="params">(Node node, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (node == TNULL || key == node.data) &#123;</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (key &lt; node.data) &#123;</span><br><span class="line">			<span class="keyword">return</span> searchTreeHelper(node.left, key);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> searchTreeHelper(node.right, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fix the rb tree modified by the delete operation</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixDelete</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">		Node s;</span><br><span class="line">		<span class="keyword">while</span> (x != root &amp;&amp; x.color == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">				s = x.parent.right;</span><br><span class="line">				<span class="keyword">if</span> (s.color == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.1</span></span><br><span class="line">					s.color = <span class="number">0</span>;</span><br><span class="line">					x.parent.color = <span class="number">1</span>;</span><br><span class="line">					leftRotate(x.parent);</span><br><span class="line">					s = x.parent.right;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (s.left.color == <span class="number">0</span> &amp;&amp; s.right.color == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.2</span></span><br><span class="line">					s.color = <span class="number">1</span>;</span><br><span class="line">					x = x.parent;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (s.right.color == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">// case 3.3</span></span><br><span class="line">						s.left.color = <span class="number">0</span>;</span><br><span class="line">						s.color = <span class="number">1</span>;</span><br><span class="line">						rightRotate(s);</span><br><span class="line">						s = x.parent.right;</span><br><span class="line">					&#125; </span><br><span class="line"></span><br><span class="line">					<span class="comment">// case 3.4</span></span><br><span class="line">					s.color = x.parent.color;</span><br><span class="line">					x.parent.color = <span class="number">0</span>;</span><br><span class="line">					s.right.color = <span class="number">0</span>;</span><br><span class="line">					leftRotate(x.parent);</span><br><span class="line">					x = root;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s = x.parent.left;</span><br><span class="line">				<span class="keyword">if</span> (s.color == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.1</span></span><br><span class="line">					s.color = <span class="number">0</span>;</span><br><span class="line">					x.parent.color = <span class="number">1</span>;</span><br><span class="line">					rightRotate(x.parent);</span><br><span class="line">					s = x.parent.left;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (s.right.color == <span class="number">0</span> &amp;&amp; s.right.color == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.2</span></span><br><span class="line">					s.color = <span class="number">1</span>;</span><br><span class="line">					x = x.parent;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (s.left.color == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">// case 3.3</span></span><br><span class="line">						s.right.color = <span class="number">0</span>;</span><br><span class="line">						s.color = <span class="number">1</span>;</span><br><span class="line">						leftRotate(s);</span><br><span class="line">						s = x.parent.left;</span><br><span class="line">					&#125; </span><br><span class="line"></span><br><span class="line">					<span class="comment">// case 3.4</span></span><br><span class="line">					s.color = x.parent.color;</span><br><span class="line">					x.parent.color = <span class="number">0</span>;</span><br><span class="line">					s.left.color = <span class="number">0</span>;</span><br><span class="line">					rightRotate(x.parent);</span><br><span class="line">					x = root;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		x.color = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rbTransplant</span><span class="params">(Node u, Node v)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">			root = v;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u.parent.left)&#123;</span><br><span class="line">			u.parent.left = v;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			u.parent.right = v;</span><br><span class="line">		&#125;</span><br><span class="line">		v.parent = u.parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteNodeHelper</span><span class="params">(Node node, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">		<span class="comment">// find the node containing key</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">z</span> <span class="operator">=</span> TNULL;</span><br><span class="line">		Node x, y;</span><br><span class="line">		<span class="keyword">while</span> (node != TNULL)&#123;</span><br><span class="line">			<span class="keyword">if</span> (node.data == key) &#123;</span><br><span class="line">				z = node;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (node.data &lt;= key) &#123;</span><br><span class="line">				node = node.right;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				node = node.left;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (z == TNULL) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Couldn&#x27;t find key in the tree&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		y = z;</span><br><span class="line">		<span class="type">int</span> <span class="variable">yOriginalColor</span> <span class="operator">=</span> y.color;</span><br><span class="line">		<span class="keyword">if</span> (z.left == TNULL) &#123;</span><br><span class="line">			x = z.right;</span><br><span class="line">			rbTransplant(z, z.right);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z.right == TNULL) &#123;</span><br><span class="line">			x = z.left;</span><br><span class="line">			rbTransplant(z, z.left);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			y = minimum(z.right);</span><br><span class="line">			yOriginalColor = y.color;</span><br><span class="line">			x = y.right;</span><br><span class="line">			<span class="keyword">if</span> (y.parent == z) &#123;</span><br><span class="line">				x.parent = y;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				rbTransplant(y, y.right);</span><br><span class="line">				y.right = z.right;</span><br><span class="line">				y.right.parent = y;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			rbTransplant(z, y);</span><br><span class="line">			y.left = z.left;</span><br><span class="line">			y.left.parent = y;</span><br><span class="line">			y.color = z.color;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (yOriginalColor == <span class="number">0</span>)&#123;</span><br><span class="line">			fixDelete(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// fix the red-black tree</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixInsert</span><span class="params">(Node k)</span>&#123;</span><br><span class="line">		Node u;</span><br><span class="line">		<span class="keyword">while</span> (k.parent.color == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k.parent == k.parent.parent.right) &#123;</span><br><span class="line">				u = k.parent.parent.left; <span class="comment">// uncle</span></span><br><span class="line">				<span class="keyword">if</span> (u.color == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// case 3.1</span></span><br><span class="line">					u.color = <span class="number">0</span>;</span><br><span class="line">					k.parent.color = <span class="number">0</span>;</span><br><span class="line">					k.parent.parent.color = <span class="number">1</span>;</span><br><span class="line">					k = k.parent.parent;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (k == k.parent.left) &#123;</span><br><span class="line">						<span class="comment">// case 3.2.2</span></span><br><span class="line">						k = k.parent;</span><br><span class="line">						rightRotate(k);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// case 3.2.1</span></span><br><span class="line">					k.parent.color = <span class="number">0</span>;</span><br><span class="line">					k.parent.parent.color = <span class="number">1</span>;</span><br><span class="line">					leftRotate(k.parent.parent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				u = k.parent.parent.right; <span class="comment">// uncle</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (u.color == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// mirror case 3.1</span></span><br><span class="line">					u.color = <span class="number">0</span>;</span><br><span class="line">					k.parent.color = <span class="number">0</span>;</span><br><span class="line">					k.parent.parent.color = <span class="number">1</span>;</span><br><span class="line">					k = k.parent.parent;	</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (k == k.parent.right) &#123;</span><br><span class="line">						<span class="comment">// mirror case 3.2.2</span></span><br><span class="line">						k = k.parent;</span><br><span class="line">						leftRotate(k);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// mirror case 3.2.1</span></span><br><span class="line">					k.parent.color = <span class="number">0</span>;</span><br><span class="line">					k.parent.parent.color = <span class="number">1</span>;</span><br><span class="line">					rightRotate(k.parent.parent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (k == root) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		root.color = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHelper</span><span class="params">(Node root, String indent, <span class="type">boolean</span> last)</span> &#123;</span><br><span class="line">		<span class="comment">// print the tree structure on the screen</span></span><br><span class="line">	   	<span class="keyword">if</span> (root != TNULL) &#123;</span><br><span class="line">		   System.out.print(indent);</span><br><span class="line">		   <span class="keyword">if</span> (last) &#123;</span><br><span class="line">		      System.out.print(<span class="string">&quot;R----&quot;</span>);</span><br><span class="line">		      indent += <span class="string">&quot;     &quot;</span>;</span><br><span class="line">		   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		      System.out.print(<span class="string">&quot;L----&quot;</span>);</span><br><span class="line">		      indent += <span class="string">&quot;|    &quot;</span>;</span><br><span class="line">		   &#125;</span><br><span class="line">            </span><br><span class="line">           <span class="type">String</span> <span class="variable">sColor</span> <span class="operator">=</span> root.color == <span class="number">1</span>?<span class="string">&quot;RED&quot;</span>:<span class="string">&quot;BLACK&quot;</span>;</span><br><span class="line">		   System.out.println(root.data + <span class="string">&quot;(&quot;</span> + sColor + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">		   printHelper(root.left, indent, <span class="literal">false</span>);</span><br><span class="line">		   printHelper(root.right, indent, <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RedBlackTree</span><span class="params">()</span> &#123;</span><br><span class="line">		TNULL = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">		TNULL.color = <span class="number">0</span>;</span><br><span class="line">		TNULL.left = <span class="literal">null</span>;</span><br><span class="line">		TNULL.right = <span class="literal">null</span>;</span><br><span class="line">		root = TNULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pre-Order traversal</span></span><br><span class="line">	<span class="comment">// Node.Left Subtree.Right Subtree</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">()</span> &#123;</span><br><span class="line">		preOrderHelper(<span class="built_in">this</span>.root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// In-Order traversal</span></span><br><span class="line">	<span class="comment">// Left Subtree . Node . Right Subtree</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">()</span> &#123;</span><br><span class="line">		inOrderHelper(<span class="built_in">this</span>.root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Post-Order traversal</span></span><br><span class="line">	<span class="comment">// Left Subtree . Right Subtree . Node</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">()</span> &#123;</span><br><span class="line">		postOrderHelper(<span class="built_in">this</span>.root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// search the tree for the key k</span></span><br><span class="line">	<span class="comment">// and return the corresponding node</span></span><br><span class="line">	<span class="keyword">public</span> Node <span class="title function_">searchTree</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> searchTreeHelper(<span class="built_in">this</span>.root, k);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the node with the minimum key</span></span><br><span class="line">	<span class="keyword">public</span> Node <span class="title function_">minimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (node.left != TNULL) &#123;</span><br><span class="line">			node = node.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the node with the maximum key</span></span><br><span class="line">	<span class="keyword">public</span> Node <span class="title function_">maximum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (node.right != TNULL) &#123;</span><br><span class="line">			node = node.right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the successor of a given node</span></span><br><span class="line">	<span class="keyword">public</span> Node <span class="title function_">successor</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">		<span class="comment">// if the right subtree is not null,</span></span><br><span class="line">		<span class="comment">// the successor is the leftmost node in the</span></span><br><span class="line">		<span class="comment">// right subtree</span></span><br><span class="line">		<span class="keyword">if</span> (x.right != TNULL) &#123;</span><br><span class="line">			<span class="keyword">return</span> minimum(x.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// else it is the lowest ancestor of x whose</span></span><br><span class="line">		<span class="comment">// left child is also an ancestor of x.</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> x.parent;</span><br><span class="line">		<span class="keyword">while</span> (y != TNULL &amp;&amp; x == y.right) &#123;</span><br><span class="line">			x = y;</span><br><span class="line">			y = y.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the predecessor of a given node</span></span><br><span class="line">	<span class="keyword">public</span> Node <span class="title function_">predecessor</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">		<span class="comment">// if the left subtree is not null,</span></span><br><span class="line">		<span class="comment">// the predecessor is the rightmost node in the </span></span><br><span class="line">		<span class="comment">// left subtree</span></span><br><span class="line">		<span class="keyword">if</span> (x.left != TNULL) &#123;</span><br><span class="line">			<span class="keyword">return</span> maximum(x.left);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> x.parent;</span><br><span class="line">		<span class="keyword">while</span> (y != TNULL &amp;&amp; x == y.left) &#123;</span><br><span class="line">			x = y;</span><br><span class="line">			y = y.parent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rotate left at node x</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> x.right;</span><br><span class="line">		x.right = y.left;</span><br><span class="line">		<span class="keyword">if</span> (y.left != TNULL) &#123;</span><br><span class="line">			y.left.parent = x;</span><br><span class="line">		&#125;</span><br><span class="line">		y.parent = x.parent;</span><br><span class="line">		<span class="keyword">if</span> (x.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.root = y;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">			x.parent.left = y;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			x.parent.right = y;</span><br><span class="line">		&#125;</span><br><span class="line">		y.left = x;</span><br><span class="line">		x.parent = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rotate right at node x</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> x.left;</span><br><span class="line">		x.left = y.right;</span><br><span class="line">		<span class="keyword">if</span> (y.right != TNULL) &#123;</span><br><span class="line">			y.right.parent = x;</span><br><span class="line">		&#125;</span><br><span class="line">		y.parent = x.parent;</span><br><span class="line">		<span class="keyword">if</span> (x.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.root = y;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.right) &#123;</span><br><span class="line">			x.parent.right = y;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			x.parent.left = y;</span><br><span class="line">		&#125;</span><br><span class="line">		y.right = x;</span><br><span class="line">		x.parent = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert the key to the tree in its appropriate position</span></span><br><span class="line">	<span class="comment">// and fix the tree</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">		<span class="comment">// Ordinary Binary Search Insertion</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">		node.parent = <span class="literal">null</span>;</span><br><span class="line">		node.data = key;</span><br><span class="line">		node.left = TNULL;</span><br><span class="line">		node.right = TNULL;</span><br><span class="line">		node.color = <span class="number">1</span>; <span class="comment">// new node must be red</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (x != TNULL) &#123;</span><br><span class="line">			y = x;</span><br><span class="line">			<span class="keyword">if</span> (node.data &lt; x.data) &#123;</span><br><span class="line">				x = x.left;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				x = x.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// y is parent of x</span></span><br><span class="line">		node.parent = y;</span><br><span class="line">		<span class="keyword">if</span> (y == <span class="literal">null</span>) &#123;</span><br><span class="line">			root = node;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.data &lt; y.data) &#123;</span><br><span class="line">			y.left = node;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			y.right = node;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if new node is a root node, simply return</span></span><br><span class="line">		<span class="keyword">if</span> (node.parent == <span class="literal">null</span>)&#123;</span><br><span class="line">			node.color = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if the grandparent is null, simply return</span></span><br><span class="line">		<span class="keyword">if</span> (node.parent.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Fix the tree</span></span><br><span class="line">		fixInsert(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// delete the node from the tree</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">		deleteNodeHelper(<span class="built_in">this</span>.root, data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print the tree structure on the screen</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prettyPrint</span><span class="params">()</span> &#123;</span><br><span class="line">        printHelper(<span class="built_in">this</span>.root, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">    	<span class="type">RedBlackTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedBlackTree</span>();</span><br><span class="line">        bst.insert(<span class="number">8</span>);</span><br><span class="line">    	bst.insert(<span class="number">18</span>);</span><br><span class="line">    	bst.insert(<span class="number">5</span>);</span><br><span class="line">    	bst.insert(<span class="number">15</span>);</span><br><span class="line">    	bst.insert(<span class="number">17</span>);</span><br><span class="line">    	bst.insert(<span class="number">25</span>);</span><br><span class="line">    	bst.insert(<span class="number">40</span>);</span><br><span class="line">    	bst.insert(<span class="number">80</span>);</span><br><span class="line">    	bst.deleteNode(<span class="number">25</span>);</span><br><span class="line">    	bst.prettyPrint();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="python">Python</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Red Black Tree implementation in Python 2.7</span></span><br><span class="line"><span class="comment"># Author: Algorithm Tutor</span></span><br><span class="line"><span class="comment"># Tutorial URL: https://algorithmtutor.com/Data-Structures/Tree/Red-Black-Trees/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># data structure that represents a node in the tree</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data  <span class="comment"># holds the key</span></span><br><span class="line">        self.parent = <span class="literal">None</span> <span class="comment">#pointer to the parent</span></span><br><span class="line">        self.left = <span class="literal">None</span> <span class="comment"># pointer to left child</span></span><br><span class="line">        self.right = <span class="literal">None</span> <span class="comment">#pointer to right child</span></span><br><span class="line">        self.color = <span class="number">1</span> <span class="comment"># 1 . Red, 0 . Black</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># class RedBlackTree implements the operations in Red Black Tree</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackTree</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.TNULL = Node(<span class="number">0</span>)</span><br><span class="line">        self.TNULL.color = <span class="number">0</span></span><br><span class="line">        self.TNULL.left = <span class="literal">None</span></span><br><span class="line">        self.TNULL.right = <span class="literal">None</span></span><br><span class="line">        self.root = self.TNULL</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pre_order_helper</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node != TNULL:</span><br><span class="line">            sys.stdout.write(node.data + <span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.__pre_order_helper(node.left)</span><br><span class="line">            self.__pre_order_helper(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__in_order_helper</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node != TNULL:</span><br><span class="line">            self.__in_order_helper(node.left)</span><br><span class="line">            sys.stdout.write(node.data + <span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.__in_order_helper(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__post_order_helper</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node != TNULL:</span><br><span class="line">            self.__post_order_helper(node.left)</span><br><span class="line">            self.__post_order_helper(node.right)</span><br><span class="line">            sys.stdout.write(node.data + <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__search_tree_helper</span>(<span class="params">self, node, key</span>):</span><br><span class="line">        <span class="keyword">if</span> node == TNULL <span class="keyword">or</span> key == node.data:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> key &lt; node.data:</span><br><span class="line">            <span class="keyword">return</span> self.__search_tree_helper(node.left, key)</span><br><span class="line">        <span class="keyword">return</span> self.__search_tree_helper(node.right, key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fix the rb tree modified by the delete operation</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__fix_delete</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">while</span> x != self.root <span class="keyword">and</span> x.color == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> x == x.parent.left:</span><br><span class="line">                s = x.parent.right</span><br><span class="line">                <span class="keyword">if</span> s.color == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># case 3.1</span></span><br><span class="line">                    s.color = <span class="number">0</span></span><br><span class="line">                    x.parent.color = <span class="number">1</span></span><br><span class="line">                    self.left_rotate(x.parent)</span><br><span class="line">                    s = x.parent.right</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> s.left.color == <span class="number">0</span> <span class="keyword">and</span> s.right.color == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># case 3.2</span></span><br><span class="line">                    s.color = <span class="number">1</span></span><br><span class="line">                    x = x.parent</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s.right.color == <span class="number">0</span>:</span><br><span class="line">                        <span class="comment"># case 3.3</span></span><br><span class="line">                        s.left.color = <span class="number">0</span></span><br><span class="line">                        s.color = <span class="number">1</span></span><br><span class="line">                        self.right_rotate(s)</span><br><span class="line">                        s = x.parent.right</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># case 3.4</span></span><br><span class="line">                    s.color = x.parent.color</span><br><span class="line">                    x.parent.color = <span class="number">0</span></span><br><span class="line">                    s.right.color = <span class="number">0</span></span><br><span class="line">                    self.left_rotate(x.parent)</span><br><span class="line">                    x = self.root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = x.parent.left</span><br><span class="line">                <span class="keyword">if</span> s.color == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># case 3.1</span></span><br><span class="line">                    s.color = <span class="number">0</span></span><br><span class="line">                    x.parent.color = <span class="number">1</span></span><br><span class="line">                    self.right_rotate(x.parent)</span><br><span class="line">                    s = x.parent.left</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> s.left.color == <span class="number">0</span> <span class="keyword">and</span> s.right.color == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># case 3.2</span></span><br><span class="line">                    s.color = <span class="number">1</span></span><br><span class="line">                    x = x.parent</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s.left.color == <span class="number">0</span>:</span><br><span class="line">                        <span class="comment"># case 3.3</span></span><br><span class="line">                        s.right.color = <span class="number">0</span></span><br><span class="line">                        s.color = <span class="number">1</span></span><br><span class="line">                        self.left_rotate(s)</span><br><span class="line">                        s = x.parent.left </span><br><span class="line"></span><br><span class="line">                    <span class="comment"># case 3.4</span></span><br><span class="line">                    s.color = x.parent.color</span><br><span class="line">                    x.parent.color = <span class="number">0</span></span><br><span class="line">                    s.left.color = <span class="number">0</span></span><br><span class="line">                    self.right_rotate(x.parent)</span><br><span class="line">                    x = self.root</span><br><span class="line">        x.color = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__rb_transplant</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="keyword">if</span> u.parent == <span class="literal">None</span>:</span><br><span class="line">            self.root = v</span><br><span class="line">        <span class="keyword">elif</span> u == u.parent.left:</span><br><span class="line">            u.parent.left = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u.parent.right = v</span><br><span class="line">        v.parent = u.parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete_node_helper</span>(<span class="params">self, node, key</span>):</span><br><span class="line">        <span class="comment"># find the node containing key</span></span><br><span class="line">        z = self.TNULL</span><br><span class="line">        <span class="keyword">while</span> node != self.TNULL:</span><br><span class="line">            <span class="keyword">if</span> node.data == key:</span><br><span class="line">                z = node</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.data &lt;= key:</span><br><span class="line">                node = node.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = node.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> z == self.TNULL:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Couldn&#x27;t find key in the tree&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        y = z</span><br><span class="line">        y_original_color = y.color</span><br><span class="line">        <span class="keyword">if</span> z.left == self.TNULL:</span><br><span class="line">            x = z.right</span><br><span class="line">            self.__rb_transplant(z, z.right)</span><br><span class="line">        <span class="keyword">elif</span> (z.right == self.TNULL):</span><br><span class="line">            x = z.left</span><br><span class="line">            self.__rb_transplant(z, z.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y = self.minimum(z.right)</span><br><span class="line">            y_original_color = y.color</span><br><span class="line">            x = y.right</span><br><span class="line">            <span class="keyword">if</span> y.parent == z:</span><br><span class="line">                x.parent = y</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.__rb_transplant(y, y.right)</span><br><span class="line">                y.right = z.right</span><br><span class="line">                y.right.parent = y</span><br><span class="line"></span><br><span class="line">            self.__rb_transplant(z, y)</span><br><span class="line">            y.left = z.left</span><br><span class="line">            y.left.parent = y</span><br><span class="line">            y.color = z.color</span><br><span class="line">        <span class="keyword">if</span> y_original_color == <span class="number">0</span>:</span><br><span class="line">            self.__fix_delete(x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># fix the red-black tree</span></span><br><span class="line">    <span class="keyword">def</span>  <span class="title function_">__fix_insert</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="keyword">while</span> k.parent.color == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> k.parent == k.parent.parent.right:</span><br><span class="line">                u = k.parent.parent.left <span class="comment"># uncle</span></span><br><span class="line">                <span class="keyword">if</span> u.color == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># case 3.1</span></span><br><span class="line">                    u.color = <span class="number">0</span></span><br><span class="line">                    k.parent.color = <span class="number">0</span></span><br><span class="line">                    k.parent.parent.color = <span class="number">1</span></span><br><span class="line">                    k = k.parent.parent</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> k == k.parent.left:</span><br><span class="line">                        <span class="comment"># case 3.2.2</span></span><br><span class="line">                        k = k.parent</span><br><span class="line">                        self.right_rotate(k)</span><br><span class="line">                    <span class="comment"># case 3.2.1</span></span><br><span class="line">                    k.parent.color = <span class="number">0</span></span><br><span class="line">                    k.parent.parent.color = <span class="number">1</span></span><br><span class="line">                    self.left_rotate(k.parent.parent)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                u = k.parent.parent.right <span class="comment"># uncle</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> u.color == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># mirror case 3.1</span></span><br><span class="line">                    u.color = <span class="number">0</span></span><br><span class="line">                    k.parent.color = <span class="number">0</span></span><br><span class="line">                    k.parent.parent.color = <span class="number">1</span></span><br><span class="line">                    k = k.parent.parent </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> k == k.parent.right:</span><br><span class="line">                        <span class="comment"># mirror case 3.2.2</span></span><br><span class="line">                        k = k.parent</span><br><span class="line">                        self.left_rotate(k)</span><br><span class="line">                    <span class="comment"># mirror case 3.2.1</span></span><br><span class="line">                    k.parent.color = <span class="number">0</span></span><br><span class="line">                    k.parent.parent.color = <span class="number">1</span></span><br><span class="line">                    self.right_rotate(k.parent.parent)</span><br><span class="line">            <span class="keyword">if</span> k == self.root:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.root.color = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__print_helper</span>(<span class="params">self, node, indent, last</span>):</span><br><span class="line">        <span class="comment"># print the tree structure on the screen</span></span><br><span class="line">        <span class="keyword">if</span> node != self.TNULL:</span><br><span class="line">            sys.stdout.write(indent)</span><br><span class="line">            <span class="keyword">if</span> last:</span><br><span class="line">                sys.stdout.write(<span class="string">&quot;R----&quot;</span>)</span><br><span class="line">                indent += <span class="string">&quot;     &quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sys.stdout.write(<span class="string">&quot;L----&quot;</span>)</span><br><span class="line">                indent += <span class="string">&quot;|    &quot;</span></span><br><span class="line"></span><br><span class="line">            s_color = <span class="string">&quot;RED&quot;</span> <span class="keyword">if</span> node.color == <span class="number">1</span> <span class="keyword">else</span> <span class="string">&quot;BLACK&quot;</span></span><br><span class="line">            <span class="built_in">print</span> <span class="built_in">str</span>(node.data) + <span class="string">&quot;(&quot;</span> + s_color + <span class="string">&quot;)&quot;</span></span><br><span class="line">            self.__print_helper(node.left, indent, <span class="literal">False</span>)</span><br><span class="line">            self.__print_helper(node.right, indent, <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Pre-Order traversal</span></span><br><span class="line">    <span class="comment"># Node.Left Subtree.Right Subtree</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self</span>):</span><br><span class="line">        self.__pre_order_helper(self.root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># In-Order traversal</span></span><br><span class="line">    <span class="comment"># left Subtree . Node . Right Subtree</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">self</span>):</span><br><span class="line">        self.__in_order_helper(self.root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Post-Order traversal</span></span><br><span class="line">    <span class="comment"># Left Subtree . Right Subtree . Node</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">self</span>):</span><br><span class="line">        self.__post_order_helper(self.root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># search the tree for the key k</span></span><br><span class="line">    <span class="comment"># and return the corresponding node</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchTree</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__search_tree_helper(self.root, k)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find the node with the minimum key</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimum</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">while</span> node.left != self.TNULL:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find the node with the maximum key</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximum</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">while</span> node.right != self.TNULL:</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find the successor of a given node</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">successor</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># if the right subtree is not None,</span></span><br><span class="line">        <span class="comment"># the successor is the leftmost node in the</span></span><br><span class="line">        <span class="comment"># right subtree</span></span><br><span class="line">        <span class="keyword">if</span> x.right != self.TNULL:</span><br><span class="line">            <span class="keyword">return</span> self.minimum(x.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># else it is the lowest ancestor of x whose</span></span><br><span class="line">        <span class="comment"># left child is also an ancestor of x.</span></span><br><span class="line">        y = x.parent</span><br><span class="line">        <span class="keyword">while</span> y != self.TNULL <span class="keyword">and</span> x == y.right:</span><br><span class="line">            x = y</span><br><span class="line">            y = y.parent</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find the predecessor of a given node</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predecessor</span>(<span class="params">self,  x</span>):</span><br><span class="line">        <span class="comment"># if the left subtree is not None,</span></span><br><span class="line">        <span class="comment"># the predecessor is the rightmost node in the </span></span><br><span class="line">        <span class="comment"># left subtree</span></span><br><span class="line">        <span class="keyword">if</span> (x.left != self.TNULL):</span><br><span class="line">            <span class="keyword">return</span> self.maximum(x.left)</span><br><span class="line"></span><br><span class="line">        y = x.parent</span><br><span class="line">        <span class="keyword">while</span> y != self.TNULL <span class="keyword">and</span> x == y.left:</span><br><span class="line">            x = y</span><br><span class="line">            y = y.parent</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># rotate left at node x</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">left_rotate</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = x.right</span><br><span class="line">        x.right = y.left</span><br><span class="line">        <span class="keyword">if</span> y.left != self.TNULL:</span><br><span class="line">            y.left.parent = x</span><br><span class="line"></span><br><span class="line">        y.parent = x.parent</span><br><span class="line">        <span class="keyword">if</span> x.parent == <span class="literal">None</span>:</span><br><span class="line">            self.root = y</span><br><span class="line">        <span class="keyword">elif</span> x == x.parent.left:</span><br><span class="line">            x.parent.left = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x.parent.right = y</span><br><span class="line">        y.left = x</span><br><span class="line">        x.parent = y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># rotate right at node x</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">right_rotate</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = x.left</span><br><span class="line">        x.left = y.right</span><br><span class="line">        <span class="keyword">if</span> y.right != self.TNULL:</span><br><span class="line">            y.right.parent = x</span><br><span class="line"></span><br><span class="line">        y.parent = x.parent</span><br><span class="line">        <span class="keyword">if</span> x.parent == <span class="literal">None</span>:</span><br><span class="line">            self.root = y</span><br><span class="line">        <span class="keyword">elif</span> x == x.parent.right:</span><br><span class="line">            x.parent.right = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x.parent.left = y</span><br><span class="line">        y.right = x</span><br><span class="line">        x.parent = y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># insert the key to the tree in its appropriate position</span></span><br><span class="line">    <span class="comment"># and fix the tree</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># Ordinary Binary Search Insertion</span></span><br><span class="line">        node = Node(key)</span><br><span class="line">        node.parent = <span class="literal">None</span></span><br><span class="line">        node.data = key</span><br><span class="line">        node.left = self.TNULL</span><br><span class="line">        node.right = self.TNULL</span><br><span class="line">        node.color = <span class="number">1</span> <span class="comment"># new node must be red</span></span><br><span class="line"></span><br><span class="line">        y = <span class="literal">None</span></span><br><span class="line">        x = self.root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> x != self.TNULL:</span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">if</span> node.data &lt; x.data:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># y is parent of x</span></span><br><span class="line">        node.parent = y</span><br><span class="line">        <span class="keyword">if</span> y == <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">elif</span> node.data &lt; y.data:</span><br><span class="line">            y.left = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.right = node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if new node is a root node, simply return</span></span><br><span class="line">        <span class="keyword">if</span> node.parent == <span class="literal">None</span>:</span><br><span class="line">            node.color = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if the grandparent is None, simply return</span></span><br><span class="line">        <span class="keyword">if</span> node.parent.parent == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Fix the tree</span></span><br><span class="line">        self.__fix_insert(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_root</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.root</span><br><span class="line"></span><br><span class="line">    <span class="comment"># delete the node from the tree</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete_node</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.__delete_node_helper(self.root, data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print the tree structure on the screen</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pretty_print</span>(<span class="params">self</span>):</span><br><span class="line">        self.__print_helper(self.root, <span class="string">&quot;&quot;</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    bst = RedBlackTree()</span><br><span class="line">    bst.insert(<span class="number">8</span>)</span><br><span class="line">    bst.insert(<span class="number">18</span>)</span><br><span class="line">    bst.insert(<span class="number">5</span>)</span><br><span class="line">    bst.insert(<span class="number">15</span>)</span><br><span class="line">    bst.insert(<span class="number">17</span>)</span><br><span class="line">    bst.insert(<span class="number">25</span>)</span><br><span class="line">    bst.insert(<span class="number">40</span>)</span><br><span class="line">    bst.insert(<span class="number">80</span>)</span><br><span class="line">    bst.delete_node(<span class="number">25</span>)</span><br><span class="line">    bst.pretty_print()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>data structure</tag>
        <tag>Algorithm Tutor</tag>
      </tags>
  </entry>
  <entry>
    <title>web link</title>
    <url>/blog/2023/10/11/data/CSAPP/data%20structure/Algorithm%20Tutor/web%20link/</url>
    <content><![CDATA[<p>algorithmtutor.com</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>data structure</tag>
        <tag>Algorithm Tutor</tag>
      </tags>
  </entry>
  <entry>
    <title>homework1</title>
    <url>/blog/2023/10/11/data/CSAPP/database/CMU-15445/homework1/</url>
    <content><![CDATA[<h1 id="overview">OVERVIEW</h1>
<p>The first homework is to construct a set of SQL queries for analysing
a dataset that will be provided to you. For this, you will look into <a
href="https://www.imdb.com/interfaces/">IMDB data</a>. This homework is
an opportunity to: (1) learn basic and certain advanced SQL features,
and (2) get familiar with using a full-featured DBMS, <a
href="https://www.sqlite.org/">SQLite</a>, that can be useful for you in
the future.</p>
<h1 id="specification">SPECIFICATION</h1>
<p>The homework contains 10 questions in total and is graded out of 100
points. For each question, you will need to construct a SQL query that
fetches the desired data from the SQLite DBMS. It will likely take you
approximately 6-8 hours to complete the questions.</p>
<h2 id="placeholder-folder">Placeholder Folder</h2>
<p>Create the placeholder submission folder with the empty SQL files
that you will use for each question:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir placeholder</span><br><span class="line">$ cd placeholder</span><br><span class="line">$ touch \</span><br><span class="line">  q1_sample.sql \</span><br><span class="line">  q2_not_the_same_title.sql \</span><br><span class="line">  q3_longest_running_tv.sql \</span><br><span class="line">  q4_directors_in_each_decade.sql \</span><br><span class="line">  q5_german_type_ratings.sql \</span><br><span class="line">  q6_who_played_a_batman.sql \</span><br><span class="line">  q7_born_with_prestige.sql \</span><br><span class="line">  q8_directing_rose.sql \</span><br><span class="line">  q9_ode_to_death.sql \</span><br><span class="line">  q10_all_played_by_leo.sql</span><br><span class="line">$ cd ..</span><br></pre></td></tr></table></figure>
<p>After filling in the queries, you can compress the folder by running
the following command:</p>
<p>$ zip -j submission.zip placeholder/*.sql</p>
<p>The <code>-j</code> flag lets you compress all the SQL queries in the
zip file without path information. The grading scripts
will <strong>not</strong> work correctly unless you do this.</p>
<h1 id="instructions">INSTRUCTIONS</h1>
<h2 id="setting-up-sqlite">Setting Up SQLite</h2>
<p>You will first need to install SQLite on your development
machine.</p>
<blockquote>
<p>Make sure that you are using at least SQLite version 3.25! Older
releases (prior to 2019) will <strong>not</strong> support the SQL
features that you need to complete this assignment.</p>
</blockquote>
<h3 id="install-sqlite3-on-ubuntu-linux">Install SQLite3 on Ubuntu
Linux</h3>
<p>Please follow the <a
href="https://www.tutorialspoint.com/sqlite/sqlite_installation.htm">instructions</a>.</p>
<h3 id="install-sqlite3-on-mac-os-x">Install SQLite3 on Mac OS X</h3>
<p>On Mac OS Leopard or later, you don't have to! It comes
pre-installed. You can upgrade it, if you absolutely need to, with <a
href="https://15445.courses.cs.cmu.edu/spring2023/homework1/brew.sh">Homebrew</a>.</p>
<h2 id="load-the-database-dump">Load the Database Dump</h2>
<ol type="1">
<li><p>Check if <code>sqlite3</code> is properly working by <a
href="https://sqlite.org/cli.html#getting_started">following this
tutorial</a>.</p></li>
<li><p>Download the <a
href="https://15445.courses.cs.cmu.edu/spring2023/files/imdb-cmudb2022.db.gz">database
dump file</a>:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget [https://15445.courses.cs.cmu.edu/fall2022/files/imdb-cmudb2022.db.gz](https://15445.courses.cs.cmu.edu/spring2023/files/imdb-cmudb2022.db.gz)</span><br></pre></td></tr></table></figure> Check its MD5 checksum to ensure that you have correctly
downloaded the file:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ md5sum imdb-cmudb2022.db.gz</span><br><span class="line">d7cdf34f4ba029597c3774fc96bc3519  imdb-cmudb2022.db.gz</span><br></pre></td></tr></table></figure></p></li>
<li><p>Unzip the database from the provided database dump by running the
following commands on your shell. Note that the database file
be <strong>836MB</strong> after you decompress it.<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gunzip imdb-cmudb2022.db.gz</span><br><span class="line">$ sqlite3 imdb-cmudb2022.db</span><br></pre></td></tr></table></figure></p></li>
<li><p>We have prepared a random sample of the original dataset for this
assignment. Although this is not required to complete the assignment,
the complete dataset is available by following the steps <a
href="https://pypi.org/project/imdb-sqlite/">here</a>.</p></li>
<li><p>Check the contents of the database by running
the <code>.tables</code> command on the <code>sqlite3</code> terminal.
You should see <strong>6 tables</strong>, and the output should look
like this:</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sqlite3 imdb-cmudb2022.db</span><br><span class="line">SQLite version 3.31.1</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt; .tables</span><br><span class="line">akas      crew      episodes  people    ratings   titles</span><br></pre></td></tr></table></figure></p></li>
<li><p>Create indices using the following commands in SQLite:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX ix_people_name ON people (name);</span><br><span class="line">CREATE INDEX ix_titles_type ON titles (type);</span><br><span class="line">CREATE INDEX ix_titles_primary_title ON titles (primary_title);</span><br><span class="line">CREATE INDEX ix_titles_original_title ON titles (original_title);</span><br><span class="line">CREATE INDEX ix_akas_title_id ON akas (title_id);</span><br><span class="line">CREATE INDEX ix_akas_title ON akas (title);</span><br><span class="line">CREATE INDEX ix_crew_title_id ON crew (title_id);</span><br><span class="line">CREATE INDEX ix_crew_person_id ON crew (person_id);</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>以上是作业一的一些要求和前置操作。不过为了不污染主机系统，所以将sqlite3安装在docker中，并通过挂载主机的目录到docker容器内完成实验作业。</p>
<p>那么首先就要安装docker，配置好docker，参考笔记<a
href="obsidian://open?vault=testrepo&amp;file=linux%2Fdocker%2F%E4%BD%BF%E7%94%A8Clash%E4%BD%9C%E4%B8%BAdocker%20daemon%E7%9A%84%E4%BB%A3%E7%90%86">使用Clash作为docker
daemon代理</a>，完成docker配置后，可以写docker
file，使用最小的Linux发行版<strong>Alpine</strong>,
安装sqlite并在容器内做实验：<br />
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update &amp;&amp; apk add sqlite</span></span><br></pre></td></tr></table></figure> 使用以下脚本启动容器并进入容器内启动sqlite：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">docker container prune -f</span><br><span class="line">docker run -it -v /home/fredom/workspace/CMU-15445/data:/data alpine-sqlite3 sh -c &quot;cd data &amp;&amp; sqlite3 imdb-cmudb2022.db&quot;</span><br></pre></td></tr></table></figure></p>
<p>记得执行上述作业前置步骤中的第6步，为数据库中的表创建好索引。</p>
<h2 id="check-the-schema">Check the schema</h2>
<p>Get familiar with the schema (structure) of the tables (what
attributes do they contain, what are the primary and foreign keys). Run
the <code>.schema $TABLE_NAME</code> command on
the <code>sqlite3</code> terminal for each table. The output should look
like the example below for each table.</p>
<h3 id="people">PEOPLE</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .schema people</span><br><span class="line">CREATE TABLE people (</span><br><span class="line">  person_id VARCHAR PRIMARY KEY,</span><br><span class="line">  name VARCHAR,</span><br><span class="line">  born INTEGER,</span><br><span class="line">  died INTEGER</span><br><span class="line">);</span><br><span class="line">CREATE INDEX ix_people_name ON people (name);</span><br></pre></td></tr></table></figure>
<p>Contains details for a person. For example, this is a row from the
table:</p>
<p>nm0000006|Ingrid Bergman|1915|1982</p>
<p>To breakdown the row, the field <code>person_id</code> corresponds to
"nm0000006", <code>name</code> corresponds to "Ingrid
Bergman", <code>born</code> corresponds to "1981",
and <code>died</code> corresponds to "1982".</p>
<p>sqlite默认的输出格式很简单，如果想要类似MySQL那样的表格格式化输出，可以使用命令<code>.mode column</code>，以列的形式输出。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select * from people limit 10;</span><br><span class="line">nm0000004|John Belushi|1949|1982</span><br><span class="line">nm0000005|Ingmar Bergman|1918|2007</span><br><span class="line">nm0000006|Ingrid Bergman|1915|1982</span><br><span class="line">nm0000011|Gary Cooper|1901|1961</span><br><span class="line">nm0000018|Kirk Douglas|1916|2020</span><br><span class="line">nm0000022|Clark Gable|1901|1960</span><br><span class="line">nm0000023|Judy Garland|1922|1969</span><br><span class="line">nm0000035|James Horner|1953|2015</span><br><span class="line">nm0000037|Gene Kelly|1912|1996</span><br><span class="line">nm0000039|Deborah Kerr|1921|2007</span><br></pre></td></tr></table></figure> 使用<code>.mode column</code>改变输出格式后：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .mode column</span><br><span class="line">sqlite&gt; select * from people limit 10;</span><br><span class="line">person_id  name            born  died</span><br><span class="line">---------  --------------  ----  ----</span><br><span class="line">nm0000004  John Belushi    1949  1982</span><br><span class="line">nm0000005  Ingmar Bergman  1918  2007</span><br><span class="line">nm0000006  Ingrid Bergman  1915  1982</span><br><span class="line">nm0000011  Gary Cooper     1901  1961</span><br><span class="line">nm0000018  Kirk Douglas    1916  2020</span><br><span class="line">nm0000022  Clark Gable     1901  1960</span><br><span class="line">nm0000023  Judy Garland    1922  1969</span><br><span class="line">nm0000035  James Horner    1953  2015</span><br><span class="line">nm0000037  Gene Kelly      1912  1996</span><br><span class="line">nm0000039  Deborah Kerr    1921  2007</span><br></pre></td></tr></table></figure></p>
<p>本作业中并未使用到数据库的所有表，使用到的表ER图如下：<br />
<img
src="https://15445.courses.cs.cmu.edu/spring2023/files/schema2022.png"
alt="ER graph" /></p>
<h2 id="construct-the-sql-queries">Construct the SQL Queries</h2>
<p>Now, it's time to start constructing the SQL queries and put them
into the placeholder files.</p>
<h3 id="q1-0-points-q1_sample">Q1 [0 points] (q1_sample):</h3>
<p>The purpose of this query is to make sure that the formatting of your
output matches exactly the formatting of our auto-grading script.</p>
<p><strong>Details:</strong> List the first ten roles of the cast crew
members ordered alphabetically.</p>
<p><strong>Answer</strong>: Here's the correct SQL query and expected
output:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT DISTINCT(category)</span><br><span class="line">   ...&gt; FROM crew</span><br><span class="line">   ...&gt; ORDER BY category</span><br><span class="line">   ...&gt; LIMIT 10;</span><br><span class="line">actor</span><br><span class="line">actress</span><br><span class="line">archive_footage</span><br><span class="line">archive_sound</span><br><span class="line">cinematographer</span><br><span class="line">composer</span><br><span class="line">director</span><br><span class="line">editor</span><br><span class="line">producer</span><br><span class="line">production_designer</span><br></pre></td></tr></table></figure></p>
<h3 id="q2-5-points-q2_not_the_same_title">Q2 [5 points]
(q2_not_the_same_title):</h3>
<p>Find the 10 Action movies with the newest premiere date whose
original title is not the same as its primary title.</p>
<p><strong>Details:</strong> Print the premiere year, followed by the
two titles in a special format. The column listing the two titles should
be in the format of <code>primary_title (original_title)</code> Note a
work is <code>Action</code> even if it is categorized in multiple
genres, as long as <code>Action</code> is one of the genres. Also note
that it's possible for the premiered year to be in the future. If
multiple movies premiered in the same year, order them alphabetically.
Your first row should look like
this: <code>2027|The Adventures of Tintin: Red Rackham's Treasure (Untitled Adventures of Tintin Sequel)</code><br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	premiered,</span><br><span class="line">	primary_title <span class="operator">||</span> <span class="string">&#x27;(&#x27;</span> <span class="operator">||</span> original_title <span class="operator">||</span> <span class="string">&#x27;)&#x27;</span> <span class="keyword">AS</span> title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	titles</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	original_title <span class="operator">!=</span> primary_title <span class="keyword">AND</span></span><br><span class="line">	genres <span class="keyword">LIKE</span> <span class="string">&#x27;%Action%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	premiered <span class="keyword">DESC</span></span><br><span class="line">LIMIT</span><br><span class="line">	<span class="number">10</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure> 本题考查的点主要是字符串的拼接，即对拼接运算符
<strong>||</strong> 的使用，其他地方没有特别的难点。</p>
<h3 id="q3-5-points-q3_longest_running_tv">Q3 [5 points]
(q3_longest_running_tv):</h3>
<p>Find the top 20 longest running tv series.</p>
<p><strong>Details:</strong> Print the title and the years the series
has been running for. The series must have a
non <code>NULL</code> premiered year. If the ended date
is <code>NULL</code>, assume it to be the current year (2023). If
multiple tv series have been running the same number of years, order
them alphabetically. Print the top 20 results.<br />
Your output should have the
format: <code>TITLE|YEARS_RUNNING</code><br />
Your first row should look like this: <code>Looney Tunes|93</code><br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	primary_title <span class="keyword">AS</span> title, (IFNULL(ended, <span class="number">2023</span>) <span class="operator">-</span> premiered) <span class="keyword">AS</span> years_running</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	titles</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	premiered <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> type <span class="operator">=</span> <span class="string">&#x27;tvSeries&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	years_running <span class="keyword">DESC</span>,</span><br><span class="line">	title <span class="keyword">ASC</span></span><br><span class="line">LIMIT</span><br><span class="line">	<span class="number">20</span></span><br><span class="line">; </span><br></pre></td></tr></table></figure>
本题考察的点是对NULL值的处理，除了IFNULL函数对遇到记录的属性为NULL值的替换，还有CASE语句可以使用，但是我没有去查CASE的使用方法，而是用了IFNULL。</p>
<h3 id="q4-10-points-q4_directors_in_each_decade">Q4 [10 points]
(q4_directors_in_each_decade):</h3>
<p>List the number directors born in each decade since 1900.</p>
<p><strong>Details:</strong> Print the decade in a fancier format by
constructing a string that looks like this: <code>1990s</code>. Order
the results by decade.<br />
Your output should look like
this: <code>DECADE|NUM_DIRECTORS</code><br />
Your first row should look like this: <code>1900s|376</code><br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">CAST</span>(born <span class="operator">/</span> <span class="number">10</span> <span class="operator">*</span> <span class="number">10</span> <span class="keyword">AS</span> TEXT) <span class="operator">||</span> <span class="string">&#x27;s&#x27;</span> <span class="keyword">AS</span> decade, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span>(p.person_id)) <span class="keyword">AS</span> num_directors</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	people <span class="keyword">AS</span> p <span class="keyword">INNER</span> <span class="keyword">JOIN</span> crew <span class="keyword">AS</span> c <span class="keyword">ON</span> p.person_id <span class="operator">=</span> c.person_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	born <span class="operator">&gt;=</span> <span class="number">1900</span> <span class="keyword">AND</span> category <span class="operator">=</span> <span class="string">&#x27;director&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> (</span><br><span class="line">	decade</span><br><span class="line">)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
本题考察的点在于通过<code>INNER JOIN</code>来结合两张表的信息一起使用，并且了解计算机的整数除法会舍去小数部分的特点。考察了转换函数，因为标题要求显示年代+'s'，这就必须把数值类型转换为字符串类型才能继续字符串拼接操作。</p>
<h3 id="q5-10-points-q5_german_type_ratings">Q5 [10 points]
(q5_german_type_ratings):</h3>
<p>Compute statistics about different type of works that has a German
title.</p>
<p><strong>Details:</strong> Compute the average (rounded to 2 decimal
places), min, and max rating for each type of work that has a German
title and the akas types is
either <code>imdbDisplay</code> or <code>original</code>. Sort the
output by the average rating of each title type.<br />
Your output should have the
format: <code>TITLE_TYPE|AVG_RATING|MIN_RATING|MAX_RATING</code><br />
Your first row should look like
this: <code>movie|6.65|3.4|8.2</code><br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	titles.type <span class="keyword">AS</span> title_type,</span><br><span class="line">	ROUND(<span class="built_in">AVG</span>(rating), <span class="number">2</span>) <span class="keyword">AS</span> avg_rating,</span><br><span class="line">	<span class="built_in">MIN</span>(rating) <span class="keyword">AS</span> min_rating,</span><br><span class="line">	<span class="built_in">MAX</span>(rating) <span class="keyword">AS</span> max_rating</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(titles <span class="keyword">INNER</span> <span class="keyword">JOIN</span> akas <span class="keyword">ON</span> titles.title_id <span class="operator">=</span> akas.title_id) <span class="keyword">INNER</span> <span class="keyword">JOIN</span> ratings <span class="keyword">ON</span> titles.title_id <span class="operator">=</span> ratings.title_id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	akas.language <span class="operator">=</span> <span class="string">&#x27;de&#x27;</span> <span class="keyword">AND</span> (akas.types <span class="operator">=</span> <span class="string">&#x27;imdbDisplay&#x27;</span> <span class="keyword">OR</span> akas.types <span class="operator">=</span> <span class="string">&#x27;original&#x27;</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> (</span><br><span class="line">	titles.type</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_rating</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
题目中说要求统计德语标题的作品的平均分、最大分、最小分。可是当然不能直接判断标题是否含有德文，一个直接的方法是使用其他表的<code>language</code>信息来做筛选条件，德语的缩写是<strong>de</strong>。</p>
<h3 id="q6-10-points-q6_who_played_a_batman">Q6 [10 points]
(q6_who_played_a_batman):</h3>
<p>List the 10 highest rated actors who played a character named
"Batman".</p>
<p><strong>Details:</strong> Calculate the actor rating by taking the
average rating of all their works. Return both the name of the actor and
their rating and only list the top 10 results in order from highest to
lowest rating. Round average rating to the nearest hundredth.<br />
Make sure your output is formatted as
follows: <code>Kayd Currier|8.05</code><br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	name, FORMAT(&quot;%.2f&quot;, <span class="built_in">AVG</span>(rating)) <span class="keyword">AS</span> avg_rating</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	ratings <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">			name,</span><br><span class="line">			title_id</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			people <span class="keyword">INNER</span> <span class="keyword">JOIN</span> crew <span class="keyword">ON</span> people.person_id <span class="operator">=</span> crew.person_id</span><br><span class="line">		<span class="keyword">WHERE</span></span><br><span class="line">			crew.person_id <span class="keyword">IN</span> (</span><br><span class="line">				<span class="keyword">SELECT</span></span><br><span class="line">					person_id</span><br><span class="line">				<span class="keyword">FROM</span></span><br><span class="line">					crew</span><br><span class="line">				<span class="keyword">WHERE</span></span><br><span class="line">					characters <span class="keyword">LIKE</span> <span class="string">&#x27;%Batman%&#x27;</span></span><br><span class="line">			)</span><br><span class="line">	) <span class="keyword">AS</span> tmp <span class="keyword">ON</span> tmp.title_id <span class="operator">=</span> ratings.title_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>(</span><br><span class="line">	name</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	avg_rating <span class="keyword">DESC</span></span><br><span class="line">LIMIT</span><br><span class="line">	<span class="number">10</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
本小题主要考察了子查询的使用。题目的大意是，找出所有曾扮演过蝙蝠侠这个角色的演员，并且找出这些演员参演过的作品，计算这些作品的平均分。然后根据平均分对这些扮演过蝙蝠侠的演员进行排序，列出平均分前十名。另外一个难题就是小数点的格式化，发现在sqlite中就算把数值类型转为<code>DECIMAL(X,Y)</code>，也不会显示Y位小数，而是始终根据有效数位显示。这里只能通过转换为字符串形式并使用字符串。</p>
<h3 id="q7-15-points-q7_born_with_prestige">Q7 [15 points]
(q7_born_with_prestige):</h3>
<p>List the number of actors or actress who were born on the year that
"The Prestige" was premiered.</p>
<p><strong>Details:</strong> Print only the total number of actors born
that year. For this question, determine distinct people by
their <code>person_id</code>, not their names. Do not hard code the
query.<br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> people.person_id)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	people <span class="keyword">INNER</span> <span class="keyword">JOIN</span> crew <span class="keyword">ON</span> people.person_id <span class="operator">=</span> crew.person_id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	born <span class="keyword">IN</span> (</span><br><span class="line">		<span class="keyword">SELECT</span></span><br><span class="line">			premiered</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			titles</span><br><span class="line">		<span class="keyword">WHERE</span></span><br><span class="line">			primary_title <span class="operator">=</span> <span class="string">&#x27;The Prestige&#x27;</span></span><br><span class="line">	) <span class="keyword">AND</span> (</span><br><span class="line">		category <span class="operator">=</span> <span class="string">&#x27;actor&#x27;</span> <span class="keyword">OR</span> category <span class="operator">=</span> <span class="string">&#x27;actress&#x27;</span></span><br><span class="line">	)</span><br><span class="line">;</span><br></pre></td></tr></table></figure> 题目大意：统计出生年份与作品“The
Prestige”首映年份相同相同的男演员或者女演员。这题没有什么难点，主要的坑在于表<code>crew</code>中的person_id并不是唯一主键，有很多重复的，查询出来的结果记得使用<strong>DISTINCT</strong>关键字去重。</p>
<h3 id="q8-15-points-q8_directing_rose.sql">Q8 [15 points]
(q8_directing_rose.sql):</h3>
<p>Find all the directors who have worked with an actress with first
name "Rose".</p>
<p><strong>Details:</strong> Print only the names of the directors in
alphabetical order. Each name should only appear once in the
output.<br />
Your first row should look like this: <code>Aimé Forget</code><br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">	name</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	crew <span class="keyword">INNER</span> <span class="keyword">JOIN</span> people <span class="keyword">ON</span> crew.person_id <span class="operator">=</span> people.person_id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	crew.category <span class="operator">=</span> <span class="string">&#x27;director&#x27;</span></span><br><span class="line">	<span class="keyword">AND</span></span><br><span class="line">	crew.title_id <span class="keyword">IN</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">			crew.title_id</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			crew <span class="keyword">INNER</span> <span class="keyword">JOIN</span> people <span class="keyword">ON</span> crew.person_id <span class="operator">=</span> people.person_id</span><br><span class="line">		<span class="keyword">WHERE</span></span><br><span class="line">			crew.category <span class="operator">=</span> <span class="string">&#x27;actress&#x27;</span> <span class="keyword">AND</span> people.name <span class="keyword">LIKE</span> <span class="string">&#x27;Rose%&#x27;</span></span><br><span class="line">	)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	name <span class="keyword">ASC</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
题目大意：列出所有参演人员列表中有名字以Rose开头的女演员的电影的导演名字。通过子查询来找到所有这样的电影，然后选出所有工作类别为导演的人，看他们参与的作品ID是否在之前找到的作品ID集合中。</p>
<h3 id="q9-15-points-q9_ode_to_the_dead">Q9 [15 points]
(q9_ode_to_the_dead):</h3>
<p>List the longest work for the first 5 cast members sorted by year of
death for each type of role.</p>
<p><strong>Details:</strong> For each role, find the first 5 artists
sorted by year of death and print their work with the longest runtime.
The final output should be sorted alphabetically by category, then by
year of death of the artist and finally by alphabetical order of artist
name. If an artist has multiple works with the the same longest runtime,
pick the one with the smallest <code>title_id</code>. Your output should
look like
this: <code>CATEGORY|NAME|DEATH YEAR|LONGEST WORK TITLE|WORK RUNTIME|CATEGORY RANK</code> Your
first row should look like
this: <code>actor|Verner Clarges|1911|A Summer Idyll|17|1</code></p>
<p><strong>Note:</strong> Omit artists that do not have work with a
non-null runtime.<br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span></span><br><span class="line">died_runt_rank <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		category,</span><br><span class="line">		name,</span><br><span class="line">		died,</span><br><span class="line">		primary_title,</span><br><span class="line">		runtime_minutes,</span><br><span class="line">		<span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">			<span class="keyword">PARTITION</span> <span class="keyword">BY</span></span><br><span class="line">				c.category</span><br><span class="line">			<span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">				p.died <span class="keyword">ASC</span>,</span><br><span class="line">				p.name <span class="keyword">ASC</span></span><br><span class="line">		) <span class="keyword">AS</span> died_rank,</span><br><span class="line">		<span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">			<span class="keyword">PARTITION</span> <span class="keyword">BY</span></span><br><span class="line">				c.category,</span><br><span class="line">				c.person_id</span><br><span class="line">			<span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">				t.runtime_minutes <span class="keyword">DESC</span>,</span><br><span class="line">				t.title_id <span class="keyword">ASC</span></span><br><span class="line">		) <span class="keyword">AS</span> runt_rank</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		crew <span class="keyword">AS</span> c</span><br><span class="line">		<span class="keyword">INNER</span> <span class="keyword">JOIN</span> people <span class="keyword">as</span> p <span class="keyword">ON</span> c.person_id <span class="operator">=</span> p.person_id</span><br><span class="line">		<span class="keyword">INNER</span> <span class="keyword">JOIN</span> titles <span class="keyword">as</span> t <span class="keyword">ON</span> c.title_id <span class="operator">=</span> t.title_id</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		p.died <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span></span><br><span class="line">		t.runtime_minutes <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">),</span><br><span class="line">first_five_per_category <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		category,</span><br><span class="line">		name,</span><br><span class="line">		died,</span><br><span class="line">		primary_title,</span><br><span class="line">		runtime_minutes,</span><br><span class="line">		died_rank</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		died_runt_rank</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		died_rank <span class="operator">&lt;=</span> <span class="number">5</span> <span class="keyword">AND</span></span><br><span class="line">		runt_rank <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	first_five_per_category</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	category <span class="keyword">ASC</span>,</span><br><span class="line">	died_rank <span class="keyword">ASC</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
这题的第一个难点是需要被排序的属性很多，弄清楚排序的优先级很重要，不能弄混，第一优先级是死亡年份，然后是作品时长。而且需要注意的是，排序是在每个职员类别之中排序，每个类别有自己的排序，不参与全局的排序，这里明显要求我们使用<code>GROUP BY</code>关键字进行分组。第二个难点在于如何固定每个分组的输出数量为5条记录，这里是通过使用DENSE_RANK()函数对分组内的记录进行排序标号，并只选取顺位小于等于5的记录来实现的。</p>
<h3 id="q10-15-points-q10_all_played_by_leo">Q10 [15 points]
(q10_all_played_by_leo):</h3>
<p>List all the unique characters Leonardo DiCaprio (born in 1974) ever
played as a string of comma-separated values in alphabetical order of
the character names.</p>
<p><strong>Details:</strong> Find all the unique characters played by
Leonardo DiCaprio and order them alphabetically. Exclude those
characters containing the character sequence <code>Self</code>. Print a
single string containing all these characters separated by commas.<br />
<strong>Hint:</strong> You might find <a
href="https://sqlite.org/lang_with.html">Recursive
CTEs</a> useful.<br />
<strong>Note:</strong> Watch out for the format of
the <code>characters</code> field. An actor can play more than one
characters in a single work.<br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span></span><br><span class="line">leo_played <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">		characters</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		people</span><br><span class="line">		<span class="keyword">INNER</span> <span class="keyword">JOIN</span> crew <span class="keyword">ON</span> people.person_id <span class="operator">=</span> crew.person_id</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		people.name <span class="operator">=</span> <span class="string">&#x27;Leonardo DiCaprio&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">		people.born <span class="operator">=</span> <span class="number">1974</span> <span class="keyword">AND</span></span><br><span class="line">		crew.characters <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%Self%&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">		crew.characters <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">		crew.characters <span class="keyword">ASC</span></span><br><span class="line">),</span><br><span class="line">json_data <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">		<span class="keyword">value</span> <span class="keyword">AS</span> characters,</span><br><span class="line">		<span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>() <span class="keyword">AS</span> row_num</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		leo_played,</span><br><span class="line">		JSON_EACH(leo_played.characters)</span><br><span class="line">),</span><br><span class="line">boundary_row_num <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		<span class="built_in">MAX</span>(row_num) <span class="keyword">AS</span> max_row_num</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		json_data</span><br><span class="line">),</span><br><span class="line">recursive_build (played, idx) <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		characters, <span class="number">1</span></span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		json_data</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		row_num <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		played <span class="operator">||</span> <span class="string">&#x27;,&#x27;</span> <span class="operator">||</span> characters, idx <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> new_idx</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		recursive_build</span><br><span class="line">		<span class="keyword">INNER</span> <span class="keyword">JOIN</span> json_data <span class="keyword">ON</span> recursive_build.idx <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> json_data.row_num</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		json_data.row_num <span class="operator">=</span> idx <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AND</span></span><br><span class="line">		idx <span class="operator">+</span> <span class="number">1</span> <span class="operator">&lt;=</span> (</span><br><span class="line">			<span class="keyword">SELECT</span></span><br><span class="line">				max_row_num</span><br><span class="line">			<span class="keyword">FROM</span></span><br><span class="line">				boundary_row_num</span><br><span class="line">		)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	recursive_build</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	idx <span class="keyword">IN</span> (</span><br><span class="line">		<span class="keyword">SELECT</span></span><br><span class="line">			max_row_num</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			boundary_row_num</span><br><span class="line">	)</span><br><span class="line">;</span><br></pre></td></tr></table></figure> 本题要列出Leonardo
DiCaprio曾经扮演过的角色的记录不难：<br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">	characters</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	people</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> crew <span class="keyword">ON</span> people.person_id <span class="operator">=</span> crew.person_id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	people.name <span class="operator">=</span> <span class="string">&#x27;Leonardo DiCaprio&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">	people.born <span class="operator">=</span> <span class="number">1974</span> <span class="keyword">AND</span></span><br><span class="line">	crew.characters <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%Self%&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">	crew.characters <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">		crew.characters <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure>
终点是这些记录怎么拼接为单一的一行字符串，而且原先的每行记录还要拆分之后重新用逗号分隔。仔细看
<strong>characters</strong>
这个属性的值可知，都是JSON字符串数组，好在sqlite有很多内置的便捷工具函数，自然处理JSON数据的工具也不在话下。<strong>JSON_EACH(table)</strong>
函数能对给定表的每一条记录，如果是数组类型的元素的话，进行拆分，数组内的每个元素将称为返回的表的每一行记录。</p>
<p>Recursive
CTE就是允许调用自身的查询，类似于递归函数，定义递归调用的入口点，每一层递归拿取下一层递归返回上来的返回值做一些处理然后再返回给上一层，一般这个处理在SELECT中完成，在SELECT中完成处理之后再返回给上一层调用。<br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">recursive_build (played, idx) <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		characters, <span class="number">1</span></span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		json_data</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		row_num <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		played <span class="operator">||</span> <span class="string">&#x27;,&#x27;</span> <span class="operator">||</span> characters, idx <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> new_idx</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		recursive_build</span><br><span class="line">		<span class="keyword">INNER</span> <span class="keyword">JOIN</span> json_data <span class="keyword">ON</span> recursive_build.idx <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> json_data.row_num</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		json_data.row_num <span class="operator">=</span> idx <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AND</span></span><br><span class="line">		idx <span class="operator">+</span> <span class="number">1</span> <span class="operator">&lt;=</span> (</span><br><span class="line">			<span class="keyword">SELECT</span></span><br><span class="line">				max_row_num</span><br><span class="line">			<span class="keyword">FROM</span></span><br><span class="line">				boundary_row_num</span><br><span class="line">		)</span><br><span class="line">)</span><br></pre></td></tr></table></figure> Recursive
CTE的关键是使用UNION来完成下一层的调用，一般来说，一张表在完成定义之前是不运行被引用的，但是使用了Recursive关键字的CTE是允许的，不过在sqlite中，不用显式地声明Recursive，会自动判定是否为递归调用。</p>
<p>使用额外的一张表把原先的行记录中的JSON数据转换为每个元素一行：<br />
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">json_data <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">		<span class="keyword">value</span> <span class="keyword">AS</span> characters,</span><br><span class="line">		<span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>() <span class="keyword">AS</span> row_num</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		leo_played,</span><br><span class="line">		JSON_EACH(leo_played.characters)</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<p>然后利用Recursive CTE的SELECT对这些已经处理的行数据递归地处理。</p>
<p>递归CTE的关键在于两部分，SELECT的实际处理，以及WHERE的递归结束条件，用于WHERE的限制条件类型一般是数值的操作类型，比如每次递归+1然后到哪个数就停止递归这样，如果是字符串类型的边界变量可能不太好定义WHERE边界条件</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>CMU-15445</tag>
      </tags>
  </entry>
  <entry>
    <title>ACID</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/ACID/</url>
    <content><![CDATA[<p>事务管理（ACID）</p>
<p>谈到事务一般都是以下四点</p>
<ol type="1">
<li>原子性（Atomicity）</li>
</ol>
<p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<ol type="1">
<li>一致性（Consistency）</li>
</ol>
<p>事务前后数据的完整性必须保持一致。</p>
<ol type="1">
<li>隔离性（Isolation）</li>
</ol>
<p>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p>
<ol type="1">
<li>持久性（Durability）</li>
</ol>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MVCC版本控制</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/MVCC%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="什么是mvcc">什么是MVCC？</h2>
<p>Multi-Version Concurrency
Control（MVCC），翻译过来就是多版本并发控制，MVCC是为提高MySQL数据库并发性能的一个重要设计。</p>
<p>同一行数据发生读写请求时，会通过锁来保证数据的一致性。MVCC可以在读写冲突时，让其读数据时通过<strong>快照读</strong>，而不是当前读，快照读不必加锁。</p>
<p>在前边文章我们也介绍了MySQL中的锁机制，不熟悉的可以翻阅前边的文章。</p>
<h2 id="innodb的事务">InnoDB的事务</h2>
<blockquote>
<p>MySQL中的MVCC是在InnoDB存储引擎中得到支持的，InnoDB中最重要，也是最特殊的可谓就是事务，所以事务相关的一些设计我们必须了解。</p>
</blockquote>
<ul>
<li><p>行级锁
InnoDB提供了行级锁，行级锁无疑使锁的粒度更细，但是数据过多时，在高并发场景下，同一时刻会产生大量的锁，因此，InnoDB也对锁进行了空间的有效优化，使得其在并发量高的情况下，也不会因为同一时刻锁过多，而导致内存耗尽。</p>
<ul>
<li>排他锁<br />
</li>
<li>共享锁。</li>
</ul></li>
<li><p>隔离级别</p>
<ul>
<li>READ_UNCOMMITTED：脏读<br />
</li>
<li>READ_COMMITTED：读提交<br />
</li>
<li>REPEATABLE_READ：重复读<br />
</li>
<li>SERIALIZABLE：串行化</li>
</ul></li>
<li><p>redo log<br />
redo log
就是保存执行的SQL语句到一个指定的Log文件，当Mysql执行recovery时重新执行redo
log记录的SQL操作即可。当客户端执行每条SQL（更新语句）时，redo
log会被首先写入log buffer；当客户端执行COMMIT命令时，log
buffer中的内容会被视情况刷新到磁盘。redo
log在磁盘上作为一个独立的文件存在，即InnoDB的log文件。</p></li>
<li><p>undo log<br />
与redo log相反，undo
log是为回滚而用，具体内容就是将事务影响到的行的原始数据行写入到到undo
buffer，在合适的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo
buffer一样，也是环形缓冲，但当缓冲满的时候，undo
buffer中的内容会也会被刷新到磁盘；与redo
log不同的是，磁盘上不存在单独的undo log文件，所有的undo
log均存放在主ibd（表空间）数据文件中，即使客户端设置了每表一个数据文件也是如此。</p></li>
</ul>
<h2 id="行更新的过程">行更新的过程</h2>
<p>InnoDB为每行记录都实现了三个隐藏字段：<br />
- 隐藏的ID<br />
- 6字节的事务ID（<strong>DB_TRX_ID</strong>）<br />
- 7字节的回滚指针（<strong>DB_ROLL_PTR</strong>）</p>
<p>行更新的过程</p>
<ol type="1">
<li><p>数据库新增一条数据，该条数据三个隐藏字段，只有ID有值</p></li>
<li><p>T1修改该条数据，开启事务，记录read_view</p>
<ul>
<li>排它锁锁定该行数据<br />
</li>
<li>记录redo log<br />
</li>
<li>将该行数据写入undo log<br />
</li>
<li>将修改值写入该条数据，填写事务Id，根据undo
log记录位置填写回滚指针</li>
</ul></li>
<li><p>T2修改该条数据，开启事务，记录read_view</p>
<ul>
<li>排它锁锁定该行数据<br />
</li>
<li>记录redo log<br />
</li>
<li>将该行数据写入undo log<br />
</li>
<li>将修改值写入该条数据，填写事务Id，通过回滚指针将undo log
的两条记录连接起来（版本链）</li>
</ul></li>
<li><p>事务提交，记录read_view</p>
<ul>
<li>正常提交<br />
</li>
<li>如果触发回滚，需要根据回滚指针找到undo log对应记录进行回滚</li>
</ul></li>
</ol>
<p>注意：</p>
<ul>
<li>InnoDB中存在purge线程，它负责查询，并清理那些无效的undo log。<br />
</li>
<li>上述过程描述的是UPDATE事务的过程，当INSERT时，原始的数据并不存在，所以在回滚时把insert丢弃即可</li>
</ul>
<h2 id="mvcc的基本特征">MVCC的基本特征</h2>
<ul>
<li>每行数据都存在一个版本，每次更新数据时都更新该版本。<br />
</li>
<li>修改时拷贝出当前版本随意修改，各个事务之间无干扰。<br />
</li>
<li>保存时比较版本号，如果成功提交事务，则覆盖原记录；如果失败回滚则放弃拷贝的数据。</li>
</ul>
<h2 id="innodb如何实现mvcc">InnoDB如何实现MVCC？</h2>
<p>MVCC则是建立在undo log 之上的。</p>
<p>undo log 中记录的数据就是MVCC中的多版本。</p>
<p>通过回滚指针形成版本链。</p>
<p>通过事务ID可以查找到read-view上的记录</p>
<p>RC隔离级别和RR隔离级别生成read-view的时机不一样，RR是在开始事务时，RC是在每一次查询，所以在RR隔离级别下，MVCC可以解决幻读问题。</p>
<p><strong>read-view记录：</strong></p>
<ul>
<li>m_ids:表示活跃事务id列表<br />
</li>
<li>min_trx_id:活跃事务中的最小事务id<br />
</li>
<li>max_trx_id:已创建的最大事务id<br />
</li>
<li>creator_trx_id:当前的事务id</li>
</ul>
<p><strong>版本链比对规则：</strong></p>
<ol type="1">
<li><p>如果 trx_id &lt;
min_trx_id，表示这个版本是已提交的事务生成的,这个数据是可见的；</p></li>
<li><p>如果 trx_id &gt;
max_trx_id，表示这个版本是由将来启动的事务生成的,是肯定不可见的。</p></li>
<li><p>如果 min_trx_id &lt;= trx_id &lt;=
max_trx_id，那就包括两种情况</p>
<ul>
<li><p>若row的trx_id在m_ids数组中，表示这个版本是由还没提交的事务生成的,不可见,当前自己的事务是可见的。</p></li>
<li><p>若row的trx_id不在m_ids数组中，表示这个版本是已经提交了的事务生成的,可见</p></li>
</ul></li>
</ol>
<p>MySQL的InnoDB实现MVCC，就是在隔离级别为<strong>读已提交</strong>和<strong>可重复读</strong>，基于<strong>乐观锁理论</strong>，通过事务ID和read-view的记录进行比较判断分析数据是否可见，从而使其大部分读操作可以无需加锁，从而提高并发性能。</p>
<p>但是在写数据的时候，InnoDB还是需要加排它锁的。</p>
<p><strong>总结，就是用乐观锁代替悲观锁，从而提高并发性能，这就是MVCC。</strong></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL忘记root密码如何重置</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/MySQL%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>为了正确地重置 MySQL 数据库的 root 密码，请按照以下步骤进行操作：</p>
<ol type="1">
<li><p>停止 MySQL 服务。</p>
<ul>
<li>在 Windows 上，你可以在服务管理中停止 "MySQL" 或 "MariaDB"
服务。<br />
</li>
<li>在 Linux 上，可以使用以下命令停止 MySQL 服务：<br />
<code>sudo systemctl stop mysql</code></li>
</ul></li>
<li><p>找到 MySQL 配置文件。</p>
<ul>
<li>在 Windows 上，默认的配置文件是 my.ini 或 my.cnf，并且通常位于 MySQL
安装目录下的 bin 目录中。<br />
</li>
<li>在 Linux 上，默认的配置文件是 my.cnf，并且通常位于 /etc/mysql/ 或
/etc 目录中。<br />
</li>
</ul></li>
<li><p>编辑 MySQL 配置文件。</p>
<p>使用文本编辑器打开 MySQL 配置文件。</p></li>
<li><p>在 [mysqld] 部分添加一行配置。</p>
<p>在 [mysqld] 部分中添加以下行（如果已经存在，则修改该行）：</p>
<p><code>skip-grant-tables</code></p>
<p>这将使 MySQL 服务器在启动时跳过权限验证。</p></li>
<li><p>保存并关闭配置文件。</p></li>
<li><p>启动 MySQL 服务。</p>
<ul>
<li><p>在 Windows 上，在命令提示符或 PowerShell
中执行以下命令，以管理员身份运行：</p>
<p><code>mysqld --console</code></p></li>
<li><p>在 Linux 上，在终端中以超级用户身份执行以下命令：</p>
<p><code>sudo mysqld_safe --skip-grant-tables &amp;</code></p></li>
</ul></li>
<li><p>打开新的终端窗口。</p>
<ul>
<li>在 Windows 上，打开新的命令提示符或 PowerShell 窗口。<br />
</li>
<li>在 Linux 上，打开新的终端窗口。<br />
</li>
</ul></li>
<li><p>连接到 MySQL 服务器。</p>
<p>运行以下命令连接到 MySQL 服务器：</p>
<p><code>mysql -u root</code></p></li>
<li><p>更新 root 用户的密码。</p>
<ul>
<li><p>如果你使用 MySQL 5.7.x 或更高版本，运行以下命令：</p>
<p><code>ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';</code></p></li>
<li><p>如果你使用 MySQL 5.6.x 或更低版本，运行以下命令：</p>
<p><code>SET PASSWORD FOR 'root'@'localhost' = PASSWORD('新密码');</code></p></li>
</ul>
<p>将 '新密码' 替换为你想要设置的新密码。</p></li>
<li><p>刷新权限并退出 MySQL Shell。</p>
<p>运行以下命令：</p>
<p><code>FLUSH PRIVILEGES; exit;</code></p></li>
<li><p>停止 MySQL 服务。</p>
<ul>
<li><p>在 Windows 上，停止 "MySQL" 或 "MariaDB" 服务。<br />
</p></li>
<li><p>在 Linux 上，使用以下命令停止 MySQL 服务：</p>
<p><code>sudo systemctl stop mysql</code></p></li>
</ul></li>
<li><p>移除或注释掉 MySQL 配置文件中添加的
<code>skip-grant-tables</code> 行。</p></li>
<li><p>启动 MySQL 服务。</p>
<ul>
<li><p>在 Windows 上，启动 "MySQL" 或 "MariaDB" 服务。<br />
</p></li>
<li><p>在 Linux 上，使用以下命令启动 MySQL 服务：</p>
<p><code>sudo systemctl start mysql</code></p></li>
</ul></li>
</ol>
<p>现在，你已经成功重置了 MySQL 数据库的 root 密码，并可以使用新密码登录
root
用户。请确保在生产环境中采取适当的安全措施，并妥善保管数据库密码。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>RANK和ROW_NUM的区别</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/RANK%E5%92%8CROW_NUM%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在SQL中，RANK和ROW_NUM函数都用于对查询结果进行排序和排名。它们之间有以下区别：</p>
<ol type="1">
<li><p>RANK函数：RANK函数为每个行分配一个排名，并允许跳过排名相同的行。如果有两行具有相同的排序值，它们将被分配相同的排名，并且下一个排名将被跳过。</p></li>
<li><p>ROW_NUMBER函数：ROW_NUMBER函数为每个行分配一个唯一的连续整数值，在排序过程中不允许跳过任何行。即使有多个行具有相同的排序值，它们也会被分配不同的行号。</p></li>
</ol>
<p>让我们通过示例来说明这两个函数的区别。假设我们有一个名为"Students"的表，包含学生姓名和他们的分数。</p>
<p>使用RANK函数：</p>
<p>sqlCopy Code</p>
<p><code>SELECT Name, Score, RANK() OVER (ORDER BY Score DESC) AS Rank FROM Students;</code></p>
<p>结果可能如下所示：</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Score</th>
<th>Rank</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alice</td>
<td>95</td>
<td>1</td>
</tr>
<tr class="even">
<td>Bob</td>
<td>90</td>
<td>2</td>
</tr>
<tr class="odd">
<td>Carol</td>
<td>85</td>
<td>3</td>
</tr>
<tr class="even">
<td>David</td>
<td>85</td>
<td>3</td>
</tr>
<tr class="odd">
<td>Emily</td>
<td>80</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>使用ROW_NUMBER函数：</p>
<p>sqlCopy Code</p>
<p><code>SELECT Name, Score, ROW_NUMBER() OVER (ORDER BY Score DESC) AS RowNumber FROM Students;</code></p>
<p>结果可能如下所示：</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Score</th>
<th>RowNumber</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alice</td>
<td>95</td>
<td>1</td>
</tr>
<tr class="even">
<td>Bob</td>
<td>90</td>
<td>2</td>
</tr>
<tr class="odd">
<td>Carol</td>
<td>85</td>
<td>3</td>
</tr>
<tr class="even">
<td>David</td>
<td>85</td>
<td>4</td>
</tr>
<tr class="odd">
<td>Emily</td>
<td>80</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>从上面的示例中可以看出，RANK函数在遇到相同的分数时会跳过下一个排名，而ROW_NUMBER函数会为每一行分配一个唯一的行号。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>rank()、dense_rank()、row_number()之间的区别</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/rank()%E3%80%81dense_rank()%E3%80%81row_number()%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="先上结论三者的区别如下">先上结论，三者的区别如下：</h2>
<ul>
<li>rank()排序相同时会重复，总数不变，即会出现1、1、3这样的排序结果；<br />
</li>
<li>dense_rank()排序相同时会重复，总数会减少，即会出现1、1、2这样的排序结果；<br />
</li>
<li>row_number()排序相同时不会重复，会根据顺序排序。</li>
</ul>
<h2 id="具体实例">具体实例</h2>
<p>建表、插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table rownumber(</span><br><span class="line">       id varchar(10) not null,</span><br><span class="line">       name varchar(10) null,</span><br><span class="line">       age varchar(10) null,</span><br><span class="line">       salary int null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into rownumber(id,name,age,salary) values(1,&#x27;a&#x27;,10,8000);</span><br><span class="line">insert into rownumber(id,name,age,salary) values(1,&#x27;a2&#x27;,11,7500);</span><br><span class="line">insert into rownumber(id,name,age,salary) values(2,&#x27;b&#x27;,12,7500);</span><br><span class="line">insert into rownumber(id,name,age,salary) values(2,&#x27;b2&#x27;,13,4500);</span><br><span class="line">insert into rownumber(id,name,age,salary) values(3,&#x27;c&#x27;,14,8000);</span><br><span class="line">insert into rownumber(id,name,age,salary) values(3,&#x27;c2&#x27;,15,20000);</span><br><span class="line">insert into rownumber(id,name,age,salary) values(4,&#x27;d&#x27;,16,30000);</span><br><span class="line">insert into rownumber(id,name,age,salary) values(5,&#x27;d2&#x27;,17,8000);</span><br><span class="line">select * from rownumber;</span><br></pre></td></tr></table></figure>
<p><img
src="https://pic4.zhimg.com/80/v2-db4ed57f599b61c212d567140ba004db_720w.webp" /></p>
<p>数据</p>
<p><code>row_number()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *, row_number() over(order by salary) as `rank` from rownumber;</span><br></pre></td></tr></table></figure>
<p><img
src="https://pic1.zhimg.com/80/v2-b250111d5585b967652102d4f631b1d4_720w.webp" /></p>
<p>row_number()排序结果</p>
<p><code>rank()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *, rank() over(order by salary) as `rank` from rownumber;</span><br></pre></td></tr></table></figure>
<p><img
src="https://pic4.zhimg.com/80/v2-dc8c97eaf5d452b9a70e61cfc6f48bab_720w.webp" /></p>
<p>rank()排序结果</p>
<p><code>dense_rank()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *, dense_rank() over(order by salary) as `rank` from rownumber;</span><br></pre></td></tr></table></figure>
<p><img
src="https://pic4.zhimg.com/80/v2-9b90df265460ac5e69e3fb1b299338bb_720w.webp" /></p>
<p>dense_rank()排序结果</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite3如何设置输出格式</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/sqlite3%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>在 SQLite 中，你可以使用 <code>.mode</code>
命令来设置输出模式，用于控制查询结果的显示方式。</p>
<p><code>.mode</code>
命令后面可以跟着不同的参数来选择不同的输出模式。以下是一些常用的
<code>.mode</code> 参数：</p>
<ul>
<li><code>column</code>：以表格列的形式显示查询结果。<br />
</li>
<li><code>list</code>：以列表的形式显示查询结果，每个字段值占一行。<br />
</li>
<li><code>csv</code>：以逗号分隔的形式显示查询结果，适合导出为 CSV
文件。<br />
</li>
<li><code>insert</code>：生成 INSERT
语句的形式，可以用于将查询结果插入到其他表中。<br />
</li>
<li><code>html</code>：以 HTML 表格的形式显示查询结果。</li>
</ul>
<p>例如，如果你想以表格列的形式显示查询结果，可以使用以下命令：<br />
<code>.mode column</code></p>
<p>如果你想以列表的形式显示查询结果，可以使用以下命令：<br />
<code>.mode list</code></p>
<p>你还可以结合 <code>.headers on</code>
命令来显示查询结果的字段头部。例如，使用以下命令可以打开字段头部显示：<br />
<code>.headers on</code></p>
<p>请注意，<code>.mode</code>
命令只对当前会话有效，并且仅影响终端或命令行界面中的输出显示。如果你使用的是
SQLite
的客户端库或其他工具来执行查询，它们可能有自己的方式来设置输出模式。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>upsert</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/upsert/</url>
    <content><![CDATA[<p>UPSERT 是用于管理数据库的 DBMS 软件的基本功能之一。此操作允许 DML
用户向表中插入新记录或更新现有数据。UPSERT
由两个名为UPDATE和INSERT的单词组合而成。前两个字母，即UP 代表UPDATE
而SERT 代表INSERT。UPSERT
是一个原子操作，这意味着它是一个一步完成的操作。例如，如果一条记录是新的，它将触发
INSERT 命令。但是，如果它已经存在于表中，那么这个操作将执行一个<a
href="http://www.yiidian.com/mysql/mysql-update.html">UPDATE
语句</a>。</p>
<p>默认情况下，<a href="http://www.yiidian.com/mysql/">MySQL</a>为
INSERT 提供了 ON DUPLICATE KEY UPDATE
选项，它完成了这个任务。但是，它还包含一些其他语句来实现此目标，例如
INSERT IGNORE 或 REPLACE。我们将详细学习并查看所有这些解决方案。</p>
<h2 id="一mysql-upsert-示例">一、MySQL UPSERT 示例</h2>
<p>我们主要可以通过以下三种方式来执行MySQL UPSERT操作：</p>
<ol type="1">
<li>UPSERT 使用 INSERT IGNORE<br />
</li>
<li>使用 REPLACE 进行 UPSERT<br />
</li>
<li>UPSERT 使用 INSERT ON DUPLICATE KEY UPDATE</li>
</ol>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>授权账户</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/%E6%8E%88%E6%9D%83%E8%B4%A6%E6%88%B7/</url>
    <content><![CDATA[<p>进入MYSQL数据库</p>
<p>use mysql</p>
<p>添加 授权192.168.<em>.</em>
的用户root可以访问所有服务器的数据库；</p>
<p>grant all privileges on <em>.</em> to 'root'@'192.168.%.%' identified
by 'pure111@111'  with grant option;</p>
<p>刷新执行</p>
<p>flush privileges;</p>
<p>查看信息（是否OK）</p>
<p>select Host,User from user;</p>
<p>GRANT ALL PRIVILEGES ON <em>.</em> TO 'root'@'120.111.%.%' IDENTIFIED
BY 'pure111@1119' WITH GRANT OPTION;</p>
<p>GRANT ALL PRIVILEGES ON <em>.</em> TO 'root'@'202.111.%.%' IDENTIFIED
BY 'pure111@111' WITH GRANT OPTION;</p>
<p>GRANT ALL PRIVILEGES ON <em>.</em> TO 'root'@'202.111.111.111'
IDENTIFIED BY 'pure111@111' WITH GRANT OPTION;</p>
<p>显示数据库名称</p>
<p>show databases;</p>
<p>show tables；</p>
<p>MySQL对用户登录ip段授权的方法</p>
<p>172.16.1.0/24</p>
<p>GRANT ALL PRIVILEGES ON <em>.</em> TO test@'172.16.1.%' identified by
'test123456' 即可。</p>
<p>172.16.0.0/16</p>
<p>GRANT ALL PRIVILEGES ON <em>.</em> TO test@'172.16.%' identified by
'test123456' 即可。</p>
<p>MySQL针对某一类（某字段开通的）数据库授权的方法</p>
<p>bbs_开头的数据库</p>
<p>grant all on <code>bbs_%</code>.* to test@'172.16.1.3' identified by
'test123456';</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>日期类型</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><a
href="https://www.cnblogs.com/pangdajin/p/9541668.html">MySQL的日期类型</a></p>
<p>-- MySQL
中有多种数据类型可以用于日期和时间的表示，不同的版本可能有所差异，表 3-2
中</p>
<p>-- 列出了 MySQL 5.0 中所支持的日期和时间类型。</p>
<p>-- 表 3-2 MySQL 中的日期和时间类型</p>
<table>
<tbody>
<tr class="odd">
<td>日期和时间类型</td>
<td>字节</td>
<td>最小值</td>
<td>最大值</td>
</tr>
<tr class="even">
<td>DATE</td>
<td>4</td>
<td>1000-01-01</td>
<td>9999-12-31</td>
</tr>
<tr class="odd">
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr class="even">
<td>TIMESTAMP</td>
<td>4</td>
<td>19700101080001</td>
<td>2038 年的某个时刻</td>
</tr>
<tr class="odd">
<td>TIME</td>
<td>3</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr class="even">
<td>YEAR</td>
<td>1</td>
<td>1901</td>
<td>2155</td>
</tr>
</tbody>
</table>
<p>日期和时间类型 字节 最小值 最大值</p>
<p>DATE 4 1000-01-01 9999-12-31<br />
DATETIME 8 1000-01-01 00:00:00 9999-12-31 23:59:59<br />
TIMESTAMP 4 19700101080001 2038 年的某个时刻<br />
TIME 3 -838:59:59 838:59:59<br />
YEAR 1 1901 2155</p>
<p>-- 这些数据类型的主要区别如下：</p>
<p>l 如果要用来表示年月日，通常用 DATE 来表示。<br />
l 如果要用来表示年月日时分秒，通常用 DATETIME 表示。<br />
l如果只用来表示时分秒，通常用 TIME 来表示。<br />
l如果需要经常插入或者更新日期为当前系统时间，则通常使用 TIMESTAMP
来表示。<br />
TIMESTAMP 值返回后显示为“YYYY-MM-DD
HH:MM:SS”格式的字符串，显示宽度固定<br />
-- 为 19 个字符。如果想要获得数字值，应在 TIMESTAMP 列添加+0。<br />
-- l 如果只是表示年份，可以用 YEAR 来表示，它比 DATE
占用更少的空间。YEAR 有 2 位或<br />
-- 4 位格式的年。默认是 4 位格式。在 4 位格式中，允许的值是 1901～2155
和 0000。在<br />
-- 2 位格式中，允许的值是 70～69，表示从 1970～2069 年。MySQL 以 YYYY
格式显示 YEAR值。</p>
<p>create table t (d date,t time,dt datetime);</p>
<p>TIMESTAMP还有一个重要特点，就是和时区相关。</p>
<p>当插入日期时，会先转换为本地时区后存放；而从数据库里面取出时，也同样需要将日期转换为本地时区后显示。</p>
<p>--
TIMESTAMP支持的时间范围较小，其取值范围从19700101080001到2038年的某个</p>
<p>-- 时间，而DATETIME是从1000-01-01 00:00:00到9999-12-31
23:59:59，范围更大。</p>
<p>--
表中的第一个TIMESTAMP列自动设置为系统时间。如果在一个TIMESTAMP列中插入</p>
<p>--
NULL，则该列值将自动设置为当前的日期和时间。在插入或更新一行但不明确给</p>
<p>--
TIMESTAMP列赋值时也会自动设置该列的值为当前的日期和时间，当插入的值超出</p>
<p>-- 取值范围时，MySQL认为该值溢出，使用“0000-00-00
00:00:00”进行填补</p>
<p>--
TIMESTAMP的插入和查询都受当地时区的影响，更能反应出实际的日期。而</p>
<p>--
DATETIME则只能反应出插入时当地的时区，其他时区的人查看数据必然会有误差的。</p>
<p>--
TIMESTAMP的属性受MySQL版本和服务器SQLMode的影响很大，本章都是以MySQL</p>
<p>来自 &lt;<a
href="https://www.cnblogs.com/pangdajin/p/9541668.html">https://www.cnblogs.com/pangdajin/p/9541668.html</a>&gt;</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>查看数据库表占用大小</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>前言</p>
<p>在mysql中有一个默认的数据表information_schema，information_schema这张数据表保存了MySQL<a
href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>所有<a
href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。</p>
<p>再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema表里面，所以请勿删改此表。<a
href="https://mp.weixin.qq.com/s?__biz=Mzk0NzAzNTM0Mg==&amp;mid=2247484856&amp;idx=1&amp;sn=b26890d36e6fb7bda8b2dd851557cef1&amp;chksm=c37c4819f40bc10f838fce19ef8aea4bc68ee75170885db07171094611ab05cd376b34b8f0dc&amp;token=1451209442&amp;lang=zh_CN#rd">整理了一份328页MySQLPDF文档</a></p>
<p>代码</p>
<p>1，切换数据库</p>
<p>use information_schema;</p>
<p>复制</p>
<p>2，查看数据库使用大小</p>
<p>select concat(round(sum(data_length/1024/1024),2),’MB’)asdata from
tables where table_schema=’DB_Name’ ;</p>
<p>3，查看表使用大小</p>
<p>select concat(round(sum(data_length/1024/1024),2),’MB’)asdata from
tables where table_schema=’DB_Name’ and table_name=’Table_Name’;</p>
<ul>
<li>先进去MySQL自带管理库：information_schema<br />
</li>
<li>然后查询 data_length,index_length<br />
</li>
<li>你自己的数据库名：dbname<br />
</li>
<li>你自己的表名：tablename</li>
</ul>
<h2 id="查看表容量大小">查看表容量大小</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use information_schema;  </span><br><span class="line">Database changed  </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> data_length,index_length  </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> tables <span class="keyword">where</span>  </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>  </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">and</span> table_name <span class="operator">=</span> <span class="string">&#x27;tablename&#x27;</span>;  </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+  </span></span><br><span class="line"><span class="operator">|</span> data_length <span class="operator">|</span> index_length <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+  </span></span><br><span class="line"><span class="operator">|</span>   <span class="number">166379520</span> <span class="operator">|</span>    <span class="number">235782144</span> <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+  </span></span><br><span class="line"><span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)  </span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> concat(round(<span class="built_in">sum</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;MB&#x27;</span>) <span class="keyword">as</span> data_length_MB, </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> concat(round(<span class="built_in">sum</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;MB&#x27;</span>) <span class="keyword">as</span> index_length_MB  </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> tables <span class="keyword">where</span>  </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>  </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">and</span> table_name <span class="operator">=</span> <span class="string">&#x27;tablename&#x27;</span>;  </span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-----------------+  </span></span><br><span class="line"><span class="operator">|</span> data_length_MB <span class="operator">|</span> index_length_MB <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-----------------+  </span></span><br><span class="line"><span class="operator">|</span> <span class="number">158.67</span>MB       <span class="operator">|</span> <span class="number">224.86</span>MB        <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-----------------+  </span></span><br><span class="line"><span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="查看所有数据库容量大小">查看所有数据库容量大小</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_schema <span class="keyword">as</span> <span class="string">&#x27;数据库&#x27;</span>, <span class="built_in">sum</span>(table_rows) <span class="keyword">as</span> <span class="string">&#x27;记录数&#x27;</span>, <span class="built_in">sum</span>(<span class="keyword">truncate</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>)) <span class="keyword">as</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>, <span class="built_in">sum</span>(<span class="keyword">truncate</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>)) <span class="keyword">as</span> <span class="string">&#x27;索引容量(MB)&#x27;</span></span><br><span class="line"><span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> table_schema</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(data_length) <span class="keyword">desc</span>, <span class="built_in">sum</span>(index_length) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<h2 id="查看指定数据库各表容量大小">查看指定数据库各表容量大小</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">table_schema <span class="keyword">as</span> <span class="string">&#x27;数据库&#x27;</span>,</span><br><span class="line">table_name <span class="keyword">as</span> <span class="string">&#x27;表名&#x27;</span>,</span><br><span class="line">table_rows <span class="keyword">as</span> <span class="string">&#x27;记录数&#x27;</span>,</span><br><span class="line"><span class="keyword">truncate</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>,</span><br><span class="line"><span class="keyword">truncate</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&#x27;索引容量(MB)&#x27;</span></span><br><span class="line"><span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> data_length <span class="keyword">desc</span>, index_length <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> concat(round(<span class="built_in">sum</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;MB&#x27;</span>) <span class="keyword">as</span> data_length_MB, concat(round(<span class="built_in">sum</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;MB&#x27;</span>) <span class="keyword">as</span> index_length_MB</span><br><span class="line"><span class="keyword">from</span> tables </span><br><span class="line"><span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;passport&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;tb_user_info&#x27;</span>;</span><br><span class="line"><span class="comment">-- 569.98MB 141.98MB</span></span><br><span class="line"><span class="keyword">select</span> concat(round(<span class="built_in">sum</span>(data_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;MB&#x27;</span>) <span class="keyword">as</span> data_length_MB, concat(round(<span class="built_in">sum</span>(index_length<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;MB&#x27;</span>) <span class="keyword">as</span> index_length_MB</span><br><span class="line"><span class="keyword">from</span> tables</span><br><span class="line"><span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;passport_v2&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;tb_user_info&#x27;</span>;</span><br><span class="line"><span class="comment">--   2128.94MB   285.00MB</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解元数据锁</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81/</url>
    <content><![CDATA[<p>前言：</p>
<p>当你在<a
href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a>中执行一条SQL时，语句并没有在你预期的时间内执行完成，这时候我们通常会登陆到<a
href="https://cloud.tencent.com/product/cdb?from=10680">MySQL数据库</a>上查看是不是出了什么问题，通常会使用的一个命令就是
show processlist，看看有哪些session，这些session在做什么事情。当你看到
waiting for table metadata lock
时，那就是遇到MDL元数据锁了。本篇文章将会介绍MDL锁的产生与排查过程。</p>
<p>1.什么是MDL锁</p>
<p>MDL全称为metadata
lock，即元数据锁。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务（显式或隐式）的时候，不可以对元数据进行写入操作。因此从MySQL5.5版本开始引入了MDL锁，来保护表的元数据信息，用于解决或者保证DDL操作与DML操作之间的一致性。</p>
<p>对于引入MDL，其主要解决了2个问题，一个是事务隔离问题，比如在可重复隔离级别下，会话A在2次查询期间，会话B对表结构做了修改，两次查询结果就会不一致，无法满足可重复读的要求；另外一个是数据复制的问题，比如会话A执行了多条更新语句期间，另外一个会话B做了表结构变更并且先提交，就会导致slave在重做时，先重做alter，再重做update时就会出现复制错误的现象。</p>
<p>元数据锁是server层的锁，表级锁，每执行一条DML、DDL语句时都会申请MDL锁，DML操作需要MDL读锁，DDL操作需要MDL写锁（MDL加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥），申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到MDL锁后，直到事务执行完才会将锁释放。（这里有种特殊情况如果事务中包含DDL操作，mysql会在DDL操作语句执行前，隐式提交commit，以保证该DDL语句操作作为一个单独的事务存在，同时也保证元数据排他锁的释放）。</p>
<p>注意：支持事务的InnoDB引擎表和不支持事务的MyISAM引擎表，都会出现Metadata
Lock Wait等待现象。一旦出现Metadata Lock
Wait等待现象，后续所有对该表的访问都会阻塞在该等待上，导致连接堆积，业务受影响。</p>
<p>2.模拟与查找MDL锁</p>
<p>MDL锁通常发生在DDL操作挂起的时候，原因是有未提交的事务对该表进行DML操作。而MySQL的会话那么多，不知道哪个会话的操作没有及时提交影响了DDL。通常我们排查这类问题，往往需要从information_schema.innodb_trx表中查询当前在执行的事务，但当SQL已经执行过了，没有commit，这个时候这个表中是看不到SQL的。</p>
<p>在MySQL5.7中，performance_schema库中新增了metadata_locks表，专门记录MDL的相关信息。首先要开启MDL锁记录，执行如下SQL开启：</p>
<p>UPDATE performance_schema.setup_instruments</p>
<p>SET ENABLED = 'YES', TIMED = 'YES'</p>
<p>WHERE NAME = 'wait/lock/metadata/sql/mdl';</p>
<h1 id="会话1-事务中执行dml操作">会话1 事务中执行DML操作</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student_tb (stu_id,stu_name) <span class="keyword">values</span> (<span class="number">1009</span>,<span class="string">&#x27;xin&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student_tb;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------+----------+---------------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> increment_id <span class="operator">|</span> stu_id <span class="operator">|</span> stu_name <span class="operator">|</span> create_time         <span class="operator">|</span> update_time         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------+----------+---------------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span>   <span class="number">1001</span> <span class="operator">|</span> from1    <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">2</span> <span class="operator">|</span>   <span class="number">1002</span> <span class="operator">|</span> dfsfd    <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">3</span> <span class="operator">|</span>   <span class="number">1003</span> <span class="operator">|</span> fdgfg    <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">4</span> <span class="operator">|</span>   <span class="number">1004</span> <span class="operator">|</span> sdfsdf   <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">5</span> <span class="operator">|</span>   <span class="number">1005</span> <span class="operator">|</span> dsfsdg   <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">6</span> <span class="operator">|</span>   <span class="number">1006</span> <span class="operator">|</span> fgd      <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">7</span> <span class="operator">|</span>   <span class="number">1007</span> <span class="operator">|</span> fgds     <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">8</span> <span class="operator">|</span>   <span class="number">1008</span> <span class="operator">|</span> dgfsa    <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">14</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">9</span> <span class="operator">|</span>   <span class="number">1009</span> <span class="operator">|</span> xin      <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">29</span> <span class="operator">|</span> <span class="number">2019</span><span class="number">-11</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">29</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------+----------+---------------------+---------------------+</span></span><br></pre></td></tr></table></figure>
<h1 id="会话2-对该表加字段-执行ddl操作-发现ddl挂起">会话2 对该表加字段
执行DDL操作 发现DDL挂起</h1>
<p>mysql&gt; alter table student_tb add stu_age int after stu_name;</p>
<h1 id="会话3-查询所有会话-发现发生mdl锁">会话3 查询所有会话
发现发生MDL锁</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----------+--------+---------+------+---------------------------------+-------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> <span class="keyword">User</span> <span class="operator">|</span> Host      <span class="operator">|</span> db     <span class="operator">|</span> Command <span class="operator">|</span> <span class="type">Time</span> <span class="operator">|</span> State                           <span class="operator">|</span> Info                                                  <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----------+--------+---------+------+---------------------------------+-------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="number">31</span> <span class="operator">|</span> root <span class="operator">|</span> localhost <span class="operator">|</span> testdb <span class="operator">|</span> Sleep   <span class="operator">|</span>  <span class="number">125</span> <span class="operator">|</span>                                 <span class="operator">|</span> <span class="keyword">NULL</span>                                                  <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="number">32</span> <span class="operator">|</span> root <span class="operator">|</span> localhost <span class="operator">|</span> testdb <span class="operator">|</span> Query   <span class="operator">|</span>    <span class="number">7</span> <span class="operator">|</span> Waiting <span class="keyword">for</span> <span class="keyword">table</span> metadata lock <span class="operator">|</span> <span class="keyword">alter</span> <span class="keyword">table</span> student_tb <span class="keyword">add</span> stu_age <span class="type">int</span> after stu_name <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="number">33</span> <span class="operator">|</span> root <span class="operator">|</span> localhost <span class="operator">|</span> testdb <span class="operator">|</span> Query   <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> starting                        <span class="operator">|</span> <span class="keyword">show</span> processlist                                      <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----------+--------+---------+------+---------------------------------+-------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<h1
id="会话3-查看metadata_locks表记录-发现student_tb表有mdl锁冲突">会话3
查看metadata_locks表记录 发现student_tb表有MDL锁冲突</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.metadata_locks;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------------+----------------+-----------------------+---------------------+---------------+-------------+--------+-----------------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> OBJECT_TYPE <span class="operator">|</span> OBJECT_SCHEMA      <span class="operator">|</span> OBJECT_NAME    <span class="operator">|</span> OBJECT_INSTANCE_BEGIN <span class="operator">|</span> LOCK_TYPE           <span class="operator">|</span> LOCK_DURATION <span class="operator">|</span> LOCK_STATUS <span class="operator">|</span> SOURCE <span class="operator">|</span> OWNER_THREAD_ID <span class="operator">|</span> OWNER_EVENT_ID <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------------+----------------+-----------------------+---------------------+---------------+-------------+--------+-----------------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> testdb             <span class="operator">|</span> student_tb     <span class="operator">|</span>        <span class="number">94189250717664</span> <span class="operator">|</span> SHARED_WRITE        <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">56</span> <span class="operator">|</span>             <span class="number">34</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GLOBAL</span>      <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="keyword">NULL</span>           <span class="operator">|</span>       <span class="number">139764477045472</span> <span class="operator">|</span> INTENTION_EXCLUSIVE <span class="operator">|</span> STATEMENT     <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">57</span> <span class="operator">|</span>             <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> SCHEMA      <span class="operator">|</span> testdb             <span class="operator">|</span> <span class="keyword">NULL</span>           <span class="operator">|</span>       <span class="number">139764477697808</span> <span class="operator">|</span> INTENTION_EXCLUSIVE <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">57</span> <span class="operator">|</span>             <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> testdb             <span class="operator">|</span> student_tb     <span class="operator">|</span>       <span class="number">139764477697904</span> <span class="operator">|</span> SHARED_UPGRADABLE   <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">57</span> <span class="operator">|</span>             <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> testdb             <span class="operator">|</span> student_tb     <span class="operator">|</span>       <span class="number">139764477697696</span> <span class="operator">|</span> EXCLUSIVE           <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> PENDING     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">57</span> <span class="operator">|</span>             <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> performance_schema <span class="operator">|</span> metadata_locks <span class="operator">|</span>       <span class="number">139764544135120</span> <span class="operator">|</span> SHARED_READ         <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">58</span> <span class="operator">|</span>             <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------------+----------------+-----------------------+---------------------+---------------+-------------+--------+-----------------+----------------+</span></span><br></pre></td></tr></table></figure>
<h1 id="会话3-联合其他系统表-查找出会话id">会话3 联合其他系统表
查找出会话ID</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> m.<span class="operator">*</span>,t.PROCESSLIST_ID <span class="keyword">from</span> performance_schema.metadata_locks m <span class="keyword">left</span> <span class="keyword">join</span> performance_schema.threads t <span class="keyword">on</span> m.owner_thread_id<span class="operator">=</span>t.thread_id;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------------+----------------+-----------------------+---------------------+---------------+-------------+--------+-----------------+----------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> OBJECT_TYPE <span class="operator">|</span> OBJECT_SCHEMA      <span class="operator">|</span> OBJECT_NAME    <span class="operator">|</span> OBJECT_INSTANCE_BEGIN <span class="operator">|</span> LOCK_TYPE           <span class="operator">|</span> LOCK_DURATION <span class="operator">|</span> LOCK_STATUS <span class="operator">|</span> SOURCE <span class="operator">|</span> OWNER_THREAD_ID <span class="operator">|</span> OWNER_EVENT_ID <span class="operator">|</span> PROCESSLIST_ID <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------------+----------------+-----------------------+---------------------+---------------+-------------+--------+-----------------+----------------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> testdb             <span class="operator">|</span> student_tb     <span class="operator">|</span>        <span class="number">94189250717664</span> <span class="operator">|</span> SHARED_WRITE        <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">56</span> <span class="operator">|</span>             <span class="number">34</span> <span class="operator">|</span>             <span class="number">31</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GLOBAL</span>      <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="keyword">NULL</span>           <span class="operator">|</span>       <span class="number">139764477045472</span> <span class="operator">|</span> INTENTION_EXCLUSIVE <span class="operator">|</span> STATEMENT     <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">57</span> <span class="operator">|</span>             <span class="number">18</span> <span class="operator">|</span>             <span class="number">32</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> SCHEMA      <span class="operator">|</span> testdb             <span class="operator">|</span> <span class="keyword">NULL</span>           <span class="operator">|</span>       <span class="number">139764477697808</span> <span class="operator">|</span> INTENTION_EXCLUSIVE <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">57</span> <span class="operator">|</span>             <span class="number">18</span> <span class="operator">|</span>             <span class="number">32</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> testdb             <span class="operator">|</span> student_tb     <span class="operator">|</span>       <span class="number">139764477697904</span> <span class="operator">|</span> SHARED_UPGRADABLE   <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">57</span> <span class="operator">|</span>             <span class="number">18</span> <span class="operator">|</span>             <span class="number">32</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> testdb             <span class="operator">|</span> student_tb     <span class="operator">|</span>       <span class="number">139764477697696</span> <span class="operator">|</span> EXCLUSIVE           <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> PENDING     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">57</span> <span class="operator">|</span>             <span class="number">18</span> <span class="operator">|</span>             <span class="number">32</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> performance_schema <span class="operator">|</span> metadata_locks <span class="operator">|</span>       <span class="number">139764544135120</span> <span class="operator">|</span> SHARED_READ         <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">58</span> <span class="operator">|</span>             <span class="number">22</span> <span class="operator">|</span>             <span class="number">33</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> performance_schema <span class="operator">|</span> threads        <span class="operator">|</span>       <span class="number">139764549217280</span> <span class="operator">|</span> SHARED_READ         <span class="operator">|</span> TRANSACTION   <span class="operator">|</span> GRANTED     <span class="operator">|</span>        <span class="operator">|</span>              <span class="number">58</span> <span class="operator">|</span>             <span class="number">22</span> <span class="operator">|</span>             <span class="number">33</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------------+----------------+-----------------------+---------------------+---------------+-------------+--------+-----------------+----------------+----------------+</span></span><br></pre></td></tr></table></figure>
<h1
id="结果解读从上面结果明显可以看出会话31持有student_tb表的shared_write锁">结果解读：从上面结果明显可以看出会话31持有student_tb表的SHARED_WRITE锁，</h1>
<h1
id="需要等待其提交后或手动杀掉该会话方可解除mdl锁">需要等待其提交后或手动杀掉该会话方可解除MDL锁。</h1>
<p>3.如何优化与避免MDL锁</p>
<p>MDL锁一旦发生会对业务造成极大影响，因为后续所有对该表的访问都会被阻塞，造成连接积压。我们日常要尽量避免MDL锁的发生，下面给出几点优化建议可供参考：</p>
<ul>
<li>开启metadata_locks表记录MDL锁。<br />
</li>
<li>设置参数lock_wait_timeout为较小值，使被阻塞端主动停止。<br />
</li>
<li>规范使用事务，及时提交事务，避免使用大事务。<br />
</li>
<li>增强监控告警，及时发现MDL锁。<br />
</li>
<li>DDL操作及备份操作放在业务低峰期执行。<br />
</li>
<li>少用工具开启事务进行查询，图形化工具要及时关闭。</li>
</ul>
<p>总结：</p>
<p>本篇文章主要分三方面来详解MDL锁，首先介绍了MDL锁产生的原因及作用，然后我们模拟出MDL锁，并给出查找及解决方法，最后给出几点避免MDL锁的建议。其实，MDL锁在DB<a
href="https://cloud.tencent.com/solution/operation?from=10680">运维</a>过程中经常遇到，它不是洪水猛兽，只是为了保护数据库对象，保证数据一致性。希望大家看完这篇文章后能对MDL锁有更清晰的认识。</p>
<p>来自 &lt;<a
href="https://cloud.tencent.com/developer/article/1553461">https://cloud.tencent.com/developer/article/1553461</a>&gt;</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>非空值查询</title>
    <url>/blog/2023/10/11/data/CSAPP/database/SQL/%E9%9D%9E%E7%A9%BA%E5%80%BC%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>空值与空字符串不同，判断方法也不同<br />
判断NULL用is null 或者 is not null。<br />
判断空字符串，要用 =”或者 &lt;&gt;”。</p>
<h3 id="获取空值或非空值的数据">获取空值或非空值的数据</h3>
<p>获取字段field为空值的数据，语法：<code>select * from tableName where field is null</code><br />
获取字段field为非空值的数据，语法：<code>select * from tableName where field is not null</code></p>
<h3
id="获取空字符串或非空字符串的数据">获取空字符串或非空字符串的数据：</h3>
<p>获取字段field为空字符串的数据，语法：<code>select * from tableName where field=”</code><br />
获取字段field为非空字符串的数据，语法：<code>select * from tableName where field!=”</code></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>内存数据库和磁盘数据库带超大缓存的区别？</title>
    <url>/blog/2023/10/11/data/CSAPP/database/principle/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%A6%E8%B6%85%E5%A4%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p>首先是文章 <em>Main Memory Database Systems</em> 中提到的：<br />
&gt; What is the difference between a MMDB and a DRDB with a very large
cache? If the cache of a DRDB is large enough, copies of the data will
reside in memory at all times. Although such a system will perform well,
it is not taking full advantage of the memory. For example, the index
structures will be designed for disk access (e.g., B-trees), even though
the data are in memory. Also, applications may have to access data
through a buffer manager, as if the data were on disk. For example,
every time an application wishes to access a given tuple, its disk
address will have to be computed, and then the buffer manager will be
invoked to check if the corresponding block is in memory. Once the block
is found, the tuple will be copied into an application tuple buffer,
where it is actually examined. Clearly, if the record will always be in
memory, it is more efficient to refer to it by its memory address.<br />
What we have illustrated is only one of the possible inmemory
optimizations. Others will be described in Section II.</p>
<p>也即，内存类型的数据库访问键值时，可以直接通过内存地址存取读写数据，而MySQL一类的面向磁盘设计的数据库，就算给它开放巨大的缓存池（大部分物理内存），在访问内存中已经缓存的数据时，也必须计算磁盘地址，然后经过缓存管理器检查是否已经存在于内存缓存中，再去返回元组数据到应用层缓存中，而内存类型数据库在设计之初就减免了这些额外的开销。</p>
<p>在21世纪初，由于主存容量和性价比的提升，<a
href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2219122998%7D">数据库</a>的大部分数据可以缓存在主存中了[1]。因此关于<a
href="https://www.zhihu.com/search?q=%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2219122998%7D">内存数据库</a>的讨论的就非常热门，当时有一篇著名的文章（2008-SIGMOD-OLTP
Through the Looking Glass, and What We Found There
[2]）回答了提问者的这个问题：</p>
<blockquote>
<p>同样是将数据缓存在内存中， 同样支持LRU淘汰，是不是设置了很大的innodb
buffer pool之后可以不用redis了？</p>
</blockquote>
<p>论文结论表明：直接开辟一个很大的<a
href="https://www.zhihu.com/search?q=buffer%20pool&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2219122998%7D">buffer
pool</a>，保证所有的页都存储在其中，并不是最有效的方式。更高效的方式是设计memory-oriented的DBMS，这个工作属于当时著名的<a
href="https://link.zhihu.com/?target=https%3A//hstore.cs.brown.edu/">H-Store</a>项目。</p>
<p>论文表示，使用一个足够大的buffer
pool是次优的，根本原因在于：<strong>磁盘DBMS的所有模块，即buffer
pool结构，日志技术，事务并发，存储模型等等模块，都是面向磁盘页而设计的，因此其首要目标不是减少内存代价，而是I/O代价。</strong>这意味着，采用传统的磁盘DBMS开辟一块很大的buffer
pool，能够显著减少磁盘I/O，但是其内存访问代价却并不是最优的选择。</p>
<p>原论文使用朴素的方法测量了磁盘DBMS下数据可以完全存放在buffer
pool中的各个模块代价，如下图所示：</p>
<p><img
src="https://picx.zhimg.com/80/v2-fd69bb86f7b84a5a4237e5ba106ec1f5_720w.webp?source=1940ef5c" /></p>
<p>如果采用提问者的方法，将分别有34.6%，16.3%和11.9%的指令花费在buffer
manager，locking和日志机制上，<strong>如果采用memory-oriented
DBMS设计（<a
href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2219122998%7D">数据结构</a>和访问模式redesign），buffer
manager的代价可以避免，locking和日志的代价可以大大降低，从而达到更优的时间性能。</strong></p>
<p>谢谢！</p>
<p><strong><a
href="https://www.zhihu.com/search?q=%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2219122998%7D">参考文献</a>：</strong></p>
<p>[1]. H. Garcia-Molina and K. Salem, "Main memory database systems: an
overview," in TKDE, vol. 4, no. 6, pp. 509-516, Dec. 1992.</p>
<p>[2]. S. Harizopoulos, D. J. Abadi, S. Madden, and M. Stonebraker.
2008. OLTP through the looking glass, and what we found there. In <a
href="https://www.zhihu.com/search?q=proceeding%20of&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2219122998%7D">proceeding
of</a> SIGMOD'08. Association for Computing Machinery, New York, NY,
USA, 981–992.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>database</tag>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title>$和$$</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/$%E5%92%8C$$/</url>
    <content><![CDATA[<p>$     表示当前行被汇编后的地址。<br />
$$      表示一个节的开始处被汇编后的地址。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>CS寄存器作用</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/CS%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>CPU的CS寄存器默认会存储当前执行指令所在的段基地址吗？</p>
<p>2023/8/18 23:22:43</p>
<p>是的，CPU 的 CS (Code Segment)
寄存器会存储当前执行指令所在的代码段的基地址。在实模式下，CS
寄存器保存了一个 16 位的段选择子，用于指示当前代码段的位置。</p>
<p>在实模式下，所有的内存访问都是基于段地址和偏移地址的组合。CS
寄存器中的段选择子指示了当前正在执行的代码段的基地址，而指令中的偏移地址指示了代码段中具体的指令位置。通过使用段选择子和偏移地址的组合，CPU
可以计算出具体的物理地址，然后从该地址中读取指令进行执行。</p>
<p>需要注意的是，在保护模式下，CS
寄存器的功能发生了变化，它不再直接存储代码段的基地址，而是存储一个包含了段描述符的索引，通过段描述符可以获取代码段的基地址和其他属性信息。</p>
<p>总结起来，CPU 的 CS
寄存器在实模式下存储当前执行指令所在的代码段的基地址，而在保护模式下存储与代码段相关的描述符信息。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP和EBP寄存器的作用</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/ESP%E5%92%8CEBP%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<ol type="1">
<li><p><strong>ESP (Extended Stack Pointer)</strong>: It always points
to the top of the stack. Since the stack grows downwards (from higher
memory addresses to lower memory addresses), this means <code>ESP</code>
points to the lowest address in the current stack frame. As you push
values onto the stack, the <code>ESP</code> decreases, and as you pop
values off the stack, the <code>ESP</code> increases.</p></li>
<li><p><strong>EBP (Extended Base Pointer)</strong>: It is traditionally
used as a frame pointer. In the context of a function call,
<code>EBP</code> is used to point to the base (or beginning) of the
current stack frame, which would be a higher memory address than where
<code>ESP</code> points. The <code>EBP</code> provides a fixed reference
point within the stack frame, making it easier to access local variables
and function arguments since their offsets from the <code>EBP</code>
remain constant throughout the function's execution, even as
<code>ESP</code> may change with pushes, pops, and local variable
allocations.</p></li>
</ol>
<p>Here's a visual representation of a typical stack frame when a
function is called:<br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Higher Memory Addresses</span><br><span class="line">------------------------</span><br><span class="line">|    Previous Frame    |</span><br><span class="line">|----------------------|</span><br><span class="line">| Caller&#x27;s Return Addr | &lt;-- EBP + 4 (if using EBP-based addressing)</span><br><span class="line">|----------------------|</span><br><span class="line">| Caller&#x27;s Frame Ptr   | &lt;-- EBP (after the callee has set it up)</span><br><span class="line">|----------------------|</span><br><span class="line">|   Callee&#x27;s Locals    |</span><br><span class="line">|----------------------| &lt;-- ESP (at its highest in this function)</span><br><span class="line">|      ...             |</span><br><span class="line">|----------------------| &lt;-- ESP (after locals are allocated)</span><br><span class="line">|                      |</span><br><span class="line">------------------------</span><br><span class="line">Lower Memory Addresses</span><br></pre></td></tr></table></figure></p>
<p>Do note that the use of <code>EBP</code> as a frame pointer is a
convention, and with optimizations, modern compilers might omit the
frame pointer (this is often called "frame pointer omission" or FPO) to
free up the <code>EBP</code> register for other general-purpose uses. In
such cases, accessing local variables and arguments is done with offsets
from <code>ESP</code> directly, and it requires more sophisticated
tracking of the stack state.</p>
<p>并且注意，ESP指针永远指向栈帧最后一个被使用了的地址，而不是下一个空地址。这样栈帧顶指针寄存器ESP往低地址移动一个字节<br />
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Higher Memory Addresses</span><br><span class="line">-----------------------</span><br><span class="line">|      Data           |</span><br><span class="line">|---------------------| </span><br><span class="line">| New Data            | &lt;-- ESP pointing here after pushing &#x27;New Data&#x27;</span><br><span class="line">|---------------------|</span><br><span class="line">| Empty/Unspecified   |</span><br><span class="line">-----------------------</span><br><span class="line">Lower Memory Addresses</span><br></pre></td></tr></table></figure></p>
<p>When you have data types that occupy more than one byte (like a
32-bit integer or a 64-bit double), they will span multiple consecutive
byte addresses in memory. For instance, if a 32-bit integer is stored at
memory address <code>0x1000</code>, it occupies addresses
<code>0x1000</code>, <code>0x1001</code>, <code>0x1002</code>, and
<code>0x1003</code>.</p>
<p>In the context of the stack frame:</p>
<ul>
<li><p>When a value is pushed onto the stack, the stack pointer (e.g.,
<code>ESP</code> for x86) is decremented by the size of that value in
bytes. If you push a 32-bit (4-byte) value, <code>ESP</code> is
decremented by 4 bytes.</p></li>
<li><p>When accessing local variables or parameters inside a function,
they are typically offset by a certain number of bytes from the base
pointer (e.g., <code>EBP</code> for x86) or the stack pointer, depending
on the convention and optimization level.</p></li>
</ul>
<p>So, whether you're working with the stack or any other part of
memory, it's byte-addressable, and operations that involve memory will
consider the size in bytes of the data they're working with.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>db - define byte 定义字符串常量</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/db%20-%20define%20byte%20%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<p>StartBootMessage: db "start boot"，这段汇编代码怎么理解？</p>
<p>2023/8/19 14:47:19</p>
<p>这段汇编代码是一个定义了名为 "StartBootMessage"
的字符串常量。在汇编语言中，字符串常量通常用 <code>db</code>（define
byte）指令来定义。</p>
<p>具体地说，<code>StartBootMessage</code>
是一个标签（label），它用于表示该字符串常量的起始位置。在汇编程序中，标签用于标识不同的代码或数据位置。</p>
<p>"start boot" 是字符串的内容。每个字符都用一个字节来表示，并按照 ASCII
或其他字符编码方式进行存储。在这里，每个字符被转换为相应的 ASCII
码，并存储在内存中。</p>
<p>这段代码的目的可能是定义一个用于启动引导过程的提示消息或标识符。在后续的汇编代码中，可以使用
<code>StartBootMessage</code>
标签来引用这个字符串常量，以便在程序执行过程中打印或处理该字符串。</p>
<p>需要注意的是，这段汇编代码可能只是一个示例，在实际使用中，可能会有更多的代码来使用这个字符串常量或实现与引导相关的功能。此外，在不同的汇编语言和平台上，字符串常量的定义方式可能有所差异。</p>
<p>所以一个字面量加英文冒号就能表示某个地址的标签？</p>
<p>2023/8/19 14:48:52</p>
<p>在汇编语言中，字面量加上英文冒号通常用于表示一个标签，而不是某个地址。标签是用来标识代码或数据的位置的符号名称。</p>
<p>在汇编程序中，标签通常放置在指令或数据的前面，并且以冒号结尾。它们可以用来标记跳转目标、变量地址或数据区域的起始位置等。通过使用标签，程序员可以更方便地引用和跳转到特定的位置，而无需直接处理具体的地址值。</p>
<p>举个例子，考虑下面的汇编代码片段：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StartLoop:</span><br><span class="line">    ; 循环体的指令</span><br><span class="line">    jmp StartLoop</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>StartLoop</code>
就是一个标签，它表示循环体的起始位置。<code>jmp StartLoop</code>
指令将执行一个无条件跳转，使程序重复回到 <code>StartLoop</code>
标签处，从而实现一个简单的循环。</p>
<p>需要注意的是，标签只是给位置起了一个有意义的名称，并不直接表示地址。在汇编程序被汇编和链接后，标签会被转换为相应的地址值。因此，在给定的上下文中，标签确实可以用于表示特定的地址。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>db, dw, dd, dq</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/db,%20dw,%20dd,%20dq/</url>
    <content><![CDATA[<p>汇编语言中，像db、dw、dd、dq这类指令，是写完内容之后就会自动到下一个未写入内容的地址吗？</p>
<p>2023/8/19 15:03:52</p>
<p>是的，像
<code>db</code>、<code>dw</code>、<code>dd</code>、<code>dq</code>
这些指令在汇编语言中被称为数据定义指令（Data Definition
Directive），用于在程序中分配内存并初始化数据。</p>
<p>这些指令会根据指定的数据类型和值，自动将数据写入当前地址，并更新到下一个未写入内容的地址。具体的工作方式如下：</p>
<ul>
<li><code>db</code>（Define
Byte）指令用于定义字节类型的数据。每个 <code>db</code> 指令会将一个字节大小的数据写入当前地址，然后将地址指针移动到下一个字节位置。<br />
</li>
<li><code>dw</code>（Define
Word）指令用于定义字类型的数据。每个 <code>dw</code> 指令会将一个字大小的数据写入当前地址，然后将地址指针移动到下一个字位置。<br />
</li>
<li><code>dd</code>（Define Double
word）指令用于定义双字类型的数据。每个 <code>dd</code> 指令会将一个双字大小的数据写入当前地址，然后将地址指针移动到下一个双字位置。<br />
</li>
<li><code>dq</code>（Define Quadruple
word）指令用于定义四字类型的数据。每个 <code>dq</code> 指令会将一个四字大小的数据写入当前地址，然后将地址指针移动到下一个四字位置。</li>
</ul>
<p>例如，考虑以下汇编代码片段：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data_segment segment</span><br><span class="line">    db 1, 2, 3   ; 将 1、2、3 写入当前地址和下两个字节位置</span><br><span class="line">    dw 4        ; 将 4 写入第四个字节位置</span><br><span class="line">    dd 5        ; 将 5 写入第八个字节位置</span><br><span class="line">data_segment ends</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>db、dw、dd、dq不是机器指令而是伪指令</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/db%E3%80%81dw%E3%80%81dd%E3%80%81dq%E4%B8%8D%E6%98%AF%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E8%80%8C%E6%98%AF%E4%BC%AA%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>汇编器指示和汇编器命令的区别是什么？参考一下GPT4的回答<br />
So, in fact, <code>db, dw, dd, dq</code> won't actually be assembled to
machine code, but hint for assembler to allocate space for data?</p>
<p>ChatGPT</p>
<p>Correct! <code>db</code>, <code>dw</code>, <code>dd</code>, and
<code>dq</code> are assembly directives, not CPU instructions. They tell
the assembler how to allocate and initialize data in the generated
machine code. They don't correspond to executable machine instructions
themselves.</p>
<p>Here's a recap:</p>
<ul>
<li><code>db</code> (Define Byte): Tells the assembler to reserve space
for one or more bytes and optionally initialize them with given
values.<br />
</li>
<li><code>dw</code> (Define Word): Reserves space for one or more 16-bit
words and optionally initializes them.<br />
</li>
<li><code>dd</code> (Define Doubleword): Reserves space for one or more
32-bit doublewords and optionally initializes them.<br />
</li>
<li><code>dq</code> (Define Quadword): Reserves space for one or more
64-bit quadwords and optionally initializes them.</li>
</ul>
<p>When you assemble a program that contains these directives, the
resultant machine code will have the specified data values embedded at
the appropriate locations. But when this machine code is executed, the
CPU doesn't "run" these directives as it would with actual instructions
like <code>mov</code>, <code>add</code>, or <code>jmp</code>. Instead,
they just represent static data in the machine code.</p>
<p>what's the difference between assembly directives and assemble
instructions?</p>
<p>ChatGPT</p>
<p>Assembly directives and assembly instructions serve different
purposes in an assembly language program. Here's a breakdown of their
differences:</p>
<ol type="1">
<li><strong>Purpose</strong>:
<ul>
<li><strong>Assembly Directives</strong>: They provide instructions to
the assembler, not the CPU. They tell the assembler how to process the
code, allocate data, set up segments, or control other aspects of the
assembly process. They don't produce executable machine code for the CPU
but influence the structure and content of the output binary.<br />
</li>
<li><strong>Assembly Instructions</strong>: These are mnemonics for
actual machine instructions. When the assembler encounters these, it
translates them into the corresponding machine code (binary format) that
the CPU can execute.<br />
</li>
</ul></li>
<li><strong>Output</strong>:
<ul>
<li><strong>Assembly Directives</strong>: They usually don't produce
executable code. Instead, they might produce data, set up offsets,
define constants, or guide the layout of the output binary.<br />
</li>
<li><strong>Assembly Instructions</strong>: They are translated directly
into executable machine code. When the CPU encounters this machine code
during execution, it knows how to perform the corresponding
operation.<br />
</li>
</ul></li>
<li><strong>Examples</strong>:
<ul>
<li><strong>Assembly Directives</strong>:
<ul>
<li><code>db</code>, <code>dw</code>, <code>dd</code>: Define data
bytes, words, or double words, respectively.<br />
</li>
<li><code>section</code> or <code>segment</code>: Used to define
sections or segments of the code or data.<br />
</li>
<li><code>equ</code>: Used for constant definitions.<br />
</li>
<li><code>include</code>: Direct the assembler to include another file
during the assembly process.<br />
</li>
</ul></li>
<li><strong>Assembly Instructions</strong>:
<ul>
<li><code>mov</code>: Move data from one location to another.<br />
</li>
<li><code>add</code>: Add two values.<br />
</li>
<li><code>jmp</code>: Jump to another location in the code.<br />
</li>
<li><code>call</code>: Call a subroutine.<br />
</li>
</ul></li>
</ul></li>
<li><strong>Scope</strong>:
<ul>
<li><strong>Assembly Directives</strong>: Influence the assembly
process. Their effect is mostly seen during the assembly time, and their
impact is on the structure, content, or layout of the assembled
output.<br />
</li>
<li><strong>Assembly Instructions</strong>: Influence the runtime
behavior of the program. When the program runs, the CPU executes these
instructions, determining the program's operation.</li>
</ul></li>
</ol>
<p>In summary, while assembly instructions define what the program does
when it runs, assembly directives guide the assembler in how to create
the final machine code and data from the source assembly code.</p>
<p>list all assembly directives and assembly instructions</p>
<p>ChatGPT</p>
<p>Listing all assembly directives and instructions is quite a task
since the specifics vary based on the architecture (x86, ARM, MIPS,
etc.) and even on the specific assembler being used (e.g., NASM, MASM,
GAS).</p>
<p>However, I can give you a broad overview and list some common
directives and instructions for the x86 architecture using the NASM
(Netwide Assembler) as a representative assembler.</p>
<h3 id="common-nasm-assembly-directives">Common NASM Assembly
Directives:</h3>
<ul>
<li><code>section</code> or <code>segment</code>: Defines a segment or
section of the code or data.<br />
</li>
<li><code>db</code>, <code>dw</code>, <code>dd</code>, <code>dq</code>:
Define data of various sizes.<br />
</li>
<li><code>resb</code>, <code>resw</code>, <code>resd</code>,
<code>resq</code>: Reserve space for uninitialized data.<br />
</li>
<li><code>equ</code>: Define a name as a constant.<br />
</li>
<li><code>include</code>: Include another file.<br />
</li>
<li><code>extern</code>: Declare external symbols.<br />
</li>
<li><code>global</code>: Declare global symbols.<br />
</li>
<li><code>times</code>: Repeat an instruction or data declaration.<br />
</li>
<li><code>align</code>: Align the next instruction or data to a
specified boundary.</li>
</ul>
<h3 id="common-x86-assembly-instructions">Common x86 Assembly
Instructions:</h3>
<p>This is just a small subset for illustrative purposes. The x86
instruction set, especially when considering both the 32-bit and 64-bit
variants, along with all extensions (like MMX, SSE, AVX), is vast.</p>
<ul>
<li>Data Movement: <code>mov</code>, <code>push</code>,
<code>pop</code>, <code>lea</code><br />
</li>
<li>Arithmetic: <code>add</code>, <code>sub</code>, <code>mul</code>,
<code>div</code>, <code>inc</code>, <code>dec</code><br />
</li>
<li>Logic: <code>and</code>, <code>or</code>, <code>xor</code>,
<code>not</code><br />
</li>
<li>Control Flow: <code>jmp</code>, <code>je</code>, <code>jne</code>,
<code>jg</code>, <code>jl</code>, <code>call</code>, <code>ret</code>,
<code>int</code><br />
</li>
<li>Comparison: <code>cmp</code>, <code>test</code><br />
</li>
<li>Bit Manipulation: <code>shl</code>, <code>shr</code>,
<code>rol</code>, <code>ror</code><br />
</li>
<li>String: <code>movs</code>, <code>cmps</code>, <code>stos</code>,
<code>lods</code>, <code>scas</code><br />
</li>
<li>Special: <code>nop</code>, <code>hlt</code>, <code>cli</code>,
<code>sti</code></li>
</ul>
<p>This list is by no means exhaustive. For a comprehensive list, you
would refer to the official documentation or manuals for the given
architecture and assembler. If you're specifically interested in a
particular architecture or assembler, or a subset of instructions (e.g.,
floating point, vector operations), please specify, and I can provide
more detailed information.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>db、dw等伪指令可选的助记符</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/db%E3%80%81dw%E7%AD%89%E4%BC%AA%E6%8C%87%E4%BB%A4%E5%8F%AF%E9%80%89%E7%9A%84%E5%8A%A9%E8%AE%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>db、dw这些汇编伪指令，前面还可以加一个自定义的字符串名称，什么意思？</p>
<p>2023/8/20 13:49:13</p>
<p>在汇编语言中，<code>DB</code>（Define Byte）和
<code>DW</code>（Define
Word）是常见的伪指令，用于定义数据并分配内存空间。</p>
<p>这些伪指令可以用来为程序中的特定位置分配字节或字大小的连续内存空间，并为这些内存位置设置初始值。语法上，它们可以包含一个可选的字符串名称作为标识符，以便在后续的代码中引用这些位置。</p>
<p>例如，下面是使用 <code>DB</code> 和 <code>DW</code>
定义数据并命名的示例：</p>
<p>Copy Code</p>
<p><code>myString DB 'Hello, world!', 0   ; 分配内存空间并设置初始值为字符串'Hello, world!'，末尾有一个空字符 '\0' myNumber DW 1234                 ; 分配内存空间并设置初始值为十进制数值 1234</code></p>
<p>在上述示例中，<code>myString</code> 和 <code>myNumber</code>
是自定义的字符串名称（也可以称之为标识符），它们与相应的内存位置关联起来。<code>DB</code>
会分配一个字节的内存空间，并将字符串常量 "Hello, world!"
存储在其中，末尾有一个空字符 '\0'。<code>DW</code>
则分配一个字（两个字节）的内存空间，并将十进制数值 1234 存储在其中。</p>
<p>通过指定这些自定义的字符串名称，你可以在后续的汇编代码中引用它们，并对其进行操作，例如将其打印到屏幕上或进行算术运算。</p>
<p>需要注意的是，不同的汇编语言可能具有不同的伪指令和语法，因此在具体的汇编语言中，可能会有其他特定的表示方式和规则。在编写汇编代码时，请参考对应的汇编语言文档以了解正确的语法和指令格式。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>x86和x86_64(amd64)架构下寄存器命名含义</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/x86%E5%92%8Cx86_64(amd64)%E6%9E%B6%E6%9E%84%E4%B8%8B%E5%AF%84%E5%AD%98%E5%99%A8%E5%91%BD%E5%90%8D%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>64-bit</th>
<th>32-bit</th>
<th>16-bit</th>
<th>8-bit (low)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RAX</td>
<td>EAX</td>
<td>AX</td>
<td>AL</td>
</tr>
<tr class="even">
<td>RBX</td>
<td>EBX</td>
<td>BX</td>
<td>BL</td>
</tr>
<tr class="odd">
<td>RCX</td>
<td>ECX</td>
<td>CX</td>
<td>CL</td>
</tr>
<tr class="even">
<td>RDX</td>
<td>EDX</td>
<td>DX</td>
<td>DL</td>
</tr>
<tr class="odd">
<td>RSI</td>
<td>ESI</td>
<td>SI</td>
<td>SIL</td>
</tr>
<tr class="even">
<td>RDI</td>
<td>EDI</td>
<td>DI</td>
<td>DIL</td>
</tr>
<tr class="odd">
<td>RBP</td>
<td>EBP</td>
<td>BP</td>
<td>BPL</td>
</tr>
<tr class="even">
<td>RSP</td>
<td>ESP</td>
<td>SP</td>
<td>SPL</td>
</tr>
<tr class="odd">
<td>R8</td>
<td>R8D</td>
<td>R8W</td>
<td>R8B</td>
</tr>
<tr class="even">
<td>R9</td>
<td>R9D</td>
<td>R9W</td>
<td>R9B</td>
</tr>
<tr class="odd">
<td>R10</td>
<td>R10D</td>
<td>R10W</td>
<td>R10B</td>
</tr>
<tr class="even">
<td>R11</td>
<td>R11D</td>
<td>R11W</td>
<td>R11B</td>
</tr>
<tr class="odd">
<td>R12</td>
<td>R12D</td>
<td>R12W</td>
<td>R12B</td>
</tr>
<tr class="even">
<td>R13</td>
<td>R13D</td>
<td>R13W</td>
<td>R13B</td>
</tr>
<tr class="odd">
<td>R14</td>
<td>R14D</td>
<td>R14W</td>
<td>R14B</td>
</tr>
<tr class="even">
<td>R15</td>
<td>R15D</td>
<td>R15W</td>
<td>R15B</td>
</tr>
</tbody>
</table>
<p>rbp是什么寄存器，存放函数返回地址的寄存器？</p>
<p>2023/8/16 13:43:41</p>
<p>rbp 是 x86-64 架构中的一个寄存器，它被用作基址指针（Base
Pointer），也被称为帧指针（Frame Pointer）。rbp
寄存器通常用于函数调用过程中保存当前函数的堆栈帧信息。</p>
<p>rbp
寄存器的主要作用是提供对当前函数的堆栈帧的访问。它指向当前函数的栈帧底部。栈帧是在函数调用时创建的一块内存区域，用于存储局部变量、函数参数和其他与函数执行相关的数据。</p>
<p>除了存储堆栈帧的信息外，rbp
寄存器还会被用于存放函数的返回地址。当函数调用结束后，程序需要返回到调用该函数的位置继续执行。函数的返回地址会被保存在栈上，而
rbp 寄存器则可以在函数返回时帮助定位并获取正确的返回地址。</p>
<p>需要注意的是，不同的编译器和编程语言可能会使用不同的约定来处理寄存器的使用和函数调用的过程。因此，在特定的编程环境中，具体的寄存器用途和函数调用约定可能会有所区别。</p>
<p>2023/8/16 13:44:01</p>
<p>e开头的寄存器是32位，r开头的寄存器是64位？</p>
<p>2023/8/16 13:44:26</p>
<p>实际上，寄存器的命名约定在 x86 架构中是有所区别的。</p>
<p>在 32 位 x86 架构中：</p>
<ul>
<li>通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP<br />
</li>
<li>段寄存器：CS、DS、SS、ES、FS、GS<br />
</li>
<li>指令指针寄存器：EIP<br />
</li>
<li>标志寄存器：EFLAGS</li>
</ul>
<p>这些寄存器均是 32 位的。</p>
<p>而在 64 位 x86 架构中：</p>
<ul>
<li>通用寄存器：RAX、RBX、RCX、RDX、RSI、RDI、RBP、RSP<br />
</li>
<li>段寄存器：CS、DS、SS、ES、FS、GS<br />
</li>
<li>指令指针寄存器：RIP<br />
</li>
<li>标志寄存器：RFLAGS</li>
</ul>
<p>这些寄存器均是 64 位的。</p>
<p>所以，以 "E" 开头的寄存器是用于 32 位模式，以 "R" 开头的寄存器是用于
64 位模式。这种命名约定有助于区分不同模式下使用的寄存器大小。</p>
<p>2023/8/16 13:44:52</p>
<p>那么E和R分别代表了什么的缩写？当初命名的时候肯定有它的涵义</p>
<p>2023/8/16 13:45:18</p>
<p>在 x86 架构中，E 和 R 分别代表了 Extended 和 Register。</p>
<ul>
<li>E：Extended，表示对应的寄存器是扩展（Extended）寄存器。在 32
位模式下，这些寄存器是 32 位的。<br />
</li>
<li>R：Register，表示对应的寄存器是通用寄存器（Register）。在 64
位模式下，这些寄存器扩展到了 64 位。</li>
</ul>
<p>这种命名约定可以追溯到 Intel 的早期 x86 处理器，当时 16
位的处理器只使用 AX、BX、CX、DX 等 16
位的寄存器，然后随着处理器架构的演变，Intel
引入了扩展寄存器来支持更大的寻址空间和数据处理能力，因此引入了
EAX、EBX、ECX、EDX 等扩展寄存器作为 32 位寄存器。</p>
<p>在引入 64 位 x86 架构时，为了区分不同模式下的寄存器大小，Intel 选择以
"R" 开头表示 64 位寄存器，例如 RAX、RBX、RCX 等。</p>
<p>虽然 E 和 R 只是简单地表示不同寄存器的大小，但这种命名约定已经成为了
x86 架构的标准，并且在后续的处理器设计中得到了延续和扩展。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的汇编代码分析示例</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012202.jpg" /></p>
<h2 id="一汇编语言是什么">一、汇编语言是什么？</h2>
<p>我们知道，CPU
只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p>
<p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a
href="https://www.ruanyifeng.com/blog/2014/11/compiler.html">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>
<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012203.jpg" /></p>
<p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是
ADD。只要还原成二进制，汇编语言就可以被 CPU
直接执行，所以它是最底层的低级语言。</p>
<h2 id="二来历">二、来历</h2>
<p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p>
<p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成
ADD。内存地址也不再直接引用，而是用标签表示。</p>
<p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为
assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做
aseembly code。标准化以后，称为 assembly language，缩写为
asm，中文译为汇编语言。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012205.jpg" /></p>
<p>每一种 CPU
的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的
x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p>
<h2 id="三寄存器">三、寄存器</h2>
<p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p>
<p>先来看寄存器。CPU
本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU
要用的时候就去内存读写数据。但是，CPU
的运算速度远高于内存的读写速度，为了避免被拖慢，CPU
都自带一级缓存和二级缓存。基本上，CPU
缓存可以看作是读写速度较快的内存。</p>
<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU
每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU
还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU
优先读写寄存器，再由寄存器跟内存交换数据。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012206.png" /></p>
<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉
CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU
的零级缓存。</p>
<h2 id="四寄存器的种类">四、寄存器的种类</h2>
<p>早期的 x86 CPU
只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p>
<blockquote>
<ul>
<li>EAX<br />
</li>
<li>EBX<br />
</li>
<li>ECX<br />
</li>
<li>EDX<br />
</li>
<li>EDI<br />
</li>
<li>ESI<br />
</li>
<li>EBP<br />
</li>
<li>ESP</li>
</ul>
</blockquote>
<p>上面这8个寄存器之中，前面七个都是通用的。ESP
寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012207.png" /></p>
<p>我们常常看到 32位 CPU、64位 CPU
这样的名称，其实指的就是寄存器的大小。32 位 CPU
的寄存器大小就是4个字节。</p>
<h2 id="五内存模型heap">五、内存模型：Heap</h2>
<p>寄存器只能存放很少量的数据，大多数时候，CPU
要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012208.png" /></p>
<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012209.png" /></p>
<p>这种因为用户主动请求而划分出来的内存区域，叫做
Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap
的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>
<h2 id="六内存模型stack">六、内存模型：Stack</h2>
<p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack
是由于函数运行而临时占用的内存区域。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png" /></p>
<p>请看下面的例子。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   int a = 2;</span><br><span class="line">   int b = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012211.png" /></p>
<p>如果函数内部调用了其他函数，会发生什么情况？</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   int a = 2;</span><br><span class="line">   int b = 3;</span><br><span class="line">   return add_a_and_b(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012212.png" /></p>
<p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack
叫做栈。生成新的帧，叫做"入栈"，英文是 push；栈的回收叫做"出栈"，英文是
pop。Stack
的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做"后进先出"的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个
Stack 就都释放了。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012213.jpg" /></p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012214.jpg" /></p>
<p>Stack
是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012215.png" /></p>
<h2 id="七cpu-指令">七、CPU 指令</h2>
<h3 id="一个实例">7.1 一个实例</h3>
<p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int add_a_and_b(int a, int b) &#123;</span><br><span class="line">   return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   return add_a_and_b(2, 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>gcc 将这个程序转成汇编语言。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ gcc -S example.c</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个
CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p>
<p><code>example.s</code>经过简化以后，大概是下面的样子。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">_add_a_and_b:</span><br><span class="line">   push   %ebx</span><br><span class="line">   mov    %eax, [%esp+8] </span><br><span class="line">   mov    %ebx, [%esp+12]</span><br><span class="line">   add    %eax, %ebx </span><br><span class="line">   pop    %ebx </span><br><span class="line">   ret  </span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">   push   3</span><br><span class="line">   push   2</span><br><span class="line">   call   _add_a_and_b </span><br><span class="line">   add    %esp, 8</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的
CPU 运行流程。</p>
<p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">push   %ebx</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这一行里面，<code>push</code>是 CPU
指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU
指令可以有零个到多个运算子。</p>
<p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p>
<h3 id="push-指令">7.2 push 指令</h3>
<p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack
上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP
寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP
寄存器所保存的地址。</p>
<p>然后，开始执行第一行代码。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">push   3</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>push</code>指令用于将运算子放入
Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>
<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出
ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP
寄存器。使用减法是因为 Stack
从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后，
3 就会写入这个地址开始的四个字节。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">push   2</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP
寄存器会再减去 4个字节（累计减去8）。</p>
<p><img
src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012216.png" /></p>
<h3 id="call-指令">7.3 call 指令</h3>
<p>第三行的<code>call</code>指令用来调用函数。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">call   _add_a_and_b</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p>
<p>下面就开始执行<code>_add_a_and_b</code>的代码。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">push   %ebx</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这一行表示将 EBX
寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p>
<p>这时，<code>push</code>指令会再将 ESP
寄存器里面的地址减去4个字节（累计减去12）。</p>
<h3 id="mov-指令">7.4 mov 指令</h3>
<p><code>mov</code>指令用于将一个值写入某个寄存器。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mov    %eax, [%esp+8] </span><br></pre></td></tr></table></figure>
</blockquote>
<p>这一行代码表示，先将 ESP
寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack
取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入
EAX 寄存器。</p>
<p>下一行代码也是干同样的事情。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mov    %ebx, [%esp+12] </span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack
取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p>
<h3 id="add-指令">7.5 add 指令</h3>
<p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">add    %eax, %ebx</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX
寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX
寄存器。</p>
<h3 id="pop-指令">7.6 pop 指令</h3>
<p><code>pop</code>指令用于取出 Stack
最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pop    %ebx</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX
寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX
寄存器用不到了）。</p>
<p>注意，<code>pop</code>指令还会将 ESP
寄存器里面的地址加4，即回收4个字节。</p>
<h3 id="ret-指令">7.7 ret 指令</h3>
<p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，该指令没有运算子。</p>
<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">add    %esp, 8 </span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP
寄存器。这是因为 ESP 寄存器的是 Stack
的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>
<h2 id="八参考链接">八、参考链接</h2>
<ul>
<li><a
href="http://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/">Introduction
to reverse engineering and Assembly</a>, by Youness Alaoui<br />
</li>
<li><a
href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86
Assembly Guide</a>, by University of Virginia Computer Science</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>写汇编代码时注意立即数后缀</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E5%86%99%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%97%B6%E6%B3%A8%E6%84%8F%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%90%8E%E7%BC%80/</url>
    <content><![CDATA[<p>debug和编译器对此的要求是不同的</p>
<p>我们在编写.asm文件时，不加H默认为10进制，加H表示为16进制，若像4c00不加H，编译时报错Non-digit
in
number，因为不加H默认为10进制，而10进制中是不允许出现字母的，也有些编译器要求以0x开头表示16进制</p>
<p>而debug中默认所有数字都是16进制。比如用A命令输入mov
ax,100a，不用加H，否则出错</p>
<p>在将.asm文件编译连接之后，使用debug对程序的执行进行跟踪时，会将源程序中的mov
ax, 10变为mov ax,000A</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>固态硬盘怎么被引导启动？</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E6%80%8E%E4%B9%88%E8%A2%AB%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>固态硬盘没有磁头磁盘，那BIOS怎么启动引导程序？</p>
<p>2023/8/16 22:29:30</p>
<p>你提到的是一个很好的问题。固态硬盘（SSD）和传统的机械硬盘（HDD）相比，确实没有物理磁头。然而，BIOS并不依赖于磁头来引导启动程序。</p>
<p>在 BIOS 引导过程中，它的主要任务是查找可引导设备上的引导记录（boot
record），这是一个特殊的扇区，包含了引导加载器（boot
loader）的代码。对于固态硬盘，BIOS会按照预先设定的启动顺序检查每个可引导设备，例如硬盘、光驱或USB设备。</p>
<p>当BIOS发现一个可引导设备时，它会读取设备的引导记录并将控制权交给引导加载器。引导加载器进而负责加载操作系统并启动计算机。</p>
<p>对于固态硬盘，BIOS和引导加载器的工作方式与传统硬盘是相同的，只是存储介质的物理结构不同。固态硬盘使用闪存芯片进行数据存储，而不是用磁道和磁头来读取数据。</p>
<p>因此，尽管固态硬盘没有磁头，但BIOS仍然可以通过读取固态硬盘上的引导记录来启动引导程序，从而启动操作系统。</p>
<p>2023/8/16 22:32:09</p>
<p>怎么样才算是一个可引导设备？它的定义是什么？</p>
<p>2023/8/16 22:32:44</p>
<p>一个可引导设备是满足以下条件的设备：</p>
<ol type="1">
<li><p>设备包含引导记录（boot
record）：可引导设备上的第一个扇区需要包含引导记录，它是引导加载器（boot
loader）的入口点。引导记录通常由引导加载器的代码和相关的引导参数组成。</p></li>
<li><p>引导记录的合法性：引导记录需要符合特定的格式和标准，以便被BIOS或UEFI识别。这些标准可能因不同的操作系统和引导加载器而异，例如MBR（Master
Boot Record）或GPT（GUID Partition Table）等。</p></li>
<li><p>设备在BIOS或UEFI的引导顺序中：可引导设备应该在计算机的BIOS或UEFI的引导设备列表中，并且设置为优先级高于其他设备，如硬盘、光驱或USB设备。</p></li>
<li><p>操作系统的安装：可引导设备必须安装了支持启动的操作系统。引导加载器负责加载操作系统的内核并启动系统。</p></li>
</ol>
<p>当满足以上条件时，设备被认为是一个可引导设备，可以由BIOS或UEFI通过读取引导记录来启动引导加载器。引导加载器进而加载操作系统并引导计算机启动。</p>
<p>需要注意的是，在传统的BIOS环境下，引导设备通常是指硬盘、光驱或USB设备等物理设备。而在新的UEFI环境下，UEFI固件更加灵活，可以直接从文件系统中的EFI启动程序（如EFI文件）引导操作系统，因此可引导设备的概念也略有不同。</p>
<p>2023/8/16 22:32:56</p>
<p>UEFI是新一代BIOS的替代吗？</p>
<p>2023/8/16 22:33:31</p>
<p>是的，UEFI（统一的扩展固件接口）被视为传统BIOS的替代技术，它是新一代的固件标准。UEFI的设计目标是取代传统BIOS，并提供更高级、更现代化的功能和特性。</p>
<p>与传统BIOS相比，UEFI具有以下几个主要优势：</p>
<ol type="1">
<li><p>引导方式：UEFI支持从文件系统直接引导操作系统，而不需要依赖于引导记录和分区表，这使得引导过程更加灵活和可靠。</p></li>
<li><p>容量限制：传统BIOS通常面临着引导磁盘容量的限制，例如2TB。而UEFI可以克服这些限制，支持更大容量的硬盘。</p></li>
<li><p>界面和图形能力：UEFI提供了更先进、更友好的图形界面，使用户能够轻松地进行配置和设置。</p></li>
<li><p>安全性：UEFI引入了安全启动（Secure
Boot）机制，通过验证引导加载器和操作系统的签名，防止恶意软件的植入和启动。</p></li>
<li><p>扩展性：UEFI提供了更强大的扩展性，允许厂商为其添加更多的功能和驱动程序。</p></li>
</ol>
<p>尽管UEFI已经成为较新计算机中的标准，但仍然存在一些老旧的计算机和设备仍在使用传统BIOS。然而，UEFI相较于传统BIOS具有更多的优势，被视为更先进的固件接口技术，并逐渐在计算机行业中得到广泛采用。</p>
<p>固态硬盘也有扇区的概念吗？</p>
<p>2023/8/16 22:39:46</p>
<p>是的，固态硬盘（SSD）在逻辑层面上仍然使用扇区的概念。扇区是存储数据的最小单位，也是文件系统和操作系统进行数据读写的基本单元。</p>
<p>然而，与传统机械硬盘（HDD）不同，固态硬盘在物理层面上并不是由旋转的可读写磁盘组成的。固态硬盘使用了非易失性闪存存储器作为存储介质，其中的数据是以电子状态的方式进行存储和访问的。</p>
<p>在固态硬盘中，扇区的概念被称为“逻辑块”（Logical
Block），每个逻辑块通常具有相同的大小，通常为512字节或4KB。逻辑块是固态硬盘进行数据读写操作的最小单位。</p>
<p>虽然固态硬盘没有磁盘旋转和寻道的概念，但为了与传统的存储系统和操作系统兼容，固态硬盘在逻辑层面上仍然将数据划分为逻辑块（扇区）。这样可以更好地实现数据的管理、读写和兼容性。</p>
<p>2023/8/16 22:43:44</p>
<p>如果一块硬盘上有多个系统，那引导记录都在第一个扇区吗？</p>
<p>2023/8/16 22:44:09</p>
<p>多个系统共存的情况下，每个系统的引导记录通常会单独存放在各自分区的引导扇区中，而不是全部都集中在硬盘的第一个扇区。</p>
<p>通常情况下，在分区表（如MBR或GPT）中会记录每个分区的起始位置和大小信息，并指定每个分区的文件系统类型。每个分区都有自己的引导扇区，其中包含了该分区的引导记录和相关的引导加载器。</p>
<p>当计算机启动时，BIOS或UEFI会读取分区表，并根据设定的引导顺序选择相应的分区进行引导。然后，引导加载器从所选分区的引导扇区中加载操作系统的内核并启动系统。</p>
<p>因此，每个系统的引导记录通常是分散存放在各自分区的引导扇区中，以便实现对多个系统的独立引导和管理。</p>
<p>2023/8/16 22:44:16</p>
<p>那么分区表在第一个扇区吗？</p>
<p>2023/8/16 22:44:46</p>
<p>是的，在传统的主引导记录（MBR）方案中，分区表位于硬盘的第一个扇区（扇区编号为0），也被称为MBR扇区或主引导扇区。这个扇区的大小通常为512字节。</p>
<p>MBR记录了硬盘的分区信息，包括分区的起始位置、大小、文件系统类型等。同时，MBR扇区还包含了引导代码（bootloader），这段代码负责加载操作系统的引导加载器（例如GRUB或NTLDR）。</p>
<p>在引导过程中，计算机的BIOS或UEFI会读取MBR扇区中的分区表，并根据分区表中设置的引导标志来确定要引导的分区。然后，引导加载器会从相应的分区的引导扇区中加载操作系统内核并启动系统。</p>
<p>需要注意的是，随着UEFI替代传统BIOS，新的分区方案GPT（GUID分区表）也逐渐取代了MBR。在GPT方案中，分区表存储在硬盘的较早扇区，通常是1号扇区（LBA
1），而不是硬盘的第一个扇区。这种变化是为了避免与保护MBR和分区表的主引导记录（MBR扇区）冲突。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串常量用单引号还是双引号？</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%94%A8%E5%8D%95%E5%BC%95%E5%8F%B7%E8%BF%98%E6%98%AF%E5%8F%8C%E5%BC%95%E5%8F%B7%EF%BC%9F/</url>
    <content><![CDATA[<p>[GPT4]<br />
In assembly language, whether to use single quotes (<code>'</code>) or
double quotes (<code>"</code>) often depends on the assembler you are
using. The conventions can vary.</p>
<ol type="1">
<li><p><strong>NASM (Netwide Assembler)</strong>:</p>
<ul>
<li>String literals are usually enclosed in double quotes
(<code>"</code>) but can also be enclosed in single quotes
(<code>'</code>).<br />
</li>
<li>For example, both <code>"Hello, World!"</code> and
<code>'Hello, World!'</code> are valid.<br />
</li>
</ul></li>
<li><p><strong>MASM (Microsoft Macro Assembler)</strong>:</p>
<ul>
<li>Double quotes (<code>"</code>) are commonly used for string
literals.<br />
</li>
</ul></li>
<li><p><strong>GAS (GNU Assembler)</strong>:</p>
<ul>
<li>Uses double quotes (<code>"</code>) for string literals.<br />
</li>
</ul></li>
<li><p><strong>FASM (Flat Assembler)</strong>:</p>
<ul>
<li>Accepts both single (<code>'</code>) and double quotes
(<code>"</code>).<br />
</li>
</ul></li>
<li><p><strong>TASM (Turbo Assembler)</strong>:</p>
<ul>
<li>Typically uses double quotes (<code>"</code>) for string
literals.<br />
</li>
</ul></li>
<li><p><strong>Others</strong>:</p>
<ul>
<li>There are many assemblers out there, and while the majority might
stick to one common convention (often double quotes), there are bound to
be exceptions or variations.</li>
</ul></li>
</ol>
<p><strong>Best Practice</strong>:</p>
<ul>
<li>Stick to the convention of the assembler you're using. Check its
documentation or sample codes.<br />
</li>
<li>Maintain consistency. Once you pick a style (either single or double
quotes) for a particular project or file, try to stick with it
throughout.</li>
</ul>
<p>It's also worth noting that sometimes, the choice between single and
double quotes might have functional implications, such as how escape
sequences are handled or how multi-character constants are interpreted.
Always refer to your assembler's documentation when in doubt.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>带冒号和不带冒号的标签</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E5%B8%A6%E5%86%92%E5%8F%B7%E5%92%8C%E4%B8%8D%E5%B8%A6%E5%86%92%E5%8F%B7%E7%9A%84%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>对于一些标签后不携带冒号的情况，比如磁盘的引导扇区中包含了FAT12文件系统的头部时：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BS_OEMNAME              DB &quot;MINEBOOT&quot;</span><br><span class="line">BPB_BYTESPERSEC DW 512</span><br><span class="line">BPB_SECPERCLUS  DB 1</span><br><span class="line">BPB_RSVDSECCNT  DW 1</span><br><span class="line">BPB_NUMFATS             DB 2</span><br><span class="line">BPB_ROOTENTCNT  DW 224</span><br><span class="line">BPB_TOTSEC16    DW 2880</span><br><span class="line">BPB_MEDIA               DB 0xF0</span><br><span class="line">BPB_FATSZ16             DW 9</span><br><span class="line">BPB_SECPERTRK   DW 18</span><br><span class="line">BPB_NUMHEADS    DW 2</span><br><span class="line">BPB_HIDDSEC             DW 2</span><br><span class="line">BPB_TOTSEC32    DD 0</span><br><span class="line">BS_DRVNUM               DB 0</span><br><span class="line">BS_RESERVED1    DB 0</span><br><span class="line">BS_BOOTSIG              DB 0x29</span><br><span class="line">BS_VOLID                DD 0</span><br><span class="line">BS_VOLLAB               DB &quot;boot loader&quot;</span><br><span class="line">BS_FILESYSTYPE  DB &quot;FAT12   &quot;</span><br></pre></td></tr></table></figure></p>
<p>通常情况下，这些标签可以通过 <code>[]</code>
操作符来解引用地址获得该地址上的数据，但是通常不会使用jmp指令跳转到这些地址，因为这些地址上存放了常量数据而并非二进制的机器指令，跳转到这里没有下一条指令可以执行，可能会造成无限死循环，或者单纯的不再执行。</p>
<p>对于一些带冒号的标签，通常是用于jmp指令跳转的，这些地址上存放着可以被识别的二进制机器指令，跳转到这里不会造成不再继续执行。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label_start:</span><br><span class="line">        MOV             ax,     cs ; copy the start address of the sector</span><br><span class="line">        MOV             ds,     ax</span><br><span class="line">        MOV             es,     ax</span><br><span class="line">        MOV             ss,     ax</span><br><span class="line">        MOV             sp,     stack_base ; set stack pointer to stack_base</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>常用寄存器 - 参考一</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%20-%20%E5%8F%82%E8%80%83%E4%B8%80/</url>
    <content><![CDATA[<h2 id="通用寄存器-general-register">通用寄存器 (general register)</h2>
<p>通用寄存器是平时运行程序会使用到的寄存器，也是最多接触的寄存器</p>
<table>
<thead>
<tr class="header">
<th>64-bit</th>
<th>32-bit</th>
<th>16-bit</th>
<th>8-bit (low)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RAX</td>
<td>EAX</td>
<td>AX</td>
<td>AL</td>
</tr>
<tr class="even">
<td>RBX</td>
<td>EBX</td>
<td>BX</td>
<td>BL</td>
</tr>
<tr class="odd">
<td>RCX</td>
<td>ECX</td>
<td>CX</td>
<td>CL</td>
</tr>
<tr class="even">
<td>RDX</td>
<td>EDX</td>
<td>DX</td>
<td>DL</td>
</tr>
<tr class="odd">
<td>RSI</td>
<td>ESI</td>
<td>SI</td>
<td>SIL</td>
</tr>
<tr class="even">
<td>RDI</td>
<td>EDI</td>
<td>DI</td>
<td>DIL</td>
</tr>
<tr class="odd">
<td>RBP</td>
<td>EBP</td>
<td>BP</td>
<td>BPL</td>
</tr>
<tr class="even">
<td>RSP</td>
<td>ESP</td>
<td>SP</td>
<td>SPL</td>
</tr>
<tr class="odd">
<td>R8</td>
<td>R8D</td>
<td>R8W</td>
<td>R8B</td>
</tr>
<tr class="even">
<td>R9</td>
<td>R9D</td>
<td>R9W</td>
<td>R9B</td>
</tr>
<tr class="odd">
<td>R10</td>
<td>R10D</td>
<td>R10W</td>
<td>R10B</td>
</tr>
<tr class="even">
<td>R11</td>
<td>R11D</td>
<td>R11W</td>
<td>R11B</td>
</tr>
<tr class="odd">
<td>R12</td>
<td>R12D</td>
<td>R12W</td>
<td>R12B</td>
</tr>
<tr class="even">
<td>R13</td>
<td>R13D</td>
<td>R13W</td>
<td>R13B</td>
</tr>
<tr class="odd">
<td>R14</td>
<td>R14D</td>
<td>R14W</td>
<td>R14B</td>
</tr>
<tr class="even">
<td>R15</td>
<td>R15D</td>
<td>R15W</td>
<td>R15B</td>
</tr>
</tbody>
</table>
<p>其中16位的寄存器中，可以访问其高8位的数据</p>
<table>
<thead>
<tr class="header">
<th>16-bit</th>
<th>8-bit (high)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AX</td>
<td>AH</td>
</tr>
<tr class="even">
<td>BX</td>
<td>BH</td>
</tr>
<tr class="odd">
<td>CX</td>
<td>CH</td>
</tr>
<tr class="even">
<td>DX</td>
<td>DH</td>
</tr>
</tbody>
</table>
<h3 id="位寄存器">32位寄存器</h3>
<ul>
<li>eax：通常用来执行加法，函数调用的返回值一般也放在这里面<br />
</li>
<li>ebx：数据存取<br />
</li>
<li>ecx：通常用作计数器，比如for循环<br />
</li>
<li>edx：暂不清楚<br />
</li>
<li>esp：栈顶指针，指向栈的顶部<br />
</li>
<li>ebp：栈底指针，指向栈的底部，通常用ebp+偏移量的形式来定位函数存放在栈中的局部变量<br />
</li>
<li>edi：字符串操作时，用于存放数据源的地址<br />
</li>
<li>esi：字符串操作时，用于存放目的地址的，和edi两个经常搭配一起使用，执行字符串的复制等操作</li>
</ul>
<h3 id="位的寄存器">64位的寄存器</h3>
<ul>
<li>rax：通常用于存储函数调用返回值<br />
</li>
<li>rsp：栈顶指针，指向栈的顶部<br />
</li>
<li>rdi：第一个入参<br />
</li>
<li>rsi：第二个入参<br />
</li>
<li>rdx：第三个入参<br />
</li>
<li>rcx：第四个入参<br />
</li>
<li>r8：第五个入参<br />
</li>
<li>r9：第六个入参<br />
</li>
<li>rbx：数据存储，遵循Callee Save原则<br />
</li>
<li>rbp：数据存储，遵循Callee Save原则<br />
</li>
<li>r12~r15：数据存储，遵循Callee Save原则<br />
</li>
<li>r10~r11：数据存储，遵循Caller Save原则</li>
</ul>
<h2 id="特殊寄存器-special-registers">特殊寄存器 (Special
registers)</h2>
<ul>
<li>指针寄存器(instruction pointer, RIP.)<br />
X86-64的RIP可以切分成32位的EIP 和
16位IP，CPU是几位模式下就只能使用对应的指针寄存器。<br />
</li>
<li>状态寄存器(status register, RFLAGS)</li>
</ul>
<p>RFLAGS也有32位和16位版本，分别是EFLAGS 和 FLAGS。但是EFLAGS 和
FLAGS可以同时使用。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-fcc30c2e490560fae0b761a5d5546e7a_720w.webp" /></p>
<p>32位的状态寄存器</p>
<ul>
<li>CF： 进位标志<br />
</li>
<li>PF ： 奇偶标志<br />
</li>
<li>ZF ： 零标志<br />
</li>
<li>SF ： 符号标志<br />
</li>
<li>OF ： 补码溢出标志<br />
</li>
<li>TF： 跟踪标志<br />
</li>
<li>IF ： 中断标志</li>
</ul>
<h2 id="段寄存器-segment-registers">段寄存器 (Segment registers)</h2>
<p>X86-64一共有6个段寄存器: CS, SS, DS, ES, FS, and GS。</p>
<ul>
<li>除了长模式以外的所有CPU运行模式里，都有一个段选择器 selector,
表示当前使用GDT 还是 LDT。 同时，还需要一个段描述符descriptor,
提供了段的基址和范围。（Linux中基本不使用分段）<br />
</li>
<li>长模式中，除了 FS 和 GS
之外的所有内容都被视为在一个具有零基地址和64位范围的平面地址空间中。 FS
和 GS 作为特殊情况保留，但不再使用段描述符表，取而代之的是，访问保存在
FSBASE 和 GSBASE 中的MSR寄存器中的基地址。</li>
</ul>
<p><img
src="https://pic2.zhimg.com/80/v2-226ccb6abac9ef805dc9b0644c989415_720w.webp" /></p>
<p>段寄存器（16位）</p>
<h2 id="调试寄存器debug-registers">调试寄存器(Debug registers)</h2>
<p>帮助和加速软件调试器的寄存器，如GDB。</p>
<ul>
<li>有6个调试寄存器，分为两种类型：DR0到DR3包含线性地址，每个地址都与一个断点条件相关。<br />
</li>
<li>DR6和DR7是调试状态和控制寄存器。DR6的低位表示遇到了哪些调试条件（在进入调试异常处理程序时），而DR7控制哪些断点地址被启用以及它们的断点条件（例如，当某一地址被写入时）。<br />
</li>
<li>DR4heDR5不清楚具体使用。但它们确实被使用于编码，但分别被当做DR6和DR7，或者在<a
href="https://link.zhihu.com/?target=http%3A//CR4.DE">http://CR4.DE</a>[位3]=1时产生#UD异常。</li>
</ul>
<h2 id="控制寄存器-control-registers">控制寄存器 (Control
registers)</h2>
<p>x86-64 定义了一组控制寄存器，可用于管理和检查 CPU 的状态。有 16
个“主”控制寄存器，所有这些都可以通过<a
href="https://link.zhihu.com/?target=https%3A//www.felixcloutier.com/x86/mov-1">MOV
variant</a>变体访问:</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CR0</td>
<td>Basic CPU operation flags</td>
</tr>
<tr class="even">
<td>CR1</td>
<td>Reserved</td>
</tr>
<tr class="odd">
<td>CR2</td>
<td>Page-fault linear address</td>
</tr>
<tr class="even">
<td>CR3</td>
<td>Virtual addressing state</td>
</tr>
<tr class="odd">
<td>CR4</td>
<td>Protected mode operation flags</td>
</tr>
<tr class="even">
<td>CR5</td>
<td>Reserved</td>
</tr>
<tr class="odd">
<td>CR6</td>
<td>Reserved</td>
</tr>
<tr class="even">
<td>CR7</td>
<td>Reserved</td>
</tr>
<tr class="odd">
<td>CR8</td>
<td>Task priority register (TPR)</td>
</tr>
<tr class="even">
<td>CR9</td>
<td>Reserved</td>
</tr>
<tr class="odd">
<td>CR10</td>
<td>Reserved</td>
</tr>
<tr class="even">
<td>CR11</td>
<td>Reserved</td>
</tr>
<tr class="odd">
<td>CR12</td>
<td>Reserved</td>
</tr>
<tr class="even">
<td>CR13</td>
<td>Reserved</td>
</tr>
<tr class="odd">
<td>CR14</td>
<td>Reserved</td>
</tr>
<tr class="even">
<td>CR15</td>
<td>Reserved</td>
</tr>
</tbody>
</table>
<p>所有reserved的控制寄存器在访问时都会产生保护模式异常，不把它们算在本文里。</p>
<p>除了 “主”CRn控制寄存器之外，还有
“扩展”控制寄存器，由XSAVE功能集引入。截至目前，XCR0是唯一指定的扩展控制寄存器。</p>
<p>扩展控制寄存器使用<a
href="https://link.zhihu.com/?target=https%3A//www.felixcloutier.com/x86/xgetbv">XGETBV</a> 和 <a
href="https://link.zhihu.com/?target=https%3A//www.felixcloutier.com/x86/xsetbv">XSETBV</a>而不是MOV的变种。</p>
<h3 id="cr0">CR0</h3>
<ul>
<li>PG：开启分页模式<br />
</li>
<li>CD：控制Cache高速缓存功能，CD=1关闭该功能<br />
</li>
<li>NW：控制使用通写还是回写，用于维护内存数据一致性，NW=1关闭该功能，数据一致性即通过MESI协议<br />
</li>
<li>AM：控制启用内存对齐自动检查<br />
</li>
<li>WP：控制开启内存写保护，WP=0开启写保护，对只读页面尝试写入将触发异常，这一机制常常被用来实现写时复制功能<br />
</li>
<li>PE：如果PE=1，则保护模式启动，如果PE=0，则在实模式下运行</li>
</ul>
<p><img
src="https://pic4.zhimg.com/80/v2-3c15147ea855ff1cbf719fff8ec9e16f_720w.webp" /></p>
<p>CR0寄存器</p>
<h3 id="cr1">CR1</h3>
<p>保留</p>
<p><img
src="https://pic3.zhimg.com/80/v2-b0c11341c00fcdd9f4b5fe11c7985f7a_720w.webp" /></p>
<h3 id="cr2">CR2</h3>
<p><img
src="https://pic4.zhimg.com/80/v2-63417d23faf777d9b7b769887ba47b63_720w.webp" /></p>
<p>x86架构中的CR2寄存器是页故障线性地址寄存器，也称为页故障地址寄存器（Page
Fault Linear Address Register）。当CPU检测到一个页故障（Page
Fault）时，它会将故障发生时的线性地址存储在CR2寄存器中，这个地址指向导致页故障的页面。</p>
<p>内核可以通过读取CR2寄存器来获取引起页故障的地址，然后对该地址所在的页面进行处理，比如进行页面的分配或者进行页面的交换。CR2寄存器的值可以在中断或异常处理例程中读取。</p>
<p>在保护模式下，访问CR2寄存器需要使用特殊的指令，比如MOV CR2,
EAX将EAX寄存器的值写入CR2寄存器，或MOV EAX,
CR2将CR2寄存器的值读取到EAX寄存器中。在x86_64架构下，CR2寄存器的大小为64位。</p>
<h3 id="cr3">CR3</h3>
<p><img
src="https://pic2.zhimg.com/80/v2-91a4db9747f7ebee754f0e00b3392c65_720w.webp" /></p>
<p>cr3寄存器和MMU密切相关，保存了当前进程所使用的虚拟地址空间的页目录地址，可以说是整个虚拟地址翻译中的顶级指挥棒，在进程空间切换的时候，CR3也将同步切换。</p>
<p>cr3寄存器的高20位用于保存页目录地址，0-11位记录标记位，所以页目录地址必须是4KB的整数倍。</p>
<h3 id="cr4">CR4</h3>
<p><img
src="https://pic2.zhimg.com/80/v2-0dbb34c8df6baf127c634953c0a7c341_720w.webp" /></p>
<p>用于控制CPU的特性和操作系统的行为。它的作用如下：</p>
<ol type="1">
<li>控制分页机制：x86CR4寄存器的最重要作用是控制分页机制。在64位x86处理器中，x86CR4寄存器的第5位（PAE）控制是否启用物理地址扩展（Physical
Address Extension，PAE）模式，第7位（PSE）控制是否启用页大小扩展（Page
Size Extension，PSE）模式，第12位（PCIDE）控制是否启用页表缓存（Page
Directory Cache，PDC）。<br />
</li>
<li>启用SMEP和SMAP保护机制：x86CR4寄存器的第20和第21位控制启用Supervisor
Mode Execution Protection（SMEP）和Supervisor Mode Access
Prevention（SMAP）保护机制。<br />
</li>
<li>启用虚拟化扩展：x86CR4寄存器的第13位控制是否启用虚拟化扩展（Virtualization
Extension，VME）。<br />
</li>
<li>其他：x86CR4寄存器还控制着其他一些特性，如Debugging
Extensions（DE）、Machine Check Exception（MCE）和Page Attribute
Table（PAT）等。</li>
</ol>
<p>在Linux内核中，x86CR4寄存器的主要作用是控制分页机制和启用SMEP和SMAP保护机制。</p>
<h2 id="system-table-pointer-registers">System table pointer
registers</h2>
<p>这就是英特尔SDM对这些寄存器的称呼。这些寄存器保存着各种保护模式表的大小和指针。</p>
<ul>
<li>据我所知，它们有四个：GDTR：存放GDT的大小和基址。<br />
</li>
<li>LDTR：保存LDT的大小和基址。<br />
</li>
<li>IDTR：保存IDT的大小和基址。<br />
</li>
<li>TR：保存TSS的选择器和TSS的基址。</li>
</ul>
<p>GDTR、LDTR和IDTR在64位模式下都是80位：16个低位是寄存器的表的大小，高64位是表的其实地址。</p>
<p>TR同样也是80位。16位用于选择器（其行为与段选择器相同），然后另外64位用于TSS的基本地址。</p>
<h3 id="gdtr48bit">GDTR(48bit)</h3>
<p>全局描述符表寄存器，CPU现在使用的是分页的内存管理方式，分段的信息存储在GDTR上。在64位的长模式中CS、DS的偏移为0，边界为0xffff。长度这就存储在一个叫全局描述符表（GDT）的表格中，并用gdtr寄存器指向这个表。这个表中的每一项都描述了一个内存段的信息。</p>
<p><img
src="https://pic4.zhimg.com/80/v2-742429507d1a575cdceb8ea5831790df_720w.webp" /></p>
<h3 id="ldtr16bit">LDTR(16bit)</h3>
<p>局部描述符表寄存器，这个寄存器和上面的gdtr一样，同样指向的是一个段描述符表（LDT）。不同的是，GDT是全局唯一，LDT是局部使用的，可以创建多个，随着任务段切换而切换（下文介绍任务寄存器会提到）。</p>
<h3 id="idtr48bit">IDTR(48bit)</h3>
<p>中断描述符表寄存器，指向了中断描述符表IDT，这个表的每一项都是一个中断处理描述符，当CPU执行过程中发生了硬中断、异常、软中断时，将自动从这个表中定位对应的表项，里面记录了发生中断、异常时该去哪里执行处理函数。</p>
<p><img
src="https://pic4.zhimg.com/80/v2-742429507d1a575cdceb8ea5831790df_720w.webp" /></p>
<h2 id="msrmodel-specific-register">MSR（Model Specific Register）</h2>
<p>MSR（Model Specific
Register）是x86架构中的概念，指的是在x86架构处理器中，一系列用于控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能等方面的寄存器。</p>
<p>到Intel
Pentium处理器的时候，Intel正式引入RDMSR和WRMSR两个指令用于读和写MSR寄存器，这个时候MSR就算被正式引入。在引入RDMSR和WRMSR指令的同时，也引入了CPUID指令，该指令用于指明具体的CPU芯片中，哪些功能是可用的，或者这些功能对应的MSR寄存器是否存在，软件可以通过CPUID指令查询某些功能是否在当前CPU上是否支持。</p>
<p>每个MSR寄存器都会有一个相应的ID，即MSR
Index，或者也叫作MSR寄存器地址，当执行RDMSR或者WRMSR指令的时候，只要提供MSR
Index就能让CPU知道目标MSR寄存器。这些MSR寄存器的编号（MSR
Index）、名字及其各个数据区域的定义可以在Intel x86架构手册”Intel 64 and
IA-32 Architectures Software Developer’s Manual”的<a
href="https://link.zhihu.com/?target=https%3A//software.intel.com/sites/default/files/managed/22/0d/335592-sdm-vol-4.pdf">Volume
4</a>中找到。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>常用寄存器 - 参考二</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%20-%20%E5%8F%82%E8%80%83%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="架构16bit">8086架构(16bit)</h2>
<p>以下寄存器都是16bit位宽</p>
<p><img
src="https://pic4.zhimg.com/80/v2-c70bc72bb0f7474457643413a5f7996b_720w.webp" /></p>
<h2 id="x86架构">x86架构</h2>
<h3 id="通用寄存器32bit">通用寄存器(32bit)</h3>
<p>通用寄存器是程序执行代码最最常用，也最最基础的寄存器，程序执行过程中，绝大部分时间都是在操作这些寄存器来实现指令功能。</p>
<ul>
<li><strong><em>eax：</em></strong>通常用来执行加法，函数调用的返回值一般也放在这里面<br />
</li>
<li><strong><em>ebx：</em></strong>数据存取<br />
</li>
<li><strong><em>ecx：</em></strong>通常用作计数器，比如for循环<br />
</li>
<li><strong><em>edx：</em></strong>暂不清楚<br />
</li>
<li>**_esp：_栈顶指针，指向栈的顶部**<br />
</li>
<li>**_ebp：_栈底指针，指向栈的底部，通常用<code>ebp+偏移量</code>的形式来定位函数存放在栈中的局部变量**<br />
</li>
<li><strong><em>edi：</em></strong>字符串操作时，用于存放数据源的地址<br />
</li>
<li><strong><em>esi：</em></strong>字符串操作时，用于存放目的地址的，和_edi_两个经常搭配一起使用，执行字符串的复制等操作</li>
</ul>
<h3 id="标志寄存器32bit">标志寄存器(32bit)</h3>
<p>标志寄存器<strong><em>eflags</em></strong>，记录了CPU执行指令过程中的一系列状态，这些标志大都由CPU自动设置和修改。</p>
<p><img
src="https://pic4.zhimg.com/80/v2-90c2e7f9796673ea63b1250ac3aa743f_720w.webp" /></p>
<ul>
<li><strong><em>CF：</em></strong> 进位标志<br />
</li>
<li><strong><em>PF ：</em></strong> 奇偶标志<br />
</li>
<li><strong><em>ZF ：</em></strong> 零标志<br />
</li>
<li><strong><em>SF ：</em></strong> 符号标志<br />
</li>
<li><strong><em>OF ：</em></strong> 补码溢出标志<br />
</li>
<li><strong><em>TF：</em></strong> 跟踪标志<br />
</li>
<li><strong><em>IF ：</em></strong> 中断标志</li>
</ul>
<h3 id="指令寄存器32bit">指令寄存器(32bit)</h3>
<p><strong><em>eip</em></strong>寄存器是CPU中最最重要的寄存器了，它指向了下一条要执行的指令所存放的地址，CPU的工作其实就是不断取出它指向的指令，然后执行这条指令，同时指令寄存器继续指向下面一条指令，如此不断重复，这就是CPU工作的基本日常。</p>
<h3 id="段寄存器16bit">段寄存器(16bit)</h3>
<ul>
<li><strong><em>cs：</em></strong>代码段<br />
</li>
<li><strong><em>ds：</em></strong> 数据段<br />
</li>
<li><strong><em>ss</em><em>：</em></strong>栈段<br />
</li>
<li><strong><em>es：</em></strong> 扩展段<br />
</li>
<li><strong><em>fs</em></strong>:<strong><em>：</em></strong>数据段<br />
</li>
<li><strong><em>gs：</em></strong> 数据段</li>
</ul>
<p>段寄存器里面存储的内容与CPU当前工作的内存寻址模式紧密相关，详细可查阅：</p>
<p><a
href="https://zhuanlan.zhihu.com/p/502776497">CPU工作模式：执行程序的三种模式8
赞同 · 0 评论文章<img
src="https://pic1.zhimg.com/v2-f621f848f82047494635b32ec2c1eb2b_r.jpg?source=172ae18b" /></a></p>
<p>段寄存器通过<strong><em>Index</em></strong>查找<strong><em>GDT表</em></strong>找到段所在的线性地址，进而开展后续工作。</p>
<p><img
src="https://pic1.zhimg.com/80/v2-3a97741c711b66ca18ecfae2f9810840_720w.webp" /></p>
<p>段寄存器结构</p>
<h3 id="控制寄存器32bit">控制寄存器(32bit)</h3>
<p>控制寄存器记录cpu运行过程中自身的一些关键信息，包括cr0~cr4寄存器。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-97470bf59fc9f15a3bb0c4926bca060a_720w.webp" /></p>
<p>cr0寄存器</p>
<ul>
<li><strong><em>PG：</em></strong>开启分页模式<br />
</li>
<li><strong><em>CD：</em></strong>控制<strong>Cache</strong>高速缓存功能，CD=1关闭该功能<br />
</li>
<li><strong><em>NW：</em></strong>控制使用通写还是回写，用于维护内存数据一致性，NW=1关闭该功能，数据一致性即通过<strong>MESI协议</strong><br />
</li>
<li><strong><em>AM：</em></strong>控制启用内存对齐自动检查<br />
</li>
<li><strong><em>WP：</em></strong>控制开启内存写保护，WP=0开启写保护，对只读页面尝试写入将触发异常，这一机制常常被用来实现<strong>写时复制</strong>功能<br />
</li>
<li><strong><em>PE：</em></strong>如果PE=1，则保护模式启动，如果PE=0，则在实模式下运行</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mov eax, cr0</span><br><span class="line">;开启 保护模式和分页模式</span><br><span class="line">bts eax, 0    ;CR0.PE =1</span><br><span class="line">bts eax, 31   ;CR0.PG = 1</span><br><span class="line">;开启 CACHE </span><br><span class="line">btr eax, 29   ;CR0.NW=0</span><br><span class="line">btr eax, 30   ;CR0.CD=0</span><br><span class="line">mov cr0, eax </span><br></pre></td></tr></table></figure>
<hr />
<p><img
src="https://pic3.zhimg.com/80/v2-42dfe95feced0146ca2d7145c27c99f2_720w.webp" /></p>
<p>cr1寄存器</p>
<p><strong><em>cr1</em></strong>寄存器暂且保留未使用</p>
<hr />
<p><img
src="https://pic2.zhimg.com/80/v2-46c5f9fc643e0fa43a9d6f7c96708485_720w.webp" /></p>
<p>cr2寄存器</p>
<p><strong><em>cr2</em></strong>寄存器页错误出现时保存导致出错的地址，比如缺页异常。</p>
<hr />
<p><img
src="https://pic2.zhimg.com/80/v2-50e6c56a13697742651ca65af51b503d_720w.webp" /></p>
<p>cr3寄存器</p>
<p><strong><em>cr3</em></strong>寄存器和<strong>MMU</strong>密切相关，保存了当前进程所使用的虚拟地址空间的<strong>页目录地址</strong>，可以说是整个虚拟地址翻译中的顶级指挥棒，<strong>在进程空间切换的时候，CR3也将同步切换</strong>。</p>
<p><strong><em>cr3</em></strong>寄存器的高20位用于保存<strong>页目录地址</strong>，0-11位记录标记位，所以<strong>页目录地址</strong>必须是4KB的整数倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, PAGE_TLB_BADR;页表物理地址</span><br><span class="line">mov cr3, eax</span><br></pre></td></tr></table></figure>
<hr />
<p><img
src="https://pic4.zhimg.com/80/v2-34cad0c93a9debdc7109d695dc9399d3_720w.webp" /></p>
<p>cr4寄存器</p>
<ul>
<li><strong><em>PAE：</em></strong>PAE =
1，使分页产生超过32位的物理地址，当清除时，限制物理地址为32位。<strong>在进入IA-32e模式（长模式）之前必须设置PAE.</strong></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">;长模式下，开始分页保护</span><br><span class="line">mov eax, cr4</span><br><span class="line">bts eax, 5   ;CR4.PAE = 1</span><br><span class="line">mov cr4, eax ;开启 PAE</span><br><span class="line">mov eax, PAGE_TLB_BADR ;物理页地址</span><br><span class="line">mov cr3, eax</span><br></pre></td></tr></table></figure>
<h3 id="描述符寄存器">描述符寄存器</h3>
<ul>
<li><strong><em>GDTR(48bit)</em></strong></li>
</ul>
<p>全局描述符表寄存器，CPU现在使用的是段+分页结合的内存管理方式，那系统总共有那些分段呢？这就存储在一个叫全局描述符表（<strong>GDT</strong>）的表格中，并用<strong><em>gdtr</em></strong>寄存器指向这个表。这个表中的每一项都描述了一个内存段的信息。</p>
<ul>
<li><strong><em>LDTR(16bit)</em></strong></li>
</ul>
<p>局部描述符表寄存器，这个寄存器和上面的<strong><em>gdtr</em></strong>一样，同样指向的是一个段描述符表（<strong>LDT</strong>）。不同的是，<strong>GDT</strong>是全局唯一，<strong>LDT</strong>是局部使用的，可以创建多个，随着任务段切换而切换（下文介绍任务寄存器会提到）。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-66df2ffcd904087e7e87b6ffe02c8372_720w.webp" /></p>
<p>gdtr、ldtr与gdt、ldt关系</p>
<p><strong>GDT</strong>和<strong>LDT</strong>中的表项，就是段描述符，一个表项占据8个字节，里面存储了一个内存分段的诸多信息：基地址、大小、权限、类型等信息。其结构如下：</p>
<p>① 32位段基址</p>
<p>② 20位段界限，即段长，粒度由G位控制</p>
<p>③ 粒度位G位：</p>
<p>当G = 0时，段长以字节为单位，则最大段长为2^20B = 1MB</p>
<p>当G = 1时，段长以页（4KB）为单位，则最大段长为2^20 * 4KB = 4GB</p>
<p><img
src="https://pic1.zhimg.com/80/v2-fea89f4707016cb82e059564cb308c84_720w.webp" /></p>
<p>段描述符结构</p>
<p><strong>IDT</strong>中的表项称为<strong>Gate</strong>，中文意思为<strong>门</strong>，因为这是应用程序进入内核的主要入口，表中存储的不全是中断描述符，<strong>IDT</strong>中的表项存在三种类型，存储了处理这个中断/异常/任务时该去哪里处理的地址，对应三种类型的门：</p>
<ul>
<li><strong>任务门</strong><br />
</li>
<li><strong>陷阱门</strong><br />
</li>
<li><strong>中断门</strong></li>
</ul>
<p><img
src="https://pic1.zhimg.com/80/v2-8d36cace8299d4f8499eb6af2ba54f1c_720w.webp" /></p>
<p>idt表项结构</p>
<ul>
<li><strong><em>IDTR(48bit)</em></strong></li>
</ul>
<p>中断描述符表寄存器，指向了<strong>中断描述符表IDT</strong>，这个表的每一项都是一个中断处理描述符，当CPU执行过程中发生了硬中断、异常、软中断时，将自动从这个表中定位对应的表项，里面记录了发生中断、异常时该去哪里执行处理函数。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-9c032dd138a561f145a173bb68d888c2_720w.webp" /></p>
<p>idtr寄存器与idt关系</p>
<h3 id="任务寄存器16bit">任务寄存器(16bit)</h3>
<ul>
<li><strong><em>TR：</em></strong>指向当前运行的任务</li>
</ul>
<p><img
src="https://pic2.zhimg.com/80/v2-26ee4b7be502638dd3b890a9499a916d_720w.webp" /></p>
<p>tr寄存器同tss关系</p>
<ul>
<li>定义了描述任务的数据结构<strong>TSS（任务状态段）</strong>，里面存储了一个任务的上下文（一系列寄存器的值），下图是一个32位CPU的TSS结构图：</li>
</ul>
<p><img
src="https://pic2.zhimg.com/80/v2-3f1221e3278a9c61bb39a27de5315461_720w.webp" /></p>
<p>TSS段结构</p>
<blockquote>
<p>x86CPU的构想是每一个任务对应一个TSS，然后由TR寄存器指向当前的任务，执行任务切换时，修改TR寄存器的指向即可，这是硬件层面的多任务切换机制。<br />
这个构想其实还是很不错的，然而现实却打了脸，包括Linux和Windows在内的主流操作系统都没有使用这个机制来进行线程切换，而是自己使用软件来实现多线程切换。<br />
所以，绝大多数情况下，TR寄存器都是指向固定的，即便线程切换了，TR寄存器仍然不会变化。<br />
注意，我这里说的的是绝大多数情况，而没有说死。虽然操作系统不依靠TSS来实现多任务切换，但这并不意味着CPU提供的TSS操作系统一点也没有使用。还是存在一些特殊情况，如一些异常处理会使用到TSS来执行处理。</p>
</blockquote>
<p><img
src="https://pic4.zhimg.com/80/v2-a60996d09b143034425959ce34ae29db_720w.webp" /></p>
<p>控制寄存器、描述符寄存器、任务寄存器关系</p>
<h3 id="模型特定寄存器">模型特定寄存器</h3>
<ul>
<li><strong><em>IA32_SYSENTER_CS</em></strong><br />
</li>
<li><strong><em>IA32_SYSENTER_ESP</em></strong><br />
</li>
<li><strong><em>IA32_SYSENTER_EIP</em></strong></li>
</ul>
<p>这三个<strong>MSR</strong>寄存器是用来实现<strong>快速系统调用</strong>。</p>
<p>在早期的x86架构CPU上，系统调用依赖于软中断实现，类似于前面调试用到的int
3指令，在Windows上，系统调用用到的是<strong>int
2e</strong>，在Linux上，用的是<strong>int 80</strong>。</p>
<p>软中断毕竟还是比较慢的，因为执行软中断就需要内存查表，通过IDTR定位到IDT，再取出函数进行执行。</p>
<p>系统调用是一个频繁触发的动作，如此这般势必对性能有所影响。在进入奔腾时代后，就加上了上面的三个MSR寄存器，<strong>分别存储了执行系统调用后，内核系统调用入口函数所需要的段寄存器、堆栈栈顶、函数地址，不再需要内存查表</strong>。快速系统调用还提供了专门的CPU指令<strong>sysenter/sysexit</strong>用来发起系统调用和退出系统调用。</p>
<p>在64位上，这一对指令升级为<strong>syscall/sysret</strong>。</p>
<h2 id="x86_64架构64bit">x86_64架构(64bit)</h2>
<h3 id="通用寄存器">通用寄存器</h3>
<ul>
<li><strong><em>rax：通常用于存储函数调用返回值</em></strong><br />
</li>
<li>**_rsp：_栈顶指针，指向栈的顶部**<br />
</li>
<li><strong><em>rdi：第一个入参</em></strong><br />
</li>
<li><strong><em>rsi：第二个入参</em></strong><br />
</li>
<li><strong><em>rdx：第三个入参</em></strong><br />
</li>
<li><strong><em>rcx：第四个入参</em></strong><br />
</li>
<li><strong><em>r8：第五个入参</em></strong><br />
</li>
<li><strong><em>r9：第六个入参</em></strong><br />
</li>
<li><strong><em>rbx：</em></strong>数据存储，遵循<strong><em>Callee
Save</em></strong>原则<br />
</li>
<li><strong><em>rbp：</em></strong>数据存储，遵循<strong><em>Callee
Save</em></strong>原则<br />
</li>
<li><strong><em>r12~r15：</em></strong>数据存储，遵循<strong><em>Callee
Save</em></strong>原则<br />
</li>
<li><strong><em>r10~r11：</em></strong>数据存储，遵循<strong><em>Caller
Save</em></strong>原则</li>
</ul>
<blockquote>
<p>_Callee
Save：函数调用时，父函数无需保存这些寄存器值，可以直接调用子函数，子函数使用这些寄存器之前，需要保存这些寄存器值，_即这些寄存器的值是由被调用者来保存和恢复。<br />
<em>Caller
Save：函数调用时，父函数需要压栈保存这些寄存器值，I子函数可随意使用这些寄存器。</em></p>
</blockquote>
<h3 id="标志寄存器">标志寄存器</h3>
<p><strong><em>eflags</em></strong>寄存器升级为64bit的<strong><em>rflags</em></strong>，不过其高32位并没有新增什么功能，保留为将来使用。</p>
<h3 id="指令寄存器">指令寄存器</h3>
<p><strong><em>eip</em></strong>寄存器升级为64位的<strong><em>rip</em></strong>寄存器。</p>
<h3 id="控制寄存器">控制寄存器</h3>
<p>除了将<strong><em>cr0~cr4</em></strong>寄存器位宽增加为64bit外，还增加了64bit位宽的<strong><em>cr8</em></strong>寄存器，用于获取当前IRQL权限等级</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>引用地址的前缀解释</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E5%BC%95%E7%94%A8%E5%9C%B0%E5%9D%80%E7%9A%84%E5%89%8D%E7%BC%80%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>The instruction <code>mov byte[bp - 2], cl</code> is an x86 assembly
instruction that can be broken down as follows:</p>
<ol type="1">
<li><p><strong><code>mov</code></strong>: This is the move instruction.
It copies the value from the source operand to the destination operand
without altering the source value.</p></li>
<li><p><strong><code>byte[bp - 2]</code></strong>:</p>
<ul>
<li><code>byte</code>: This specifies the size of the data being
accessed. In this case, it's a byte.<br />
</li>
<li><code>bp</code>: This is the base pointer register, which typically
points to the base of the current stack frame in many calling
conventions. The base pointer is used as a frame of reference to access
local variables and function parameters on the stack.<br />
</li>
<li><code>bp - 2</code>: This means we're referencing the memory address
that is 2 bytes before (or "below" in typical stack growth direction)
where the <code>bp</code> currently points.<br />
</li>
</ul></li>
<li><p><strong><code>cl</code></strong>: This is the low byte of the
<code>cx</code> register.</p></li>
</ol>
<p>So, the instruction <code>mov byte[bp - 2], cl</code> takes the value
in the <code>cl</code> register and stores it into the memory location
that is 2 bytes before the memory address currently held in the
<code>bp</code> register.</p>
<p>A common scenario where you might see this is when working with local
variables in a function. The <code>bp</code> register (when used as a
base pointer in a function) points to the base of the current stack
frame. The instruction might be storing a value into a local variable
that has been allocated on the stack.</p>
<p>except for <code>byte[]</code> prefix to specify data length being
accessed, is there any other prefix</p>
<p>ChatGPT</p>
<p>Yes, in x86 assembly, there are several size specifiers (or prefixes)
you can use to indicate the size of the data being accessed. These
are:</p>
<ol type="1">
<li><p><strong><code>byte</code></strong>: Represents 8 bits or 1 byte
of data.</p>
<ul>
<li>Example: <code>mov byte[si], al</code><br />
</li>
</ul></li>
<li><p><strong><code>word</code></strong>: Represents 16 bits or 2 bytes
of data.</p>
<ul>
<li>Example: <code>mov word[si], ax</code><br />
</li>
</ul></li>
<li><p><strong><code>dword</code></strong> (double word): Represents 32
bits or 4 bytes of data. It's often used in 32-bit x86 assembly.</p>
<ul>
<li>Example: <code>mov dword[esi], eax</code><br />
</li>
</ul></li>
<li><p><strong><code>qword</code></strong> (quad word): Represents 64
bits or 8 bytes of data. It's often used in 64-bit x86 assembly (x86_64
or AMD64).</p>
<ul>
<li>Example: <code>mov qword[rsi], rax</code><br />
</li>
</ul></li>
<li><p><strong><code>tbyte</code></strong> (ten bytes): Represents 80
bits or 10 bytes of data. This is less common and is typically used for
extended precision floating-point values in the x87 floating-point
unit.</p>
<ul>
<li>Example: <code>fstp tbyte[rbp-10]</code></li>
</ul></li>
</ol>
<p>The exact specifiers available and their semantics might vary
slightly based on the specific assembler you're using. Always consult
the documentation for your assembler to get the precise details.</p>
<p>These size specifiers are important because x86 processors support
multiple data sizes, and the same memory operation could be interpreted
in different ways depending on the intended size. For instance, a
<code>mov</code> operation without a size specifier might be ambiguous,
as the assembler wouldn't know how many bytes to move.</p>
<p>can I use the upper case version? <code>BYTE[]</code>？</p>
<p>ChatGPT</p>
<p>Yes, in most x86 assemblers, including NASM (Netwide Assembler) and
MASM (Microsoft Macro Assembler), the size specifiers like
<code>byte</code>, <code>word</code>, <code>dword</code>, etc., are not
case-sensitive. This means you can use them in uppercase, lowercase, or
even mixed case.</p>
<p>So, both <code>byte[address]</code> and <code>BYTE[address]</code>
are equivalent.</p>
<p>However, while the assembler itself might not be case-sensitive for
these directives, it's a good practice to maintain consistent casing
throughout your code for readability and maintainability. Typically,
assembly code examples and tutorials use lowercase for these specifiers,
but the choice is ultimately up to the programmer or the coding
standards they're following.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么知道寄存器是几位大小的？</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%AF%E5%87%A0%E4%BD%8D%E5%A4%A7%E5%B0%8F%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<p>mov ax, 0600h，这是往一个8位寄存器存储了0600h这个十六进制数值吗？</p>
<p>2023/8/18 23:26:45</p>
<p>不是的。<code>mov ax, 0600h</code> 是将一个十六进制数值
<code>0600h</code> 存储到一个 16 位寄存器 AX 中。</p>
<p>在这个指令中，<code>mov</code>
是汇编语言中的一条指令，用于将数据从一个位置复制到另一个位置。<code>ax</code>
是一个 16 位的寄存器，它可以存储 2 个字节（16 位）的数据。而
<code>0600h</code> 是一个表示十六进制值的常量，相当于一个 16 位的数值
<code>1536</code>（十进制），它会被复制到 <code>ax</code> 寄存器中。</p>
<p>请注意，<code>ax</code> 是一个 16 位寄存器，不是 8 位寄存器。如果要向
8 位寄存器存储一个值，应该使用 <code>mov al, 0600h</code>，其中
<code>al</code> 是指 <code>ax</code> 寄存器的低 8 位部分。</p>
<p>2023/8/18 23:27:01</p>
<p>我怎么知道ax寄存器是16位的呢，从名字看不出来呀</p>
<p>2023/8/18 23:27:40</p>
<p>确实，从寄存器的名称中无法直接确定其大小。在汇编语言中，寄存器的大小通常通过约定来确定。一般来说，常见的约定如下：</p>
<ul>
<li><code>ax</code>、<code>bx</code>、<code>cx</code>、<code>dx</code> 等以 <code>x</code> 结尾的寄存器是
16 位寄存器。<br />
</li>
<li><code>eax</code>、<code>ebx</code>、<code>ecx</code>、<code>edx</code> 等以 <code>x</code> 结尾的寄存器是
32 位寄存器。<br />
</li>
<li><code>rax</code>、<code>rbx</code>、<code>rcx</code>、<code>rdx</code> 等以 <code>x</code> 结尾的寄存器是
64 位寄存器。</li>
</ul>
<p>这种命名约定可以帮助程序员识别寄存器的大小，但仍然需要参考具体的体系结构和编程环境。不同的体系结构和编程环境可能使用不同的寄存器命名和大小规定。</p>
<p>因此，要确定一个特定寄存器的大小，最可靠的方法是查阅所用体系结构的文档或参考编程环境的规范。在特定的体系结构和编程环境中，对于每个寄存器名称都会有明确的定义和规定。</p>
<p>0600h最后这个h不是数值的一部分吧，应该是什么修饰符？</p>
<p>2023/8/18 23:39:03</p>
<p>你是对的，<code>h</code>
在这里是一个修饰符，表示后面的数值是一个十六进制（hexadecimal）数。</p>
<p>在汇编语言中，常用的数值表示方式有多种，包括：</p>
<ul>
<li>十进制（decimal）：例如 <code>100</code>。<br />
</li>
<li>十六进制（hexadecimal）：以 <code>0x</code> 或 <code>h</code> 作为前缀，例如 <code>0x64</code> 或 <code>64h</code>。<br />
</li>
<li>八进制（octal）：以 <code>0</code> 作为前缀，例如 <code>0144</code>。<br />
</li>
<li>二进制（binary）：以 <code>0b</code> 或 <code>b</code> 作为前缀，例如 <code>0b1100100</code> 或 <code>1100100b</code>。</li>
</ul>
<p>在这个例子中，<code>0600h</code> 表示一个十六进制数，相当于十进制数的
<code>1536</code>。修饰符 <code>h</code>
告诉汇编器或编译器将后面的数值解释为十六进制。</p>
<p>需要注意的是，在不同的汇编语言和编译器中，可能会有不同的修饰符表示方式和约定。因此，在具体的编程环境中，应该查阅相关文档或规范，以确保使用正确的数值表示方式。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>方括号解引用的时候会解释多少字节作为数值？</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E6%96%B9%E6%8B%AC%E5%8F%B7%E8%A7%A3%E5%BC%95%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A3%E9%87%8A%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E4%BD%9C%E4%B8%BA%E6%95%B0%E5%80%BC%EF%BC%9F/</url>
    <content><![CDATA[<p>In x86 assembly, when you use <code>[]</code> to dereference a memory
location, the size of the data being accessed (byte, word, double-word,
etc.) isn't determined solely by the brackets. Instead, it's based on a
combination of:</p>
<ol type="1">
<li>The context provided by the instruction.<br />
</li>
<li>Any size specifiers you might use.<br />
</li>
<li>The register's width you're working with (if applicable).</li>
</ol>
<p>Here are a few scenarios to clarify:</p>
<ol type="1">
<li><p><strong>Using a Size Specifier</strong>:</p>
<p>If you use a size specifier like <code>byte</code>,
<code>word</code>, <code>dword</code>, etc., it will dictate the size of
the data:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   mov al, byte [bx]    ; Loads a byte from memory address in BX into AL.</span><br><span class="line">mov ax, word [bx]    ; Loads a word (2 bytes) from memory address in BX into AX.</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Based on Register Size</strong>:<br />
If there's no explicit size specifier, the size might be inferred from
the register you're working with:<br />
<code>mov al, [bx]    ; Loads a byte because AL is a byte-sized register. mov ax, [bx]    ; Loads a word (2 bytes) because AX is a word-sized register.</code></p></li>
<li><p><strong>Instructions with Inherent Sizes</strong>:</p>
<p>Some instructions inherently operate on specific sizes, and you'd
need to provide the correct context or use a size override if you want
something different.</p></li>
</ol>
<p>For clarity and to avoid ambiguity, it's often a good practice to use
size specifiers when there's any potential for confusion.</p>
<p>In 32-bit and 64-bit modes (like in x86-64 architecture), the default
sizes can change, and you have additional registers (like EAX, RAX)
which work with larger data sizes. Always be aware of the mode you're
working in and the size of the data you intend to work with.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>无法直接使用立即数设置段寄存器</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%AB%8B%E5%8D%B3%E6%95%B0%E8%AE%BE%E7%BD%AE%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<p>In x86 assembly, the segment registers (like <code>es</code>,
<code>cs</code>, <code>ss</code>, <code>ds</code>, <code>fs</code>, and
<code>gs</code>) have some restrictions on how they can be set. Unlike
general-purpose registers, you cannot load them directly with immediate
values. Instead, you often have to use a two-step process, loading a
general-purpose register with the desired value and then transferring
that value to the segment register.</p>
<p>Here's an example of how you might set the <code>es</code>
register:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, someSegment ; Load the value into AX (or another general-purpose register)</span><br><span class="line">mov es, ax          ; Transfer the value to ES</span><br></pre></td></tr></table></figure></p>
<p>This restriction exists largely due to the architecture and
historical design decisions of the x86 platform. When writing code,
especially for tasks like setting up memory segments in real mode (as
seen in older DOS programs or bootloaders), you'll often see this
pattern of using a general-purpose register as an intermediary to set a
segment register's value.</p>
<p>In x86 assembly language, the <code>es</code> register is one of
several segment registers. Originally, the x86 architecture used a
segmented memory model, where memory was divided into segments, and each
segment could be accessed using a particular segment register in
combination with an offset.</p>
<p>Here are the primary segment registers in the x86 architecture:</p>
<ol type="1">
<li><code>cs</code> (Code Segment): Points to the segment containing the
current instruction.<br />
</li>
<li><code>ds</code> (Data Segment): Typically points to the segment
where variables are stored.<br />
</li>
<li><code>ss</code> (Stack Segment): Points to the segment where the
stack is located.<br />
</li>
<li><code>es</code> (Extra Segment): This is an additional data segment
register. In many contexts, it's used as a destination segment for
string operations. For instance, in the <code>movsb</code> instruction
(which moves a byte from the source string to the destination string),
the source address is taken from <code>[ds:si]</code> and the
destination address is from <code>[es:di]</code>.<br />
</li>
<li><code>fs</code>, <code>gs</code>: These were introduced in later
versions of the x86 architecture and are additional segment
registers.</li>
</ol>
<p>更直观的解释是：历史遗留问题。这是由于Intel当时推出8086微处理器时，段寄存器和通用寄存器是分开的，而立即数存放的指令队列无法直接与段寄存器之间直接访问。<br />
<img
src="https://img-blog.csdnimg.cn/20200128131151774.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwdTA3Nw==,size_16,color_FFFFFF,t_70" /></p>
<p>我们可以看出，立即数存放在指令队列缓冲器中，而指令队列缓冲器并不能直接和BIU中的段寄存器直接链接，而是需要将数据传入通用寄存器（数据寄存器）中，然后通过16位的数据总线传入到段寄存器中，所以指令MOV
DS ，1008H是错误的。要改写成MOV AX，1008H；MOV DS，AX。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>请正确解释地址数据长度！</title>
    <url>/blog/2023/10/11/data/CSAPP/os/assemble/%E8%AF%B7%E6%AD%A3%E7%A1%AE%E8%A7%A3%E9%87%8A%E5%9C%B0%E5%9D%80%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%EF%BC%81/</url>
    <content><![CDATA[<p>比如以下两条指令：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add word[address], 1</span><br><span class="line">add byte[address], 1</span><br></pre></td></tr></table></figure></p>
<p>假设地址 <strong>address</strong>
上现在存放着一个两字节长的数据也就是16位的数据，并且机器是小端序的CPU机器，假设地址上存放的数据为0x1234，那么如果使用第一条加法指令，则将address地址解释为数值0x1234，CPU的加法器单元会将0x1234和0x0001作为操作数进行相加，这样结果是0x1235，在小端序CPU上，低地址存放了低位字节，此时两条指令的最终结果是一样的，都是0x1235。</p>
<p>但是若第二个加数更大，是两字节的加数，那么此时使用<code>byte[address]</code>来解释待加数的地址显然就会造成溢出，并且将不正确的结果存放到address处。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>assemble</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图的最大匹配</title>
    <url>/blog/2023/10/11/data/algorithmn/OI%20WIKI/%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>为了描述方便将两个集合分成左和右两个部分，所有匹配边都是横跨左右两个集合，可以假想成男女配对。</p>
<p>假设图有 <span class="math inline">\(n\)</span> 个顶点，<span
class="math inline">\(m\)</span> 条边。</p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个二分图 <span
class="math inline">\(G\)</span>，即分左右两部分，各部分之间的点没有边连接，要求选出一些边，使得这些边没有公共顶点，且边的数量最大。</p>
<h2 id="增广路算法-augmenting-path-algorithm">增广路算法 Augmenting Path
Algorithm</h2>
<p>因为增广路长度为奇数，路径起始点非左即右，所以我们先考虑从左边的未匹配点找增广路。
注意到因为交错路的关系，增广路上的第奇数条边都是非匹配边，第偶数条边都是匹配边，于是左到右都是非匹配边，右到左都是匹配边。
于是我们给二分图 <strong>定向</strong>，问题转换成，有向图中从给定起点找一条简单路径走到某个未匹配点，此问题等价给定起始点 <span
class="math inline">\(s\)</span> 能否走到终点 <span
class="math inline">\(t\)</span>。 那么只要从起始点开始 DFS
遍历直到找到某个未匹配点，<span class="math inline">\(O(m)\)</span>。
未找到增广路时，我们拓展的路也称为 <strong>交错树</strong>。</p>
<h3 id="性质">性质</h3>
<p>因为要枚举 <span class="math inline">\(n\)</span>
个点，总复杂度为 <span class="math inline">\(O(mn)\)</span>。</p>
<h3 id="实现">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BipartiteGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; seta; <span class="comment">// set A</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; setb; <span class="comment">// set B</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visi; <span class="comment">// visited or not</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_a = <span class="number">0</span>;    <span class="comment">// number of elements in set A</span></span><br><span class="line">    <span class="type">int</span> num_b = <span class="number">0</span>;    <span class="comment">// number of elements in set B</span></span><br><span class="line">    <span class="type">int</span> stamp = <span class="number">0</span>;    <span class="comment">// time stamp of each step</span></span><br><span class="line">    <span class="type">int</span> match = <span class="number">0</span>;    <span class="comment">// maximum matches magnitude</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BipartiteGraph</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">BipartiteGraph</span>(<span class="type">int</span> na, <span class="type">int</span> nb) : <span class="built_in">num_a</span>(na), <span class="built_in">num_b</span>(nb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(na &gt;= <span class="number">0</span> &amp;&amp; nb &gt;= <span class="number">0</span>);</span><br><span class="line">        seta = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(na, <span class="number">-1</span>);</span><br><span class="line">        setb = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nb, <span class="number">-1</span>);</span><br><span class="line">        visi = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(na);</span><br><span class="line">        graph.<span class="built_in">resize</span>(na);</span><br><span class="line"></span><br><span class="line">        stamp = <span class="number">0</span>;</span><br><span class="line">        match = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(src &gt;= <span class="number">0</span> &amp;&amp; dst &gt;= <span class="number">0</span>);</span><br><span class="line">        graph[src].<span class="built_in">push_back</span>(dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> vtx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visi[vtx] = stamp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; nbg : graph[vtx])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (setb[nbg] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                seta[vtx] = nbg;</span><br><span class="line">                setb[nbg] = vtx;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; nbg : graph[vtx])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visi[setb[nbg]] != stamp &amp;&amp; <span class="built_in">dfs</span>(setb[nbg]))</span><br><span class="line">            &#123;</span><br><span class="line">                seta[vtx] = nbg;</span><br><span class="line">                setb[nbg] = vtx;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stamp++;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// find all augment paths</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_a; ++i)</span><br><span class="line">                <span class="keyword">if</span> (seta[i] == <span class="number">-1</span> &amp;&amp; <span class="built_in">dfs</span>(i)) cnt++;</span><br><span class="line">            <span class="comment">// if there is no augment path anymore, exit</span></span><br><span class="line">            <span class="keyword">if</span> (!cnt) <span class="keyword">break</span>;</span><br><span class="line">            match += cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> match;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>OI WIKI</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> <code>[7,1,5,3,6,4]</code><br />
<strong>输出：</strong> <code>5</code><br />
<strong>解释：</strong> 在第 2 天（股票价格 = 1）的时候买入，在第 5
天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 =
6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> <code>prices = [7,6,4,3,1]</code><br />
<strong>输出：</strong> <code>0</code><br />
<strong>解释：</strong> 在这种情况下, 没有交易完成, 所以最大利润为
0。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code><br />
</li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<p>即找到每个数右边的最大值。只需要一次遍历并在遍历的途中维护已经遇到过的最大值就可以了，然后填入<code>每个数右边的最大值</code>这个数组。每个数在得知自己右边的最大值了之后，就可以知道这笔交易的例利润了，然后利润也可以在遍历的图中维护着不断更新最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tmpMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            rightMax[i] = tmpMax;</span><br><span class="line">            tmpMax = <span class="built_in">max</span>(tmpMax, prices[i]);</span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rightMax[i] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>2240. 买钢笔和铅笔的方案数</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/2240.%20%E4%B9%B0%E9%92%A2%E7%AC%94%E5%92%8C%E9%93%85%E7%AC%94%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>给你一个整数 <code>total</code> ，表示你拥有的总钱数。同时给你两个整数 <code>cost1</code> 和 <code>cost2</code> ，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。</p>
<p>请你返回购买钢笔和铅笔的 <strong>不同方案数目</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> total = 20, cost1 = 10, cost2 = 5<br />
<strong>输出：</strong> 9<br />
<strong>解释：</strong> 一支钢笔的价格为 10 ，一支铅笔的价格为 5
。<br />
- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。<br />
- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。<br />
- 如果你买 2 支钢笔，那么你没法买任何铅笔。<br />
所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> total = 5, cost1 = 10, cost2 = 10<br />
<strong>输出：</strong> 1<br />
<strong>解释：</strong> 钢笔和铅笔的价格都为 10
，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0
支钢笔和 0 支铅笔。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= total, cost1, cost2 &lt;= 106</code></li>
</ul>
<p>看起来是中等难度的题，但实际上仔细想一下感觉就是小学的数学应用题目，只不过现在要求使用代码来解题罢了。小学的时候经常有这种小朋友去购物，用零花钱买商品A和商品B的方案数量的题目。最简单的解法就是先固定商品A的数量，然后直接统计商品B能购买多少个：<br />
* 0个A：0、1、2、3、4、...、n个B，这里有 <span
class="math inline">\(n+1\)</span> 种方案<br />
* 1个A：0、1、2、3、4、...、m个B，这里有 <span
class="math inline">\(m+1\)</span> 种方案</p>
<p>因此我们只需要在总价减去一个固定商品A数量的总价之后，求得商品B的整除商即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">waysToBuyPensPencils</span><span class="params">(<span class="type">int</span> total, <span class="type">int</span> cost1, <span class="type">int</span> cost2)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll bound1 = total / cost1;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= bound1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += (total - cost1 * i) / cost2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>228. 汇总区间</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/228.%20%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>给定一个
 <strong>无重复元素</strong> 的 <strong>有序</strong> 整数数组 <code>nums</code> 。</p>
<p>返回 <em><strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表</em> 。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p>
<p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p>
<ul>
<li><code>"a-&gt;b"</code> ，如果 <code>a != b</code><br />
</li>
<li><code>"a"</code> ，如果 <code>a == b</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> nums = [0,1,2,4,5,7]<br />
<strong>输出：</strong>["0-&gt;2","4-&gt;5","7"]<br />
<strong>解释：</strong> 区间范围是：<br />
[0,2] --&gt; "0-&gt;2"<br />
[4,5] --&gt; "4-&gt;5"<br />
[7,7] --&gt; "7"</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> nums = [0,2,3,4,6,8,9]<br />
<strong>输出：</strong>["0","2-&gt;4","6","8-&gt;9"]<br />
<strong>解释：</strong> 区间范围是：<br />
[0,0] --&gt; "0"<br />
[2,4] --&gt; "2-&gt;4"<br />
[6,6] --&gt; "6"<br />
[8,9] --&gt; "8-&gt;9"</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 20</code><br />
</li>
<li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code><br />
</li>
<li><code>nums</code> 中的所有值都 <strong>互不相同</strong><br />
</li>
<li><code>nums</code> 按升序排列</li>
</ul>
<p>很明显是模拟题，只要是模拟题难度一般都是简单或中等。模拟题最考验的就是边界条件处理。这题可以使用双指针来解决，只需判断下一个数是否是上一个数+1即可。难点在于末尾的最后一个数字容易混淆思维，可能让人误认为需要额外的判断条件。其实，可以用while循环来完成一段有序子序列区间范围的探测，然后下一次探测的起始位置与本次不重合即可，这样最后一个数字一定是先被双指针的尾指针探测定位到，也无需额外的if-else来判断双指针是否越界了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tail = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lend = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (head &lt; lend &amp;&amp; tail &lt; lend)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (tail + <span class="number">1</span> &lt; lend &amp;&amp; nums[tail + <span class="number">1</span>] == nums[tail] + <span class="number">1</span>) tail++;</span><br><span class="line">            <span class="keyword">if</span> (head ^ tail)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[head]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[tail]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[head]));</span><br><span class="line">            tail++;      <span class="comment">// prepare for the next probe</span></span><br><span class="line">            head = tail; <span class="comment">// prepare for the next probe</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>2511. 最多可以摧毁的敌人城堡数目</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/2511.%20%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E6%91%A7%E6%AF%81%E7%9A%84%E6%95%8C%E4%BA%BA%E5%9F%8E%E5%A0%A1%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>给你一个长度为 <code>n</code> ，下标从 <strong>0</strong> 开始的整数数组 <code>forts</code> ，表示一些城堡。<code>forts[i]</code> 可以是 <code>-1</code> ，<code>0</code> 或者 <code>1</code> ，其中：</p>
<ul>
<li><code>-1</code> 表示第 <code>i</code> 个位置 <strong>没有</strong> 城堡。<br />
</li>
<li><code>0</code> 表示第 <code>i</code> 个位置有一个 <strong>敌人</strong> 的城堡。<br />
</li>
<li><code>1</code> 表示第 <code>i</code> 个位置有一个你控制的城堡。</li>
</ul>
<p>现在，你需要决定，将你的军队从某个你控制的城堡位置 <code>i</code> 移动到一个空的位置 <code>j</code> ，满足：</p>
<ul>
<li><code>0 &lt;= i, j &lt;= n - 1</code><br />
</li>
<li>军队经过的位置 <strong>只有</strong> 敌人的城堡。正式的，对于所有 <code>min(i,j) &lt; k &lt; max(i,j)</code> 的 <code>k</code> ，都满足 <code>forts[k] == 0</code> 。</li>
</ul>
<p>当军队移动时，所有途中经过的敌人城堡都会被 <strong>摧毁</strong> 。</p>
<p>请你返回 <strong>最多</strong> 可以摧毁的敌人城堡数目。如果 <strong>无法</strong> 移动你的军队，或者没有你控制的城堡，请返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> forts =
<code>[1,0,0,-1,0,0,0,0,1]</code><br />
<strong>输出：</strong> 4<br />
<strong>解释：</strong><br />
- 将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2
。<br />
- 将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。<br />
4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> forts = <code>[0,0,1,-1]</code><br />
<strong>输出：</strong> 0<br />
<strong>解释：</strong> 由于无法摧毁敌人的城堡，所以返回 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= forts.length &lt;= 1000</code><br />
</li>
<li><code>-1 &lt;= forts[i] &lt;= 1</code></li>
</ul>
<p>这是一道简单题，所以不用想的太复杂，但是也不能掉以轻心，很多简单题却往往是数论题，而数论题如果没有一定数学基础的同学很难做出来，如果只是普通的数据结构题，中等难度可能都没有简单难度的数论题难。</p>
<p>本题转化一下题意，就是要求两端被 1 或 -1 包裹的最长 连续 0
子数组。这题最开始的时候考虑到会不会与前缀和数组有关，可是后来想了一下，觉得前缀和在这里是无法判断出连续子数组两端是否被
1 或 -1 包围，这是要求找到一个
0，并且往两边发散寻找的模式，与前缀和的应用情况不太一样，前缀和是要求单向向前求解的。</p>
<p>那用两个数组，一个数组记录原数组每个位置距离其左边最近的 1，
一个数组记录每个位置距离其右边最近的
-1？但是这仍然还没有考虑距离其左边最近的 -1 和距离其右边最近的 1
呀，这样子岂不是需要四个数组来维护？这样子的话就是 <span
class="math inline">\(O(4n)\)</span> 了，虽然题目给的数据范围只到
1000，但是这是
leetcode，放在普通的OJ平台简单题也可能会在数据范围上做手脚的。对于任意一道算法题，一般最优的时间复杂度就是
<span class="math inline">\(O(n)\)</span>
了，因为你至少需要见过一遍所有的输入数据，这里就至少 <span
class="math inline">\(O(n)\)</span>
了，如果能在只要见过所有数据之后就能求解出题目答案，那么这种算法通常都是最优的。</p>
<p>本题有没有办法做到 <span class="math inline">\(O(n)\)</span>
的时间复杂度呢？我们期望一边扫描数据，一边就能更新答案的最大值。仔细想想我们可以发现，连续子数组两端的情况要么是
<span class="math inline">\((1,-1)\)</span> 要么是 <span
class="math inline">\((-1,
1)\)</span>，它们的和为0，因此我们可以在碰到非0的位置时，记录为起点，然后如果终点位置的元素和为0，则我们找到了一个合法的包裹区间。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">captureForts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; forts)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = forts.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (forts[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; len &amp;&amp; !forts[j]) j++;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; len &amp;&amp; forts[i] + forts[j] == <span class="number">0</span>)</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, j - i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>2582. 递枕头</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/2582.%20%E9%80%92%E6%9E%95%E5%A4%B4/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p><code>n</code> 个人站成一排，按从 <code>1</code> 到 <code>n</code> 编号。</p>
<p>最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。</p>
<ul>
<li>例如，当枕头到达第 <code>n</code> 个人时，TA
会将枕头传递给第 <code>n - 1</code> 个人，然后传递给第 <code>n - 2</code> 个人，依此类推。</li>
</ul>
<p>给你两个正整数 <code>n</code> 和 <code>time</code> ，返回 <code>time</code> 秒后拿着枕头的人的编号。</p>
<p><strong>示例 1：</strong><br />
<strong>输入：</strong> <code>n = 4, time = 5</code><br />
<strong>输出：</strong> <code>2</code><br />
<strong>解释：</strong> 队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 -&gt;
4 -&gt; 3 -&gt; 2 。<br />
5 秒后，枕头传递到第 2 个人手中。</p>
<p><strong>示例 2：</strong><br />
<strong>输入：</strong> <code>n = 3, time = 2</code><br />
<strong>输出：</strong> <code>3</code><br />
<strong>解释：</strong> 队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3
。<br />
2 秒后，枕头传递到第 3 个人手中。</p>
<p><strong>提示：</strong><br />
- <code>2 &lt;= n &lt;= 1000</code><br />
- <code>1 &lt;= time &lt;= 1000</code></p>
<p>简单的规律题，我们只需要直到某个时刻 <span
class="math inline">\(t\)</span> 是处于 <span class="math inline">\(1
\rightarrow n\)</span> 还是 <span class="math inline">\(n \rightarrow
1\)</span> 的过程中即可。我们可以发现，在 <span class="math inline">\(1
\rightarrow n\)</span> 的时候，我们会经过 <span class="math inline">\(n
- 1\)</span> 个时刻，反过来也是一样，所以每过 <span
class="math inline">\(n - 1\)</span>
个时刻，方向就会翻转一次。我们可以利用整除也就是 <span
class="math inline">\(time / (n - 1)\)</span>
得到的整数商来推断现在是处于正向传递还是逆向传递，然后余数 <span
class="math inline">\(r\)</span>
也知道了，就可以知道当前时刻枕头是栓第到 <span class="math inline">\(1 +
r\)</span> 还是 <span class="math inline">\(n - r\)</span>
的位置了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">passThePillow</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> passRound = time / (n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> restTimes = time % (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (passRound % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + restTimes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (passRound % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n -  restTimes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>2591. 将钱分给最多的儿童</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/2591.%20%E5%B0%86%E9%92%B1%E5%88%86%E7%BB%99%E6%9C%80%E5%A4%9A%E7%9A%84%E5%84%BF%E7%AB%A5/</url>
    <content><![CDATA[<p>给你一个整数 <code>money</code> ，表示你总共有的钱数（单位为美元）和另一个整数 <code>children</code> ，表示你要将钱分配给多少个儿童。</p>
<p>你需要按照如下规则分配：</p>
<ul>
<li>所有的钱都必须被分配。<br />
</li>
<li>每个儿童至少获得 <code>1</code> 美元。<br />
</li>
<li>没有人获得 <code>4</code> 美元。</li>
</ul>
<p>请你按照上述规则分配金钱，并返回 <strong>最多</strong> 有多少个儿童获得 <strong>恰好</strong> <code>8</code> 美元。如果没有任何分配方案，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> money = 20, children = 3<br />
<strong>输出：</strong> 1<br />
<strong>解释：</strong><br />
最多获得 8 美元的儿童数为 1 。一种分配方案为：<br />
- 给第一个儿童分配 8 美元。<br />
- 给第二个儿童分配 9 美元。<br />
- 给第三个儿童分配 3 美元。<br />
没有分配方案能让获得 8 美元的儿童数超过 1 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> money = 16, children = 2<br />
<strong>输出：</strong> 2<br />
<strong>解释：</strong> 每个儿童都可以获得 8 美元。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= money &lt;= 200</code><br />
</li>
<li><code>2 &lt;= children &lt;= 30</code></li>
</ul>
<p>这题挂着简单题的名号，但实际上考验我们的边界决策能力和情况判断能力。本题给出的数据量比较小，并且从题意来看也无需特殊的数据结构，所以本题应该是逻辑思维题，这种题也一般出现在面试的较后的技术面试作为智力题出现。</p>
<p>先总结出比较明显的前提，也就是题目给出的：<br />
1. 每个人至少分到1元，如果无法达成此前提则返回-1，代表没有分配方案<br />
2.
尽量给每个人凑到8元，如果没有一个人能凑到8元则返回0，表示最多能凑成8元的人数为0<br />
3.
调整每个人的分配的时候，不能出现4元（这其实是一个混淆视听的约束，因为只要至少有两个人那么就有调整的余地，两个人之间可以进行随意的分配，只要不分配其中一个人为4元，那么就不可能出现4元的分配，当然这也是因为题目没有要求每个人得到的分配有某个上限）</p>
<p>直接按情况分类讨论：<br />
1. 每个人给一块钱都做不到，返回-1<br />
2.
每个人给完一块钱之后还有多余的，或者没有多余的，总之没办法再拿出7块钱凑出一个8块，返回0<br />
3.
现在确定能至少凑出一个8块钱了，但是最多能凑出几个8块钱不知道，继续分类讨讨论<br />
1.
如果所有人分到8块钱之后，还有多余的钱，那这部分钱必须放到一个人身上，那这个人就不是8块钱了，所以最终返回<code>children - 1</code><br />
2. 如果所有人刚好分到8块钱，那么直接返回<code>children</code><br />
3.
如果所有人都至少能分到1块钱，也能凑出一部分8块钱，那么我们需要计算能有多少个8块钱</p>
<p><code>money</code>
减去能完整分配的8块钱的数量之后，剩下的钱，要给剩下的人先每人至少一块钱，同时如果遇到最特殊的情况，刚好只剩下一人并且这个人会得到4块钱，那只能把它变成3块钱，把多余的一块钱分配给某个8块钱，这样已知的8块钱还要再减少一个了。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> satisfied = money / <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> restMoney = money - satisfied * <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> restChildren = children - satisfied;</span><br></pre></td></tr></table></figure>
其中<code>satisfied</code>是假设先分配为8块钱的人的数量，之后我们需要考虑剩余的人和剩余的钱的关系。如果剩余的钱每个人都能至少发到1块钱，那么此时就可以直接返回<code>satisfied</code>作为分配到8块钱的可能的最多的人数了。如果剩余的钱无法给每个人都发到一块钱，那么还得从前面已经发了8块钱的人的手中拿钱过来补贴，但是注意
<strong>拿已经分配了8块钱的人的钱过来补贴，至少要给那个人留一块钱，所以之前已经分配好的8块钱的人，每人最多有7块钱的补贴额度</strong>，在满足了剩余的人至少拿到一块钱之后，看看破坏了多少个完整的8块钱即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distMoney</span><span class="params">(<span class="type">int</span> money, <span class="type">int</span> children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (money &lt; children) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (money &lt; children + <span class="number">7</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (children * <span class="number">8</span> &lt; money) <span class="keyword">return</span> children - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (children * <span class="number">8</span> == money) <span class="keyword">return</span> children;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> satisfied = money / <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> restMoney = money - satisfied * <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> restChildren = children - satisfied;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (restChildren == <span class="number">1</span> &amp;&amp; restMoney == <span class="number">4</span>) <span class="keyword">return</span> satisfied - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (restChildren &gt; restMoney)</span><br><span class="line">            <span class="keyword">return</span> satisfied - ((restChildren - restMoney - <span class="number">1</span>) / <span class="number">7</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> satisfied;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>2605. 从两个数字数组里生成最小数字</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/2605.%20%E4%BB%8E%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E6%95%B0%E7%BB%84%E9%87%8C%E7%94%9F%E6%88%90%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>给你两个只包含 1 到 9
之间数字的数组 <code>nums1</code> 和 <code>nums2</code> ，每个数组中的元素 <strong>互不相同</strong> ，请你返回 <strong>最小</strong> 的数字，两个数组都 <strong>至少</strong> 包含这个数字的某个数位。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> nums1 = [4,1,3], nums2 = [5,7]<br />
<strong>输出：</strong> 15<br />
<strong>解释：</strong> 数字 15 的数位 1 在 nums1 中出现，数位 5 在
nums2 中出现。15 是我们能得到的最小数字。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> nums1 = [3,5,2,6], nums2 = [3,1,7]<br />
<strong>输出：</strong> 3<br />
<strong>解释：</strong> 数字 3 的数位 3 在两个数组中都出现了。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 9</code><br />
</li>
<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 9</code><br />
</li>
<li>每个数组中，元素 <strong>互不相同</strong> 。</li>
</ul>
<p>这是一道简单题，所有需要注意的坑题目都已经明说了，只需要按照题目的意思进行模拟实现即可。一般思路是很明确的，两个数组中，谁的数字小，谁排在高位。<br />
<span class="math display">\[  
ans = min(min1 \times 10 + min2, min2 \times 10 + min1)  
\]</span><br />
最后，示例2已经给出了需要特殊处理的情况了，当两个数组中包含有相同的数字时，不需要组合为两位数，一位数就可以符合题意，所以如果需要在
<span class="math inline">\(O(n)\)</span>
的时间复杂度内完成题目，需要额外的空间辅助我们记录 <span
class="math inline">\(nums1\)</span> 中的每一个数字，这样 <span
class="math inline">\(nums2\)</span>
在遍历并维护最小值的同时就可以检测到与 <span
class="math inline">\(nums1\)</span>
中的哪些数字相同，并更新答案的最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        std::set&lt;<span class="type">int</span>&gt; nums1Set;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> min1 = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> min2 = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> ans  = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1Set.<span class="built_in">insert</span>(num);</span><br><span class="line">            min1 = <span class="built_in">min</span>(min1, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1Set.<span class="built_in">count</span>(num))</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, num);</span><br><span class="line">            min2 = <span class="built_in">min</span>(min2, num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">min</span>(min1 * <span class="number">10</span> + min2, min2 * <span class="number">10</span> + min1));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>2651. 计算列车到站时间</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/2651.%20%E8%AE%A1%E7%AE%97%E5%88%97%E8%BD%A6%E5%88%B0%E7%AB%99%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>给你一个正整数 <code>arrivalTime</code> 表示列车正点到站的时间（单位：小时），另给你一个正整数 <code>delayedTime</code> 表示列车延误的小时数。</p>
<p>返回列车实际到站的时间。</p>
<p>注意，该问题中的时间采用 24 小时制。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> arrivalTime = 15, delayedTime = 5
<strong>输出：</strong> 20 <strong>解释：</strong> 列车正点到站时间是
15:00 ，延误 5 小时，所以列车实际到站的时间是 15 + 5 = 20（20:00）。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> arrivalTime = 13, delayedTime = 11<br />
<strong>输出：</strong> 0<br />
<strong>解释：</strong> 列车正点到站时间是 13:00 ，延误 11
小时，所以列车实际到站的时间是 13 + 11 = 24（在 24 小时制中表示为 00:00
，所以返回 0）。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arrivaltime &lt; 24</code><br />
</li>
<li><code>1 &lt;= delayedTime &lt;= 24</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDelayedArrivalTime</span><span class="params">(<span class="type">int</span> arrivalTime, <span class="type">int</span> delayedTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (arrivalTime + delayedTime) % <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>605. 种花问题</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/605.%20%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>
<code>flowerbed = [1,0,0,0,1], n = 1</code><br />
<strong>输出：</strong> <code>true</code></p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>
<code>flowerbed = [1,0,0,0,1], n = 2</code><br />
<strong>输出：</strong> <code>false</code></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= flowerbed.length &lt;= 2 * 104</code><br />
</li>
<li><code>flowerbed[i]</code> 为 <code>0</code> 或 <code>1</code><br />
</li>
<li><code>flowerbed</code> 中不存在相邻的两朵花<br />
</li>
<li><code>0 &lt;= n &lt;= flowerbed.length</code></li>
</ul>
<p>本题是一道数论题，也是要求用户有严格的边界处理能力和思考能力，从个别测试用例得出的规律结论来推广到普适规律。花坛种花，敏锐的用户可能马上会想到的边界条件是左右两侧是否种了花，因为最左右两侧的位置可以少受到一侧约束，而一般的位置却要受到两侧的约束。</p>
<p>然后再来看看一般情况下的种花问题。我们只能在没有种过花的花坛位置种花，翻译成实际的数学表示就是我们要寻找连续0子数组，因此可以使用双指针的想法，每次遇到0的位置，就让第二个指针往前面继续探索前进直到遇到非空位置，也就是数组中遇到1的时候停下来，此时两个指针之间的位置都是空的，可以尝试种花；双指针找到的连续0子数组很明显是被左右两端的1包围着的，那么左右两端的两个空位置就不能种花了，因为它们毗邻着端点的1，题意要求我们不能出现每朵花之间必须隔开一个花坛，因此假设实际的连续0子数组长度是
<span class="math inline">\(len\)</span>，那么能用来种花的就只有 <span
class="math inline">\(len - 2\)</span> 了。再来看给定一块长度为 <span
class="math inline">\(x\)</span>
的位置，如果间隔种花最多能种多少朵花？如果 <span
class="math inline">\(x\)</span> 是奇数，那么就是 <span
class="math inline">\(x / 2 + 1\)</span> ，如果 <span
class="math inline">\(x\)</span> 是偶数，那么就是 <span
class="math inline">\(x /
2\)</span>，说白了5个位置能有3朵花，4个位置能有2朵花，也就是说我们希望
<span class="math inline">\(x / 2\)</span> 这个操作是向上取整的，这样
<span class="math inline">\(5 / 2 = 2.5 \rightarrow 3\)</span>
就可以少写判断奇偶数的 <code>if</code>
语句了，只要我们知道空的花坛的数量，可以直接得出间隔种花的数量是 <span
class="math inline">\(\lceil x/2 \rceil\)</span>
。因为大多数编程语言的除法都默认是向下取整，所以向上取整需要我们自己实现，但其实也就是一个很简单的技巧而已。如果想要
<span class="math inline">\(a / b\)</span>
是向上取整的话，只需要调整公式为 <span class="math inline">\((a - 1) / b
+ 1\)</span> 就行啦。</p>
<p>考虑完一般情况之后，来看看特殊情况怎么处理——如果空花坛的位置两端是起始位置或者结束位置的话。也就是说，一般情况由于空花坛区域的两端是有种了花的花坛作为毗邻端点的（连续0子数组的两端是1），那么空花坛会损失边缘的两个位置。如果两端是起始位置的话，那么有一端就可以不损失那个空花坛，如果两端都是数组的端点，那么两个边缘位置的空花坛都不用损失。所以我们发现，对于边界情况来说，只要有一端是数组的边界位置，那么实际的空花坛数量就可以少损失一个，于是我们只需要检测双指针探测出来的连续0子数组的两端是否是原数组的两端即可，有一个端则空花坛损失数量减少一。最后得到可用空花坛数量后，就可以得到这块区域最多能间隔种花的数量了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowerbed, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = flowerbed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> ((len - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span> &lt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> planted = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; len &amp;&amp; q &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; len &amp;&amp; flowerbed[p]) p++;</span><br><span class="line">            q = p;</span><br><span class="line">            <span class="keyword">while</span> (q &lt; len &amp;&amp; !flowerbed[q]) q++;</span><br><span class="line">            <span class="type">int</span> restPos = q - p - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">                restPos++;</span><br><span class="line">            <span class="keyword">if</span> (q == len)</span><br><span class="line">                restPos++;</span><br><span class="line">            <span class="keyword">if</span> (restPos &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                planted += (restPos - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; planted;</span></span><br><span class="line">        <span class="keyword">return</span> planted &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>617. 合并二叉树</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/617.%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null
的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
<p><strong>示例 1：</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" /></p>
<p><strong>输入：</strong> root1 = [1,3,2,5], root2 =
[2,1,3,null,4,null,7]<br />
<strong>输出：</strong> [3,4,5,5,4,null,7]</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> root1 = [1], root2 = [1,2]<br />
<strong>输出：</strong> [2,2]</p>
<p><strong>提示：</strong></p>
<ul>
<li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内<br />
</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p>简单的递归题目，但是这种题目比较迷惑人的是，如何把这个函数自身做成一个递归终点。根节点和根节点的合并就在当前函数完成，左子树和左子树，右子树和右子树就交给下一层函数，等下一层函数返回上来，拿到左右子树的新合并子树，再把这两棵子树作为当前节点的左右子树往上一层返回。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* rootl, TreeNode* rootr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rootl &amp;&amp; !rootr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ( rootl &amp;&amp; !rootr) <span class="keyword">return</span> rootl;</span><br><span class="line">        <span class="keyword">if</span> (!rootl &amp;&amp;  rootr) <span class="keyword">return</span> rootr;</span><br><span class="line">        TreeNode* newNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootl-&gt;val + rootr-&gt;val);</span><br><span class="line">        newNode-&gt;left  = <span class="built_in">mergeTrees</span>(rootl-&gt;left , rootr-&gt;left );</span><br><span class="line">        newNode-&gt;right = <span class="built_in">mergeTrees</span>(rootl-&gt;right, rootr-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LCP 06. 拿硬币</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/LCP%2006.%20%E6%8B%BF%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>桌上有 <code>n</code> 堆力扣币，每堆的数量保存在数组 <code>coins</code> 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>[4,2,1]</code></p>
<p>输出：<code>4</code></p>
<p>解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1
次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>[2,3,10]</code></p>
<p>输出：<code>8</code></p>
</blockquote>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 4</code><br />
</li>
<li><code>1 &lt;= coins[i] &lt;= 10</code></li>
</ul>
<p>一看题目，差点以为又是博弈论的题目，但是一看难度是Easy感觉应该还有点希望（因为大部分简单题实际上有时候并不简单）。<code>n</code>
堆硬币，可以任意选一堆然后取走一枚或者两枚。遇到题目时，首先考虑最简单最暴力的解法，然后再尝试使用更好的数据结构或者算法来优化，这才是软件工程做事的方法，而不是一开始就要求找到最优的方案，这通常是不可能的而且容易导致花费大量的时间做无用功，最优方案通常是有一定的数学推理和数论的，对于应用工程学来说，要通过数论推理找到最优的方案通常很难。</p>
<p>最直接的贪心就是任意选一堆硬币，以最少的次数取完硬币，所有硬币堆的最少取用次数之和就是拿完所有硬币的最少次数。在选取硬币堆的时候，选择哪一堆并不会影响其他硬币堆的最少取完次数，因此每个选取动作都是独立不相关的，因此我们直接遍历每一堆硬币求出最少取完次数并求和即可。</p>
<p>本题使用到的一个数学处理技巧是向上取整，C/C++
默认的整数除法是向下取整，那么如何完成向上取整呢？使用如下公式即可：<br />
<span class="math display">\[  
(a - 1) / b + 1  
\]</span><br />
每次可以拿两个或一个硬币，也可以理解为一次最多可以取走两个硬币，如果只剩下一个硬币的话也可以直接拿走，因为
<strong>我们每次最多可以取走两枚硬币</strong>，所以我们只需要求每堆硬币除以2的向上取整的商即可（反正要么刚好拿完要么剩一枚硬币然后多花费一次，这取决于硬币堆的硬币数量是奇数还是偶数）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; cnt : coins)</span><br><span class="line">            ans += ((cnt - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LCP 50. 宝石补给</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/easy/LCP%2050.%20%E5%AE%9D%E7%9F%B3%E8%A1%A5%E7%BB%99/</url>
    <content><![CDATA[<h2 id="简单">[<span style="color:green;">简单</span>]</h2>
<p>欢迎各位勇者来到力扣新手村，在开始试炼之前，请各位勇者先进行「宝石补给」。</p>
<p>每位勇者初始都拥有一些能量宝石， <code>gem[i]</code> 表示第 <code>i</code> 位勇者的宝石数量。现在这些勇者们进行了一系列的赠送，<code>operations[j] = [x, y]</code> 表示在第 <code>j</code> 次的赠送中
第 <code>x</code> 位勇者将自己一半的宝石（需向下取整）赠送给第 <code>y</code> 位勇者。</p>
<p>在完成所有的赠送后，请找到拥有<strong>最多</strong>宝石的勇者和拥有<strong>最少</strong>宝石的勇者，并返回他们二者的宝石数量<strong>之差</strong>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>赠送将按顺序逐步进行。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>gem = [3,1,2], operations = [[0,2],[2,1],[2,0]]</code></p>
<p>输出：<code>2</code></p>
<p>解释： 第 1
次操作，勇者 <code>0</code> 将一半的宝石赠送给勇者 <code>2</code>， <code>gem = [2,1,3]</code> 第
2
次操作，勇者 <code>2</code> 将一半的宝石赠送给勇者 <code>1</code>， <code>gem = [2,2,2]</code> 第
3
次操作，勇者 <code>2</code> 将一半的宝石赠送给勇者 <code>0</code>， <code>gem = [3,2,1]</code> 返回
3 - 1 = 2</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>gem = [100,0,50,100], operations = [[0,2],[0,1],[3,0],[3,0]]</code></p>
<p>输出：<code>75</code></p>
<p>解释： 第 1
次操作，勇者 <code>0</code> 将一半的宝石赠送给勇者 <code>2</code>， <code>gem = [50,0,100,100]</code> 第
2
次操作，勇者 <code>0</code> 将一半的宝石赠送给勇者 <code>1</code>， <code>gem = [25,25,100,100]</code> 第
3
次操作，勇者 <code>3</code> 将一半的宝石赠送给勇者 <code>0</code>， <code>gem = [75,25,100,50]</code> 第
4
次操作，勇者 <code>3</code> 将一半的宝石赠送给勇者 <code>0</code>， <code>gem = [100,25,100,25]</code> 返回
100 - 25 = 75</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：<code>gem = [0,0,0,0], operations = [[1,2],[3,1],[1,2]]</code></p>
<p>输出：<code>0</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= gem.length &lt;= 10^3</code><br />
</li>
<li><code>0 &lt;= gem[i] &lt;= 10^3</code><br />
</li>
<li><code>0 &lt;= operations.length &lt;= 10^4</code><br />
</li>
<li><code>operations[i].length == 2</code><br />
</li>
<li><code>0 &lt;= operations[i][0], operations[i][1] &lt; gem.length</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">giveGem</span><span class="params">(gem []<span class="type">int</span>, operations [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> operations &#123;</span><br><span class="line">        gem[opt[<span class="number">1</span>]] += (gem[opt[<span class="number">0</span>]] &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        gem[opt[<span class="number">0</span>]] -= (gem[opt[<span class="number">0</span>]] &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mingem := <span class="type">int</span>(<span class="number">1e3</span>)</span><br><span class="line">    maxgem := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> gem &#123;</span><br><span class="line">        mingem = min(mingem, val)</span><br><span class="line">        maxgem = max(maxgem, val)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, mingem)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxgem - mingem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">giveGem</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gem, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; operations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; opt : operations)</span><br><span class="line">        &#123;</span><br><span class="line">            gem[opt[<span class="number">1</span>]] += (gem[opt[<span class="number">0</span>]] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            gem[opt[<span class="number">0</span>]] -= (gem[opt[<span class="number">0</span>]] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxgem = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mingem = <span class="built_in">int</span>(<span class="number">1e3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; g : gem)</span><br><span class="line">        &#123;</span><br><span class="line">            maxgem = <span class="built_in">max</span>(maxgem, g);</span><br><span class="line">            mingem = <span class="built_in">min</span>(mingem, g);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxgem - mingem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>123. 买卖股票的最佳时机 III</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/hard/123.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20III/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong><br />
<strong>输入：</strong> <code>prices = [3,3,5,0,0,3,1,4]</code><br />
<strong>输出：</strong> <code>6</code><br />
<strong>解释：</strong> 在第 4 天（股票价格 = 0）的时候买入，在第 6
天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br />
  随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 =
4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
<p><strong>示例 2：</strong><br />
<strong>输入：</strong> <code>prices = [1,2,3,4,5]</code><br />
<strong>输出：</strong> <code>4</code><br />
<strong>解释：</strong> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天
（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。    
注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。    
因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p><strong>示例 3：</strong><br />
<strong>输入：</strong> <code>prices = [7,6,4,3,1]</code>
<strong>输出：</strong> <code>0</code> <strong>解释：</strong>
在这个情况下, 没有交易完成, 所以最大利润为 0。</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong> <code>prices = [1]</code><br />
<strong>输出：</strong> <code>0</code></p>
<p><strong>提示：</strong><br />
- <code>1 &lt;= prices.length &lt;= 10^5</code><br />
- <code>0 &lt;= prices[i] &lt;= 10^5</code></p>
<p>这题也许看起来和 <a
href="obsidian://open?vault=testrepo&amp;file=algorithmn%2Fleetcode%2Fmidium%2F122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II">买卖股票系列题的第二题</a>有点关系，但实际上并没有什么关系，因为我直接套用第二题的代码然后找出交易额最大的两笔交易然后求和，只能过80%的用例，其中一个用例是这样的：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,4,2,5,7,2,4,9,0]</span><br></pre></td></tr></table></figure>
如果按照第二题的方法找到所有的上升区间，并利用优先队列找到交易额前二的交易求和，那么得到的交易额之和是12，但是本用例的最大交易额是13，也即
<span class="math inline">\(5 - 2\)</span> 和 <span
class="math inline">\(9 - 2\)</span>,
但如果是按照找递增区间的方法来统计交易，那么会统计到 <span
class="math inline">\(4 - 2\)</span> 和 <span class="math inline">\(9 -
2\)</span>，也就是12。</p>
<p>本题的官方题解链接<a
href="%5B123.%20买卖股票的最佳时机%20III%20-%20力扣（LeetCode）%5D(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solutions/552695/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/)">在此</a>，但是官方题解用了四个状态来进行动态规划，比较难看懂，反而是评论区有一位作者的方法简单易懂又非常好，也是
<span class="math inline">\(O(n)\)</span>
的时间复杂度，因此我这里记录那位作者的方法。</p>
<p>起始本题不需要多复杂的状态来完成动态规划。因为题目要求最多进行两次交易，而两次交易的区间不能有重叠，因为手上最多持有一支股票。因此我们可以把原数组划分为两个区间，对应着两次交易发生的区间。然后我们可以分别求出两个区间内的最大交易额，再对这两个最大交易额求和即可。</p>
<p>两个区间内的最大交易额求解可以使用不同的方法，不过为了整体的统一性，因此使用了作者的动态规划方法。注意，每个区间内只能发生一次交易，我们需要通过动态规划找到最大的交易额（当然也可以通过买卖股票第一题的方法，找到最大的交易额）。</p>
<p>我们把原数组划分为两个区间，第一笔交易发生在第一个区间，第二笔交易发生在第二个区间。对于第一个区间，我们创建动态规划数组
<span class="math inline">\(dpLeft[\ ]\)</span>，其中 <span
class="math inline">\(dpLeft[i]\)</span> 表示在已知第 <span
class="math inline">\(i\)</span>
天以及之前的股票价格时，发生一次交易能获取的最大交易额利润是多少；对于第二个区间，我们创建动态规划数组
<span class="math inline">\(dpRigh[\ ]\)</span>，其中 <span
class="math inline">\(dpRigh[i]\)</span> 表示在已知第 <span
class="math inline">\(i\)</span>
天以及之后的股票价格时，发生一次交易能获取的最大交易额利润是多少。</p>
<p>现在我们将原数组划分为了 <span class="math inline">\([0,\ i]\)</span>
和 <span class="math inline">\([i + 1,\ n]\)</span>
，只要我们求出这两个区间内的唯一交易最大利润即可。于是我们可以从位置
<span class="math inline">\(0\)</span> 开始划分区间（从位置 <span
class="math inline">\(0\)</span>
开始划分的话代表考虑到了只发生一次交易的情况，因为数组的所有范围都划分给了其中一次交易，另一次交易没有区间也就代表没有发生），划分
<span class="math inline">\(n\)</span>
次，也就是对于第一第二次交易的范围一共有 <span
class="math inline">\(n\)</span> 种划分方式。我们求出这 <span
class="math inline">\(n\)</span>
种不同划分方式的左右区间最大利润之和，然后维护一个最大值即可。</p>
<p>其中，左区间动态规划求最大值我们希望从左往右求，这样刚好第一个值作为动态规划的初始值，并且随着遍历往右走，动态规划的结果
<span class="math inline">\(dpLeft[i]\)</span>
也可以随之存放到对应位置；右区间的动态规划求最大值我们希望从右往左求，否则我们动态规划维护的值都存放到最右边的端点处了，这样没有办法存放第二区间所有划分位置的动态规划结果，但如果是从右往左动态规划，那么刚好就可以把维护的值存放在当前位置然后把区间端点向左开拓，这样一直规划到位置
<span class="math inline">\(0\)</span>，也就是数组的开头。</p>
<p>为了避免在循环中写 <code>if</code>
语句来检测是否是端点边界等情况，我们可以给原数组两端再复制一次放在两端，然后我们自己从原来的数组两端开始，这样复制出来的两端可以作为初始化的值直接使用了；因为在动态规划的时候，问题总是依赖于子问题的，所以经常会出现类似于
<code>dp[i] = min/max(dp[i - 1], ...)</code> 这样的表达式，当 <span
class="math inline">\(i = 0\)</span>
的时候，这种表达式会导致数组越界访问 <span
class="math inline">\(-1\)</span> 的下标位置，因此需要额外的
<code>if</code>
判断是否是边界或者端点。如果我们在原先的边界处添加新的伪端点，然后计算仍然从原始的端点开始，此时
<span class="math inline">\(i = 1\)</span> 才是起点，那么
<code>dp[i - 1]</code> 这种表达式就可以一直合法，循环内也无需写
<code>if</code> 判断了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> numPrices = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 为了方便的边界处理，左右位置添加两个复制端点值</span></span><br><span class="line">        prices.<span class="built_in">insert</span>(prices.<span class="built_in">begin</span>(), prices.<span class="built_in">front</span>());</span><br><span class="line">        prices.<span class="built_in">insert</span>(prices.<span class="built_in">end</span>(), prices.<span class="built_in">back</span>());</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpLeft</span><span class="params">(numPrices + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> minVal = prices.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numPrices; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dpLeft[i] = <span class="built_in">max</span>(dpLeft[i - <span class="number">1</span>], prices[i] - minVal);</span><br><span class="line">            minVal = <span class="built_in">min</span>(minVal, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpRigh</span><span class="params">(numPrices + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> maxVal = prices.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = numPrices; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            dpRigh[i] = <span class="built_in">max</span>(dpRigh[i + <span class="number">1</span>], maxVal - prices[i]);</span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numPrices + <span class="number">1</span>; ++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dpLeft[i] + dpRigh[i + <span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>1654. 到家的最少跳跃次数</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/hard/1654.%20%E5%88%B0%E5%AE%B6%E7%9A%84%E6%9C%80%E5%B0%91%E8%B7%B3%E8%B7%83%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>有一只跳蚤的家在数轴上的位置 <code>x</code> 处。请你帮助它从位置 <code>0</code> 出发，到达它的家。</p>
<p>跳蚤跳跃的规则如下：</p>
<ul>
<li>它可以 <strong>往前</strong> 跳恰好 <code>a</code> 个位置（即往右跳）。<br />
</li>
<li>它可以 <strong>往后</strong> 跳恰好 <code>b</code> 个位置（即往左跳）。<br />
</li>
<li>它不能 <strong>连续</strong> 往后跳 <code>2</code> 次。<br />
</li>
<li>它不能跳到任何 <code>forbidden</code> 数组中的位置。</li>
</ul>
<p>跳蚤可以往前跳 <strong>超过</strong> 它的家的位置，但是它 <strong>不能跳到负整数</strong> 的位置。</p>
<p>给你一个整数数组 <code>forbidden</code> ，其中 <code>forbidden[i]</code> 是跳蚤不能跳到的位置，同时给你整数 <code>a</code>， <code>b</code> 和 <code>x</code> ，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达 <code>x</code> 的可行方案，请你返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> forbidden = [14,4,18,1,15], a = 3, b = 15, x
= 9<br />
<strong>输出：</strong> 3<br />
<strong>解释：</strong> 往前跳 3 次（0 -&gt; 3 -&gt; 6 -&gt;
9），跳蚤就到家了。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> forbidden = [8,3,16,6,12,20], a = 15, b = 13,
x = 11<br />
<strong>输出：</strong>-1</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> forbidden = [1,6,2,14,5,17,4], a = 16, b = 9,
x = 7<br />
<strong>输出：</strong> 2<br />
<strong>解释：</strong> 往前跳一次（0 -&gt; 16），然后往回跳一次（16
-&gt; 7），跳蚤就到家了。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= forbidden.length &lt;= 1000</code><br />
</li>
<li><code>1 &lt;= a, b, forbidden[i] &lt;= 2000</code><br />
</li>
<li><code>0 &lt;= x &lt;= 2000</code><br />
</li>
<li><code>forbidden</code> 中所有位置互不相同。<br />
</li>
<li>位置 <code>x</code> 不在 <code>forbidden</code> 中。</li>
</ul>
<p>这题看到的第一眼是想用动态规划做的，但是仔细想想，题目有限制不能连续往后跳跃，这要怎么在动态规划中表达出来呢？仔细一看这题，甚至有可能是一道数论题，因为是否能到达目的地
<strong>x</strong> 可以被表示为：<br />
<span class="math display">\[  
am + bn = x  
\]</span><br />
所以只要找到合适的 <span class="math inline">\((m,n)\)</span>
就代表此题是可解的数论题；但真的是这样吗？我们发现，题目中的
“它不能 <strong>连续</strong> 往后跳 <code>2</code> 次”
这个限制，使得很多方法都没有办法很好的处理这个情况。我个人最开始尝试用动态规划的时候，想的是前进的规划分配一个数组
<span class="math inline">\(dpf\)</span>，后退的规划也分配一个数组 <span
class="math inline">\(dpb\)</span>，然后考虑如何结合这两个数组来完成动态规划。</p>
<p>那么如果从模拟的角度来看，BFS 或者 DFS
是否可行呢？可以预见的是，DFS很难可行，因为当题目给定的前进步数 a
和后退步数 b 比较小的时候，而终点 x
又比较远的话，堆栈可能无法承受这么深的递归调用。</p>
<p>从模拟的角度来说，我们还能很快地根据 a，b
的大小进行分类讨论（假设跳蚤是聪明的，不会绕路，也就是说，能第一次到达的位置，绝不会兜兜转转的去其他地方再回来此处，也就不会发生先前进几步再后退回来或者怎样）：<br />
1. 当 a = b 时：此时跳蚤只能不断地前进，并且每次前进的长度是一样的都是
a，因为后退是没有意义地，正如题目所说，跳蚤需要找到一条步数最少的路径，后退一次只会增加无用功。<br />
2. 当 a &gt; b
时：此时就算跳蚤能在前进的过程中选择后退，跳蚤至少也要前进 (a-b)
的距离，因此等价于跳蚤每次可以前进 a 或者前进 (a-b) 的距离。<br />
3. 当 a &lt; b
时：此时跳蚤既可以前进又可以后退，这种情况就比较麻烦了，我们很难直接通过数论的方式解出一个前进后退组合来确定跳蚤是否能到达终点
x。</p>
<p>以上是个人的一些思考了，可惜虽然算是与正确题解沾上了一点边，但是离正确的解法还是差了很多的，因为这题的官方题解还包括了一段比较难的边界证明。</p>
<h2 id="官方题解">官方题解</h2>
<h3 id="分类讨论">分类讨论</h3>
<p>求最短路径一般需要用广度优先搜索，但是此题中的图是个无限图，如果不限制搜索的范围，无法处理无解的情况。因此，解决此题的关键是找出搜索的范围，其中下限已经由题目给出，不能跳到负整数的位置，我们还需要找出搜索的上限，下面分情况讨论：<br />
==a =
b==：此时为了次数最少，跳蚤没有必要向后跳，只需要一直往前跳。当它超过
xxx 却没有遇到 xxx，表示它再也跳不到 xxx 了，此时的上限可以设置为
xxx。</p>
<p>==a &gt; b==：题目规定，跳蚤不能连续往后跳 2
次，因此这只跳蚤运动轨迹中，任意连续的两次跳跃，总的行程一定是在前进的，前进了
a−b
的距离。即使它某一步是在后退，这一步的前一步和后一步（如果有的话）一定是在前进。此时跳蚤运动的上限为
x+b，在这个上限的情况下，跳蚤往回跳一步可以到达
x。在大于这个上限的情况下，即使跳蚤马上往回跳一步，所处的位置也大于
x，而且跳蚤接下来前进的次数必然会大于等于后退的次数，再也无法到达
x。因此在这种情况下，上限为 x+b。</p>
<p>==a &lt; b==：在这种情况下，上限为 <span
class="math inline">\(max(max(forbidden)+a+b,x)\)</span>。接下来证明这一点。为了方便，记
<span class="math inline">\(max⁡(forbidden) =
f\)</span>。首先，需要将数轴上大于等于 0 的位置分为三个区域：<br />
1. <span class="math inline">\([0, f]\)</span>，禁止区。所有 <span
class="math inline">\(forbidden\)</span> 中的位置都位于这个区域<br />
2. <span
class="math inline">\((f,max(f+a+b,x)]\)</span>，安全区，它的右边界是 a
&lt; b 情况下我们想要证明的广度优先搜索的上限<br />
3. <span class="math inline">\((\max(f+a+b, x),
+\infty)\)</span>，界外区。</p>
<p>这三个区域合起来组成了数轴上大于等于 0 的所有部分，注意 x
可能位于禁止区或者安全区，但不会是 forbidden 数组中的元素。</p>
<p>假设某个步数最少的路径中的一段路径，我们用一组点 <span
class="math inline">\(C, \dots, H\)</span> 表示这些位置。假设点<span
class="math inline">\(C\)</span>（或者说位置也行，点就是一个位置）是这段路径中第一个进入界外区（前进进入）的点，而点
<span class="math inline">\(H\)</span>
是第一个离开界外区（后退离开）的点。因为 <span
class="math inline">\(x\)</span>
只可能位于禁止区或者安全区，因此如果这条路径存在入口点 <span
class="math inline">\(C\)</span>，那么必然存在退出点 <span
class="math inline">\(H\)</span>， 因为我们已经假设了这是一条能到达终点
<span class="math inline">\(x\)</span>
的路径，所以我们出了界外区的话是一定会折返的。</p>
<p>如下图，横坐标为步数，纵坐标为与原点的距离。箭头朝右上表示前进，箭头朝右下表示后退。<br />
<img
src="https://assets.leetcode-cn.com/solution-static/1654/1.png" /></p>
<p>接下来，我们通过交换线段 <span class="math inline">\(BC\)</span>
和线段 <span
class="math inline">\(GH\)</span>，并保持其他线段的的方向不变，来使得点
<span class="math inline">\(C\)</span> 不再位于界外区（看纵坐标，点
<span class="math inline">\(C\)</span>
由前进到达改变为后退到达，因又因为 <span
class="math inline">\(C\)</span>
是第一个<strong>进入</strong>界外区的点，并且已知我们现在的讨论情况是
后退距离大于前进距离 的情况，所以改为后退到达的话，点 <span
class="math inline">\(C\)</span> 一定在安全区界限之下）。如下图，线段
<span class="math inline">\(BC&#39;\)</span> 变为后退而线段 <span
class="math inline">\(G&#39;H\)</span> 变为前进。<br />
<img
src="https://assets.leetcode-cn.com/solution-static/1654/2.png" /></p>
<h3 id="边界证明">边界证明</h3>
<p>我们从以下几个方面论证这种交换的可行性：</p>
<p>交换前，点 <span class="math inline">\(C，D，\dots，F，G\)</span>
全都位于界外区，与原点的距离大于 <span
class="math inline">\(f+a+b\)</span>。通过交换，这些点与原点的距离缩小了
<span class="math inline">\(a+b\)</span>，仍然大于 <span
class="math inline">\(f\)</span>。因此，这些点不会落到 <span
class="math inline">\(forbidden\)</span>
中。交换后不会增加这个路径的步数，也不会影响点 <span
class="math inline">\(H\)</span> 之后的点的位置。</p>
<p>交换不会造成两次倒退。交换后，前进的线段 <span
class="math inline">\(BC\)</span> 变为后退的线段 <span
class="math inline">\(BC&#39;\)</span>，但是 <span
class="math inline">\(BC&#39;\)</span> 的前一段 <span
class="math inline">\(AB\)</span> 一定是前进的。可以利用反证法证明，如果
<span class="math inline">\(AB\)</span> 是后退的，又因为 <span
class="math inline">\(a&lt;b\)</span>（前进距离小于后退距离），那么点
<span class="math inline">\(A\)</span> 就会在界外区，这样的话点 <span
class="math inline">\(C\)</span> 就不会是第一个界外区的点，因此 <span
class="math inline">\(AB\)</span>一定是前进的。<span
class="math inline">\(BC&#39;\)</span> 的后一段 <span
class="math inline">\(C&#39;D&#39;\)</span>
一定也是前进的。这里需要分为两种情况：<br />
1. <span class="math inline">\(CD\)</span> 原本就是前进的，那么 <span
class="math inline">\(C&#39;D&#39;\)</span>
会保持原来前进的方向。通过交换，我们不会造成两次倒退。<br />
2. <span class="math inline">\(CD\)</span> 原本是后退的，那么点 <span
class="math inline">\(D\)</span> 就是我们前面讨论的第一个离开界外区的点
<span class="math inline">\(H\)</span>，因为 <span
class="math inline">\(a&lt;b\)</span>。这样一来，我们其实是交换了前进的
<span class="math inline">\(BC\)</span> 和后退的 <span
class="math inline">\(CD\)</span>，得到了后退的 <span
class="math inline">\(BC’\)</span> 和前进的 <span
class="math inline">\(C’D\)</span>，仍然不会造成两次倒退。</p>
<p>通过这样的交换，我们使得一个有效路径第一个进入界外区的点，不再位于界外区。新的路径，第一个进入界外区的点，可能位于点
<span class="math inline">\(C\)</span> 和点 <span
class="math inline">\(H\)</span> 之间，也可能位于点 <span
class="math inline">\(H\)</span>
之后，也可能不存在这样的点。总之，我们可以不停地寻找第一个进入界外区的点，然后经过上述的交换，使得最终的路径的所有点都位于禁止区和安全区。这样，我们就证明出，如果某个输入有解，那么至少有一条最短路径，它的所有点都处于上限
<span class="math inline">\(max⁡(f+a+b,x)\)</span>
之内。因此在这种情况下，上限为 <span
class="math inline">\(max(max(forbidden)+a+b,x)\)</span>。</p>
<p>综合以上三种情况，广度优先搜索的上限是
max(max(forbidden)+a,x)+b。</p>
<p>在进行广度优先搜索时，除了需要注意到上下限，不能达到
forbiddenforbidden
数组中的坐标，还需要注意到达每个坐标时，都会有前进到达还是后退到达两种状态。如果是前进到达时，下一步可以选择前进或者后退；如果是后退到达时，下一步只能选择前进。因此广度优先搜索的每个元素，需要保存三个信息，坐标，方向和步数。在代码中，我们用
111 表示前进，−1-1−1 表示后退，用哈希集合 visitedvisited
来记录已经达到过的位置和方向状态。在搜索的过程中，如果坐标第一次为
xxx，则返回当前步数。当队列为空时，表示 xxx 不可到达，返回 −1-1−1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumJumps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; forbidden, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; posdirstpQueue;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; visitedSet;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">forbdenSet</span><span class="params">(forbidden.begin(), forbidden.end())</span></span>;</span><br><span class="line">        posdirstpQueue.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// add the start point</span></span><br><span class="line">        visitedSet.<span class="built_in">emplace</span>(<span class="number">0</span>);           <span class="comment">// add the start point</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lower = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> upper = <span class="built_in">max</span>(*<span class="built_in">max_element</span>(forbidden.<span class="built_in">begin</span>(), forbidden.<span class="built_in">end</span>()) + a, x) + b;</span><br><span class="line">        <span class="keyword">while</span> (!posdirstpQueue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [pos, dir, stp] = posdirstpQueue.<span class="built_in">front</span>();</span><br><span class="line">            posdirstpQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pos == x) <span class="keyword">return</span> stp; <span class="comment">// first reached path steps</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> nxtPos = pos + a;</span><br><span class="line">            <span class="type">int</span> nxtDir = +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lower &lt;= nxtPos &amp;&amp; nxtPos &lt;= upper &amp;&amp; !visitedSet.<span class="built_in">count</span>(nxtPos * nxtDir) &amp;&amp; !forbdenSet.<span class="built_in">count</span>(nxtPos))</span><br><span class="line">            &#123;</span><br><span class="line">                posdirstpQueue.<span class="built_in">emplace</span>(nxtPos, nxtDir, stp + <span class="number">1</span>);</span><br><span class="line">                visitedSet.<span class="built_in">emplace</span>(nxtPos * nxtDir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if we use forward to reach this position, we can backward</span></span><br><span class="line">            <span class="keyword">if</span> (dir &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nxtPos = pos - b;</span><br><span class="line">                nxtDir = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (lower &lt;= nxtPos &amp;&amp; nxtPos &lt;= upper &amp;&amp; !visitedSet.<span class="built_in">count</span>(nxtPos * nxtDir) &amp;&amp; !forbdenSet.<span class="built_in">count</span>(nxtPos))</span><br><span class="line">                &#123;</span><br><span class="line">                    posdirstpQueue.<span class="built_in">emplace</span>(nxtPos, nxtDir, stp + <span class="number">1</span>);</span><br><span class="line">                    visitedSet.<span class="built_in">emplace</span>(nxtPos * nxtDir);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// no valid solution</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>1782. 统计点对的数目</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/hard/1782.%20%E7%BB%9F%E8%AE%A1%E7%82%B9%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>给你一个无向图，无向图由整数 <code>n</code>  ，表示图中节点的数目，和 <code>edges</code> 组成，其中 <code>edges[i] = [ui, vi]</code> 表示 <code>ui</code> 和 <code>vi</code> 之间有一条无向边。同时给你一个代表查询的整数数组 <code>queries</code> 。</p>
<p>第 <code>j</code> 个查询的答案是满足如下条件的点对 <code>(a, b)</code> 的数目：</p>
<ul>
<li><code>a &lt; b</code><br />
</li>
<li><code>cnt</code> 是与 <code>a</code> <strong>或者</strong> <code>b</code> 相连的边的数目，且 <code>cnt</code> <strong>严格大于</strong> <code>queries[j]</code> 。</li>
</ul>
<p>请你返回一个数组 <code>answers</code> ，其中 <code>answers.length == queries.length</code> 且 <code>answers[j]</code> 是第 <code>j</code> 个查询的答案。</p>
<p>请注意，图中可能会有 <strong>重复边</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img
src="https://pic.leetcode-cn.com/1614828447-GMnLVg-image.png" /></p>
<p><strong>输入：</strong> n = 4, edges =
[[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]<br />
<strong>输出：</strong>[6,5]<br />
<strong>解释：</strong>
每个点对中，与至少一个点相连的边的数目如上图所示。<br />
answers[0] = 6。所有的点对(a, b)中边数和都大于2，故有6个；<br />
answers[1] = 5。所有的点对(a,
b)中除了(3,4)边数等于3，其它点对边数和都大于3，故有5个。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> n = 5, edges =
[[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries =
[1,2,3,4,5]<br />
<strong>输出：</strong>[10,10,9,8,6]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 2 * 10^4</code><br />
</li>
<li><code>1 &lt;= edges.length &lt;= 105</code><br />
</li>
<li><code>1 &lt;= ui, vi &lt;= n</code><br />
</li>
<li><code>ui != vi</code><br />
</li>
<li><code>1 &lt;= queries.length &lt;= 20</code><br />
</li>
<li><code>0 &lt;= queries[j] &lt; edges.length</code></li>
</ul>
<p>首先第一眼，要求所有 <code>a &lt; b</code>
的点对，那很明显是双层遍历直接排列组合生成这些点对，但是一看数据量，<span
class="math inline">\(2\times 10^4\)</span>
就知道如果使用双层遍历的方法，时间复杂度是O(n^2)，这对于题目给出的数据范围来说是不可接受的。而要解任何一个题目，所有数据至少要看过一次，也就是说，最低的时间复杂度是O(n)，其他额外附加的时间复杂度就看算法怎么处理读入的数据了。</p>
<p>既然是图论题，那么数据结构大概率少不了unordered_map和map，首先需要哈希表来存储边的信息，其次需要一个数组来保存每个点的度，因为查询queries[j]的答案answer[j]与点对两个点的度有关。</p>
<p>另外需要注意的一点就是，题目给出边的数据中可能存在重复边，且重复多少次是未知的，重复边给出的形式有可能是(a,b)或者(b,a)，也就是说，点对中点的顺序并不重要了。这提示我们，顶点a和顶点b的度之和不一定等于与这两个顶点相连的边的数量。</p>
<p>给定以上分析，假设现在的查询值是queries[j]，那么最直接的办法是双层遍历找到所有符合条件的点对，但是这种操作是O(n^2)的，不可行。换一种思路，假设已经确定了顶点a，那么顶点b的确定就与queries[j]的值有关，是什么限制条件呢？因为顶点a的度与顶点b的度之和必须
<strong>严格大于</strong>
queries[j]（此处暂时不考虑重复边重复计数贡献的度），则当确定了顶点a后，顶点b的度必须严格大于
<strong>queries[j] - degree[a]</strong>
，其中<code>degree</code>是保存了每个顶点的度的数组。现在解题的一个条件具有比较的性质，那么可以考虑使用排序顶点的度后进行二分查找，这样算法的总体时间复杂度是O(n+logn)，这是可以接受的。将degree数组升序排序为degree_sorted，此时根据限制值下界
<strong>queries[j] - degree[a]</strong>
找到分界点，分界点之后所有的顶点都能与顶点a组成满足度数条件的点对(a,b)。另外排序后顶点的编号是乱的，因为排序的根据是点的度，因此有可能编号大的顶点在排序后数组的前面，而编号小的顶点在后面，这样在选定前面的顶点a时，二分查找数组得到的分界点之后的顶点b有可能顶点编号大于a，这样满足题目要求的点对(a,b)中
a &gt; b
的条件吗？这其实是一个干扰条件，我们只是排序之后的数组把顶点a放在了前面，顶点b放在了后面，因此我们习惯说这是点对(a,b)，但实际上我们可以说成点对(b,a)，就像以前中文是从右往左读一样，这只是习惯问题，点对(a,b)和点对(b,a)标识的是同一个二元组，因为我们只关心这个二元组的度，这个二元组标识符的文字顺序我们并不关心。</p>
<p>最后，我们还要处理重复边的问题，因为给定边的时候(a,b)和(b,a)是一样的，如何构建顶点顺序无关的边存储数据结构呢？最简单的办法就是把(b,a)也记作(a,b)，当我们遍历读取边数组时，如果遇到边(a,b)中a
&lt;
b，简单的交换一下两个变量存储的数值即可，这样(a,b)和(b,a)在变量表示中都是(small,
big)了，于是无论(a,b)还是(b,a)，对重复边计数都算到一个key上，这个key就是(a,b)。使用一个unordered_map&lt;int,
int&gt; 来存储每条边的数量，关于key，可以直接使用std::pair&lt;int,
int&gt;(a,b)，也可以使用一种取巧的办法，一个整数代表两个数，key = a * n
+
b，解码就可以用除法和取模来重新获得(a,b)。如果存在边(a,b)，则顶点a和顶点b的度之和会重复计算这条边两次，顶点a的度计入了一次，顶点b的度又计入了一次，因此顶点a和顶点b的实际度之和是
degree[a] + degree[b] - repeat[(a,b)]，也就是减去一次重复计数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countPairs</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; repeat;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; edge : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> b = edge[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">            degree[a]++;</span><br><span class="line">            degree[b]++;</span><br><span class="line">            repeat[a * n + b]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; degree_sorted = degree;</span><br><span class="line">        <span class="built_in">sort</span>(degree_sorted.<span class="built_in">begin</span>(), degree_sorted.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; ans.<span class="built_in">reserve</span>(queries.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; bound : queries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = std::<span class="built_in">upper_bound</span>(</span><br><span class="line">                    degree_sorted.<span class="built_in">begin</span>() + i + <span class="number">1</span>,</span><br><span class="line">                    degree_sorted.<span class="built_in">end</span>(),</span><br><span class="line">                    bound - degree_sorted[i]</span><br><span class="line">                ) - degree_sorted.<span class="built_in">begin</span>();</span><br><span class="line">                total += n - j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, val] : repeat)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a = key / n;</span><br><span class="line">                <span class="type">int</span> b = key % n;</span><br><span class="line">                <span class="keyword">if</span> (degree[a] + degree[b] &gt; bound &amp;&amp; degree[a] + degree[b] - val &lt;= bound)</span><br><span class="line">                    total--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>188. 买卖股票的最佳时机 IV</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/hard/188.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20IV/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> <code>k = 2, prices = [2,4,1]</code><br />
<strong>输出：</strong> <code>2</code><br />
<strong>解释：</strong> 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天
(股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>
<code>k = 2, prices = [3,2,6,5,0,3]</code><br />
<strong>输出：</strong> <code>7</code><br />
<strong>解释：</strong> 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天
(股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br />
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3)
的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= 100</code><br />
</li>
<li><code>1 &lt;= prices.length &lt;= 1000</code><br />
</li>
<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
<p>本题是比较难的动态规划题，难在不容易想到合适的状态来表达题目的变化。另外，动态规划的初始边界条件也非常重要，因此要同时考虑到这两点十分不易，本题可以作为学习拓展题来看。</p>
<h2 id="主要思路">主要思路</h2>
<p><a
href="%5B123.%20买卖股票的最佳时机%20III%20-%20力扣（LeetCode）%5D(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/?envType=daily-question&amp;envId=2023-10-03)">买卖股票III</a>和买卖股票IV的动态规划很像，第三题是第四题的前驱热身，第三题的状态设计提示了我们第四题应该怎么设计状态，不过第三题是限制了只有两次交易，所以还有很多其他的技巧可以解题，不仅限于动态规划。</p>
<p>动态规划需要注意的两个变量就是 <strong>时刻</strong> 和
<strong>状态</strong>，在本题中，时刻就是天数，第几天第几天等，状态就是买入和卖出，如果第
<span class="math inline">\(i\)</span>
个时刻是买入状态也即我们手中会持有一支股票，否则第 <span
class="math inline">\(i\)</span>
个状态是卖出状态也即我们手里没有持有任何股票。注意题目没有限制每天的交易次数，也就是说当天的股票可以一直重复买入和卖出，只不过收益是0而已。我们可以把买入和卖出操作看作是状态之间的转换。</p>
<p>动态规划总是期望从子问题的最优解得到当前问题的最优解；我们有两个状态一条时间线，那么应该使用两个动态规划来维护两个状态在某个时刻的最优解，因为一个子问题就涉及到这两个状态了。当前问题是给定观测数据前
<span class="math inline">\(i\)</span> 天的股票价格，以及固定的交易次数
<span class="math inline">\(j\)</span>
，求这个观测下的最优解。从贪心的角度来看，到达交易的最后一天的时候如果手里还有没卖出的股票那么就会亏损，因为不卖出股票还不如不买这只股票可以省下成本钱，反而能到达更大利润也即更优解。假定我们的两个状态定义为
<span class="math inline">\(buy\)</span> 和 <span
class="math inline">\(sel\)</span>，那么 <span
class="math inline">\(buy[i][j]\)</span> 表示给定观测 <span
class="math inline">\(i\)</span> 个价格数据，<span
class="math inline">\(j\)</span>
次交易限制的前提下，我们达到的终态是手里持有股票未卖出时这个，子问题的最优解（注意，这
<span class="math inline">\(j\)</span>
次交易的时刻没有限制，不一定要在最后一天或者某个时刻完成第 <span
class="math inline">\(j\)</span> 次交易，只要是在这 <span
class="math inline">\(i\)</span> 个时刻内就可以了）；同理 <span
class="math inline">\(sel[i][j]\)</span>
表示终态为手里没有股票未卖出时子问题的最优解。子问题是什么？子问题就是给定
<span class="math inline">\(i\)</span> 个时刻的价格以及必须要完成 <span
class="math inline">\(j\)</span> 次交易的限制。</p>
<p>现在来看这两个状态的状态转移方程：<br />
- 对于买入终态 <span class="math inline">\(buy[i][j]\)</span>
：导致这个终态的原因要么是第 <span class="math inline">\(i\)</span>
个时刻买入了股票，要么是第 <span class="math inline">\(i\)</span>
个时刻之前就已经买了一支股票但是一直没有卖出。所以可以确定影响当前这个状态最优解的两个子状态是：<br />
1. <span class="math inline">\(sel[i-1][j]\)</span>：也即由于第 <span
class="math inline">\(i\)</span> 个时刻才买入股票，并且到达的终态满足了
<span class="math inline">\(j\)</span>
次交易的限制，而由于只是买入并不能算完成一次交易，所以可以推断在买入之前就已经满足了
<span class="math inline">\(j\)</span> 次交易了，由于第 <span
class="math inline">\(i\)</span> 个时刻才买入股票，那么第 <span
class="math inline">\(i-1\)</span>
个时刻的终态一定是没有持有股票也就是没有买入股票，因为按照题目的限制下一次交易之前当前交易必须完成，交易完成的意思就是股票已经卖出手上没有未卖出的股票，如果第
<span class="math inline">\(i-1\)</span>
个时刻买入股票而不卖出的话，是到达不了我们假设的当前第 <span
class="math inline">\(i\)</span> 个时刻买入股票的终态的。因此如果第
<span class="math inline">\(i\)</span>
个时刻买入股票导致了这个当前问题的终态是持有股票也就是 <span
class="math inline">\(buy[i][j]\)</span>，那么与当前这个假设有关联的子问题是“前
<span class="math inline">\(i-1\)</span> 个时刻完成了 <span
class="math inline">\(j\)</span> 次交易”且状态是未持有股票，也就是 <span
class="math inline">\(sel[i-1][j]\)</span>。注意如果是这个状态的话，那么买入第
<span class="math inline">\(i\)</span>
个时刻的股票还要扣除买入的价格噢<br />
2. <span class="math inline">\(buy[i-1][j]\)</span>：也即由于第 <span
class="math inline">\(i\)</span>
个时刻什么也没有做，并且到达的终态满足了 <span
class="math inline">\(j\)</span> 次交易的限制，也就是说前 <span
class="math inline">\(i-1\)</span> 个时刻一定已经完成了 <span
class="math inline">\(j\)</span>
次交易并且已经处于手上持有股票未卖出的状态了，也就是 <span
class="math inline">\(buy[i-1][j]\)</span><br />
则 <span class="math inline">\(buy[i][j]\)</span>
的状态转移方程是：<br />
<span class="math display">\[  
    buy[i][j] = max(buy[i-1][j],\ sel[i-1][j] - pricies[i])  
    \]</span><br />
- 对于卖出终态 <span
class="math inline">\(sel[i][j]\)</span>：导致这个终态的原因要么是第
<span class="math inline">\(i\)</span> 个时刻卖出了股票，要么是第 <span
class="math inline">\(i\)</span>
个时刻之前就已经卖出了股票但是一直没有买入。所以可以确定影响当前这个状态的最优解的两个子状态是：<br />
1. <span class="math inline">\(sel[i-1][j]\)</span>：前 <span
class="math inline">\(i-1\)</span> 个时刻就已经完成了 <span
class="math inline">\(j\)</span> 次交易<br />
2. <span class="math inline">\(buy[i-1][j-1]\)</span>：前 <span
class="math inline">\(i-1\)</span> 个时刻完成了 <span
class="math inline">\(j-1\)</span> 次交易，直到第 <span
class="math inline">\(i\)</span> 个时刻的卖出才算完成了 <span
class="math inline">\(j\)</span>
次交易。因为卖出股票一定代表着一个交易的完成，所以如果我们的终态是 <span
class="math inline">\(sel[i][j]\)</span> 的话，也就是在第 <span
class="math inline">\(i\)</span> 个时刻卖出了股票并且交易次数是 <span
class="math inline">\(j\)</span> ，则没卖出这支股票的时候交易次数一定是
<span class="math inline">\(j-1\)</span><br />
则 <span class="math inline">\(sel[i][j]\)</span>
的状态转移方程是：<br />
<span class="math display">\[  
    sel[i][j] = max(sel[i-1][j], buy[i-1][j-1] + pricies[i])  
    \]</span></p>
<h2 id="边界条件及初始化注意事项">边界条件及初始化注意事项</h2>
<p>很容易发现，如果我们的dp数组下标从0开始，那么一旦涉及到 <span
class="math inline">\(i-1\)</span>
之类的下标一定是非法访问，所以这要求我们自己初始化下标为0的位置的信息，并且从下标1开始进行动态规划。现在我们需要把
<span class="math inline">\(buy[0][0]\)</span> 和 <span
class="math inline">\(sel[0][0]\)</span>
初始化好。当我们只有第0天的价格数据时，<span
class="math inline">\(buy[0][0]\)</span>
代表在完成0次交易的前提下，我们要以买入第0时刻的股票作为结束终态，那么没有办法，只能是负债了，也就是此时的利润是负数，因为我们只买入了
<span class="math inline">\(pricies[0]\)</span>
而没有在合适的时刻卖出它；<span class="math inline">\(buy[0][0] =
-pricies[0]\)</span>。</p>
<p>对于 <span class="math inline">\(buy[0][1\dots
k]\)</span>，由于我们只有一支股票的价格，因此我们只能买入一次达到 <span
class="math inline">\(buy\)</span>
的终态，后面的都是无法完成的情况，可以把它们设置为和第一个值一样的负债数字。</p>
<p>对于 <span class="math inline">\(sel[0][1\dots
k]\)</span>，与前者一样，我们第一天的时候是可以合法的，也就是不买入股票也就可以不用卖股票了（虽然买了也可以卖掉就是了，题目并没有限制），但是后面超过0次的交易次数是没有办法达成的，也都可以设置为和第一个值一样的0。</p>
<p>然后，对于题目给定的数据范围，交易次数 <span
class="math inline">\(k\)</span> 可能到达 <span
class="math inline">\(10^9\)</span>
，这是一个混淆视听的数据范围，因为能产生有效利润的交易最多就是 <span
class="math inline">\(\lfloor{\frac{n}{2}}\rfloor\)</span>
了，在当天执行的所有完整交易获得的利润是0，因为股票价格并没有涨跌。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        k = <span class="built_in">min</span>(k, len / <span class="number">2</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buy</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sel</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        buy[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sel[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            buy[<span class="number">0</span>][i] = sel[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            buy[i][<span class="number">0</span>] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>][<span class="number">0</span>], sel[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                buy[i][j] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>][j], sel[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                sel[i][j] = <span class="built_in">max</span>(sel[i - <span class="number">1</span>][j], buy[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(sel.<span class="built_in">back</span>().<span class="built_in">begin</span>(), sel.<span class="built_in">back</span>().<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>2251. 花期内花的数目</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/hard/2251.%20%E8%8A%B1%E6%9C%9F%E5%86%85%E8%8A%B1%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>flowers</code> ，其中 <code>flowers[i] = [starti, endi]</code> 表示第 <code>i</code> 朵花的 <strong>花期</strong> 从 <code>starti</code> 到 <code>endi</code> （都 <strong>包含</strong>）。同时给你一个下标从 <strong>0</strong> 开始大小为 <code>n</code> 的整数数组 <code>people</code> ，<code>people[i]</code> 是第 <code>i</code> 个人来看花的时间。</p>
<p>请你返回一个大小为 <code>n</code> 的整数数组 <code>answer</code> ，其中 <code>answer[i]</code>是第 <code>i</code> 个人到达时在花期内花的 <strong>数目</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg" /></p>
<p><strong>输入：</strong>
<code>flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]</code><br />
<strong>输出：</strong> <code>[1,2,2,2]</code><br />
<strong>解释：</strong>
上图展示了每朵花的花期时间，和每个人的到达时间。<br />
对每个人，我们返回他们到达时在花期内花的数目。</p>
<p><strong>示例 2：</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg" /></p>
<p><strong>输入：</strong>
<code>flowers = [[1,10],[3,3]], people = [3,3,2]</code><br />
<strong>输出：</strong> <code>[2,2,1]</code><br />
<strong>解释：</strong>
上图展示了每朵花的花期时间，和每个人的到达时间。<br />
对每个人，我们返回他们到达时在花期内花的数目。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= flowers.length &lt;= 5 * 10^4</code><br />
</li>
<li><code>flowers[i].length == 2</code><br />
</li>
<li><code>1 &lt;= starti &lt;= endi &lt;= 10^9</code><br />
</li>
<li><code>1 &lt;= people.length &lt;= 5 * 104</code><br />
</li>
<li><code>1 &lt;= people[i] &lt;= 109</code></li>
</ul>
<p>这题其实可以算作一道智力题，因为这道题读题之后，能很明显的感知到，有一个非常简单的逻辑就可以做出来，并不需要什么复杂的数据结构，只是需要弄清楚满足花期的花的数量到底怎么求。</p>
<h2 id="数论">数论</h2>
<p>对于一位观赏者，称他的观赏时刻为 <span
class="math inline">\(t\)</span>，我们需要求的是开花时刻在 <span
class="math inline">\(t\)</span> 之前（或者等于 <span
class="math inline">\(t\)</span>），谢花时刻在 <span
class="math inline">\(t\)</span> 之后（或等于 <span
class="math inline">\(t\)</span>）
。我们可以对所有的开花时刻进行升序排序，对所有的谢花时刻进行升序排序。然后，使用二分查找找到所有开花时刻
<span class="math inline">\(x \leq t\)</span>
的花的数量，找到所有谢花时刻 <span class="math inline">\(y &lt;
t\)</span>
的花的数量，因为在当天谢花也是可以被观赏到的，所以我们不希望哪些在观赏日当天才凋谢的花被排除掉；然后
<span class="math inline">\(x - y\)</span>
就是花期刚好囊括了观赏者来观赏的日期的花。我们先求出的 <span
class="math inline">\(x\)</span>，相当于在观赏者来观赏前开花的数量，可是我们并不知道那些花能维持到观赏者的到来，因此我们再求出在观赏者到来之前就已经凋谢的花的数量
<span class="math inline">\(y\)</span>
，即可间接的知道实际能被指定日期观赏的花的数量。</p>
<blockquote>
<p><code>lower_bound( )</code>和<code>upper_bound( )</code>都是利用二分查找的方法在一个排好序的数组中进行查找的。</p>
<p>在从小到大的排序数组中，</p>
<ol type="1">
<li><code>lower_bound( begin,end,num)</code>：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。<br />
</li>
<li><code>upper_bound( begin,end,num)</code>：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</li>
</ol>
<p>在从大到小的排序数组中，重载lower_bound()和upper_bound()</p>
<ol type="1">
<li><code>lower_bound(begin,end,num,greater&lt;type&gt;())</code>:从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。<br />
</li>
<li><code>upper_bound(begin,end,num,greater&lt;type&gt;())</code>:从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fullBloomFlowers</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flowers, vector&lt;<span class="type">int</span>&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; begs; begs.<span class="built_in">reserve</span>(flowers.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ends; ends.<span class="built_in">reserve</span>(flowers.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; flower : flowers) &#123;</span><br><span class="line">            begs.<span class="built_in">emplace_back</span>(flower[<span class="number">0</span>]);</span><br><span class="line">            ends.<span class="built_in">emplace_back</span>(flower[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(begs.<span class="built_in">begin</span>(), begs.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(ends.<span class="built_in">begin</span>(), ends.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; ans.<span class="built_in">reserve</span>(people.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; t : people)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="type">flowers_open_before_t</span> = std::<span class="built_in">upper_bound</span>(begs.<span class="built_in">begin</span>(), begs.<span class="built_in">end</span>(), t) - begs.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> <span class="type">flowers_dead_afterd_t</span> = std::<span class="built_in">lower_bound</span>(ends.<span class="built_in">begin</span>(), ends.<span class="built_in">end</span>(), t) - ends.<span class="built_in">begin</span>();</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(<span class="type">flowers_open_before_t</span> - <span class="type">flowers_dead_afterd_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="离散化差分数组">离散化差分数组</h2>
<p>这题其实是典型的差分数组题。知道一朵花的花期，其实就相当于给这个区间执行
<span class="math inline">\(+1\)</span>
操作，让这个区间的可被观赏的花朵数目 <span
class="math inline">\(+1\)</span>，使用差分数组的性质根据给定的花期进行多次区间修改操作，最后花费
<span class="math inline">\(O(n)\)</span>
的时间对差分数组求前缀和还原原数组即可，然后根据观赏者的到来时间 <span
class="math inline">\(people\)</span>
去查询还原出来的数组对应位置的数值即可。</p>
<p>但是注意到本题的数据范围中，花期的端点可能出现的最大值是 <span
class="math inline">\(10^9\)</span>，由于 <span
class="math inline">\(10^8\)</span>
就是一亿了已经，因此花期可能出现的最大值是十亿，这已经接近
<code>int</code>
类型的上限了，这说明我们无法构造一个这么大的差分数组（通常vector能开到十万左右的空间）。离散化差分数组的思想是，只记录端点的变化情况，省去了没有原始版本的差分数组中，没有任何操作的位置都是0，导致有非常多冗余0的问题。因为差分数组只记录修改区间的两端端点的变化情况，因此区间中间的那些位置在差分数组中都是0，除非这些位置都作为某个区间的端点参与修改了，而在我们通过对差分数组求前缀和的过程中，这些大量的冗余0的部分对前缀和并没有任何的影响。差分数组的功能是多次区间修改后，通过前缀和还原后，即可进行单点查询，那么我们只需要对查询的这个位置之前的所有差分数组端点求前缀和即可；对原数组的一次区间修改将对差分数组产生两个新的端点或修改两个已有的端点（即非零位置），一个端点代表了一次数值的改变，如果单点查询的位置介于端点
<span class="math inline">\(a\)</span> 和端点 <span
class="math inline">\(b\)</span> 之间，并且 <span
class="math inline">\([a,\ b]\)</span>
之间再没有任何其他的端点，则对原数组 <span class="math inline">\([a,\
b]\)</span>
区间内的单点查询都将得到同一个值，那就是对差分数组求前缀和直到端点 <span
class="math inline">\(a\)</span> 的值。</p>
<p>有了以上的思路之后，我们就可以构造一个离散化只保存端点的差分数组了。另外一个可以做的小优化是：把观赏者按照他们的到来时间进行一次排序，这样当我们遍历离散化差分数组求得第
<span class="math inline">\(i\)</span>
个观赏者的查询值之后，现在我们差分数组求前缀和的位置在不超过第 <span
class="math inline">\(i\)</span>
个观赏者查询时刻的最后一个端点，当我们求第 <span
class="math inline">\(i+1\)</span>
个观赏者的时刻时，我们的差分数组前缀和可以继续向前累计差分直到第 <span
class="math inline">\(i+1\)</span>
个观赏者的时刻之前的最后一个端点；如果观赏者的查询时刻是无序的，那么我们只能每次都从头开始对差分数组求前缀和了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fullBloomFlowers</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flowers, vector&lt;<span class="type">int</span>&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 离散化差分数组</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; discretePresub;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; period : flowers)</span><br><span class="line">        &#123;</span><br><span class="line">            discretePresub[period[<span class="number">0</span>]]++;</span><br><span class="line">            discretePresub[period[<span class="number">1</span>] + <span class="number">1</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将观赏者按其到来时间排序，这样等下遍历差分数组</span></span><br><span class="line">        <span class="comment">// 求前缀和的时候，可以从左往右一次求完所有的观赏</span></span><br><span class="line">        <span class="comment">// 者的观赏时刻花的数目</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">peopleIndicies</span><span class="params">(people.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 生成顺序填入的线性数值，作为每个观赏者的下标</span></span><br><span class="line">        std::<span class="built_in">iota</span>(peopleIndicies.<span class="built_in">begin</span>(), peopleIndicies.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        std::<span class="built_in">sort</span>(peopleIndicies.<span class="built_in">begin</span>(), peopleIndicies.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> people[a] &lt; people[b];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求离散化差分（前缀差）数组的前缀和并对某个时刻</span></span><br><span class="line">        <span class="comment">// 进行查询</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(people.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> preSubIter = discretePresub.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; personIndex : peopleIndicies)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (preSubIter != discretePresub.<span class="built_in">end</span>() &amp;&amp; preSubIter-&gt;first &lt;= people[personIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                preSum += preSubIter-&gt;second;</span><br><span class="line">                preSubIter++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[personIndex] = preSum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullBloomFlowers</span><span class="params">(flowers [][]<span class="type">int</span>, people []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    discretePresub := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, period := <span class="keyword">range</span> flowers &#123;</span><br><span class="line">        discretePresub[period[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        discretePresub[period[<span class="number">1</span>] + <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sortedMapPair := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, val := <span class="keyword">range</span> discretePresub &#123;</span><br><span class="line">        sortedMapPair = <span class="built_in">append</span>(sortedMapPair, []<span class="type">int</span>&#123;key, val&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(sortedMapPair, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedMapPair[i][<span class="number">0</span>] &lt; sortedMapPair[j][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    sortedPeople := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> idx, tme := <span class="keyword">range</span> people &#123;</span><br><span class="line">        sortedPeople = <span class="built_in">append</span>(sortedPeople, []<span class="type">int</span>&#123;tme, idx&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(sortedPeople, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedPeople[i][<span class="number">0</span>] &lt; sortedPeople[j][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    iter := <span class="number">0</span></span><br><span class="line">    preSum := <span class="number">0</span></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(people))</span><br><span class="line">    <span class="keyword">for</span> _, personTime := <span class="keyword">range</span> sortedPeople &#123;</span><br><span class="line">        <span class="keyword">for</span> iter &lt; <span class="built_in">len</span>(sortedMapPair) &amp;&amp; sortedMapPair[iter][<span class="number">0</span>] &lt;= personTime[<span class="number">0</span>] &#123;</span><br><span class="line">            preSum += sortedMapPair[iter][<span class="number">1</span>]</span><br><span class="line">            iter += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans[personTime[<span class="number">1</span>]] = preSum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>23. 合并 K 个升序链表</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/hard/23.%20%E5%90%88%E5%B9%B6%20K%20%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> lists = [[1,4,5],[1,3,4],[2,6]]<br />
<strong>输出：</strong>[1,1,2,3,4,4,5,6]<br />
<strong>解释：</strong> 链表数组如下：<br />
[<br />
1-&gt;4-&gt;5,<br />
1-&gt;3-&gt;4,<br />
2-&gt;6<br />
]<br />
将它们合并到一个有序链表中得到。<br />
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> lists = []<br />
<strong>输出：</strong>[]</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> lists = [[]]<br />
<strong>输出：</strong>[]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>k == lists.length</code><br />
</li>
<li><code>0 &lt;= k &lt;= 10^4</code><br />
</li>
<li><code>0 &lt;= lists[i].length &lt;= 500</code><br />
</li>
<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code><br />
</li>
<li><code>lists[i]</code> 按 <strong>升序</strong> 排列<br />
</li>
<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>
</ul>
<p>多个元素只取最大最小，可以使用大根堆和小根堆，C++中使用<code>priority_queue&lt;type, container&lt;type&gt;, compare_object&gt;</code>来使用堆。通过传入自定义的lambda函数或者仿函数对象给第三个模板参数来自定义元素在堆中的下沉比较，当参与比较的两个元素在比较函数返回true时，第一个元素将会保留在堆顶，否则是第二个元素，通过控制比较函数来获得大根堆或者小根堆。</p>
<p>因为我们不知道链表数组中到底有多少条链表，所以不推荐把每条链表的所有结点都遍历到并放入堆中，最后再一个一个从堆顶取来形成答案链表，虽然这样也可以，但是肯定不优雅。</p>
<p>我们可以递进式的推进链表的结点遍历过程。先把所有的链表头节点加入到小根堆中，然后根据结点的值大小，从堆顶弹出最小值的结点，并把它连接在我们自己的链表后面，然后放入该弹出结点的下一个结点到堆中（如果这个next不是nullptr的话），我们必须在弹出一个节点后，把该节点的下一个非空结点放入堆中，否则堆不就是遍历完头节点就空了吗。这是必要的，否则会漏掉很多值；比如某些头节点的值本身就很高，有某些链表整条链的节点值都在这个头节点之下，那么肯定是其他链表先全部连接完再轮到起始值比较大的这条链表了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> pair_comp = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, ListNode*&gt;&amp; pa, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, ListNode*&gt;&amp; pb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pa.first &gt; pb.first;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        std::priority_queue&lt;</span><br><span class="line">            std::pair&lt;<span class="type">int</span>, ListNode*&gt;,</span><br><span class="line">            std::vector&lt;std::pair&lt;<span class="type">int</span>, ListNode*&gt;&gt;,</span><br><span class="line">            <span class="keyword">decltype</span>(pair_comp)</span><br><span class="line">        &gt; pq;</span><br><span class="line"></span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* dumy = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ListNode*&amp; tmp_list : lists)</span><br><span class="line">            <span class="keyword">if</span> (tmp_list) pq.<span class="built_in">push</span>(&#123;tmp_list-&gt;val, tmp_list&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* top_node = pq.<span class="built_in">top</span>().second;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            head-&gt;next = top_node;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (top_node-&gt;next)</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;top_node-&gt;next-&gt;val, top_node-&gt;next&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dumy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>2681. 英雄的力量</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/hard/2681.%20%E8%8B%B1%E9%9B%84%E7%9A%84%E5%8A%9B%E9%87%8F/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的 <strong>力量</strong> 定义为：</p>
<ul>
<li><code>i0</code> ，<code>i1</code> ，... <code>ik</code> 表示这组英雄在数组中的下标。那么这组英雄的力量为 <code>max(nums[i0],nums[i1] ... nums[ik])2 * min(nums[i0],nums[i1] ... nums[ik])</code> 。</li>
</ul>
<p>请你返回所有可能的 <strong>非空</strong> 英雄组的 <strong>力量</strong> 之和。由于答案可能非常大，请你将结果对 <code>109 + 7</code> <strong>取余。</strong></p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> nums = [2,1,4]<br />
<strong>输出：</strong> 141<br />
<strong>解释：</strong> 第 1 组：[2] 的力量为 22 * 2 = 8 。<br />
第 2 组：[1] 的力量为 12 * 1 = 1 。<br />
第 3 组：[4] 的力量为 42 * 4 = 64 。<br />
第 4 组：[2,1] 的力量为 22 * 1 = 4 。<br />
第 5 组：[2,4] 的力量为 42 * 2 = 32 。<br />
第 6 组：[1,4] 的力量为 42 * 1 = 16 。<br />
第​ ​​​​​​7 组：[2,1,4] 的力量为 42​​​​​​​ * 1 = 16 。<br />
所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> nums = [1,1,1]<br />
<strong>输出：</strong> 7<br />
<strong>解释：</strong> 总共有 7 个英雄组，每一组的力量都是 1
。所以所有英雄组的力量之和为 7 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length <span class="math inline">\(\leq\)</span> <span
class="math inline">\(10^5\)</span><br />
</li>
<li>1 &lt;= nums[i] <span class="math inline">\(\leq\)</span> <span
class="math inline">\(10^9\)</span></li>
</ul>
<p>刚开始看题没看到数据范围之前，觉得这题可以用排列组合把可能的元素组合列出来然后直接算，但是发现这样每个组合的最大最小值都是O(n)，而列出所有组合已经是O(<span
class="math inline">\(n^2\)</span>)了，所以这个方法行不通，后来看到数据范围直接人傻了。很久没做题了，这题没什么思路，看到标签里有前缀和，知道需要排序，但是排序之后怎么做没有思路。</p>
<p>官方题解是通过动态规划分解为子问题来求解。但其实这题另外一个关键的难点是取余求模。</p>
<p>首先涉及到子序列相关的问题，我们可以把问题拆分为找到所有子序列和应用在某个子序列之上的计算过程，而某个子序列又刚好是其他更大子序列的一个子集，这完全符合动态规划要求拆分为子问题的思想，因此子序列和动态规划是非常容易结合在一起的。</p>
<p>因为本题计算涉及到的数值是子序列的最大值和最小值，与子序列的元素排列顺序无关，因此可以先对整个数组进行排序，这样，每个子序列的最大值最小值都是有迹可循了，最大值就是子序列的最后一个值，最小值就是子序列的最后一个值。</p>
<p>设 dp[i]
为排序后，以nums[i]结尾的各个子序列的最小值的和，根据前一段所述，我们知道这些子序列的最大值都是nums[i]，所以乘法分配律，只需要知道所有子序列的最小值即可计算出以nums[i]结尾的所有子序列的英雄力量之和：<span
class="math inline">\(max_i^2 \times (min_i + min_j + \cdots +
min_0)\)</span>。由于最小的子序列就是只有一个值的序列，最大值和最小值都是它自己。因此dp[i]所涉及的最小子序列中，还包括nums[i]自己，则dp[i]的计算式为：<br />
<span class="math display">\[  
dp[i] = nums[i] + \sum_{j=0}^{i-1}dp[j]  
\]</span><br />
那么以nums[i]为结尾的子序列的英雄组的力量之和为：<br />
<span class="math display">\[  
nums[i] \times nums[i] \times dp[i]  
\]</span></p>
<p>但是上述做法存在两个嵌套的<span
class="math inline">\(O(n)\)</span>复杂度，首先是计算所有子序列最小值之和有一次遍历操作（0到i-1），然后是计算每个nums[i]的英雄组力量之和（0到n）。发现每次计算所有子序列的最小值之和都是上一个值加上当前的nums[i]就行了，所以这里可以用前缀和优化，实现<span
class="math inline">\(O(1)\)</span>的复杂度，这样整体算法就变成了<span
class="math inline">\(O(n)\)</span>，然后又发现，每次计算所有子序列最小值之和，除了用到当前的nums[i]和dp[i-1]之外，之前的值没有再用了，所以前缀和数组也可以通过滚动数组的方式优化为只保留前一个“所有子序列最小值之和”这个值来优化空间复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfPower</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> arrLen = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dpi = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> psm = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mod = (<span class="type">int</span>)(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dpi = (nums[i] + psm) % mod;</span><br><span class="line">            psm = (psm + dpi) % mod;</span><br><span class="line">            res = (<span class="type">int</span>)((res + (<span class="type">long</span> <span class="type">long</span>)nums[i] * nums[i] % mod * dpi) % mod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第二个难点是数值类型和取模，因为nums[i]有可能取值到<span
class="math inline">\(1\times10^9\)</span>也就是十亿级别，而普通的int只能支持到二十亿左右，因此nums[i]取出来先转为更大的数值类型再参与运算，这样才不会发生中间结果溢出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfPower</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arrLen <span class="type">int</span> = <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dpi <span class="type">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> psm <span class="type">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> res <span class="type">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> mod = <span class="type">uint64</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; arrLen; i++ &#123;</span><br><span class="line">        dpi = (<span class="type">uint64</span>(nums[i]) + psm) % mod</span><br><span class="line">        psm = (psm + dpi) % mod</span><br><span class="line">        res = (res + <span class="type">uint64</span>(nums[i]) * <span class="type">uint64</span>(nums[i]) % mod * dpi) % mod</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>630. 课程表 III</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/hard/630.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20III/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>这里有 <code>n</code> 门不同的在线课程，按从 <code>1</code> 到 <code>n</code> 编号。给你一个数组 <code>courses</code> ，其中 <code>courses[i] = [durationi, lastDayi]</code> 表示第 <code>i</code> 门课将会 <strong>持续</strong> 上 <code>durationi</code> 天课，并且必须在不晚于 <code>lastDayi</code> 的时候完成。</p>
<p>你的学期从第 <code>1</code> 天开始。且不能同时修读两门及两门以上的课程。</p>
<p>返回你最多可以修读的课程数目。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> courses = [[100, 200], [200, 1300], [1000,
1250], [2000, 3200]]<br />
<strong>输出：</strong> 3<br />
<strong>解释：</strong><br />
这里一共有 4 门课程，但是你最多可以修 3 门：<br />
首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101
天开始下门课。<br />
第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101
天开始下门课程。<br />
第三，修第 2 门课，耗时 200 天，在第 1300 天完成。<br />
第 4 门课现在不能修，因为将会在第 3300
天完成它，这已经超出了关闭日期。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> courses = [[1,2]]<br />
<strong>输出：</strong> 1</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> courses = [[3,2],[4,3]]<br />
<strong>输出：</strong> 0</p>
<p>本题读完题之后大致可以猜到，需要对原数组进行排序，以及需要优先队列来维护某个性质的变量。但问题是给定数组的元素包含两个数字，到底需要以哪一个为排序标准暂时不得而知。另外优先队列需要如何使用也暂时不得而知。我们可以先假设最晚结束时间越早的课程应该需要先学习，也可以假设课程所需时间越短的课程先上课。到这里暂时就没有什么思路了。</p>
<p>官方题解的优先队列+贪心也需要一定的时间来理解。官方题解如下：</p>
<h2 id="思路">思路</h2>
<p>对于两门课程 <span class="math inline">\((t_1,d_1)\)</span> 和 <span
class="math inline">\((t_2,d_2)\)</span> ，如果后者的关闭时间较晚，即
<span class="math inline">\(d1 &lt; d2\)</span>
，那么我们先学习前者，再学习后者，总是最优的。这是因为：<br />
设开始学习的时间点为 <span class="math inline">\(x\)</span>。<br />
* 如果先学习前者，再学习后者，那么需要满足：<br />
<span class="math display">\[  
\left\{  
\begin{aligned}  
x + t_1 &amp;\leq d_1 \\  
x + t_1 + t_2 &amp;\leq d_2 \\  
\end{aligned}  
\right.  
\]</span><br />
* 如果先学习后者，再学习前者，那么需要满足：<br />
<span class="math display">\[  
\left\{  
\begin{aligned}  
x + t_2 &amp;\leq d_2 \\  
x + t_2 + t_1 &amp;\leq d_1 \\  
\end{aligned}  
\right.  
\]</span></p>
<p>如果 <span class="math inline">\(x + t_2 + t_1 \leq d_1\)</span>
成立，那么由于 <span class="math inline">\(d_1 \leq d_2\)</span> 则有
<span class="math inline">\(x + t_2 + t_1 \leq d_1 \leq d_2\)</span>
并且有 <span class="math inline">\(x + t_1 \leq d_1\)</span>
，也就是说如果先学后面的课程也能完成，那么先学前面的课程是一定能完成的。但是由先学习前面的课程的约束条件不能得出后面的课程也能在
<span class="math inline">\(d_2\)</span> 之前完成例如当 <span
class="math inline">\(x = 0\)</span>, <span class="math inline">\((t_1,
d_1) = (2, 3)\)</span>，<span class="math inline">\((t_2, d_2) = (5,
100)\)</span>
时，虽然能「先学习前者，再学习后者」，但不能「先学习后者，再学习前者」。</p>
<p>因此，我们可以讲所有的课程按照关闭时间 <span
class="math inline">\(d\)</span> 进行升序排序，再依次挑选课程并按照顺序进行学习。</p>
<p>在遍历的过程中，假设我们当前遍历到了第 <span
class="math inline">\(i\)</span> 门课 <span class="math inline">\((t_i,
d_i)\)</span>，而在前 <span class="math inline">\(i-1\)</span>
门课程中我们选择了 <span class="math inline">\(k\)</span> 门课 <span
class="math inline">\((t_{x1},d_{x1}),(t_{x2},d_{x2}),\dots
,(t_{xk},d_{xk})\)</span> ，且满足 <span class="math inline">\(x_1 &lt;
x_2 &lt; \dots &lt; x_k\)</span> ，那么有：<br />
<span class="math display">\[  
\left\{  
\begin{aligned}  
t_{x1} &amp;\leq d_{x1} \\  
t_{x1} + t_{x2} &amp;\leq d_{x2} \\  
\cdots \\  
t_{x1} + t_{x2} + \dots + t_{xk} &amp;\leq d_{xk}  
\end{aligned}  
\right.  
\]</span><br />
假定上述选择方案是前 <span class="math inline">\(i-1\)</span>
门课程的最优选择方案，即不存在能选择 <span
class="math inline">\(k+1\)</span>
门课程的方案（课程数量更多所以更优），也不存在能在选择 <span
class="math inline">\(k\)</span>
门课程时总时长比当前方案更短的方案（时间更短所以更优），那么我们可以根据前
<span class="math inline">\(i-1\)</span> 门课程的这个最优方案来构造前
<span class="math inline">\(i\)</span> 门课程的最优方案：<br />
* 如果 <span class="math inline">\(t_{x1} + t_{x2} + \dots + t_{xk} \leq
d_{xk}\)</span> ，那么我们可以直接将第 <span
class="math inline">\(i\)</span>
门课程加入到已选课程列表当中，此时的方案就是前 <span
class="math inline">\(i\)</span>
门课程的最优方案了，可以通过如下的反证法来证明：<br />
* 假设我们在遍历到第 <span class="math inline">\(i\)</span>
门课程的时候，把它加入到课程列表的方案并不能成为最优方案，那么一定还存在着一个更优的方案，那个方案不需要第
<span class="math inline">\(i\)</span>
门课程就能达到更多的课程数量，既然有无第 <span
class="math inline">\(i\)</span>
门课程都不影响这个最优方案的存在，那么其实这个方案也就是前 <span
class="math inline">\(i-1\)</span>
门课程的最优方案了，这与我们的假设已经矛盾了。<br />
* 假设最优方案也是需要加入第 <span class="math inline">\(i\)</span>
门课程的，根据我们之前的推论：<strong>「先学习前者，再学习后者，总是最优的」</strong>，我们可以把前
<span class="math inline">\(i-1\)</span>
门课程看作是一门大课程，然后是第 <span class="math inline">\(i\)</span>
门课程，如果当前方案和那个假设的最优方案都暂时不学习第 <span
class="math inline">\(i\)</span>
门课程了，那么那个假设存在的最优方案不就是前 <span
class="math inline">\(i-1\)</span>
门课程的最优方案了吗？这同样也与我们的假设矛盾了。</p>
<ul>
<li>如果 <span class="math inline">\(t_{x1} + t_{x2} + \dots + t_{xk}
&gt; d_{xk}\)</span> ，那么现在第 <span class="math inline">\(i\)</span>
门课程的学习时间超过了最晚结课时间，我们无法将这门课程加入到已选课程列表中，因为题目没有限制每门课程的学习开始时间，因此我们可以考虑第
<span class="math inline">\(i\)</span>
门课程能不能用于替换掉前面的某个课程来使得当前的课程列表中所有课程的学习时间更短，为后续的课程腾出更多的时间来获得更多选择的可能性。如果
<span class="math inline">\(t_{x1}, t_{x2}, \dots, t_{xk}\)</span>
都小于等于 <span
class="math inline">\(t_i\)</span>，那么显然我们并不能通过替换课程来使得学习所有课程的时间减少。但如果其中学习时间最长的那门课程的学习时间
<span class="math inline">\(t_{xj}\)</span> 大于 <span
class="math inline">\(t_i\)</span>
的话，则我们可以替换掉这门课程来获得更短的总学习时间了，这样的替换会使得总学习时间减少
<span class="math inline">\(t_{xj} -
t_i\)</span>。替换课程之后学习时间是否还满足在结课时间之前的要求呢？
<ul>
<li>对于课程 <span class="math inline">\(x_1, x_2, \dots,
x_{j-1}\)</span>，这显然是满足的，因为替换的课程是 <span
class="math inline">\(x_j\)</span>，这并不会影响到前面课程<br />
</li>
<li>对于 <span class="math inline">\(x_{j+1}, \dots, x_{k}\)</span>
的课程，由于缺少了课程 <span
class="math inline">\(x_j\)</span>，由于原先本就是符合要求的，现在少上一门课，预留的可调整时间变多了，自然可以提前学习课程，那么也不会超过这些课程的原本的结课时间<br />
</li>
<li>总的来说，因为原不等式 <span class="math inline">\(t_1 + t_2 +
\cdots + t_{xk} &lt; d_{xk}\)</span> 且 <span
class="math inline">\(t_{xj} &lt; t_i\)</span>，则将 <span
class="math inline">\(t_{xj}\)</span> 替换为 <span
class="math inline">\(t_i\)</span> 时，原不等式也一定满足</li>
</ul></li>
</ul>
<p>有了上述的贪心方案之后，我们在遍历完所有课程时就可以确定我们的选课列表了。</p>
<h2 id="算法">算法</h2>
<p>我们需要一个数据结构能够支持直接取出当前课程列表中所需学习时间最长的那门课程的学习时间，因此可以使用大根堆来维护课程列表中课程的学习时间。我们一次遍历每一门课程，当遍历到<span
class="math inline">\((t_i, d_i)\)</span> 时：<br />
* 如果当前优先队列中的学习时间总时间 + <span
class="math inline">\(t_i\)</span> 小于等于 <span
class="math inline">\(d_i\)</span>，那么直接将第 <span
class="math inline">\(i\)</span> 门课程的学习时间 <span
class="math inline">\(ti\)</span>，加入到优先队列中进行维护<br />
* 如果当前优先队列中的学习时间总时间 + <span
class="math inline">\(t_i\)</span> 大于 <span
class="math inline">\(d_i\)</span>，那么我们尝试进行课程替换，检测优先队列的堆顶（也就是最长的学习时间）<span
class="math inline">\(t_{xj}\)</span> 是否大于当前课程的学习时间 <span
class="math inline">\(t_i\)</span>，如果 <span
class="math inline">\(t_{xj} &gt; t_i\)</span>，那么将 <span
class="math inline">\(t_{xj}\)</span> 弹出堆顶，并将 <span
class="math inline">\(t_i\)</span> 加入到优先队列中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scheduleCourse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(</span><br><span class="line">            courses.<span class="built_in">begin</span>(),</span><br><span class="line">            courses.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; p0, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; p1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// return true if you want p0 ahead of p1</span></span><br><span class="line">                <span class="keyword">return</span> p0[<span class="number">1</span>] &lt; p1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;uint, vector&lt;uint&gt;, less&lt;uint&gt;&gt; pq;</span><br><span class="line">        uint time_cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; course : courses)</span><br><span class="line">        &#123;</span><br><span class="line">            uint ti = course[<span class="number">0</span>];</span><br><span class="line">            uint di = course[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (time_cost + ti &lt;= di)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// try to maximize course amount</span></span><br><span class="line">                time_cost += ti;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>() &gt; ti)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// try to minimize course time cost</span></span><br><span class="line">                time_cost -= (pq.<span class="built_in">top</span>() - ti);</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                pq.<span class="built_in">emplace</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkIfPrerequisite</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>, queries [][]<span class="type">int</span>)</span></span> []<span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// try Floyd-Warshall algorithm</span></span><br><span class="line">    adjcentMatrix := <span class="built_in">make</span>([][]<span class="type">bool</span>, numCourses);</span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> adjcentMatrix &#123;</span><br><span class="line">        adjcentMatrix[idx] = <span class="built_in">make</span>([]<span class="type">bool</span>, numCourses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, prep := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        adjcentMatrix[prep[<span class="number">0</span>]][prep[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; numCourses; k++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; numCourses; j++ &#123;</span><br><span class="line">                adjcentMatrix[i][j] = adjcentMatrix[i][j] || (adjcentMatrix[i][k] &amp;&amp; adjcentMatrix[k][j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(queries))</span><br><span class="line">    <span class="keyword">for</span> idx, query := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        <span class="keyword">if</span> adjcentMatrix[query[<span class="number">0</span>]][query[<span class="number">1</span>]] &#123;</span><br><span class="line">            ans[idx] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LCP 04. 覆盖</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/hard/LCP%2004.%20%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h2 id="困难">[<span style="color:red;">困难</span>]</h2>
<p>你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为<code>1 * 2</code>的多米诺骨牌，你想把这些骨牌<strong>不重叠</strong>地覆盖在<strong>完好</strong>的格子上，请找出你最多能在棋盘上放多少块骨牌？这些骨牌可以横着或者竖着放。</p>
<p>输入：<code>n, m</code>代表棋盘的大小；<code>broken</code>是一个<code>b * 2</code>的二维数组，其中每个元素代表棋盘上每一个坏掉的格子的位置。</p>
<p>输出：一个整数，代表最多能在棋盘上放的骨牌数。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> n = 2, m = 3, broken = [[1, 0], [1, 1]]<br />
<strong>输出：</strong> 2<br />
<strong>解释：</strong> 我们最多可以放两块骨牌：[[0, 0], [0, 1]]以及[[0,
2], [1, 2]]。（见下图）</p>
<p><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/09/domino_example_1.jpg" /></p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> n = 3, m = 3, broken = []<br />
<strong>输出：</strong> 4<br />
<strong>解释：</strong> 下图是其中一种可行的摆放方式</p>
<p><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/09/domino_example_2.jpg" /></p>
<p><strong>限制：</strong></p>
<ol type="1">
<li><code>1 &lt;= n &lt;= 8</code><br />
</li>
<li><code>1 &lt;= m &lt;= 8</code><br />
</li>
<li><code>0 &lt;= b &lt;= n * m</code></li>
</ol>
<p>本题可以转化为二分图问题，将网格的相邻格子涂成不同颜色，这样就得到了两个不同颜色的格子集合。这样涂色后的棋盘，一个骨牌需要占据两个不同颜色的格子，可以把顾盼抽象为连接两个集合中对应点的一条边；这样，放置最多的骨牌问题就转化为了求解二分图的最大匹配问题，也即给定两个集合找到匹配最多的匹配方式。二分图的定义可以参考<a
href="https://leetcode-cn.com/problems/is-graph-bipartite/">785.
判断二分图</a><br />
<img
src="https://pic.leetcode-cn.com/1630982158-ZqfjKv-image.png" /><br />
二分图最大匹配问题，一般可以用匈牙利算法解决。在介绍匈牙利算法之前，我们需要明确一些专有名词：<br />
1.
匹配集合：我们最终的目标是最大化边的数量，这些边将加入匹配集合。<br />
2.
匹配边、匹配点：在二分图中，如果我们本次将两个点连成的边加入匹配集合，就说我们当前将这条边作为了匹配边，边的两个端点均称作匹配点。<br />
3.
未匹配边、未匹配点：在二分图中，如果一个点有一条以上的边，并且其中某一条边已经被加入了匹配集合成为了匹配边，那么剩余的边均称作未匹配边，这些边的另一个端点称为未匹配点。<br />
4.
增广路：以未匹配边开始和结束，且未匹配边与匹配边交替出现的路径。<br />
<img
src="https://pic.leetcode-cn.com/1630983504-mVLUxa-image.png" /><br />
为了便于大家理解，我们通过下图（红框和篮框分别表示二分图中的两部分，黑色圆圈表示不同的点。黄色和绿色线条都表示点之间的边）来解释上面
4 个概念：</p>
<p>我们首先将 1 号点和 5
号点之间的边放入匹配集合，该边就变成了匹配边（黄色标识）。111 和 555
号点就均变为了匹配点，此时，这两个点连接的其他边（(1,7),(2,5),(4,5)）就称作未匹配边，对应的点
2,4,7 就均称作未匹配点。我们其次将 333 号点和 666
号点之间的边放入匹配集合，该边就变成了匹配边，这两个点变为了匹配点。由于这两个点没有连其他的边，所以不会出现新的未匹配边。</p>
<p>此时，我们发现，路径 2−5−1−7 就是一条 未匹配边-匹配边-未匹配边
组合的增广路径。</p>
<p>明确了这些概念后，我们便来看我们的匈牙利算法：</p>
<ol type="1">
<li>初始时，最大匹配集合为空。<br />
</li>
<li>我们先找到一组匹配边，加入匹配集合。<br />
</li>
<li>找到一条增广路径，我们将其中的所有匹配边变为未匹配边，将所有的未匹配边变为匹配边。<br />
</li>
<li>循环步骤 ，直到图中不存在增广路径。算法结束<br />
匈牙利算法中，最重要的便是步骤 。我们来深入理解一下：</li>
</ol>
<p>对于一条增广路径，根据其定义，必定含有 k+1 条未匹配边以及 k
条匹配边。那么，步骤 3
的作用，其实就是将未匹配边和匹配边互换，这样，该路径上就会更新为 kkk
条未匹配边以及 k+1 条匹配边，这样匹配边的数量就比互换之前多了 1
个。结合刚才的图片来看：<br />
<img
src="https://pic.leetcode-cn.com/1630984075-avxQSO-image.png" /><br />
我们将增广路径 2−5−1−7 上的未匹配边 (2,5),(1,7) 变为匹配边，将匹配边
(5,1)
变为未匹配边，图中总匹配边数就从原来的两条（(1,5),(3,6)）变成了三条（(2,5),(1,7),(3,6)）。</p>
<p>以上就是我们的匈牙利算法啦！在代码中，我们使用了二分图模板
BinaryGraph 类初始化二分图，利用其中的 add 函数完成加边，并利用其中的
solve 方法即可直接求得最大匹配。</p>
<p>作者：算法小爱<br />
链接：https://leetcode.cn/problems/broken-board-dominoes/solutions/983247/suan-fa-xiao-ai-cong-ling-dao-yi-jiao-hu-8b4k/<br />
来源：力扣（LeetCode）<br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BipartiteGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; seta; <span class="comment">// set A</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; setb; <span class="comment">// set B</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visi; <span class="comment">// visited or not</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_a = <span class="number">0</span>;    <span class="comment">// number of elements in set A</span></span><br><span class="line">    <span class="type">int</span> num_b = <span class="number">0</span>;    <span class="comment">// number of elements in set B</span></span><br><span class="line">    <span class="type">int</span> stamp = <span class="number">0</span>;    <span class="comment">// time stamp of each step</span></span><br><span class="line">    <span class="type">int</span> match = <span class="number">0</span>;    <span class="comment">// maximum matches magnitude</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BipartiteGraph</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">BipartiteGraph</span>(<span class="type">int</span> na, <span class="type">int</span> nb) : <span class="built_in">num_a</span>(na), <span class="built_in">num_b</span>(nb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(na &gt;= <span class="number">0</span> &amp;&amp; nb &gt;= <span class="number">0</span>);</span><br><span class="line">        seta = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(na, <span class="number">-1</span>);</span><br><span class="line">        setb = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nb, <span class="number">-1</span>);</span><br><span class="line">        visi = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(na);</span><br><span class="line">        graph.<span class="built_in">resize</span>(na);</span><br><span class="line"></span><br><span class="line">        stamp = <span class="number">0</span>;</span><br><span class="line">        match = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dst)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(src &gt;= <span class="number">0</span> &amp;&amp; dst &gt;= <span class="number">0</span>);</span><br><span class="line">        graph[src].<span class="built_in">push_back</span>(dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> vtx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visi[vtx] = stamp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; nbg : graph[vtx])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (setb[nbg] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                seta[vtx] = nbg;</span><br><span class="line">                setb[nbg] = vtx;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; nbg : graph[vtx])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visi[setb[nbg]] != stamp &amp;&amp; <span class="built_in">dfs</span>(setb[nbg]))</span><br><span class="line">            &#123;</span><br><span class="line">                seta[vtx] = nbg;</span><br><span class="line">                setb[nbg] = vtx;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stamp++;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// find all augment paths</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_a; ++i)</span><br><span class="line">                <span class="keyword">if</span> (seta[i] == <span class="number">-1</span> &amp;&amp; <span class="built_in">dfs</span>(i)) cnt++;</span><br><span class="line">            <span class="comment">// if there is no augment path anymore, exit</span></span><br><span class="line">            <span class="keyword">if</span> (!cnt) <span class="keyword">break</span>;</span><br><span class="line">            match += cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> match;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">domino</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; broken)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">isok</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pos : broken)</span><br><span class="line">            isok[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">BipartiteGraph <span class="title">bg</span><span class="params">(n * m, m * n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// broken position, skipped</span></span><br><span class="line">                <span class="keyword">if</span> (!isok[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// we only need to build edges from one side</span></span><br><span class="line">                <span class="keyword">if</span> ((i + j) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; ++d)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> drow = i + dirs[d][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> dcol = j + dirs[d][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (drow &lt; <span class="number">0</span> || drow &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dcol &lt; <span class="number">0</span> || dcol &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!isok[drow][dcol]) <span class="keyword">continue</span>;</span><br><span class="line">                    bg.<span class="built_in">add</span>(i * m + j, drow * m + dcol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bg.<span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>1004. 最大连续1的个数 III</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1004.%20%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20III/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p>
<p><strong>示例 1：</strong><br />
<strong>输入：</strong>
<code>nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2</code><br />
<strong>输出：</strong> <code>6</code><br />
<strong>解释：</strong>
<code>[1,1,1,0,0,**1**,1,1,1,1,**1**]</code><br />
粗体数字从 0 翻转到 1，最长的子数组长度为 6。</p>
<p><strong>示例 2：</strong><br />
<strong>输入：</strong>
<code>nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</code><br />
<strong>输出：</strong> <code>10</code><br />
<strong>解释：</strong>
<code>[0,0,1,1,**1**,**1**,1,1,1,**1**,1,1,0,0,0,1,1,1,1]</code><br />
粗体数字从 0 翻转到 1，最长的子数组长度为 10。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code><br />
</li>
<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code><br />
</li>
<li><code>0 &lt;= k &lt;= nums.length</code></li>
</ul>
<p>首先看到数据范围，已经到了 <span class="math inline">\(10^5\)</span>
了，也就是如果使用暴力空间求解以保证时间复杂度的话，起码要开十万级别的数组，这是不现实的。</p>
<p>一个基本的思路是使用双指针，虽然这题可能看起来和前缀和有点关系，但是仔细思考，如果本体使用前缀和的话，是需要统计什么的和呢？某个元素及其左边的
<span class="math inline">\(1\)</span> 的数量？<span
class="math inline">\(0\)</span>
的数量？统计完的信息需要如何利用呢？我们需要最长的连续 <span
class="math inline">\(1\)</span> 的子数组，那么每一段连续 <span
class="math inline">\(1\)</span> 子数组之间的 <span
class="math inline">\(0\)</span>
也需要被单独遍历考虑到，否则很可能导致有用信息的遗漏，如果单纯地只是比较相邻的两个连续
<span class="math inline">\(1\)</span> 子数组中间的 <span
class="math inline">\(0\)</span>
是否能被填充满从而将两个连续子数组连接起来，这样会导致某些情况被漏掉：<br />
1.
被孤立在中央的数组，无法连接到两边的连续子数组，但是它的长度加上可翻转的
<span class="math inline">\(0\)</span>
之后是最长的，比左右两侧那些短的碎片子数组连接起来要长多了<br />
2. 最边上的两个连续子数组也许其左右侧就已经是数组的两端了，没有空余的
<span class="math inline">\(0\)</span></p>
<p>所以本题最好的方法还是使用双指针，假设头指针是 <span
class="math inline">\(q\)</span> ，尾指针是 <span
class="math inline">\(p\)</span>，使用双指针我们需要考虑两件事情：<br />
1. 前面的指针 <span class="math inline">\(q\)</span>
在什么条件下可以前进以及什么条件下需要停止等待<br />
2. 后面的指针 <span class="math inline">\(p\)</span>
在什么条件下可以前进以及什么条件下需要停止等待</p>
<p>很明显，指针 <span class="math inline">\(q\)</span> 只要反转 <span
class="math inline">\(0\)</span>
的次数没有使用完就可以一直往前走，直到遇到某个 <span
class="math inline">\(0\)</span>
的时候，翻转次数也已经用完了，此时头指针 <span
class="math inline">\(q\)</span>
必须停下；这个时候就应该轮到后面的尾指针 <span
class="math inline">\(p\)</span> 行动了，指针 <span
class="math inline">\(p\)</span> 应该前进多少呢？应该在离开 <span
class="math inline">\(0\)</span>
的时候补充一次翻转次数，并且只要补充了一次翻转次数就可以停下来，这里无需将翻转次数还原到最大容量再停止，因为这样可能会使得指针
<span class="math inline">\(p\)</span>
前进的太多而导致我们忽略了不应该忽略的 <span
class="math inline">\(0\)</span>，毕竟我们的最大长度是由 <span
class="math inline">\(q - p\)</span>
决定的，而我们当然希望这个值尽可能地大，也就是说，尾指针应该尽可能地不前进，头指针应该尽可能地前进。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (K == len)</span><br><span class="line">            <span class="keyword">return</span> K;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; len &amp;&amp; r &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[r] || K)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!A[r++])</span><br><span class="line">                    K--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!A[l++])</span><br><span class="line">                    r++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res &gt; r - l ? res : r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。
（即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" /></p>
<p><strong>输入：</strong> root = [3,9,20,null,null,15,7]<br />
<strong>输出：</strong>[[3],[9,20],[15,7]]</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> root = [1]<br />
<strong>输出：</strong>[[1]]</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> root = []<br />
<strong>输出：</strong>[]</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内<br />
</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>非常经典的题，可以使用队列存储每一层的非空节点，通过在遍历每一层之前确定每一层的节点数量，这样就可以完整地获得一层的节点了。重点在于遍历当前层的节点的时候，准备好下一层的节点到队列之中，因为每一层只处理固定数量的节点，所以遍历当前层在对类中的节点时不会不小心消耗掉下一层的节点。</p>
<p>C++:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; levelTraversal;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; levelNodes;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (levelSize--)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* curr = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                levelNodes.<span class="built_in">push_back</span>(curr-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;left) q.<span class="built_in">emplace</span>(curr-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;right) q.<span class="built_in">emplace</span>(curr-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            levelTraversal.<span class="built_in">emplace_back</span>(levelNodes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> levelTraversal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Go:<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Enqueue(val <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *q = <span class="built_in">append</span>(*q, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Dequeue() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> q.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    front := (*q)[<span class="number">0</span>]</span><br><span class="line">    *q = (*q)[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> front</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q := Queue&#123;&#125;</span><br><span class="line">    levelTraversal := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    q.Enqueue(root)</span><br><span class="line">    <span class="keyword">for</span> !q.IsEmpty() &#123;</span><br><span class="line">        levelNodes := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(q)</span><br><span class="line">        <span class="keyword">for</span> ; levelSize != <span class="number">0</span>; levelSize-- &#123;</span><br><span class="line">            curr := q.Dequeue().(*TreeNode)</span><br><span class="line">            levelNodes = <span class="built_in">append</span>(levelNodes, curr.Val)</span><br><span class="line">            <span class="keyword">if</span> curr.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                q.Enqueue(curr.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> curr.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                q.Enqueue(curr.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        levelTraversal = <span class="built_in">append</span>(levelTraversal, levelNodes)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> levelTraversal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1109. 航班预订统计</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1109.%20%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>这里有 <code>n</code> 个航班，它们分别从 <code>1</code> 到 <code>n</code> 进行编号。</p>
<p>有一份航班预订表 <code>bookings</code> ，表中第 <code>i</code> 条预订记录 <code>bookings[i] = [firsti, lasti, seatsi]</code> 意味着在从 <code>firsti</code> 到 <code>lasti</code> （<strong>包含</strong> <code>firsti</code> 和 <code>lasti</code> ）的 <strong>每个航班</strong> 上预订了 <code>seatsi</code> 个座位。</p>
<p>请你返回一个长度为 <code>n</code> 的数组 <code>answer</code>，里面的元素是每个航班预定的座位总数。</p>
<p><strong>示例 1：</strong><br />
<strong>输入：</strong>
<code>bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</code><br />
<strong>输出：</strong> <code>[10,55,45,25,25]</code><br />
<strong>解释：</strong><br />
航班编号 1 2 3 4 5<br />
预订记录 1 ： 10 10<br />
预订记录 2 ： 20 20<br />
预订记录 3 ： 25 25 25 25<br />
总座位数： 10 55 45 25 25<br />
因此，answer = <code>[10,55,45,25,25]</code></p>
<p><strong>示例 2：</strong><br />
<strong>输入：</strong>
<code>bookings = [[1,2,10],[2,2,15]], n = 2</code><br />
<strong>输出：</strong> <code>[10,25]</code><br />
<strong>解释：</strong><br />
航班编号 1 2<br />
预订记录 1 ： 10 10<br />
预订记录 2 ： 15<br />
总座位数： 10 25<br />
因此，answer = <code>[10,25]</code></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 2 * 104</code><br />
</li>
<li><code>1 &lt;= bookings.length &lt;= 2 * 10^4</code><br />
</li>
<li><code>bookings[i].length == 3</code><br />
</li>
<li><code>1 &lt;= firsti &lt;= lasti &lt;= n</code><br />
</li>
<li><code>1 &lt;= seatsi &lt;= 10^4</code></li>
</ul>
<p>本题是差分数组的模板题，也是学习差分数组的非常好的入门题。差分数组是一个和前缀和数组相对的概念，前缀和数组每个位置
<span class="math inline">\(i\)</span> 的元素是 <span
class="math inline">\(nums[0] + nums[1] + \dots + nums[i]\)</span>
的和，也就是该位置之前的元素的累积量。差分数组的位置 <span
class="math inline">\(i\)</span> 则是原数组的 <span
class="math inline">\(nums[i] - nums[i - 1]\)</span>
的差，所以被称为差分数组。</p>
<p>前缀和数组需要花 <span class="math inline">\(O(n)\)</span>
的时间构建起来，但是之后的所有区间和查询操作都是 <span
class="math inline">\(O(1)\)</span> 的，当我们需要查询原数组区间 <span
class="math inline">\([i, j]\)</span> 的区间和的时候，只需要 <span
class="math inline">\(presum[j] - presum[i - 1]\)</span>
即可，这样就前去了前面一部分的前缀和，得到了中间这部分的前缀和。前缀和数组求每个元素原本的值也是
<span class="math inline">\(O(1)\)</span>
的，相当于区间和的区间长度是1罢了。</p>
<p>差分数组的构造需要花 <span class="math inline">\(O(n)\)</span>
的时间构造起来，第一个值的差分（也就是与前面那个不存在的值的差）可以就是它自己，这相当于数组的开头添加了一个伪数值0。差分数组的位置
<span class="math inline">\(i\)</span>，代表了原数组 <span
class="math inline">\(nums[i] - nums[i-1]\)</span>
的差。当我们构建好差分数组之后，所有的区间修改都是 <span
class="math inline">\(O(1)\)</span>
的，因为我们只需要修改差分数组区间两端的值即可表达这一个区间的统一修改（比如区间
<span class="math inline">\([i,j]\)</span> 统一 <span
class="math inline">\(+10\)</span>，或者统一 <span
class="math inline">\(-5\)</span>
等操作），这是与前缀和数组的区间修改优势相对应的。当我们希望给原数组的区间
<span class="math inline">\([i,j]\)</span> 的每个元素增加 <span
class="math inline">\(d\)</span> 时，我们只需要在差分数组中执行：<br />
<span class="math display">\[  
\left\{  
\begin{aligned}  
    presub[i] &amp;= presub[i] + d \\  
    presub[j + 1] &amp;= presub[i + 1] - d \\  
\end{aligned}  
\right.  
\]</span><br />
因为原数组从 <span class="math inline">\(nums[i]\)</span>
开始每个元素都增加了10，因此 <span class="math inline">\(nums[i] -
nums[i - 1]\)</span> 的差会增多10，因为 <span
class="math inline">\(nusm[i - 1]\)</span>
没有受到区间加操作的影响，还是原来的数值，即如果 <span
class="math inline">\(a - b = c\)</span> 那么 <span
class="math inline">\((a + d) - b = c + d\)</span>；而 <span
class="math inline">\(presub[j + 1]\)</span> 则需要减少增加量 <span
class="math inline">\(d\)</span> ，因为它的前一个数有了一个增量 <span
class="math inline">\(d\)</span>，而它自己却没有增量，因此差额减少 <span
class="math inline">\(d\)</span>。</p>
<p>完成所有的区间修改操作之后，我们只需要 <span
class="math inline">\(O(n)\)</span>
的时间对差分数组计算一次前缀和就可以得到原数组了，这是显而易见的，差分数组中的第一个数就是它本身，然后第二个数就是原数组第一个数到第二个数的差，因此加上这个差就得到了第二个数，以此类推继续把“与下一个数字的差”累积起来，就得到了原本的每一个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; bookings, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefixSub</span><span class="params">(n + <span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; book : bookings)</span><br><span class="line">        &#123;</span><br><span class="line">            prefixSub[book[<span class="number">0</span>]] += book[<span class="number">2</span>];</span><br><span class="line">            prefixSub[book[<span class="number">1</span>] + <span class="number">1</span>] -= book[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            prefixSub[i] += prefixSub[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(prefixSub.<span class="built_in">begin</span>() + <span class="number">1</span>, prefixSub.<span class="built_in">end</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1123. 最深叶节点的最近公共祖先</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1123.%20%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你一个有根节点 <code>root</code> 的二叉树，返回它 <em>最深的叶节点的最近公共祖先</em> 。</p>
<p>回想一下：</p>
<ul>
<li><strong>叶节点</strong> 是二叉树中没有子节点的节点<br />
</li>
<li>树的根节点的 <strong>深度</strong> 为 <code>0</code>，如果某一节点的深度为 <code>d</code>，那它的子节点的深度就是 <code>d+1</code><br />
</li>
<li>如果我们假定 <code>A</code> 是一组节点 <code>S</code> 的 <strong>最近公共祖先</strong>，<code>S</code> 中的每个节点都在以 <code>A</code> 为根节点的子树中，且 <code>A</code> 的深度达到此条件下可能的最大值。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img
src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" /></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4]<br />
<strong>输出：</strong>[2,7,4]<br />
<strong>解释：</strong> 我们返回值为 2 的节点，在图中用黄色标记。<br />
在图中用蓝色标记的是树的最深的节点。<br />
注意，节点 6、0 和 8 也是叶节点，但是它们的深度是 2 ，而节点 7 和 4
的深度是 3 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> root = [1]<br />
<strong>输出：</strong>[1]<br />
<strong>解释：</strong>
根节点是树中最深的节点，它是它本身的最近公共祖先。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> root = [0,1,3,null,2]<br />
<strong>输出：</strong>[2]<br />
<strong>解释：</strong> 树中最深的叶节点是 2
，最近公共祖先是它自己。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数将在 <code>[1, 1000]</code> 的范围内。<br />
</li>
<li><code>0 &lt;= Node.val &lt;= 1000</code><br />
</li>
<li>每个节点的值都是 <strong>独一无二</strong> 的。</li>
</ul>
<p><strong>注意：</strong>本题与力扣 865 重复：<a
href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/">https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/</a></p>
<p>这题一个比较简单的暴力思路是，直接利用前序遍历获得去到叶子节点的路径节点链表，有多少个相同深度的最深叶节点，最终就会统计到几条叶节点链路。在收集完这些叶节点链路后，直接遍历每一条链路的同层节点，只要有一次比较是不同的节点指针地址，那么说明岔路口发生在上一个节点，我们直接返回任意链路的上一个节点即可。</p>
<p>比较链路的时候，应该使用结点指针的地址值比较，而非节点存储的数据值
<code>val</code>，因为这不是严格二叉搜索树，所以不同节点之间的值有可能是一样的。</p>
<p>由于链路可能会很深，根据题目的数据范围来看，最多1000个节点，如果是最坏情况的二叉树，那么可能需要递归1000层才能获得完整的叶节点链路，为了避免开辟过多的栈帧导致爆栈，大部分参数应该使用引用传递，因此需要我们自己手动维护到达叶节点的链路，给前序遍历的所有探测共同使用，这要求我们设计合理的
<code>push_back</code> 和 <code>pop_back()</code>
的时机，最好是在函数进入时将该树节点压入链表，在函数离开时将本层的这个树节点去除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;TreeNode*&gt;&gt; pathVec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pathTracker</span><span class="params">(TreeNode* root, <span class="type">int</span> depth, vector&lt;TreeNode*&gt;&amp; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth)</span><br><span class="line">            &#123;</span><br><span class="line">                pathVec.<span class="built_in">clear</span>();</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (depth == maxDepth)</span><br><span class="line">                pathVec.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pathTracker</span>(root-&gt;left, depth + <span class="number">1</span>, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pathTracker</span>(root-&gt;right, depth + <span class="number">1</span>, path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; temPath;</span><br><span class="line">        <span class="built_in">pathTracker</span>(root, <span class="number">0</span>, temPath);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; path : pathVec)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode* node : path)</span><br><span class="line">                cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pathVec.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> pathVec[<span class="number">0</span>].<span class="built_in">back</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxDepth; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; pathVec.<span class="built_in">size</span>() - <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// the root(0) must be the same in all path</span></span><br><span class="line">                <span class="comment">// so we can omit the judgement of  whether</span></span><br><span class="line">                <span class="comment">// index &#x27;i&#x27; is valid.</span></span><br><span class="line">                <span class="keyword">if</span> (pathVec[j][i] != pathVec[j + <span class="number">1</span>][i])</span><br><span class="line">                    <span class="keyword">return</span> pathVec[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong><br />
<strong>输入：</strong><code>prices = [7,1,5,3,6,4]</code><br />
<strong>输出：</strong> <code>7</code><br />
<strong>解释：</strong> 在第 2 天（股票价格 = 1）的时候买入，在第 3
天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4
。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 =
6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。总利润为 4 + 3 = 7
。</p>
<p><strong>示例 2：</strong><br />
<strong>输入：</strong> <code>prices = [1,2,3,4,5]</code><br />
<strong>输出：</strong> <code>4</code><br />
<strong>解释：</strong> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天
（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。<br />
  总利润为 4 。</p>
<p><strong>示例 3：</strong><br />
<strong>输入：</strong> <code>prices = [7,6,4,3,1]</code><br />
<strong>输出：</strong> <code>0</code><br />
<strong>解释：</strong> 在这种情况下,
交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10^4</code><br />
</li>
<li><code>0 &lt;= prices[i] &lt;= 10^4</code></li>
</ul>
<p>把题意翻译成简单的程序需求描述就是，找到这个数组中的所有严格递增区间，然后累积这些区间的最大值减去最小值的差。可以使用双指针来做，涉及两个函数，检测给定的位置是波峰还是波谷，一个指针往前推进找波谷，然后一个指针移到波谷的位置往前推进找波峰的位置。</p>
<p>另外需要注意的是，我们的波峰波谷探测函数需要解决非严格递增区间的问题，比如
<span class="math inline">\([\dots, 1, 1, 2, \dots]\)</span> 和 <span
class="math inline">\([\dots, 2, 2, 1,
\dots]\)</span>，这两种情况，那么我们认为，平地而起的第一个值和平地而落的最后一个值是我们期望的参与端点计算的值：<br />
-
比如波谷之后都是平地，那么为了尽快的往前推进，我们可以选择平地的最后一个值，也就是下一个位置就开始上升了<br />
-
比如波峰之后都是平地，那么为了尽快的往前推进，我们可以选择平地的最后一个值，也就是下一个位置就开始下降了</p>
<p>反正平地上的值哪一个作为波峰波谷参与计算得到的数值是一样的，那么为什么不选择能推进更远距离的值呢？所以我们可以设计如下的波峰波谷检测函数：<br />
- 波峰：<span class="math inline">\(nums[i - 1] \leq nums[i]\
\&amp;\&amp;\ nums[i] &gt; nums[i + 1]\)</span><br />
- 波谷：<span class="math inline">\(nums[i - 1] \geq nums[i]\
\&amp;\&amp;\ nums[i] &lt; nums[i + 1]\)</span></p>
<p>注意第一个比较是大于等于和小于等于而不是严格的大于和小于，这样的比较方式使得我们探测到的波峰和波谷是平地上最远的那个位置。</p>
<p>另外，为了更好的处理边界的位置，不用在循环中写if来每次都判断一下是否是边界，我们可以用一个取巧的办法——再两端多添加两个端点值，新添加的值就是左右端点的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> isPeak = [&amp;](<span class="type">const</span> <span class="type">int</span>&amp; idx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> prices[idx - <span class="number">1</span>] &lt;= prices[idx] &amp;&amp; prices[idx] &gt; prices[idx + <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> isValy = [&amp;](<span class="type">const</span> <span class="type">int</span>&amp; idx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> prices[idx - <span class="number">1</span>] &gt;= prices[idx] &amp;&amp; prices[idx] &lt; prices[idx + <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 找到所有上升区间</span></span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 为了方便的边界处理，左右位置添加两个端点值</span></span><br><span class="line">        prices.<span class="built_in">insert</span>(prices.<span class="built_in">begin</span>(), prices.<span class="built_in">front</span>());</span><br><span class="line">        prices.<span class="built_in">insert</span>(prices.<span class="built_in">end</span>(), prices.<span class="built_in">back</span>());</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= len &amp;&amp; q &lt;= len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p &lt;= len &amp;&amp; !<span class="built_in">isValy</span>(p)) p++;</span><br><span class="line">            q = p;</span><br><span class="line">            <span class="keyword">while</span> (q &lt;= len &amp;&amp; !<span class="built_in">isPeak</span>(q)) q++;</span><br><span class="line">            sum += prices[q] - prices[p];</span><br><span class="line">            cout &lt;&lt; prices[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; prices[q] &lt;&lt; endl;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是其实有更简单的方法，因为没有说同一天不能继续买入，其实与其找到一个整体的上升区间，不如只要有上升差值的时候就累积起来：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                sum += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1222. 可以攻击国王的皇后</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1222.%20%E5%8F%AF%E4%BB%A5%E6%94%BB%E5%87%BB%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>在一个 <strong>8x8</strong> 的棋盘上，放置着若干「黑皇后」和一个「白国王」。</p>
<p>给定一个由整数坐标组成的数组 <code>queens</code> ，表示黑皇后的位置；以及一对坐标 <code>king</code> ，表示白国王的位置，返回所有可以攻击国王的皇后的坐标(任意顺序)。</p>
<p><strong>示例 1：</strong></p>
<p><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram.jpg" /></p>
<p><strong>输入：</strong> queens =
[[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]<br />
<strong>输出：</strong> [[0,1],[1,0],[3,3]]<br />
<strong>解释：</strong> [0,1] 的皇后可以攻击到国王，因为他们在同一行上。
[1,0] 的皇后可以攻击到国王，因为他们在同一列上。 [3,3]
的皇后可以攻击到国王，因为他们在同一条对角线上。 [0,4]
的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。 [4,0]
的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。 [2,4]
的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。</p>
<p><strong>示例 2：</strong></p>
<p><strong><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram-1.jpg" /></strong></p>
<p><strong>输入：</strong> queens =
[[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]<br />
<strong>输出：</strong> [[2,2],[3,4],[4,4]]</p>
<p><strong>示例 3：</strong></p>
<p><strong><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram-2.jpg" /></strong></p>
<p><strong>输入：</strong>
<code>queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]</code><br />
<strong>输出：</strong>
<code>[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]</code></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= queens.length &lt;= 63</code><br />
</li>
<li><code>queens[i].length == 2</code><br />
</li>
<li><code>0 &lt;= queens[i][j] &lt; 8</code><br />
</li>
<li><code>king.length == 2</code><br />
</li>
<li><code>0 &lt;= king[0], king[1] &lt; 8</code><br />
</li>
<li>一个棋盘格上最多只能放置一枚棋子。</li>
</ul>
<p>这是一道模拟题，因为棋盘的大小是固定的 <span class="math inline">\(8
\times
8\)</span>，数据范围不大，并且国王可以被攻击的方向只能来自8个方向。根据题目给的示例示意，在同一行、同一列、同一斜上的女王，只有第一个女王才能攻击到国王，其他之后的女王是不能攻击到国王的。我们直接从国王的位置往8个方向遍历棋盘的其他位置，找到第一个可以攻击国王的女王即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">8</span>][<span class="number">2</span>] = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, <span class="comment">// top</span></span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, <span class="comment">// top right</span></span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, <span class="comment">// right</span></span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, <span class="comment">// bottom right</span></span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, <span class="comment">// bottom</span></span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, <span class="comment">// bottom left</span></span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, <span class="comment">// left</span></span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125; <span class="comment">// top left</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">queensAttacktheKing</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queens, vector&lt;<span class="type">int</span>&gt;&amp; king) &#123;</span><br><span class="line">        set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; posMark;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; queenPos : queens)</span><br><span class="line">            posMark.<span class="built_in">emplace</span>(queenPos[<span class="number">0</span>], queenPos[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> brow = king[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> bcol = king[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                brow += dirs[i][<span class="number">0</span>];</span><br><span class="line">                bcol += dirs[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (posMark.<span class="built_in">find</span>(&#123;brow, bcol&#125;) != posMark.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;brow, bcol&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (brow &gt;= <span class="number">0</span> &amp;&amp; brow &lt; <span class="number">8</span> &amp;&amp; bcol &gt;= <span class="number">0</span> &amp;&amp; bcol &lt; <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1267. 统计参与通信的服务器</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1267.%20%E7%BB%9F%E8%AE%A1%E5%8F%82%E4%B8%8E%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>这里有一幅服务器分布图，服务器的位置标识在 <code>m * n</code> 的整数矩阵网格 <code>grid</code> 中，1
表示单元格上有服务器，0 表示没有。</p>
<p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p>
<p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-6.jpg" /></p>
<p><strong>输入：</strong> grid = [[1,0],[0,1]]<br />
<strong>输出：</strong> 0<br />
<strong>解释：</strong> 没有一台服务器能与其他服务器进行通信。</p>
<p><strong>示例 2：</strong></p>
<p><strong><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-4-1.jpg" /></strong></p>
<p><strong>输入：</strong> grid = [[1,0],[1,1]]<br />
<strong>输出：</strong> 3<br />
<strong>解释：</strong>
所有这些服务器都至少可以与一台别的服务器进行通信。</p>
<p><strong>示例 3：</strong></p>
<p><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-1-3.jpg" /></p>
<p><strong>输入：</strong> grid =
[[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]<br />
<strong>输出：</strong> 4<br />
<strong>解释：</strong>
第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code><br />
</li>
<li><code>n == grid[i].length</code><br />
</li>
<li><code>1 &lt;= m &lt;= 250</code><br />
</li>
<li><code>1 &lt;= n &lt;= 250</code><br />
</li>
<li><code>grid[i][j] == 0 or 1</code></li>
</ul>
<p>很纯粹的模拟题，没有什么好说的。统计每行每列上存在的服务器数量就可以了，然后重新遍历一遍网格，当某个位置上有服务器时，检查服务器所在的行和列存在的服务器数量是否大于1（也就是当前服务器本身）即可。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countServers</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">mrowsmask</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ncolsmask</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    mrowsmask[i]++;</span><br><span class="line">                    ncolsmask[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &amp;&amp; (mrowsmask[i] &gt; <span class="number">1</span> || ncolsmask[j] &gt; <span class="number">1</span>))</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1333. 餐厅过滤器</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1333.%20%E9%A4%90%E5%8E%85%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你一个餐馆信息数组 <code>restaurants</code>，其中  <code>restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]</code>。你必须使用以下三个过滤器来过滤这些餐馆信息。</p>
<p>其中素食者友好过滤器 <code>veganFriendly</code> 的值可以为 <code>true</code> 或者 <code>false</code>，如果为 <em>true</em> 就意味着你应该只包括 <code>veganFriendlyi</code> 为
true
的餐馆，为 <em>false</em> 则意味着可以包括任何餐馆。此外，我们还有最大价格 <code>maxPrice</code> 和最大距离 <code>maxDistance</code> 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。</p>
<p>过滤后返回餐馆的 <strong><em>id</em></strong>，按照 <em><strong>rating</strong></em> 从高到低排序。如果 <em><strong>rating</strong></em> 相同，那么按 <em><strong>id</strong></em> 从高到低排序。简单起见， <code>veganFriendlyi</code> 和 <code>veganFriendly</code> 为 <em>true</em> 时取值为 <em>1</em>，为 <em>false</em> 时，取值为 <em>0
。</em></p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>
<code>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10</code><br />
<strong>输出：</strong> <code>[3,1,5]</code><br />
<strong>解释：</strong> 这些餐馆为：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">餐馆 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]</span><br><span class="line">餐馆 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]</span><br><span class="line">餐馆 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]</span><br><span class="line">餐馆 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]</span><br><span class="line">餐馆 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] </span><br></pre></td></tr></table></figure> 在按照 veganFriendly = 1, maxPrice = 50 和 maxDistance =
10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆
5（按评分从高到低排序）。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>
<code>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10</code><br />
<strong>输出：</strong> <code>[4,3,2,1,5]</code><br />
<strong>解释：</strong> 餐馆与示例 1 相同，但在 veganFriendly = 0
的过滤条件下，应该考虑所有餐馆。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>
<code>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3</code><br />
<strong>输出：</strong> <code>[4,5]</code></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= restaurants.length &lt;= 10^4</code><br />
</li>
<li><code>restaurants[i].length == 5</code><br />
</li>
<li><code>1 &lt;= idi, ratingi, pricei, distancei &lt;= 10^5</code><br />
</li>
<li><code>1 &lt;= maxPrice, maxDistance &lt;= 10^5</code><br />
</li>
<li><code>veganFriendlyi</code> 和 <code>veganFriendly</code> 的值为 0
或 1 。<br />
</li>
<li>所有 <code>idi</code> 各不相同。</li>
</ul>
<p>这题是比较简单的模拟+数据结构知识考察。对于题目中的三个条件来过滤最后参与排序的这个要求其，就是三个<code>if</code>语句的事情，并没有什么技术含量。本题的排序也是比较简单的，可以有多种实现方式，如果只是单纯的要求排序的话，那么常见的快排、堆排、归并都是可以的，但问题在于，本题有第二个排序条件：当rating属性相同的时候，要求根据id从高到低排序，并且我们知道，id作为每个餐馆的索引，一定是不一样的，否则题目应该提供第三个排序条件；总之，排序想要保持某个稳定性，则必须有一个具有比较的且每个元素的该属性都具有不同值的属性。</p>
<p>如果选择先使用快排按照rating对最后留下来的餐馆进行排序的话，那么我们还需要实现一个相对复杂的过程来识别rating相同的餐馆向量（或者自己重新构造成结构体也不是不行）并对他们再根据id进行一次快排。</p>
<p>C++的原生快排算法或者堆排算法（直接使用set或者map，内置实现就是红黑树）是支持自定义的排序规则的：<br />
1. 排序对象本身重载了 operator &lt; (const Type&amp; rhs) const { ...
}，那么无需在使用排序算法的时候显式地提供排序规则，对象可以是struc或者class<br />
2. 如果对象和排序规则是分离的，需要显式地提供排序规则，那么应该实现一个
Lambda 函数，也就是需要定义函数类型 bool myComp (const Type&amp; obj1,
const Type&amp; obj2) { ... }</p>
<h3 id="通过定义仿函数functor">1. 通过定义仿函数（Functor）</h3>
<p>仿函数是重载了<code>operator()</code>的对象，可以像函数一样被调用。下面是一个使用仿函数的例子：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义排序规则，例如：降序</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Compare</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : v) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用lambda表达式">2. 使用Lambda表达式</h3>
<p>Lambda表达式是C++11引入的，可以方便地定义匿名函数。下面是一个使用<code>lambda</code>表达式的例子：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b) &#123;</span><br><span class="line">        <span class="comment">// 自定义排序规则，例如：降序</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : v) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这两个例子中，我们都定义了一个自定义排序规则（降序），然后将其传递给<code>std::sort</code>函数，实现了对<code>vector</code>的自定义排序。</p>
<p>那么我们可以自定义排序规则，使得这个规则利用rating和id两个属性，如果rating一样则使用id来进行排序<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vecComp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec0, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec1)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (vec0[<span class="number">1</span>] ^ vec1[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> vec0[<span class="number">1</span>] &gt; vec1[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// we do guarantee that id will be different</span></span><br><span class="line">            <span class="keyword">return</span> vec0[<span class="number">0</span>] &gt; vec1[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">filterRestaurants</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; restaurants, <span class="type">int</span> veganFriendly, <span class="type">int</span> maxPrice, <span class="type">int</span> maxDistance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// filtration with 3 filter</span></span><br><span class="line">        <span class="comment">// then output order from rb-tree</span></span><br><span class="line">        set&lt;vector&lt;<span class="type">int</span>&gt;, vecComp&gt; vecSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec : restaurants)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (veganFriendly &amp;&amp; !vec[<span class="number">2</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vec[<span class="number">3</span>] &gt; maxPrice) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vec[<span class="number">4</span>] &gt; maxDistance) <span class="keyword">continue</span>;</span><br><span class="line">            vecSet.<span class="built_in">insert</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; ans.<span class="built_in">reserve</span>(vecSet.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = vecSet.<span class="built_in">begin</span>(); it != vecSet.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>((*it)[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1448. 统计二叉树中好节点的</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1448.%20%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你一棵根为 <code>root</code> 的二叉树，请你返回二叉树中好节点的数目。</p>
<p>「好节点」X 定义为：从根到该节点 X
所经过的节点中，没有任何节点的值大于 X 的值。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/test_sample_1.png" /></strong></p>
<p><strong>输入：</strong> root = [3,1,4,3,null,1,5]<br />
<strong>输出：</strong> 4<br />
<strong>解释：</strong> 图中蓝色节点为好节点。<br />
根节点 (3) 永远是个好节点。<br />
节点 4 -&gt; (3,4) 是路径中的最大值。<br />
节点 5 -&gt; (3,4,5) 是路径中的最大值。<br />
节点 3 -&gt; (3,1,3) 是路径中的最大值。</p>
<p><strong>示例 2：</strong></p>
<p><strong><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/test_sample_2.png" /></strong></p>
<p><strong>输入：</strong> root = [3,3,null,4,2]<br />
<strong>输出：</strong> 3<br />
<strong>解释：</strong> 节点 2 -&gt; (3, 3, 2) 不是好节点，因为 "3"
比它大。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> root = [1]<br />
<strong>输出：</strong> 1<br />
<strong>解释：</strong> 根节点是好节点。</p>
<p><strong>提示：</strong></p>
<ul>
<li>二叉树中节点数目范围是 <code>[1, 10^5]</code> 。<br />
</li>
<li>每个节点权值的范围是 <code>[-10^4, 10^4]</code> 。</li>
</ul>
<p>看到树类型的题目应该能马上考虑到递归类型的解法。但是题目的入口函数不太适合做递归入口，因为使用常规的前序遍历DFS的话，还需要携带一个路径上最大值的信息，这个信息应该是随着递归链一起传递的。因此我们可以再自定义一个自己的dfs函数。以下是题目自带的模板：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一个统计“好的节点”的直接的方法是：当前根节点是否是“好节点” +
左子树“好节点”总数 +
右子树“好节点”总数，一条路径上的最大值可以只使用一个值来保存，而无需保存路径上遇到过的所有值。</p>
<p>另外需要注意的一点是，递归函数对边界条件的处理，遇到空节点时直接返回0即可，空子树的“好节点”的数量当然是0。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> themax)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        themax = <span class="built_in">max</span>(root-&gt;val, themax);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == themax) sum++;</span><br><span class="line">        sum += <span class="built_in">dfs</span>(root-&gt;left, themax);</span><br><span class="line">        sum += <span class="built_in">dfs</span>(root-&gt;right, themax);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>146. LRU 缓存</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/146.%20LRU%20%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>请你设计并实现一个满足  <a
href="https://baike.baidu.com/item/LRU">LRU (最近最少使用)
缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化
LRU 缓存<br />
</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。<br />
</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<p><strong>输入</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br></pre></td></tr></table></figure> <strong>输出</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br></pre></td></tr></table></figure></p>
<p><strong>解释</strong><br />
LRUCache lRUCache = new LRUCache(2);<br />
lRUCache.put(1, 1); // 缓存是 {1=1}<br />
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br />
lRUCache.get(1); // 返回 1<br />
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1,
3=3}<br />
lRUCache.get(2); // 返回 -1 (未找到)<br />
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4,
3=3}<br />
lRUCache.get(1); // 返回 -1 (未找到)<br />
lRUCache.get(3); // 返回 3<br />
lRUCache.get(4); // 返回 4</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code><br />
</li>
<li><code>0 &lt;= key &lt;= 10000</code><br />
</li>
<li><code>0 &lt;= value &lt;= 105</code><br />
</li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<p>根据题目的要求，<code>get</code>和<code>put</code>操作在多次函数调用之后，要求达到
<span class="math inline">\(O(1)\)</span>
的时间复杂度，那么即随即插入和随机访问都是 <span
class="math inline">\(O(1)\)</span>
的，满足这种要求的数据结构一般可以选择哈希表，但是题目要求实现的数据结构是
<strong>LRU</strong>，也即除了保存数据之外，我们还需要调整数据被淘汰的顺序，最简单的实现方式就是被访问或者被加入的数据排在头部，然后之前的数据就逐渐会挪到尾部，最后当缓存存储的键值数量已经达到了预设数量，头部新加入的键值对会挤走尾部的键值对。</p>
<p>要实现这样的要求，难点在于调整数据的淘汰顺序。我们可以结合双向链表和哈希表两种数据结构来完成这个要求；双向列表能让我们方便的调整数据在队列中的顺序，只需要在删除元素或者添加元素的时候设置元素指向的前驱节点和后继节点即可。我们可以实现一个帮助函数
<code>del(int key)</code>
来帮助我们从链表中删除这个节点指针（删除之前将它的前驱和后继节点设置好联系关系即可，记得要把队列已经存储的键值对数量减一，因为我们删除了一个键值对）</p>
<p>函数职责：<br />
*
<code>get(int key)</code>：如果键不存在于记录中（即在哈希表中没有发现），那么直接返回-1，否则一个键值对就被认为是被访问过的，需要更新位置到队列头部，我们可以调用<code>del(int key)</code>函数先将该键值对从原位置删除，然后使用<code>put(int key, int val)</code>添加到头部<br />
*
<code>put(int key, int val)</code>：如果键值对不存在于记录中，那么尝试添加到头部，并将已存储键值对数量+1，如果检测发现此时键值对数量超过了预设容量，那么使用<code>del(int key)</code>删除尾部一个元素。如果键值对存在于记录中，则将该键值对从原位置删除，并添加新的记录值键值对到头部<br />
*
<code>del(int key)</code>：如果键值对不存在于记录中，或者此时队列根本没有存储任何键值对，那么什么也不做。如果键被检查到存在于记录中，则将该键值对从其原本的位置删除，并将已存储键值对数量减一</p>
<p>cpp:<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    std::shared_ptr&lt;node&gt; prev;</span><br><span class="line">    std::shared_ptr&lt;node&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> _key, <span class="type">int</span> _val) : <span class="built_in">key</span>(_key), <span class="built_in">val</span>(_val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cacheSize;</span><br><span class="line">    <span class="type">int</span> cacheCapcity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, std::shared_ptr&lt;node&gt;&gt; idx2node;</span><br><span class="line">    std::shared_ptr&lt;node&gt; head;</span><br><span class="line">    std::shared_ptr&lt;node&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> sptr = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (sptr != tail)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; sptr-&gt;key &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; sptr-&gt;val &lt;&lt; endl;</span><br><span class="line">            sptr = sptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheSize)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = idx2node.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == idx2node.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        idx2node[key]-&gt;prev-&gt;next = idx2node[key]-&gt;next;</span><br><span class="line">        idx2node[key]-&gt;next-&gt;prev = idx2node[key]-&gt;prev;</span><br><span class="line">        idx2node.<span class="built_in">erase</span>(it);</span><br><span class="line">        cacheSize--;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;del &quot; &lt;&lt; key &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// printElements();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        cacheSize = <span class="number">0</span>;</span><br><span class="line">        cacheCapcity = capacity;</span><br><span class="line">        head = std::<span class="built_in">shared_ptr</span>&lt;node&gt;(<span class="keyword">new</span> <span class="built_in">node</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">        tail = std::<span class="built_in">shared_ptr</span>&lt;node&gt;(<span class="keyword">new</span> <span class="built_in">node</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx2node.<span class="built_in">find</span>(key) == idx2node.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;exist get &quot; &lt;&lt; key &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// printElements();</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val = idx2node[key]-&gt;val;</span><br><span class="line">        <span class="built_in">del</span>(key);</span><br><span class="line">        <span class="built_in">put</span>(key, val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;none get &quot; &lt;&lt; key &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// printElements();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">// 如果已经存在，更新即可</span></span><br><span class="line">        <span class="keyword">if</span> (idx2node.<span class="built_in">find</span>(key) != idx2node.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">del</span>(key);</span><br><span class="line">            <span class="built_in">put</span>(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试添加新值</span></span><br><span class="line">        cacheSize++;</span><br><span class="line">        <span class="keyword">if</span> (cacheSize &gt; cacheCapcity)</span><br><span class="line">            <span class="built_in">del</span>(tail-&gt;prev-&gt;key);</span><br><span class="line">        </span><br><span class="line">        idx2node[key] = std::<span class="built_in">shared_ptr</span>&lt;node&gt;(<span class="keyword">new</span> <span class="built_in">node</span>(key, value));</span><br><span class="line"></span><br><span class="line">        head-&gt;next-&gt;prev = idx2node[key];</span><br><span class="line">        idx2node[key]-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = idx2node[key];</span><br><span class="line">        idx2node[key]-&gt;prev = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;put &quot; &lt;&lt; key &lt;&lt; &#x27;&amp;&#x27; &lt;&lt; value &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// printElements();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>golang<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key <span class="type">int</span></span><br><span class="line">    val <span class="type">int</span></span><br><span class="line">    prev *node</span><br><span class="line">    next *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    cacheSize <span class="type">int</span></span><br><span class="line">    cacheCapacity <span class="type">int</span></span><br><span class="line">    idx2node <span class="keyword">map</span>[<span class="type">int</span>]*node</span><br><span class="line">    head *node</span><br><span class="line">    tail *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    cacheList := LRUCache&#123;</span><br><span class="line">        cacheSize: <span class="number">0</span>,</span><br><span class="line">        cacheCapacity: capacity,</span><br><span class="line">        idx2node: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*node),</span><br><span class="line">        head: &amp;node&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">        tail: &amp;node&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cacheList.head.next = cacheList.tail</span><br><span class="line">    cacheList.tail.prev = cacheList.head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cacheList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Del(key <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.idx2node[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.idx2node) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.idx2node[key].prev.next = this.idx2node[key].next</span><br><span class="line">    this.idx2node[key].next.prev = this.idx2node[key].prev</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(this.idx2node, key)</span><br><span class="line">    this.cacheSize--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.idx2node[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> val <span class="type">int</span> = this.idx2node[key].val</span><br><span class="line">    this.Del(key)</span><br><span class="line">    this.Put(key, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, val <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.idx2node[key]; ok &#123;</span><br><span class="line">        this.Del(key)</span><br><span class="line">        this.Put(key, val);</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNode := &amp;node &#123; key, val, <span class="literal">nil</span>, <span class="literal">nil</span> &#125;</span><br><span class="line">    newNode.next = this.head.next</span><br><span class="line">    newNode.prev = this.head</span><br><span class="line">    this.head.next.prev = newNode</span><br><span class="line">    this.head.next = newNode</span><br><span class="line">    this.idx2node[key] = newNode</span><br><span class="line">    this.cacheSize++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> this.cacheSize &gt; this.cacheCapacity &#123;</span><br><span class="line">        this.Del(this.tail.prev.key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(capacity);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Get(key);</span></span><br><span class="line"><span class="comment"> * obj.Put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1462. 课程表 IV</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1462.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20IV/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>你总共需要上 <code>numCourses</code> 门课，课程编号依次为 <code>0</code> 到 <code>numCourses-1</code> 。你会得到一个数组 <code>prerequisite</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> 表示如果你想选 <code>bi</code> 课程，你 <strong>必须</strong> 先选 <code>ai</code> 课程。</p>
<ul>
<li>有的课会有直接的先修课程，比如如果想上课程 <code>1</code> ，你必须先上课程 <code>0</code> ，那么会以 <code>[0,1]</code> 数对的形式给出先修课程数对。</li>
</ul>
<p>先决条件也可以是 <strong>间接</strong> 的。如果课程 <code>a</code> 是课程 <code>b</code> 的先决条件，课程 <code>b</code> 是课程 <code>c</code> 的先决条件，那么课程 <code>a</code> 就是课程 <code>c</code> 的先决条件。</p>
<p>你也得到一个数组 <code>queries</code> ，其中 <code>queries[j] = [uj, vj]</code>。对于第 <code>j</code> 个查询，您应该回答课程 <code>uj</code> 是否是课程 <code>vj</code> 的先决条件。</p>
<p>返回一个布尔数组 <code>answer</code> ，其中 <code>answer[j]</code> 是第 <code>j</code> 个查询的答案。</p>
<p><strong>示例 1：</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg" /></p>
<p><strong>输入：</strong> numCourses = 2, prerequisites = [[1,0]],
queries = [[0,1],[1,0]]<br />
<strong>输出：</strong>[false,true]<br />
<strong>解释：</strong> 课程 0 不是课程 1 的先修课程，但课程 1 是课程 0
的先修课程。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> numCourses = 2, prerequisites = [], queries =
[[1,0],[0,1]]<br />
<strong>输出：</strong>[false,false]<br />
<strong>解释：</strong> 没有先修课程对，所以每门课程之间是独立的。</p>
<p><strong>示例 3：</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg" /></p>
<p><strong>输入：</strong> numCourses = 3, prerequisites =
[[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]<br />
<strong>输出：</strong>[true,true]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= numCourses &lt;= 100</code><br />
</li>
<li><code>0 &lt;= prerequisites.length &lt;= (numCourses * (numCourses - 1) / 2)</code><br />
</li>
<li><code>prerequisites[i].length == 2</code><br />
</li>
<li><code>0 &lt;= ai, bi &lt;= n - 1</code><br />
</li>
<li><code>ai != bi</code><br />
</li>
<li>每一对 <code>[ai, bi]</code> 都 <strong>不同</strong><br />
</li>
<li>先修课程图中没有环。<br />
</li>
<li><code>1 &lt;= queries.length &lt;= 10^4</code><br />
</li>
<li><code>0 &lt;= ui, vi &lt;= n - 1</code><br />
</li>
<li><code>ui != vi</code></li>
</ul>
<p>课程表系列的题大部分都是图论题，但是目前还没有遇到并查集的题目。今天这道课程表使用的是弗洛伊德算法，弗洛伊德算法可以计算出小型图中的多源最短路径，当然本题无需解出最短路径所需的步数，只需要判断图中任意两个顶点是否联通即可。</p>
<p>Floyd-Warshall算法的伪代码：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function floydWarshall(A):</span><br><span class="line">    n = length(A)</span><br><span class="line"></span><br><span class="line">    for k from 1 to n:</span><br><span class="line">        for i from 1 to n:</span><br><span class="line">            for j from 1 to n:</span><br><span class="line">                A[i][j] = min(A[i][j], A[i][k] + A[k][j])</span><br><span class="line">    return A</span><br></pre></td></tr></table></figure></p>
<p>但是弗洛伊德是一个 <span class="math inline">\(O(n^3)\)</span>
的算法，对于小型图和中型图来说这是一个比较有效的算法，对于大型图来说，这也许不是一个可行的方法，幸运的是，本体的数据范围非常小，只有100个顶点，这种规模的图是可以使用弗洛伊德算法的，并且在在构建好多源最短路径的邻接矩阵之后，对两个顶点是否联通的查询的花费是
<span class="math inline">\(O(1)\)</span> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// try Floyd Warshall algorithm</span></span><br><span class="line">        <span class="type">bool</span>** adjcentMatrix = <span class="keyword">new</span> <span class="type">bool</span>*[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            adjcentMatrix[i] = <span class="keyword">new</span> <span class="type">bool</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numCourses; ++j)</span><br><span class="line">                adjcentMatrix[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; prep : prerequisites)</span><br><span class="line">            adjcentMatrix[prep[<span class="number">0</span>]][prep[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// update the adjcent matrix</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; numCourses; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numCourses; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    adjcentMatrix[i][j] = adjcentMatrix[i][j] || (adjcentMatrix[i][k] &amp;&amp; adjcentMatrix[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; ans; ans.<span class="built_in">reserve</span>(queries.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; query : queries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (adjcentMatrix[query[<span class="number">0</span>]][query[<span class="number">1</span>]])</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">delete</span>[] adjcentMatrix[i];</span><br><span class="line">        <span class="keyword">delete</span>[] adjcentMatrix;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是二维数组的初始化和释放，需要手动对第二维度的指针进行初始化和释放。</p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1761. 一个图中连通三元组的最小度数</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1761.%20%E4%B8%80%E4%B8%AA%E5%9B%BE%E4%B8%AD%E8%BF%9E%E9%80%9A%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<h2 id="题干">题干</h2>
<p>给你一个无向图，整数 <code>n</code> 表示图中节点的数目，<code>edges</code> 数组表示图中的边，其中 <code>edges[i] = [ui, vi]</code> ，表示 <code>ui</code> 和 <code>vi</code> 之间有一条无向边。</p>
<p>一个 <strong>连通三元组</strong> 指的是 <strong>三个</strong> 节点组成的集合且这三个点之间 <strong>两两</strong> 有边。</p>
<p><strong>连通三元组的度数</strong> 是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。</p>
<p>请你返回所有连通三元组中度数的 <strong>最小值</strong> ，如果图中没有连通三元组，那么返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios1.png" /></p>
<p><strong>输入：</strong>
<code>n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]</code><br />
<strong>输出：</strong> <code>3</code><br />
<strong>解释：</strong> 只有一个三元组
<code>[1,2,3]</code>。构成度数的边在上图中已被加粗。</p>
<p><strong>示例 2：</strong></p>
<p><img
src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios2.png" /></p>
<p><strong>输入：</strong>
<code>n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]</code><br />
<strong>输出：</strong> <code>0</code><br />
<strong>解释：</strong> 有 3 个三元组：<br />
<code>1) [1,4,3]，度数为 0 。</code><br />
<code>2) [2,5,6]，度数为 2 。</code><br />
<code>3) [5,6,7]，度数为 2 。</code></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 400</code><br />
</li>
<li><code>edges[i].length == 2</code><br />
</li>
<li><code>1 &lt;= edges.length &lt;= n * (n-1) / 2</code><br />
</li>
<li><code>1 &lt;= ui, vi &lt;= n</code><br />
</li>
<li><code>ui != vi</code><br />
</li>
<li>图中没有重复的边。</li>
</ul>
<h2 id="常规解法">常规解法</h2>
<p>仔细观察这题之后，应该都能推断出使用邻接矩阵或者邻接链表的暴力解法。另外，如果找到了一个三元组，那么题意要求的最小度数怎么计算呢？<br />
<span class="math display">\[  
minTrioDegree = degree[a] + degree[b] + degree[c] - 6  
\]</span><br />
计算方法很简单，即三个顶点的度数之和减去它们之间两两互相连接的边的度数，我们用三条边可以两两连接三个顶点，因此这三条边，每个顶点的度会计算一次，这样三个顶点重复计算了三次，因此最终不包含用于两两连接的边的度数之和就是减去这三次重复计算的度数，也即
<span class="math inline">\(2 \times 3 = 6\)</span>。</p>
<p>至于如何判断三个点是否是三元组也很方便，只需要判断这三条边是否存在即可，因为我们构建了邻接矩阵/邻接链表，因此可以直接以
<span class="math inline">\(O(1)\)</span>
的时间复杂度查询到边是否存在。以下是使用了邻接链表+部分剪枝的实现方法，可惜使用邻接链表在本题只能通过95%的用例，部分用例是稠密图，会超时。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTrioDegree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// construct adjcent list</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; adjcentList;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; edge : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            adjcentList[edge[<span class="number">0</span>]].<span class="built_in">insert</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            adjcentList[edge[<span class="number">1</span>]].<span class="built_in">insert</span>(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> minTrioDegree = n * (n - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (adjcentList[i].<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!adjcentList[i].<span class="built_in">count</span>(j)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!adjcentList[j].<span class="built_in">count</span>(k)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!adjcentList[k].<span class="built_in">count</span>(i)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; &#x27;-&#x27; &lt;&lt; j &lt;&lt; &#x27;-&#x27; &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">                    <span class="type">int</span> newTrioDegree = adjcentList[i].<span class="built_in">size</span>() + adjcentList[j].<span class="built_in">size</span>() + adjcentList[k].<span class="built_in">size</span>() - <span class="number">6</span>;</span><br><span class="line">                    minTrioDegree = <span class="built_in">min</span>(minTrioDegree, newTrioDegree);</span><br><span class="line">                    <span class="keyword">if</span> (minTrioDegree == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minTrioDegree &lt; n * (n - <span class="number">1</span>) / <span class="number">2</span> ? minTrioDegree : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用邻接矩阵的方法可以刚好通过所有测试用例：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTrioDegree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; edge: edges) &#123;</span><br><span class="line">            <span class="type">int</span> x = edge[<span class="number">0</span>] - <span class="number">1</span>, y = edge[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            g[x][y] = g[y][x] = <span class="number">1</span>;</span><br><span class="line">            ++degree[x];</span><br><span class="line">            ++degree[y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (g[i][k] == <span class="number">1</span> &amp;&amp; g[j][k] == <span class="number">1</span>) &#123;</span><br><span class="line">                            ans = <span class="built_in">min</span>(ans, degree[i] + degree[j] + degree[k] - <span class="number">6</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上解法时间复杂度是 <span class="math inline">\(O(n^3)\)</span>
的，因此如果数据范围更大的话，不一定能在有效时间内给出解。我们还有其他更加高效的判断三个顶点是否是三元组的方法。</p>
<h2 id="高效解法">高效解法</h2>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1921. 消灭怪物的最大数量</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1921.%20%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从
0
开始</strong> 且长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 是第 <code>i</code> 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</p>
<p>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 <code>n</code> 的整数数组 <code>speed</code> 表示每个怪物的速度，其中 <code>speed[i]</code> 是第 <code>i</code> 个怪物的速度（单位：米/分）。</p>
<p>怪物从 <strong>第 0
分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第
0
分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p>
<p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为 <strong>输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</p>
<p>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  <code>n</code> 。</p>
<p><strong>示例 1：</strong><br />
<strong>输入：</strong> dist = [1,3,4], speed = [1,1,1]<br />
<strong>输出：</strong> 3<br />
<strong>解释：</strong><br />
第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。<br />
第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。<br />
第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。<br />
第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。<br />
所有 3 个怪物都可以被消灭。</p>
<p><strong>示例 2：</strong><br />
<strong>输入：</strong> dist = [1,1,2,3], speed = [1,1,1,1]<br />
<strong>输出：</strong> 1<br />
<strong>解释：</strong><br />
第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。<br />
第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。<br />
你只能消灭 1 个怪物。</p>
<p><strong>示例 3：</strong><br />
<strong>输入：</strong> dist = [3,2,4], speed = [5,3,2]<br />
<strong>输出：</strong> 1<br />
<strong>解释：</strong><br />
第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。<br />
第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。 你只能消灭 1
个怪物。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == dist.length == speed.length</code><br />
</li>
<li><code>1 &lt;= n &lt;= 10^5</code><br />
</li>
<li><code>1 &lt;= dist[i], speed[i] &lt;= 10^5</code></li>
</ul>
<p>本题第一个直观的想法是，将每个怪物到达城堡的时间计算出来，某个时间点可能会有多个怪物同时到达。在计算每个怪物到达的时间点的同时，我们可以得知最后到达的怪物的时间点
<span class="math inline">\(maxTime\)</span>，我们从第0分钟遍历到第
<span class="math inline">\(maxTime\)</span>
分钟，每分钟我们可以对某个时间点上的怪物数量
-1，如果我们遍历到该时刻的时候，该时刻仍然有剩余的怪物，则判定为失败。</p>
<p>由于怪物可能是在每分钟的中间到达，而我们只希望整数计算，使用了浮点数的话不方便计算时间。一个重要的技巧和知识点是：向上整除。因为普通的整数除法都是向下整除，但是本题我们需要把在每分钟中间到达的怪物算作是每分钟的末尾来计算，才能符合每分钟开始的时候仍然可以选择一只怪物杀死，否则的话，如果算在每分钟的开始，则直接判定为失败。</p>
<p>向下整除：<br />
<span class="math display">\[  
a / b  
\]</span></p>
<p>向上整除：<br />
<span class="math display">\[  
(a - 1) / b + 1  
\]</span></p>
<p>向上整除的原理是：对于原本结果的商就不是整数的除法算式，其实 <span
class="math inline">\(a/b + 1\)</span> 就可以满足我们的要求了，+1
就相当于是把向下整除的作用给消除了，但问题是对于原本商就是整数的除法算式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eliminateMaximum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dist, vector&lt;<span class="type">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numOnTime;</span><br><span class="line">        <span class="type">int</span> len = dist.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            numOnTime[(dist[i] - <span class="number">1</span>) / speed[i] + <span class="number">1</span>]++;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxTime = numOnTime.<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">        <span class="type">int</span> nonemptyIdx = numOnTime.<span class="built_in">begin</span>()-&gt;first;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxTime; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (numOnTime[i]) <span class="keyword">break</span>;</span><br><span class="line">            numOnTime[nonemptyIdx]--;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">while</span> (!numOnTime[nonemptyIdx] &amp;&amp; nonemptyIdx &lt;= maxTime) nonemptyIdx++;</span><br><span class="line">            <span class="keyword">if</span> (nonemptyIdx &gt; maxTime) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>1993. 树上的操作</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/1993.%20%E6%A0%91%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你一棵 <code>n</code> 个节点的树，编号从 <code>0</code> 到 <code>n - 1</code> ，以父节点数组 <code>parent</code> 的形式给出，其中 <code>parent[i]</code> 是第 <code>i</code> 个节点的父节点。树的根节点为 <code>0</code> 号节点，所以 <code>parent[0] = -1</code> ，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。</p>
<p>数据结构需要支持如下函数：</p>
<ul>
<li><strong>Lock：</strong>
指定用户给指定节点 <strong>上锁</strong> ，上锁后其他用户将无法给同一节点上锁。只有当节点处于未上锁的状态下，才能进行上锁操作。<br />
</li>
<li><strong>Unlock：</strong>
指定用户给指定节点 <strong>解锁</strong> ，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。<br />
</li>
<li><strong>Upgrade：</strong>
指定用户给指定节点 <strong>上锁</strong> ，并且将该节点的所有子孙节点 <strong>解锁</strong> 。只有如下
3 个条件 <strong>全部</strong> 满足时才能执行升级操作：
<ul>
<li>指定节点当前状态为未上锁。<br />
</li>
<li>指定节点至少有一个上锁状态的子孙节点（可以是 <strong>任意</strong> 用户上锁的）。<br />
</li>
<li>指定节点没有任何上锁的祖先节点。</li>
</ul></li>
</ul>
<p>请你实现 <code>LockingTree</code> 类：</p>
<ul>
<li><code>LockingTree(int[] parent)</code> 用父节点数组初始化数据结构。<br />
</li>
<li><code>lock(int num, int user)</code> 如果 id
为 <code>user</code> 的用户可以给节点 <code>num</code> 上锁，那么返回 <code>true</code> ，否则返回 <code>false</code> 。如果可以执行此操作，节点 <code>num</code> 会被
id 为 <code>user</code> 的用户 <strong>上锁</strong> 。<br />
</li>
<li><code>unlock(int num, int user)</code> 如果 id
为 <code>user</code> 的用户可以给节点 <code>num</code> 解锁，那么返回 <code>true</code> ，否则返回 <code>false</code> 。如果可以执行此操作，节点 <code>num</code> 变为 <strong>未上锁</strong> 状态。<br />
</li>
<li><code>upgrade(int num, int user)</code> 如果 id
为 <code>user</code> 的用户可以给节点 <code>num</code> 升级，那么返回 <code>true</code> ，否则返回 <code>false</code> 。如果可以执行此操作，节点 <code>num</code> 会被 <strong>升级</strong> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2021/07/29/untitled.png" /></p>
<p><strong>输入：</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;LockingTree&quot;, &quot;lock&quot;, &quot;unlock&quot;, &quot;unlock&quot;, &quot;lock&quot;, &quot;upgrade&quot;, &quot;lock&quot;]</span><br><span class="line">[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]</span><br></pre></td></tr></table></figure> <strong>输出：</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[null, true, false, true, true, true, false]</span><br></pre></td></tr></table></figure></p>
<p><strong>解释：</strong><br />
LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);<br />
lockingTree.lock(2, 2); // 返回 true ，因为节点 2 未上锁。<br />
// 节点 2 被用户 2 上锁。<br />
lockingTree.unlock(2, 3); // 返回 false ，因为用户 3 无法解锁被用户 2
上锁的节点。<br />
lockingTree.unlock(2, 2); // 返回 true ，因为节点 2 之前被用户 2
上锁。<br />
// 节点 2 现在变为未上锁状态。<br />
lockingTree.lock(4, 5); // 返回 true ，因为节点 4 未上锁。<br />
// 节点 4 被用户 5 上锁。<br />
lockingTree.upgrade(0, 1); // 返回 true ，因为节点 0
未上锁且至少有一个被上锁的子孙节点（节点 4）。<br />
// 节点 0 被用户 1 上锁，节点 4 变为未上锁。<br />
lockingTree.lock(0, 1); // 返回 false ，因为节点 0 已经被上锁了。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == parent.length</code><br />
</li>
<li><code>2 &lt;= n &lt;= 2000</code><br />
</li>
<li>对于 <code>i != 0</code> ，满足 <code>0 &lt;= parent[i] &lt;= n - 1</code><br />
</li>
<li><code>parent[0] == -1</code><br />
</li>
<li><code>0 &lt;= num &lt;= n - 1</code><br />
</li>
<li><code>1 &lt;= user &lt;= 104</code><br />
</li>
<li><code>parent</code> 表示一棵合法的树。<br />
</li>
<li><code>lock</code> ，<code>unlock</code> 和 <code>upgrade</code> 的调用 <strong>总共</strong> 不超过 <code>2000</code> 次。</li>
</ul>
<p>这是一道模拟题，会涉及比较多的知识，以及操作实践能力。<code>lock</code>和<code>unlock</code>函数按照题意实现即可。本题主要考察的是系统设计与实现的能力，如何快速的实现一个小的需求并且能尝试优化，能较好的组织代码结构，对于大部分模拟题来说，代码量都是比较大的，如果没有良好的代码结构组织以及命名规范和调用规范，很容易在大片的代码中迷失。</p>
<p>题目中的树不一定是一颗二叉树，这是需要注意的，所以必须按照普通树来设计数据结构，另外由于题目的<code>upgrade</code>操作涉及到查询父节点的操作，在设计节点的时候，应该包含指向父节点的指针。除了这两点之外，其他的主要靠自己的编程习惯了。</p>
<p>本题的数据范围是比较小的，因此可以先尝试使用暴力的方法去解决，如果能过的话再尝试是用其他方法优化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; childs;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> nodeIdx;</span><br><span class="line">    <span class="type">int</span> currUser;</span><br><span class="line">    <span class="type">bool</span> isLocked;</span><br><span class="line">    <span class="built_in">node</span>() : <span class="built_in">nodeIdx</span>(<span class="number">-1</span>), <span class="built_in">currUser</span>(<span class="number">-1</span>), <span class="built_in">isLocked</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> idx) : <span class="built_in">nodeIdx</span>(idx), <span class="built_in">currUser</span>(<span class="number">-1</span>), <span class="built_in">isLocked</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> idx, <span class="type">int</span> prt) : <span class="built_in">parent</span>(prt), <span class="built_in">nodeIdx</span>(idx), <span class="built_in">currUser</span>(<span class="number">-1</span>), <span class="built_in">isLocked</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockingTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parentLink;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, std::shared_ptr&lt;node&gt;&gt; idx2node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LockingTree</span>(vector&lt;<span class="type">int</span>&gt;&amp; parent) &#123;</span><br><span class="line">        parentLink = parent;</span><br><span class="line">        <span class="type">int</span> numNodes = parentLink.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numNodes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx2node[parentLink[i]] == <span class="literal">nullptr</span>)</span><br><span class="line">                idx2node[parentLink[i]] = std::<span class="built_in">shared_ptr</span>&lt;node&gt;(<span class="keyword">new</span> <span class="built_in">node</span>(parentLink[i]));</span><br><span class="line">            <span class="keyword">if</span> (idx2node[i] == <span class="literal">nullptr</span>)</span><br><span class="line">                idx2node[i] = std::<span class="built_in">shared_ptr</span>&lt;node&gt;(<span class="keyword">new</span> <span class="built_in">node</span>(i));</span><br><span class="line"></span><br><span class="line">            idx2node[parentLink[i]]-&gt;childs.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            idx2node[i]-&gt;parent = parentLink[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lock</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx2node[num]-&gt;isLocked) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        idx2node[num]-&gt;isLocked = <span class="literal">true</span>;</span><br><span class="line">        idx2node[num]-&gt;currUser = user;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unlock</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!idx2node[num]-&gt;isLocked) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (user &gt; <span class="number">0</span> &amp;&amp; idx2node[num]-&gt;currUser ^ user) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        idx2node[num]-&gt;currUser = <span class="number">-1</span>;</span><br><span class="line">        idx2node[num]-&gt;isLocked = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">upgrade</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定节点当前为未上锁状态</span></span><br><span class="line">        <span class="keyword">if</span> (idx2node[num]-&gt;isLocked) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 没有祖先是上锁状态</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curr = parentLink[num];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (curr &gt;= <span class="number">0</span> &amp;&amp; !idx2node[curr]-&gt;isLocked) curr = parentLink[curr];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curr &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 至少有一个子节点是上锁状态</span></span><br><span class="line">        <span class="type">bool</span> haveLockedChild = <span class="literal">false</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; toBeUnlock;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; scanq;</span><br><span class="line">        scanq.<span class="built_in">emplace</span>(num);</span><br><span class="line">        <span class="keyword">while</span> (!scanq.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curr = scanq.<span class="built_in">front</span>();</span><br><span class="line">            scanq.<span class="built_in">pop</span>();</span><br><span class="line">            toBeUnlock.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">            <span class="keyword">if</span> (idx2node[curr]-&gt;isLocked)</span><br><span class="line">                haveLockedChild = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; next : idx2node[curr]-&gt;childs)</span><br><span class="line">                scanq.<span class="built_in">emplace</span>(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!haveLockedChild) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; child : toBeUnlock)</span><br><span class="line">            <span class="built_in">unlock</span>(child, <span class="number">-1</span>); <span class="comment">// root previlege</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">lock</span>(num, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LockingTree object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LockingTree* obj = new LockingTree(parent);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;lock(num,user);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;unlock(num,user);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;upgrade(num,user);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>207. 课程表</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites
给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须
先学习课程 bi 。</p>
<p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1
。<br />
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回
false 。</p>
<p>示例 1：</p>
<p>输入：numCourses = 2, prerequisites = [[1,0]]<br />
输出：true<br />
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0
。这是可能的。<br />
示例 2：</p>
<p>输入：numCourses = 2, prerequisites = [[1,0],[0,1]]<br />
输出：false<br />
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0
；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</p>
<p>提示：</p>
<p>1 &lt;= numCourses &lt;= 105<br />
0 &lt;= prerequisites.length &lt;= 5000<br />
prerequisites[i].length == 2<br />
0 &lt;= ai, bi &lt; numCourses<br />
prerequisites[i] 中的所有课程对 互不相同</p>
<p>简单的拓扑排序，首先用一个邻接链表记录有向图的信息，然后我们根据给出的课程前后关系记录每个节点的入度，即先修课程作为先前的节点提供一条出方向的边，则后修课程必须接收这条边，也就是会有一个入度，我们先把所有节点的入度标记好，这是拓扑排序的关键。然后我们扫描一遍每个节点的入度信息，把入度为0的节点全部放入BFS起始队列q中，然后利用邻接链表，我们看看这些入度为0的节点的邻接节点都有谁，当我们根据拓扑排序把这些入度为0的节点弹出队列后，它们相应的所有邻接节点的入度都要-1，当我们发现一个新的入度为0的节点的时候将其加入拓扑排序队列q。直到队列为空，然后我们检查这个拓扑排序队列是否弹出过所有的节点(即是否所有节点都被排序了，如果有某个节点没被排序，证明肯定有环，环是无法拓扑排序的，返回false)。<br />
C++:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegrees</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; adjcentList;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; p : prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            adjcentList[p[<span class="number">1</span>]].<span class="built_in">push_back</span>(p[<span class="number">0</span>]);</span><br><span class="line">            indegrees[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!indegrees[i])</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="comment">// there must be a loop in the graph</span></span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>(); cnt++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; next : adjcentList[temp])</span><br><span class="line">            &#123;</span><br><span class="line">                indegrees[next]--;</span><br><span class="line">                <span class="keyword">if</span> (!indegrees[next])</span><br><span class="line">                    q.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>golang:<br />
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// implement a queue as golang not provide a built-in one</span></span><br><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Enqueue(val <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *q = <span class="built_in">append</span>(*q, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Dequeue() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> q.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    front := (*q)[<span class="number">0</span>]</span><br><span class="line">    *q = (*q)[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> front</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    adjcentList := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">    inDegree := <span class="built_in">make</span>([]<span class="type">int</span>, numCourses) <span class="comment">// define an all-0 array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        adjcentList[val[<span class="number">1</span>]] = <span class="built_in">append</span>(adjcentList[val[<span class="number">1</span>]], val[<span class="number">0</span>])</span><br><span class="line">        inDegree[val[<span class="number">0</span>]]++ </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q := &amp;Queue&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> idx, val := <span class="keyword">range</span> inDegree &#123;</span><br><span class="line">        <span class="comment">// do not use `!` operator to convert zero</span></span><br><span class="line">        <span class="comment">// or none-zero value to bool type, golang</span></span><br><span class="line">        <span class="comment">// does not support implicit type conversion</span></span><br><span class="line">        <span class="keyword">if</span> val == <span class="number">0</span> &#123;</span><br><span class="line">            q.Enqueue(idx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cnt <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> !q.IsEmpty() &#123;</span><br><span class="line">        curr := q.Dequeue().(<span class="type">int</span>)</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span> _, next := <span class="keyword">range</span> adjcentList[curr] &#123;</span><br><span class="line">            inDegree[next]--;</span><br><span class="line">            <span class="keyword">if</span> inDegree[next] == <span class="number">0</span> &#123;</span><br><span class="line">                q.Enqueue(next)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(cnt)</span><br><span class="line">    <span class="keyword">return</span> cnt == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>213. 打家劫舍 II</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> nums = [2,3,2]<br />
<strong>输出：</strong> 3<br />
<strong>解释：</strong> 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3
号房屋（金额 = 2）, 因为他们是相邻的。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> nums = [1,2,3,1]<br />
<strong>输出：</strong> 4<br />
<strong>解释：</strong> 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3
号房屋（金额 = 3）。<br />
  偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> nums = [1,2,3]<br />
<strong>输出：</strong> 3</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code><br />
</li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<p>本题是打家劫舍系列题中的第二题，如果没有做过第一题的话，可能这题并没有什么思路，唯一能感觉到的就是本题会使用动态规划来解题，但问题是，题目中的“房屋是紧挨着的，围成了一个圈”，这个时候由于我们平常遇到的动态规划都是线性数组完成的，题目中此处可能会误导认为使用其他数据结构。</p>
<p>本题仍然可以使用常规的动态规划来解题，但是需要注意很多边界条件以及动态规划的初始化，如果这题是ACM模式的话，也即无法看到提交之后错误的用例，那么本题的难度可以上升为
hard，因为本题真正难的地方在于边界条件的初始化，动态规划的转移方程推断到不是很难；基本的动态规划转移方程如下：<br />
<span class="math display">\[  
dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])  
\]</span><br />
也就是，对于遍历到的第 <span class="math inline">\(i\)</span>
栋房屋，如果选择偷窃，则前一栋房屋是不能偷窃的，否则会触发警报；如果选择不偷窃，那么当前偷窃的最大值就是遍历到上一栋房屋时的最大值，没有发生变化。</p>
<p>如果头尾两栋房子是紧挨着的，那么我们只有两个动态规划选择。在线性规划的时候，要么排除第一栋房子，要么排除最后一栋房屋，也就是把这个圆环展平来看。这样，我们可以进行两次动态规划，然后比较它们最终维护的值的大小并返回最大的值。现在我们可以把这两此动态规划单独看作是不同的两排房屋，没有头尾相连的约束条件了。<br />
*
对于排除第一栋房屋来说，我们要从第二栋房屋开始初始化，第二栋房屋现在作为我们能遍历到的第一栋房屋。遍历第一栋房子时的可获得最大价值当然就是选择偷窃第一栋房屋的价值了，因此很简单就是
<span
class="math inline">\(nums[1]\)</span>。由于我们是从第二栋房屋开始初始化，因此对于转移方程来说，我们从第三栋房屋开始就可以使用转移方程来继承子问题的解以维护最大值了，因此对于排除第一栋房子的情况来说，我们只需要初始化
<span class="math inline">\(dp\)</span> 数组中的一个值。<br />
<span class="math display">\[  
dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])  
\]</span><br />
* 对于排除最后一栋房屋来说，我们要负责初始化 <span
class="math inline">\(dp[0]\)</span> 和 <span
class="math inline">\(dp[1]\)</span>，因为动态规划的转移方程必须从下标2开始才能避免出现-1下标。<span
class="math inline">\(dp[0]\)</span> 的最大值就是 <span
class="math inline">\(nums[0]\)</span>，<span
class="math inline">\(dp[1]\)</span> 的最大值就是 <span
class="math inline">\(max(nums[0],
nums[1])\)</span>，因为如果在第二栋房屋选择偷窃，则第一栋房屋就不能偷窃，这两栋房屋的最大价值选其一。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpNobeg</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dpNobeg[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; len; ++i)</span><br><span class="line">            dpNobeg[i] = <span class="built_in">max</span>(dpNobeg[i - <span class="number">2</span>] + nums[i], dpNobeg[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpNoend</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dpNoend[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dpNoend[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">            dpNoend[i] = <span class="built_in">max</span>(dpNoend[i - <span class="number">2</span>] + nums[i], dpNoend[i - <span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dpNobeg[len - <span class="number">1</span>], dpNoend[len - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sze := <span class="built_in">len</span>(nums)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, sze)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; sze; i++ &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; sze - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(dp[sze - <span class="number">1</span>], dp[sze - <span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>2337. 移动片段得到字符串</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/2337.%20%E7%A7%BB%E5%8A%A8%E7%89%87%E6%AE%B5%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你两个字符串 <code>start</code> 和 <code>target</code> ，长度均为 <code>n</code> 。每个字符串 <strong>仅</strong> 由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成，其中：</p>
<ul>
<li>字符 <code>'L'</code> 和 <code>'R'</code> 表示片段，其中片段 <code>'L'</code> 只有在其左侧直接存在一个 <strong>空位</strong> 时才能向 <strong>左</strong> 移动，而片段 <code>'R'</code> 只有在其右侧直接存在一个 <strong>空位</strong> 时才能向 <strong>右</strong> 移动。<br />
</li>
<li>字符 <code>'_'</code> 表示可以被 <strong>任意</strong> <code>'L'</code> 或 <code>'R'</code> 片段占据的空位。</li>
</ul>
<p>如果在移动字符串 <code>start</code> 中的片段任意次之后可以得到字符串 <code>target</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> start = "_L__R__R_", target =
"L______RR"<br />
<strong>输出：</strong> true<br />
<strong>解释：</strong> 可以从字符串 start 获得 target
，需要进行下面的移动：<br />
- 将第一个片段向左移动一步，字符串现在变为 "<strong>L</strong>___R__R_"
。<br />
- 将最后一个片段向右移动一步，字符串现在变为
"L_<strong>R</strong>_<strong>R</strong>" 。<br />
- 将第二个片段向右移动三步，字符串现在变为 "L______<strong>R</strong>R"
。<br />
可以从字符串 start 得到 target ，所以返回 true 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> start = "R_L_", target = "__LR"<br />
<strong>输出：</strong> false<br />
<strong>解释：</strong> 字符串 start 中的 'R' 片段可以向右移动一步得到
"<em><strong>R</strong>L</em>" 。<br />
但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到
target 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> start = "_R", target = "R_"<br />
<strong>输出：</strong> false<br />
<strong>解释：</strong> 字符串 start
中的片段只能向右移动，所以无法从字符串 start 得到 target 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == start.length == target.length</code><br />
</li>
<li><code>1 &lt;= n &lt;= 105</code><br />
</li>
<li><code>start</code> 和 <code>target</code> 由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成</li>
</ul>
<p><strong>标签：</strong><br />
==双指针== ==字符串==</p>
<p>既然字符串长度这么长，那肯定最多是O(n)的时间复杂度了，也就是一边读取一边处理，不可能统计完整个字符串的数据再回来处理。一个最简单的比较字符串是否相等的方法就是看字符是否能一一对应的上，不仅检查了种类，还检查了数量，因此，假设把
'_'
字符看作空直接去除，一一比较剩下的字符的话，最好的办法就是双指针，一个指针指向一条字符串，然后一个字符一个字符比较着推进，如果遇到不同的字符直接返回false。就是一个while循环的事，同时处理一下，指针遇到字符'_'时直接跳过，遇到'L'或者'R'才停下来。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canChange</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line">        uint len = str1.<span class="built_in">size</span>();</span><br><span class="line">        uint sp1 = <span class="number">0</span>;</span><br><span class="line">        uint sp2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sp1 &lt; len || sp2 &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (sp1 &lt; len &amp;&amp; str1[sp1] == <span class="string">&#x27;_&#x27;</span>) sp1++;</span><br><span class="line">            <span class="keyword">while</span> (sp2 &lt; len &amp;&amp; str2[sp2] == <span class="string">&#x27;_&#x27;</span>) sp2++;</span><br><span class="line">            <span class="keyword">if</span> (sp1 == len || sp2 == len)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sp1 == sp2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str1[sp1] ^ str2[sp2]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            sp1++;</span><br><span class="line">            sp2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是这样只能过前两个用例，第三个用例无法通过。观察第三个用例，发现很巧妙的源字符串的'R'左边有'_'，导致源字符串的'R'无法左移，因此无法转变为目标字符串，由此我们可以除普通的字符串比较条件外（种类、数量）发现第二个限制条件，那就是第一个指向第一个字符串的字符与指向第二个字符串的字符的相对位置。因为本题要求str1尝试转变为str2；假设现在两个字符指针指向相同的字母：<br />
1.
都指向'L'：则此时指针sp1位置必须大于等于sp2指针位置，这代表sp1的'L'可以左滑至sp2的位置，否则sp1的'L'是无法往右移动达到sp2的位置的。<br />
2.
都指向'R'：则此时指针sp1位置必须小于等于sp2指针位置，这代表sp1的'R'可以又滑至sp2的位置，否则sp1的'R'是无法往左移动达到sp2的位置的。</p>
<p>基于以上条件，修改代码增加限制条件：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canChange</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line">        uint len = str1.<span class="built_in">size</span>();</span><br><span class="line">        uint sp1 = <span class="number">0</span>;</span><br><span class="line">        uint sp2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sp1 &lt; len || sp2 &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (sp1 &lt; len &amp;&amp; str1[sp1] == <span class="string">&#x27;_&#x27;</span>) sp1++;</span><br><span class="line">            <span class="keyword">while</span> (sp2 &lt; len &amp;&amp; str2[sp2] == <span class="string">&#x27;_&#x27;</span>) sp2++;</span><br><span class="line">            <span class="keyword">if</span> (sp1 == len || sp2 == len)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sp1 == sp2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str1[sp1] ^ str2[sp2]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// try to transform str1 to str2</span></span><br><span class="line">            <span class="type">char</span> curchar = str1[sp1];</span><br><span class="line">            <span class="keyword">if</span> (curchar == <span class="string">&#x27;L&#x27;</span> &amp;&amp; sp1 &lt; sp2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (curchar == <span class="string">&#x27;R&#x27;</span> &amp;&amp; sp1 &gt; sp2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            sp1++;</span><br><span class="line">            sp2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>2560. 打家劫舍 IV</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/2560.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20IV/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。</p>
<p>由于相邻的房屋装有相互连通的防盗系统，所以小偷 <strong>不会窃取相邻的房屋</strong> 。</p>
<p>小偷的 <strong>窃取能力</strong> 定义为他在窃取过程中能从单间房屋中窃取的 <strong>最大金额</strong> 。</p>
<p>给你一个整数数组 <code>nums</code> 表示每间房屋存放的现金金额。形式上，从左起第 <code>i</code> 间房屋中放有 <code>nums[i]</code> 美元。</p>
<p>另给你一个整数 <code>k</code> ，表示窃贼将会窃取的 <strong>最少</strong> 房屋数。小偷总能窃取至少 <code>k</code> 间房屋。</p>
<p>返回小偷的 <strong>最小</strong> 窃取能力。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> <code>nums = [2,3,5,9], k = 2</code><br />
<strong>输出：</strong> <code>5</code><br />
<strong>解释：</strong><br />
小偷窃取至少 2 间房屋，共有 3 种方式：<br />
- 窃取下标 0 和 2 处的房屋，窃取能力为
<code>max(nums[0], nums[2]) = 5</code> 。<br />
- 窃取下标 0 和 3 处的房屋，窃取能力为
<code>max(nums[0], nums[3]) = 9</code> 。<br />
- 窃取下标 1 和 3 处的房屋，窃取能力为
<code>max(nums[1], nums[3]) = 9</code> 。<br />
因此，返回 <code>min(5, 9, 9) = 5</code> 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> <code>nums = [2,7,9,3,1], k = 2</code><br />
<strong>输出：</strong> <code>2</code><br />
<strong>解释：</strong> 共有 7
种窃取方式。窃取能力最小的情况所对应的方式是窃取下标 0 和 4
处的房屋。返回 <code>max(nums[0], nums[4]) = 2</code> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code><br />
</li>
<li><code>1 &lt;= nums[i] &lt;= 109</code><br />
</li>
<li><code>1 &lt;= k &lt;= (nums.length + 1)/2</code></li>
</ul>
<p>从题目的限制条件可知，小偷最少窃取的房屋数量不会超过房屋总数的一半，毕竟最多的偷取方式就是间隔偷取了，而连续元素间隔抽取即等价于元素总数的一半。</p>
<p>这题最坑的地方在于题目的误导性：“返回小偷的 <strong>最小</strong> 窃取能力”，这很容易让人误以为本题要求小偷偷尽可能少的房屋并且这些房屋的价值都要尽可能的小，这样这些房屋的价值最大值才会尽可能的小。本着“先使用最简单的方法再逐渐优化”的做题思想，我先按照自己认为的可能比较合适的方案去实现了这个思路，但是很可惜，只能过60%的用例，并且还不是超时错误，就是用例错误，这说明思路可能有缺漏或者根本上就是错误的。事实证明，这道题确实与贪心无关，与我最开始的思路就不是一个类型的。<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCapability</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = k;</span><br><span class="line">        map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; numToIdx;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(len + <span class="number">2</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            numToIdx[nums[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = numToIdx.<span class="built_in">begin</span>(); it != numToIdx.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> validCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; idx : it-&gt;second)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[idx] &amp;&amp; !visited[idx + <span class="number">1</span>] &amp;&amp; !visited[idx + <span class="number">2</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    validCnt++;</span><br><span class="line">                    visited[idx + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; validCnt &lt;&lt; endl;</span><br><span class="line">            cnt -= validCnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= <span class="number">0</span>) <span class="keyword">return</span> it-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; k == (len + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> oddMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>)</span><br><span class="line">                oddMax = <span class="built_in">max</span>(oddMax, nums[i]);</span><br><span class="line">            <span class="keyword">return</span> oddMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; k == (len + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> evnMax1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>)</span><br><span class="line">                evnMax1 = <span class="built_in">max</span>(evnMax1, nums[i]);</span><br><span class="line">            <span class="type">int</span> evnMax2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>)</span><br><span class="line">                evnMax2 = <span class="built_in">max</span>(evnMax2, nums[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(evnMax1, evnMax2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这确实是模拟和暴力的感觉，因为一般的最优题解不会超过50行。上述思路实现的是——“窃取尽可能少的房屋并且维护已偷窃的房屋的最大价值”。首先使用红黑树map记录每种价值的房屋的位置（为了防止窃取到相邻的两间房屋），然后从价值最低的房屋开始窃取，一旦已经窃取了
<code>k</code>
间或以上数量的房屋，那么直接返回目前的最大值。这是利用了二叉搜索树的有序遍历性质。这个思路的关键在于贪心，先贪价值最小的房屋，这样能保证维护中的最大值增长地尽可能地慢，在窃取的同时我们必须认真检查有没有窃取到相邻的房屋，如果是相邻的房屋那么就跳过，并且不计入已窃取的房屋数量；直到窃取完某个价值的房屋之后发现窃取的总数已经大于等于<code>k</code>，返回当前正在窃取的房屋的价值，就是已窃取房屋的最大价值，也就是题意要求的
<strong>最小窃取能力</strong>。</p>
<p>可惜这忽略了一个点，那就是打家劫舍系列的题目，小偷应该是偷窃尽可能多的房屋，但是上述思路刚好与之相反，偷窃尽可能少的房屋，一旦得手目标就撤退，这与小偷的“贪心”也不符合。</p>
<p>本题的题意可以理解为以下两种方式：</p>
<p>题意（版本 A）<br />
说，有个小偷公司，给小偷定的 KPI
是偷至少 k 间房子，要求偷的房子不能相邻。<br />
张三作为其中的一个小偷，他不想偷太多，否则一不小心就「数额巨大」，这可太刑了。所以张三计划，在他偷过的房子中，偷走的最大金额要尽量地小。这个最小值是多少呢？</p>
<p>题意（版本 B）<br />
给定数组 nums，从中选择一个长度至少为 k 的子序列 A，要求 A 中没有任何元素在 nums 中是相邻的。最小化 max⁡(A)。</p>
<p>本题的解法与题目<a
href="obsidian://open?vault=testrepo&amp;file=algorithmn%2Fleetcode%2Fmidium%2F2594.%20%E4%BF%AE%E8%BD%A6%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4">2594.修车的最少时间</a>是一样的，通过二分查找最优的值来推断。注意，能使用二分查找的题目一定在某个方面具有单调递增的性质。本题单调递增的性质是：<strong>小偷只要偷窃了一间房屋，那么窃取总值一定增加而不会减少或不变</strong>。</p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>2594. 修车的最少时间</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/2594.%20%E4%BF%AE%E8%BD%A6%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你一个整数数组 <code>ranks</code> ，表示一些机械工的 <strong>能力值</strong> 。<code>ranksi</code> 是第 <code>i</code> 位机械工的能力值。能力值为 <code>r</code> 的机械工可以在 <code>r * n2</code> 分钟内修好 <code>n</code> 辆车。</p>
<p>同时给你一个整数 <code>cars</code> ，表示总共需要修理的汽车数目。</p>
<p>请你返回修理所有汽车 <strong>最少</strong> 需要多少时间。</p>
<p><strong>注意：</strong> 所有机械工可以同时修理汽车。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> ranks = [4,2,3,1], cars = 10<br />
<strong>输出：</strong> 16<br />
<strong>解释：</strong><br />
- 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。<br />
- 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。<br />
- 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。<br />
- 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。<br />
16 分钟是修理完所有车需要的最少时间。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> ranks = [5,1,8], cars = 6<br />
<strong>输出：</strong> 16<br />
<strong>解释：</strong><br />
- 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。<br />
- 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。<br />
- 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。<br />
16 分钟时修理完所有车需要的最少时间。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= ranks.length &lt;= 10^5</code><br />
</li>
<li><code>1 &lt;= ranks[i] &lt;= 100</code><br />
</li>
<li><code>1 &lt;= cars &lt;= 10^6</code></li>
</ul>
<p>这题看起来像
01背包问题的变例，其实仔细观察发现这题并不能使用背包问题的模板去解题，因为所有修理工可以同时修车，而数组没办法同时维护，只能是线性地维护。这题做的时候没有太好的思路，知道自己一时半会是解不出来的，所以索性就去看题解了。</p>
<p>根据题解，一个关键的需要理解的地方是，如果给定时间 <span
class="math inline">\(t\)</span>，并且所有的工人是可以同时开工的，那么这个时间
<span class="math inline">\(t\)</span>
是可以对所有工人求出他们能确切修理的车辆数量。<br />
<span class="math display">\[  
num[i] = \sqrt{\frac{t}{rank[i]}}  
\]</span><br />
因此，我们可以求出所有工人可修理的车辆数量之和，然后与 <span
class="math inline">\(cars\)</span> 进行比较，如果可修理车辆总数大于
<span
class="math inline">\(cars\)</span>，那么说明这是一种可行的修车方案，但是不一定是用时最少的方案。如何找到用时最少的方案呢？当然可以从1分钟一直枚举到统计的修理车辆总数大于
<span class="math inline">\(cars\)</span>
为止然后输出，但是这种算法显然是 <span
class="math inline">\(O(n^2)\)</span>
的，对于题目给定的数据范围不一定能通过。</p>
<p>本题的答案值域通过观察可以发现，如果某个时间 <span
class="math inline">\(t\)</span> 能修完所有的车辆，那么之后所有的时间
<span class="math inline">\(t&#39;\)</span>
都是一定能修完所有车辆的，如果某个时间 <span
class="math inline">\(t\)</span>
无法修完所有的车辆，那么其之前的时间点也一定无法修完所有的车辆，这说明答案的值域是有单调性的。在有单调性的值域上进行查询，我们可以使用二分查找，但问题是如何确定查找的上界。任意一名修理工完成修车的时间都可以作为上界，因为既然一名修理工能在时间
<span class="math inline">\(t\)</span>
之内完成修车任务，那么不止一名修理工的时候修车时间肯定更短。虽然不同修理工单独完成所有车辆修理工作的总时间不一定相同（也就是我们有多个可选择的上界），但是这些上界都是合法的上界，它们一定大于多名修理工修理完所有车辆所需的时间。因此我们选择0分钟作为下界，任意一名修理工修理完成所有车辆的时间作为上界，如此进行二分查找即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">repairCars</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">int</span> cars)</span> </span>&#123;</span><br><span class="line">        ll l = <span class="number">1</span>;</span><br><span class="line">        ll r = <span class="number">1ll</span> * ranks[<span class="number">0</span>] * cars * cars;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](ll time)</span><br><span class="line">        &#123;</span><br><span class="line">            ll cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; rank : ranks)</span><br><span class="line">                cnt += <span class="built_in">sqrt</span>(time / rank);</span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= cars;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            ll m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(m))</span><br><span class="line">                r = m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>2596. 检查骑士巡视方案</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/2596.%20%E6%A3%80%E6%9F%A5%E9%AA%91%E5%A3%AB%E5%B7%A1%E8%A7%86%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>骑士在一张 <code>n x n</code> 的棋盘上巡视。在 <strong>有效</strong> 的巡视方案中，骑士会从棋盘的 <strong>左上角</strong> 出发，并且访问棋盘上的每个格子 <strong>恰好一次</strong> 。</p>
<p>给你一个 <code>n x n</code> 的整数矩阵 <code>grid</code> ，由范围 <code>[0, n * n - 1]</code> 内的不同整数组成，其中 <code>grid[row][col]</code> 表示单元格 <code>(row, col)</code> 是骑士访问的第 <code>grid[row][col]</code> 个单元格。骑士的行动是从下标 <strong>0</strong> 开始的。</p>
<p>如果 <code>grid</code> 表示了骑士的有效巡视方案，返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><strong>注意</strong>，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。<br />
<img src="https://pic.leetcode.cn/1694590028-CTMBQL-image.png" /></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode.cn/1694590044-AmhkRb-image.png" /></p>
<p><strong>输入：</strong> grid =
[[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]<br />
<strong>输出：</strong> true<br />
<strong>解释：</strong> grid
如上图所示，可以证明这是一个有效的巡视方案。</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://pic.leetcode.cn/1694590057-FIMBAG-image.png" /></p>
<p><strong>输入：</strong> grid = [[0,3,6],[5,8,1],[2,7,4]]<br />
<strong>输出：</strong> false<br />
<strong>解释：</strong> grid 如上图所示，考虑到骑士第 7
次行动后的位置，第 8 次行动是无效的。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length == grid[i].length</code><br />
</li>
<li><code>3 &lt;= n &lt;= 7</code><br />
</li>
<li><code>0 &lt;= grid[row][col] &lt; n * n</code><br />
</li>
<li><code>grid</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p>本题看到数据范围可以直接进行模拟了，直接按照题意对每一步和下一步检查是否合法即可。我们可以用一个数组保存按顺序的每一步的行和列位置，因为每一步的顺序题目给定的那个数组已经给出了，我们只需要按照顺序填入维护数组的对应位置即可。</p>
<p>需要注意的是，如果骑士的第一步并不是从左上角开始的话，那么并不是一个有效的巡视方案。</p>
<p>可以单独把检查每一步与下一步的行动是否合法的代码封装为一个函数，方便调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    uint boardLen;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidStep</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pos0, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pos1)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        uint absrow = <span class="built_in">abs</span>(pos0[<span class="number">0</span>] - pos1[<span class="number">0</span>]);</span><br><span class="line">        uint abscol = <span class="built_in">abs</span>(pos0[<span class="number">1</span>] - pos1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> (absrow == <span class="number">1</span> &amp;&amp; abscol == <span class="number">2</span>) || (absrow == <span class="number">2</span> &amp;&amp; abscol == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidGrid</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        boardLen = grid.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">poses</span>(boardLen * boardLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boardLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; boardLen; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                poses[grid[i][j]] = vector&lt;<span class="type">int</span>&gt; &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (poses[<span class="number">0</span>][<span class="number">0</span>] + poses[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// not start from left up corner</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boardLen * boardLen - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isValidStep</span>(poses[i], poses[i + <span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidStep</span><span class="params">(pos0, pos1 []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    absrow := abs(pos0[<span class="number">0</span>] - pos1[<span class="number">0</span>])</span><br><span class="line">    abscol := abs(pos0[<span class="number">1</span>] - pos1[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> (absrow == <span class="number">1</span> &amp;&amp; abscol == <span class="number">2</span>) || (absrow == <span class="number">2</span> &amp;&amp; abscol == <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkValidGrid</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    boardLen := <span class="built_in">len</span>(grid)</span><br><span class="line">    poses := <span class="built_in">make</span>([][]<span class="type">int</span>, boardLen * boardLen)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; boardLen; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; boardLen; j++ &#123;</span><br><span class="line">            poses[grid[i][j]] = []<span class="type">int</span>&#123;i, j&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> poses[<span class="number">0</span>][<span class="number">0</span>] + poses[<span class="number">0</span>][<span class="number">1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; boardLen * boardLen - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> !isValidStep(poses[i], poses[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>309. 买卖股票的最佳时机含冷冻期</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/309.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给定一个整数数组<code>prices</code>，其中第  <code>prices[i]</code> 表示第 <code>_i_</code> 天的股票价格
。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>注意：</strong>
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong><br />
<strong>输入:</strong> <code>prices = [1,2,3,0,2]</code><br />
<strong>输出:</strong> <code>3</code> <strong>解释:</strong>
对应的交易状态为: <code>[买入, 卖出, 冷冻期, 买入, 卖出]</code></p>
<p><strong>示例 2:</strong><br />
<strong>输入:</strong> <code>prices = [1]</code><br />
<strong>输出:</strong> <code>0</code></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 5000</code><br />
</li>
<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
<p>如果已经做过买卖股票系列的第三第四题的话，可以比较容易地做出本题，因为只要是买卖股票系列的题，都有一个通用的动态规划状态设计解，而这个解法在第三题开始出现，第四题对这种动态规划的状态设计进行了拓展。<a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii">买卖股票III</a>、<a
href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv">买卖股票IV</a></p>
<p>本题因为没有限制买卖的总次数，因此还是需要使用动态规划来解决，并且通过前面
<span class="math inline">\(i-1\)</span> 天观测数据的子问题最优解得到第
<span class="math inline">\(i\)</span> 天的最优解。</p>
<h2 id="动态规划基本设计">动态规划基本设计</h2>
<p>仿照买卖股票第三第四题的思路，我们可以把每个交易日结束时的终态分为两个状态：手中持有股票和手中未持有股票；我们分别设这两个状态为
<span class="math inline">\(buy\)</span> 和 <span
class="math inline">\(sel\)</span>。只有买入了股票作为前提，交易日的终态才能具有“持有股票”这一状态，可以是在当日买入也可以是在之前买入了但是没有卖出，如果是当天买入的话我们还能得知一个额外的约束——昨天一定没有卖出过股票；如果当天的终态是未持有股票，那么可能是当天卖出了也可能是之前卖出了但是一直没有买入。</p>
<p>通过上述分析我们来看状态转移方程：<br />
- 今天是持有股票终态 <span
class="math inline">\(buy[i]\)</span>：如果是今天的买入操作导致的，则昨天一定没有卖出股票，并且在今天买入股票前手上未持有股票（题目要求开启一笔交易前另一笔交易一定要完成），所以得知昨天一定没有卖出股票并且手上没有持有股票，前天一定是“未持有股票”状态，如果前天已经持有股票了而昨天又不能卖出，那么当天就无法再次购入股票了，因此可以确定的是
<span class="math inline">\(sel[i-2]\)</span> 这个状态，但我们不能用
<span class="math inline">\(sel[i-1]\)</span>，因为这代表着第 <span
class="math inline">\(i -1\)</span>
个时刻的卖出操作导致的“未持有股票终态”，而我们想当天买股票的话，昨天是不能有卖出操作的。如果不是今天的买入操作导致的“持有股票”终态，那么就是之前某个时刻买的股票但是没有卖掉，那么今天没有做任何操作，沿用的是
<span class="math inline">\(buy[i - 1]\)</span>。<br />
- <span class="math display">\[  
  buy[i] = max(buy[i - 1], sel[i - 2] - pricies[i])  
  \]</span><br />
- 今天是未持有股票终态 <span
class="math inline">\(sel[i]\)</span>：如果是今天的卖出操作导致的，则可以确定的是，我们昨天一定是以“持有股票”终态结束了一天的交易日，因此依赖的状态是
<span
class="math inline">\(buy[i-1]\)</span>，如果是之前的卖出操作然后一直没有买股票，那么没有持有股票的最大可能的利润当然是拥有越多的观测数据越好，也就是最大值贪心的话是
<span class="math inline">\(sel[i-1]\)</span>。<br />
- <span class="math display">\[  
  sel[i] = max(sel[i - 1], buy[i - 1] + prices[i])  
  \]</span><br />
有了状态转移方程之后，就可以开始考虑边界条件的初始化了。因为我们的下标涉及到
<span class="math inline">\(i -
2\)</span>，所以前两个位置的子问题最优解肯定需要我们自己初始化，因为我们的dp遍历将从
<span class="math inline">\(i = 2\)</span> 开始。<br />
当只有一天的观测数据时：<br />
- <span
class="math inline">\(buy[0]\)</span>：要在第0天以持有股票的状态结束，那么只能买入，所以
<span class="math inline">\(buy[0] = -prices[0]\)</span><br />
- <span
class="math inline">\(sel[0]\)</span>：要在第0天以未持有股票的状态结束，并且还要求利润的最大值，那么最好的方法就是不买入，因为买入了再卖出今天的股票也没有波动不会有差价可以赚。<br />
当有两天的观测数据时：<br />
- <span
class="math inline">\(buy[1]\)</span>：第1天以持有股票的状态结束，并且要求最大利润。如果我们是第0天购买了股票，第1天卖，但是为了以“持有股票”的状态结束，必须会再购买回来，这样一来今天的买卖相互抵消了，也就等价于第一天买了今天没有操作。如果是第1天购买了股票，我们也能以“持有股票”的状态结束，所以现在第0、1天都只能是买入股票这个选项，就看谁亏的少一些<br />
- <span
class="math inline">\(sel[1]\)</span>：第1天以“未持有股票”的状态结束，并且要求最大利润。如果我们在第0天买入了股票并且第1天上涨了，我们可以卖出专区差价，否则如果第0天买的第1天跌了我们还卖出股票就会有亏损，那还不如最开始的时候不买（这是因为我们有上帝视角，现实生活中的炒股不可能知道明天的情况来指导今天的购买的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, prices[<span class="number">1</span>] - prices[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sel</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sel[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        buy[<span class="number">1</span>] = <span class="built_in">max</span>(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">        sel[<span class="number">1</span>] = <span class="built_in">max</span>(<span class="number">0</span>, prices[<span class="number">1</span>] - prices[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            buy[i] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>], sel[i - <span class="number">2</span>] - prices[i]);</span><br><span class="line">            sel[i] = <span class="built_in">max</span>(sel[i - <span class="number">1</span>], buy[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sel[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>337. 打家劫舍 III</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。
如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p>
<p><strong>示例 1:</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" /></p>
<p><strong>输入:</strong>
<code>root = [3,2,3,null,3,null,1]</code><br />
<strong>输出:</strong> <code>7</code>
<strong>解释:</strong> 小偷一晚能够盗取的最高金额
<code>3 + 3 + 1 = 7</code></p>
<p><strong>示例 2:</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" /></p>
<p><strong>输入:</strong> <code>root = [3,4,5,1,3,null,1]</code><br />
<strong>输出:</strong> <code>9</code><br />
<strong>解释:</strong> 小偷一晚能够盗取的最高金额
<code>4 + 5 = 9</code></p>
<p><strong>提示：</strong></p>
<ul>
<li>树的节点数在 <code>[1, 104]</code> 范围内<br />
</li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p>本题是打家劫舍系列题中的第二题，通过前面两题可知，这个系列的题一般是动态规划解法，但是本题的主要数据结构是二叉树，这怎么和动态规划联系起来呢？遇到本体的树形dp时，一个简单的想法是二叉树的某一层都选择然后相邻的上下两层都不选取，但这其实也是错误的想法，因为每棵子树都有自己的最大值维护，因此不能和整棵树的其他子树相联系。</p>
<p>在前面的打家劫舍题目中，我们的动态规划需要用到当前遍历到的
<code>nums[i]</code> 的值以及 <code>nums[i - 1]</code> 和
<code>nums[i - 2]</code>的值，在树形结构中，我们可以直接得到子节点的值，也就对应于了线性表结构的
<code>nums[i - 1]</code>，但是 <code>nums[i - 2]</code>
要怎么办呢？一般二叉树结构并没有指向子节点的子节点的指针，这导致我们无法把线性表上的方法类比到这题，线性表由于其可以直接
<span class="math inline">\(o(1)\)</span>
索引的特性，从而可以方便地应用状态转移方程，但是树形结构无法直接索引，所以必须通过某种遍历方式先去到最底层获取各个子问题的解，然后逐渐往上回溯以求解出更大的问题，那么本题显然需要使用中序遍历而非前序遍历或者后序遍历，我们需要直到左右子树作为子问题的最优解之后，才能得出根节点的最优解。</p>
<p>可以类比<a
href="obsidian://open?vault=testrepo&amp;file=algorithmn%2Fleetcode%2Fmidium%2F213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II">打家劫舍II</a>，我们需要维护两条线路，<strong>可以选择某个节点</strong>
和 <strong>不可以选择某个节点</strong>
的最优解，然后在最后比较这两条线路的最优解来得到最终的最优解。在本题的树形结构中，我们可以很容易的感知到，一个节点可以被选择或者不被选择而跳过，这会产生两个解，因此我们可以先假定认为，解决问题的函数需要一次返回两个值。</p>
<p>现在我们可以思考得到这题树形DP的状态转移方程：<br />
* 当本层根节点被选择时，两个子节点是可不以被选择的，因此我们在</p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>449. 序列化和反序列化二叉搜索树</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/449.%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>
<p>设计一个算法来序列化和反序列化 <strong>二叉搜索树</strong> 。
对序列化/反序列化算法的工作方式没有限制。
您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p>
<p><strong>编码的字符串应尽可能紧凑。</strong></p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> root = [2,1,3]<br />
<strong>输出：</strong>[2,1,3]</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> root = []<br />
<strong>输出：</strong>[]</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数范围是 <code>[0, 104]</code><br />
</li>
<li><code>0 &lt;= Node.val &lt;= 10^4</code><br />
</li>
<li>题目数据 <strong>保证</strong> 输入的树是一棵二叉搜索树。</li>
</ul>
<p>做过剑指OfferII的同学看到这一题第一印象应该是这题 —— <a
href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">剑指
Offer
37. 序列化二叉树</a>，但是那题的难度是困难。本题之所以是中等题是因为添加了一个辅助条件——搜索树。而之前那题是普通二叉树，没有限制是二叉搜索树。二叉搜索树的恢复需要前序遍历或者后序遍历即可（前序遍历和后序遍历来恢复搜索二叉树结构的核心思想是一样的），而普通二叉树想要恢复序列化字符串必须设计合理的编译器解析文法才行，设计编译器文法的难度较大。</p>
<p>本题无需按照剑指Offer37.题的设计编译器文法的方法来解题。只需要对原始的搜索二叉树进行前序遍历或者后序遍历（我使用了前序遍历），并得到前序遍历的数值序列的字符串即可算作是序列化了。</p>
<p>反序列化需要先将字符串所代表的前序遍历数组转换为数组先（我使用了std::vector&lt;int&gt;），然后就能使用前序遍历数组还原搜索二叉树了。第一个数是二叉树的根，根据搜索二叉树的性质，右子树的所有值一定比根大，左子树的所有值一定比根小，那么即使前序遍历数组没有经过排序，它仍然是部分有序的，一定是先是一段左子树的前序遍历序列，然后是右子树的前序遍历序列，我们只需要找到右子树的根，即可把原前序遍历数组划分为左子树的前序遍历数组和右子树的前序遍历数组，然后再递归地使用相同的方法用子树的前序遍历数组还原子树的结构。</p>
<p>提示：利用 &lt;algorithm&gt;
头文件的upper_bound和lower_bound函数来方便地找到右子树的根，因为右子树的根是原前序遍历数组中第一个大于根的值的数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; nodeVec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeVec.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nodeVec[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(nodeVec.<span class="built_in">begin</span>(), nodeVec.<span class="built_in">end</span>(), root-&gt;val);</span><br><span class="line">        TreeNode* leftSub  = <span class="built_in">helper</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nodeVec.<span class="built_in">begin</span>() + <span class="number">1</span>, it));</span><br><span class="line">        TreeNode* rightSub = <span class="built_in">helper</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(it, nodeVec.<span class="built_in">end</span>()));</span><br><span class="line">        root-&gt;left = leftSub;</span><br><span class="line">        root-&gt;right = rightSub;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string serializedLeft = <span class="built_in">serialize</span>(root-&gt;left);</span><br><span class="line">        string serializedRight = <span class="built_in">serialize</span>(root-&gt;right);</span><br><span class="line">        string serializedRoot = <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> serializedRoot + <span class="string">&quot; &quot;</span> + serializedLeft + <span class="string">&quot; &quot;</span> + serializedRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dataLen = data.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nodeVec;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::string_view <span class="title">dataView</span><span class="params">(data)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dataLen; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> j = i;</span><br><span class="line">                    <span class="keyword">while</span> (data[j] != <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">                    nodeVec.<span class="built_in">emplace_back</span>(<span class="built_in">stoi</span>(std::<span class="built_in">string</span>(dataView.<span class="built_in">substr</span>(i, j - i))));</span><br><span class="line">                    i = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(nodeVec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec* ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec* deser = new Codec();</span></span><br><span class="line"><span class="comment">// string tree = ser-&gt;serialize(root);</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser-&gt;deserialize(tree);</span></span><br><span class="line"><span class="comment">// return ans;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>56. 合并区间</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> intervals =
[[1,3],[2,6],[8,10],[15,18]]<br />
<strong>输出：</strong> [[1,6],[8,10],[15,18]]<br />
<strong>解释：</strong> 区间 [1,3] 和 [2,6] 重叠, 将它们合并为
[1,6].</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> intervals = [[1,4],[4,5]]<br />
<strong>输出：</strong> [[1,5]]<br />
<strong>解释：</strong> 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 10^4</code><br />
</li>
<li><code>intervals[i].length == 2</code><br />
</li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 10^4</code></li>
</ul>
<p>本题属于模拟题，按照题目的意思进行求解即可。但是，模拟题的难点一般都是边界情况的处理。本题在求解的过程中踩了几个坑：<br />
1.
题目给出的用例是按照区间的起点排序好了，但是实际其他用例不一定有经过排序，需要用户自己完成排序处理。<br />
2.
区间的长度是不定的，与区间所在的排序后的位置无关，有可能前面的区间覆盖了后面很多个区间，而不一定是前一个区间只覆盖了后一个区间。<br />
3.
如何处理只有一个区间的覆盖区间？因为最终产生的区间段是不存在重复的，因此双指针每检测完一个覆盖区间，要怎么摆放双指针呢？两个指针都指向同一个位置还是头尾分别指向不同的位置？</p>
<p>考虑完上述问题后，就可以开始编写了，代码如下：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(</span><br><span class="line">            intervals.<span class="built_in">begin</span>(),</span><br><span class="line">            intervals.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; v1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; v2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        uint len = intervals.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        uint p = <span class="number">0</span>;</span><br><span class="line">        uint q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; len &amp;&amp; q &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> beg = intervals[p][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> end = intervals[q][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (q + <span class="number">1</span> &lt; len &amp;&amp; end &gt;= intervals[q + <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                end = <span class="built_in">max</span>(end, intervals[q + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;beg, end&#125;);</span><br><span class="line">            q++;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>57. 插入区间</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/57.%20%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你一个 <strong>无重叠的</strong> _，_按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> intervals = [[1,3],[6,9]], newInterval =
[2,5]<br />
<strong>输出：</strong>[[1,5],[6,9]]</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> intervals =
[[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br />
<strong>输出：</strong>[[1,2],[3,10],[12,16]]<br />
<strong>解释：</strong> 这是因为新的区间 <code>[4,8]</code> 与
<code>[3,5],[6,7],[8,10]</code> 重叠。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> intervals = [], newInterval = [5,7]<br />
<strong>输出：</strong>[[5,7]]</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong> intervals = [[1,5]], newInterval =
[2,3]<br />
<strong>输出：</strong>[[1,5]]</p>
<p><strong>示例 5：</strong></p>
<p><strong>输入：</strong> intervals = [[1,5]], newInterval =
[2,7]<br />
<strong>输出：</strong>[[1,7]]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= intervals.length &lt;= 10^4</code><br />
</li>
<li><code>intervals[i].length == 2</code><br />
</li>
<li><code>0 &lt;= intervals[i][0] &lt;= intervals[i][1] &lt;= 10^5</code><br />
</li>
<li><code>intervals</code> 根据 <code>intervals[i][0]</code> 按 <strong>升序</strong> 排列<br />
</li>
<li><code>newInterval.length == 2</code><br />
</li>
<li><code>0 &lt;= newInterval[0] &lt;= newInterval[1] &lt;= 10^5</code></li>
</ul>
<p>这题的序号是57，并且题目名称是“插入区间”，所以做过<a
href="obsidian://open?vault=testrepo&amp;file=algorithmn%2Fleetcode%2F56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4">第56题
-
合并区间</a>的同学一眼就能看出应该与第56题是有关联的，因此本题的一半解法就是直接将
newInterval
插入原有的区间列表，然后调用第56题合并区间的解法来求解。这样的时间复杂度是<span
class="math inline">\(O(n +
logn)\)</span>，以题目给出的数据范围来看，还是可以接受的。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merges</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(</span><br><span class="line">            intervals.<span class="built_in">begin</span>(),</span><br><span class="line">            intervals.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; v1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; v2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        uint len = intervals.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        uint p = <span class="number">0</span>;</span><br><span class="line">        uint q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; len &amp;&amp; q &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> beg = intervals[p][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> end = intervals[q][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (q + <span class="number">1</span> &lt; len &amp;&amp; end &gt;= intervals[q + <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                end = <span class="built_in">max</span>(end, intervals[q + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;beg, end&#125;);</span><br><span class="line">            q++;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        intervals.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merges</span>(intervals);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然这样解题很方便，但是使用了排序还是会导致时间复杂度的增加。本题如果不嫌麻烦，也可以使用枚举
newInterval 可能存在与 intervals
位置的不同情况来完成。使用情况枚举的话，时间复杂度可以降低至<span
class="math inline">\(O(n)\)</span>，但是枚举对于ACM模式下的题目并不友好，leetcode
是核心模式，每个无法通过的样例都会给出，这样的话是很容易完善代码补全缺漏的情况的。但如果是
ACM 原始模式的话，并不会给出无法通过的样例，只会显示 <strong>Wrong
Answer</strong>，这个时候就很难去想到一些特殊用例了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="type">int</span> len = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;newInterval&#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">bool</span> inserted = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// case 1</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[<span class="number">0</span>][<span class="number">0</span>] &gt; newInterval[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">            inserted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt;= newInterval[<span class="number">0</span>] &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> beg = <span class="built_in">min</span>(intervals[i][<span class="number">0</span>], newInterval[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">int</span> end = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], newInterval[<span class="number">1</span>]);</span><br><span class="line">                <span class="type">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; len &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= end)</span><br><span class="line">                &#123;</span><br><span class="line">                    end = <span class="built_in">max</span>(end, intervals[j][<span class="number">1</span>]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;beg, end&#125;);</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">                inserted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 3</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[len - <span class="number">1</span>][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">            inserted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 4</span></span><br><span class="line">        <span class="keyword">if</span> (!inserted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (*it)[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">if</span> ((*it)[<span class="number">0</span>] &gt; newInterval[<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    it = ans.<span class="built_in">insert</span>(it, newInterval);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用枚举的方式，时间复杂度是 <span
class="math inline">\(O(n)\)</span>，因此提交后能超越大部分其他提交：<br />
&gt; 时间 12 ms<br />
击败 85.79%<br />
内存 16.7 MB<br />
击败 26.81%</p>
<p>一共就四种情况：<br />
1. newInterval 应该在 intervals 的开头之前插入<br />
2. newInterval 应该在 intervals 的末尾之后插入<br />
3. newInterval 会覆盖 intervals 的部分区间，需要合并<br />
4. newInterval 会成为 intervals 的一个新区间，没有合并发生</p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>714. 买卖股票的最佳时机含手续费</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/714.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格
；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><strong>示例 1：</strong><br />
<strong>输入：</strong>
<code>prices = [1, 3, 2, 8, 4, 9], fee = 2</code><br />
<strong>输出：</strong> <code>8</code><br />
<strong>解释：</strong> 能够达到的最大利润:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br></pre></td></tr></table></figure></p>
<p><strong>示例 2：</strong><br />
<strong>输入：</strong>
<code>prices = [1,3,7,5,10,3], fee = 3</code><br />
<strong>输出：</strong> <code>6</code></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 5 * 10^4</code><br />
</li>
<li><code>1 &lt;= prices[i] &lt; 5 * 10^4</code><br />
</li>
<li><code>0 &lt;= fee &lt; 5 * 10^4</code></li>
</ul>
<p>本题也是使用动态规划的买卖股票题，并且只要是买卖股票的问题，状态都可以归结为每个交易日结束的时候手上是否持有股票，记作
<span class="math inline">\(buy\)</span> 和 <span
class="math inline">\(sel\)</span>。然后分别对这每个子问题在这两个状态下的最优解进行动态规划维护即可。最后的最优答案就是以售出状态为终态的子问题的最优解，也就是
<span class="math inline">\(sel[prices.size() - 1]\)</span>
作为最优解，因为当天能卖出的话利润只可能不变或者增加，而当天买入的话肯定还要扣除买入股票的成本，更别说本题还有手续费了。</p>
<p>如果使用 <span class="math inline">\(buy\)</span> 和 <span
class="math inline">\(sel\)</span>
这两个状态来进行动态规划的话，具体的状态转移方程以及设计思路可以参考之前的买卖股票冷冻期和买卖股票IV。</p>
<p>仿照买卖股票第三第四题的思路，我们可以把每个交易日结束时的终态分为两个状态：手中持有股票和手中未持有股票；我们分别设这两个状态为
<span class="math inline">\(buy\)</span> 和 <span
class="math inline">\(sel\)</span>。只有买入了股票作为前提，交易日的终态才能具有“持有股票”这一状态，可以是在当日买入也可以是在之前买入了但是没有卖出，如果是当天卖出的话我们还能得知一个额外的约束——需要交一笔手续费。</p>
<p>通过上述分析我们来看状态转移方程：<br />
- 今天是持有股票终态 <span
class="math inline">\(buy[i]\)</span>：有两种情况：今天的买入操作导致的终态是“持有股票”
和之前买入的股票一直没有卖出导致的终态是“持有股票”。如果是今天买入的话，那么可知前一天的状态是“未持有股票”，所以是前
<span class="math inline">\(i-1\)</span> 天这个观测数据子问题的 <span
class="math inline">\(sel\)</span>
状态作为我们的子问题最优解基础，这样今天买入的话还要记得扣除掉买入的成本，这样才是今天以“持有股票”状态结束时能获取的最大利润，不要忘记了减去这个购买成本；如果是之前买入了但一直没有卖，那么可以确定前一天交易日结束时也一定是以“持有股票”作为终态，因此选择前一天子问题的
<span class="math inline">\(buy\)</span>
状态最为子问题最优解基础来求当前最优解。为什么考虑的都是前 <span
class="math inline">\(i-1\)</span> 天的观测数据而不是前 <span
class="math inline">\(i-2\)</span>
天呢？因为子问题在拥有更多观测数据的时候更有可能获得更大值的最优解，这是一个显而易见的正确贪心，多出来的观测数据只可能使我们的子问题最优解得到提升或者不变，因此我们应该选择观测数据尽量多的子问题，也就是选择
<span class="math inline">\(dp[i-1]\)</span> 而不涉及到 <span
class="math inline">\(dp[i-2]\)</span>
的原因，虽然有时候它们的最优解的值是一样的。<br />
- <span class="math display">\[  
  buy[i] = max(buy[i - 1], sel[i - 1] - prices[i])  
  \]</span><br />
- 今天是未持有股票终态 <span
class="math inline">\(sel[i]\)</span>：如果是今天的卖出操作导致的，则可以确定的是，我们昨天一定是以“持有股票”终态结束了一天的交易日，因此依赖的状态是
<span
class="math inline">\(buy[i-1]\)</span>，如果是之前的卖出操作然后一直没有买股票，那么没有持有股票的最大可能的利润当然是拥有越多的观测数据越好，也就是最大值贪心的话是
<span
class="math inline">\(sel[i-1]\)</span>，另外记住，我们卖出股票的时候相当于完成了一次交易，需要交一笔手续费的<br />
- <span class="math display">\[  
  sel[i] = max(sel[i - 1], buy[i - 1] + prices[i] - fee)  
  \]</span></p>
<p>最终的动态规划代码如下：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sel</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sel[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            buy[i] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>], sel[i - <span class="number">1</span>] - prices[i]);</span><br><span class="line">            sel[i] = <span class="built_in">max</span>(sel[i - <span class="number">1</span>], buy[i - <span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sel[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>, fee <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">len</span> := <span class="built_in">len</span>(prices)</span><br><span class="line"></span><br><span class="line">    buy := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>)</span><br><span class="line">    sel := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">    buy[<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    sel[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>; i++ &#123;</span><br><span class="line">        buy[i] = max(buy[i - <span class="number">1</span>], sel[i - <span class="number">1</span>] - prices[i])</span><br><span class="line">        sel[i] = max(sel[i - <span class="number">1</span>], buy[i - <span class="number">1</span>] + prices[i] - fee)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sel[<span class="built_in">len</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>823. 带因子的二叉树</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/823.%20%E5%B8%A6%E5%9B%A0%E5%AD%90%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给出一个含有不重复整数元素的数组 <code>arr</code> ，每个整数 <code>arr[i]</code> 均大于
1。</p>
<p>用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。</p>
<p>满足条件的二叉树一共有多少个？答案可能很大，返回 <strong>对</strong> <code>109 + 7</code> <strong>取余</strong> 的结果。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> <code>arr = [2, 4]</code><br />
<strong>输出:</strong> 3<br />
<strong>解释:</strong> 可以得到这些二叉树:
<code>[2], [4], [4, 2, 2]</code></p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> <code>arr = [2, 4, 5, 10]</code><br />
<strong>输出:</strong> <code>7</code><br />
<strong>解释:</strong> 可以得到这些二叉树:
<code>[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]</code>.</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code><br />
</li>
<li><code>2 &lt;= arr[i] &lt;= 109</code><br />
</li>
<li><code>arr</code> 中的所有值 <strong>互不相同</strong></li>
</ul>
<p>首先看到这题，大部分同学应该能在第一时间反应过来是求数组内各个数的因式分解，通过每次将数分解为两个因数的分解式，一直分解到无法在继续分解为止。</p>
<p>根据题目给出的测试样例，单独一个数作为根节点就能成为一颗树，然后一次因式分解得到的两个因数成为左右子树，并且左右子树交换位置可以算作是一颗新的树。那么选定一个数作为根节点，以给定的数组为可选因数集合，不断进行二叉分解，一共能得到多少棵子树？不难发现，其等于：<code>1 + numLeftSubTree * numRightSubTree</code>
或者
<code>1 + numLeftSubTree * numRightSubTree * 2</code>，这取决于因式分解得到的两个因数是否相同，如果不相同，那么这两个因数作为左右子树的根节点，交换这两棵子树就得到了新的组合。综上，一个数通过因式分解得到的二叉树组合数总共有：</p>
<ul>
<li>因数1 == 因数2 -&gt; 总数 = 根节点作为一棵树 + 左子树组合数 *
右子树组合数<br />
</li>
<li>因数1 != 因数2 -&gt; 总数 = 根节点作为一棵树 + 左子树组合数 *
右子树组合数 * 2</li>
</ul>
<p>因此本题的第一个重点是如何找到一个数的因式分解，最直观的方法是，将待选因数集合排序，使用双指针法，一头指向小因数，一头指向大因数，往中间扫描即可。</p>
<p>可以声明一个数组
<code>std::vector&lt;unsigned long long&gt; dpv</code>
来存储各个数所代表的二叉树组合数，这样后面其它数在因式分解时如果得到了这个之前已经求过的更小的数，可以直接从dp数组以
<span class="math inline">\(O(1)\)</span>
的时间复杂度获取。通过动态规划，我们将求解 <code>dp[i]</code>
这个问题分解为了求两个 <code>dp[x]</code> 的子问题。</p>
<p>将原数组排序后，<code>dpv[i]</code> 代表了 <code>arr[i]</code>
通过因式分解所能找到的所有二叉树组合数。由题意可知，<code>arr</code>
中的每个数均大于1，那么我们在排序后的数组中，找 <code>arr[i]</code>
的因数时，就应该在 <span class="math inline">\(arr[0] \leq \cdots &lt;
arr[i]\)</span> 中寻找。</p>
<p>以下是第一版本实现，但是首先使用了二分查找尝试是否会超时，但很明显是超时的，因为基本的上述提到的，单层的动态规划就能完成任务，我的第一次尝试却使用了递归函数，因为我当时看到二叉树，树的一个非常重要的性质就是，子树也是一棵树，能对一棵树执行的函数，自然也能够对其子树执行。所以这一版本实现虽然主题思想与官方题解是一致的，但是缺少优化：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    uint numFactors;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; factors;</span><br><span class="line">    unordered_map&lt;uint, uint&gt; dict;</span><br><span class="line">    <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; factor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = numFactors - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (factors[m] == factor) <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (factors[m] &gt; factor) r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (factors[m] &lt; factor) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binary search would exceeds the time limit</span></span><br><span class="line">    <span class="comment">// use map or unordered_map to store position</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; factorIdxs;</span><br><span class="line"></span><br><span class="line">    <span class="function">uint <span class="title">factorization</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; factor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dict[factor]) <span class="keyword">return</span> dict[factor];</span><br><span class="line">        uint cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// int factorIdx = binarySearch(factor);</span></span><br><span class="line">        <span class="type">int</span> factorIdx = factorIdxs[factor];</span><br><span class="line">        <span class="keyword">if</span> (factorIdx &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> q = factorIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="built_in">float</span>(factor) / <span class="built_in">float</span>(factors[p]) - <span class="built_in">float</span>(factors[q])) &lt; eps)</span><br><span class="line">            <span class="comment">// if (factors[p] * factors[q] == factor)</span></span><br><span class="line">            &#123;</span><br><span class="line">                uint tmp = <span class="built_in">factorization</span>(factors[p]) * <span class="built_in">factorization</span>(factors[q]);</span><br><span class="line">                <span class="keyword">if</span> (p ^ q)</span><br><span class="line">                    cnt += tmp * <span class="number">2</span>; <span class="comment">// 交换两棵子树的位置</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt += tmp;</span><br><span class="line">                p++;</span><br><span class="line">                q--;            </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">float</span>(factors[p]) &lt; <span class="built_in">float</span>(factor) / <span class="built_in">float</span>(factors[q]))</span><br><span class="line">                p++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">float</span>(factors[p]) &gt; <span class="built_in">float</span>(factor) / <span class="built_in">float</span>(factors[q]))</span><br><span class="line">                q--;</span><br><span class="line">            <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dict[factor] = cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        factors = arr;</span><br><span class="line">        numFactors = factors.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(factors.<span class="built_in">begin</span>(), factors.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// store every factor&#x27;s position</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numFactors; ++i)</span><br><span class="line">            factorIdxs[factors[i]] = i;</span><br><span class="line"></span><br><span class="line">        uint total = <span class="number">0</span>;</span><br><span class="line">        uint mod = <span class="built_in">uint</span>(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numFactors; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            total = (total + <span class="built_in">factorization</span>(factors[i])) % mod;</span><br><span class="line">            cout &lt;&lt; factors[i] &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; dict[factors[i]] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是使用动态规划的版本，优化了因式分解的查询过程：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        uint len = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;ull&gt; <span class="title">dpv</span><span class="params">(len, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        uint tlt = <span class="number">0</span>;</span><br><span class="line">        uint mod = <span class="built_in">uint</span>(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> q = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// while (p &lt;= q)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     if (ull(arr[p]) * ull(arr[q]) == ull(arr[i]))</span></span><br><span class="line">            <span class="comment">//     &#123;</span></span><br><span class="line">            <span class="comment">//         dpv[i] += (p ^ q ? dpv[p] * dpv[q] * 2 : dpv[p] * dpv[q]);</span></span><br><span class="line">            <span class="comment">//         p++;</span></span><br><span class="line">            <span class="comment">//         q--;</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">//     else if (ll(arr[i]) / ll(arr[p]) - ll(arr[q]) &gt; 0)</span></span><br><span class="line">            <span class="comment">//         p++;</span></span><br><span class="line">            <span class="comment">//     else if (ll(arr[i]) / ll(arr[p]) - ll(arr[q]) &lt; 0)</span></span><br><span class="line">            <span class="comment">//         q--;</span></span><br><span class="line">            <span class="comment">//     else &#123;&#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>, q = i - <span class="number">1</span>; p &lt;= q; p++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p &lt;= q &amp;&amp; (ll)arr[i] / (ll)arr[p] - (ll)arr[q] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p &lt;= q &amp;&amp; (ll)arr[p] * arr[q] == arr[i]) &#123;</span><br><span class="line">                    dpv[i] += (p ^ q ? dpv[p] * dpv[q] * <span class="number">2</span> : dpv[p] * dpv[q]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tlt = (tlt + dpv[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)tlt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题的第二个重点是选择合适的类型来存储中间结果。虽然题目提示，计算过程中的数可能会非常大，需要对
<span class="math inline">\(10^9 + 7\)</span>
取余，但是我还是没有想到居然能有这么大。这主要发生在我设计因式分解的双指针查找时。因为一开始我是用
<span class="math inline">\(a \times b = c\)</span>
的方式来检测是否找到因数 a 和因数 b ，但是在后面的几个测试样例中，<span
class="math inline">\(a \times b\)</span> 的值已经远远超过了
<code>unsigned int</code>
所能表示的范围，但是我并没有意识到是数据类型的问题导致测试样例没有通过，一直以为是逻辑问题，排查了很久，后面我换成了
<span class="math inline">\(a = c \div b\)</span>
的形式，来防止类型溢出，但似乎 <span class="math inline">\(a, b,
c\)</span> 自己本身就已经溢出了，并不是运算过程中导致的溢出......<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> q = i - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// while (p &lt;= q)</span></span><br><span class="line">	<span class="comment">// &#123;</span></span><br><span class="line">	<span class="comment">//     if (ull(arr[p]) * ull(arr[q]) == ull(arr[i]))</span></span><br><span class="line">	<span class="comment">//     &#123;</span></span><br><span class="line">	<span class="comment">//         dpv[i] += (p ^ q ? dpv[p] * dpv[q] * 2 : dpv[p] * dpv[q]);</span></span><br><span class="line">	<span class="comment">//         p++;</span></span><br><span class="line">	<span class="comment">//         q--;</span></span><br><span class="line">	<span class="comment">//     &#125;</span></span><br><span class="line">	<span class="comment">//     else if (ll(arr[i]) / ll(arr[p]) - ll(arr[q]) &gt; 0)</span></span><br><span class="line">	<span class="comment">//         p++;</span></span><br><span class="line">	<span class="comment">//     else if (ll(arr[i]) / ll(arr[p]) - ll(arr[q]) &lt; 0)</span></span><br><span class="line">	<span class="comment">//         q--;</span></span><br><span class="line">	<span class="comment">//     else &#123;&#125;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>, q = i - <span class="number">1</span>; p &lt;= q; p++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p &lt;= q &amp;&amp; (ll)arr[i] / (ll)arr[p] - (ll)arr[q] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			q--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= q &amp;&amp; (ll)arr[p] * arr[q] == arr[i]) &#123;</span><br><span class="line">			dpv[i] += (p ^ q ? dpv[p] * dpv[q] * <span class="number">2</span> : dpv[p] * dpv[q]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tlt = (tlt + dpv[i]) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上述代码中，注释的代码段就是最初使用
<code>unsigned int</code>
类型无法通过的双指针查找，因为无法通过测试样例，所以我也没有办法确定到底是逻辑问题还是数据类型问题。官方题解的双指针查找其实并不是很直观，虽然多看几遍也能看懂，但是终究还是不直观的......</p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>849. 到最近的人的最大距离</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/849.%20%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>给你一个数组 <code>seats</code> 表示一排座位，其中 <code>seats[i] = 1</code> 代表有人坐在第 <code>i</code> 个座位上，<code>seats[i] = 0</code> 代表座位 <code>i</code> 上是空的（<strong>下标从
0 开始</strong>）。</p>
<p>至少有一个空座位，且至少有一人已经坐在座位上。</p>
<p>亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。</p>
<p>返回他到离他最近的人的最大距离。</p>
<p><strong>示例 1：</strong></p>
<p><img
src="https://assets.leetcode.com/uploads/2020/09/10/distance.jpg" /></p>
<p><strong>输入：</strong> seats = [1,0,0,0,1,0,1]<br />
<strong>输出：</strong> 2<br />
<strong>解释：</strong><br />
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2
。<br />
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。<br />
因此，他到离他最近的人的最大距离是 2 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> seats = [1,0,0,0]<br />
<strong>输出：</strong> 3<br />
<strong>解释：</strong><br />
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。<br />
这是可能的最大距离，所以答案是 3 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> seats = [0,1]<br />
<strong>输出：</strong> 1</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= seats.length &lt;= 2 * 104</code><br />
</li>
<li><code>seats[i]</code> 为 <code>0</code> 或 <code>1</code><br />
</li>
<li>至少有一个 <strong>空座位</strong><br />
</li>
<li>至少有一个 <strong>座位上有人</strong></li>
</ul>
<p>本题的难点在于左右两边的连续最长0-子数组要先处理了，记录下来，然后再记录数组中间的最长0-子数组。本题可以转化为找到数组中的最长0-子数组，然后分三种情况来讨论：<br />
1. 最长0-子数组从左边开头，Alex可以坐在最左边<br />
2.
最长0-子数组在数组中间，那么Alex应该坐在最中间的位置，这样它距离两边最近的人至少有一边是最大距离<br />
3. 最长0-子数组在右边结尾，Alex可以坐在最右边<br />
应该先处理了左右两边的边界情况，再处理中间的。</p>
<p>错误版本代码：左中右三种情况一起处理，代码无法整合，能通过95%的用例：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistToClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line">        uint tmp = <span class="number">0</span>;</span><br><span class="line">        uint teg = <span class="number">0</span>;</span><br><span class="line">        uint beg = <span class="number">0</span>;</span><br><span class="line">        uint res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seats.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!seats[i]) tmp++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp &gt;= res)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = tmp;</span><br><span class="line">                    beg = teg;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">                teg = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= res)</span><br><span class="line">        &#123;</span><br><span class="line">            res = tmp;</span><br><span class="line">            beg = teg;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; beg &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beg == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span> (seats.<span class="built_in">size</span>() - beg == res) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res % <span class="number">2</span> ? res / <span class="number">2</span> + <span class="number">1</span> : res / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>修改版本的代码：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistToClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line">        uint len = seats.<span class="built_in">size</span>();</span><br><span class="line">        uint smx = <span class="number">0</span>;</span><br><span class="line">        uint mmx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        uint lbound = <span class="number">0</span>;</span><br><span class="line">        uint rbound = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!seats[lbound]) lbound++;</span><br><span class="line">        <span class="keyword">while</span> (!seats[rbound]) rbound--;</span><br><span class="line"></span><br><span class="line">        smx = <span class="built_in">max</span>(lbound, len - <span class="number">1</span> - rbound);</span><br><span class="line"></span><br><span class="line">        uint tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lbound + <span class="number">1</span>; i &lt;= rbound; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (seats[i]) tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> mmx = <span class="built_in">max</span>(mmx, ++tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(smx, (mmx % <span class="number">2</span> ? mmx + <span class="number">1</span> : mmx) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，smx代表两侧的最大连续0-子数组长度，mmx代表中间的最大连续0-子数组长度，由于两侧的作为可以直接坐到头，只用考虑其中一边的距离最近的陌生人，因此无需将距离除以一半。中间的mmx与两侧的smx在参与比较时，比较的值应该是处理过的连续子数组中间位置距离两端的最小值（奇数长度时直接坐最中间位置距离两端空余的座位数是相同的，偶数长度时只能坐在中间的靠左一半或靠右一半，根据题意，选取较短的这一半作为最近距离）.</p>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>901. 股票价格跨度</title>
    <url>/blog/2023/10/11/data/algorithmn/leetcode/midium/901.%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="中等">[<span style="color:orange;">中等</span>]</h2>
<p>设计一个算法收集某些股票的每日报价，并返回该股票当日价格的 <strong>跨度</strong> 。</p>
<p>当日股票价格的 <strong>跨度</strong> 被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p>
<ul>
<li>例如，如果未来 7
天股票的价格是 <code>[100,80,60,70,60,75,85]</code>，那么股票跨度将是 <code>[1,1,1,2,1,4,6]</code> 。</li>
</ul>
<p>实现 <code>StockSpanner</code> 类：</p>
<ul>
<li><code>StockSpanner()</code> 初始化类对象。<br />
</li>
<li><code>int next(int price)</code> 给出今天的股价 <code>price</code> ，返回该股票当日价格的 <strong>跨度</strong> 。</li>
</ul>
<p><strong>示例：</strong></p>
<p><strong>输入</strong>：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]</span><br><span class="line">[[], [100], [80], [60], [70], [60], [75], [85]]</span><br></pre></td></tr></table></figure> <strong>输出</strong>：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[null, 1, 1, 1, 2, 1, 4, 6]</span><br></pre></td></tr></table></figure></p>
<p><strong>解释：</strong><br />
StockSpanner stockSpanner = new StockSpanner();<br />
stockSpanner.next(100); // 返回 1<br />
stockSpanner.next(80); // 返回 1<br />
stockSpanner.next(60); // 返回 1<br />
stockSpanner.next(70); // 返回 2<br />
stockSpanner.next(60); // 返回 1<br />
stockSpanner.next(75); // 返回 4 ，因为截至今天的最后 4 个股价
(包括今天的股价 75) 都小于或等于今天的股价。<br />
stockSpanner.next(85); // 返回 6</p>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= price &lt;= 105</code><br />
</li>
<li>最多调用 <code>next</code> 方法 <code>10^4</code> 次</li>
</ul>
<p>首先想到暴力方法：每次给出了新的股票价格之后直接从后往前遍历已有的股票价格然后统计，但是看到数据范围是
<span
class="math inline">\(10^4\)</span>，按照最坏情况算，每次都要遍历到第一个元素的话，就是
<span class="math inline">\(O(n^2)\)</span>
的时间复杂度，一般这个时间复杂度很难接受，另外 <span
class="math inline">\(O(n^2)\)</span> 大致估计如果操作次数超过了 <span
class="math inline">\(10^5\)</span> 那么一般会超时的。</p>
<p>一个稍微优化一点的方法可能是用哈希表记录每个值的最新位置？但问题就在于这里，题目如果是说“跨度指的是当日价格大于往日的价格的连续长度”还好说，但可惜题目是“大于等于”，一旦出现等于就意味着可能会有相同的值，这个时候哈希表就没法处理了，当然可以记录最早出现的那个值，可是我们无法保证在记录位置到今天位置中间有没有某个时刻突然股票价格很高超过了当日价格的时候，那么连续子数组应该在价格很高的那个时候截断而不是在哈希表记录的最早位置截断，比如
<code>[1,2,3,5,3,2,6,1]</code>， 对于末尾的
<code>1</code>，难道符合题意的子数组长度是从开头那个1开始算起吗？当然不是，应该是从末尾的前面的
6 算起。</p>
<p>本体的正确解法是是用单调栈，但是也需要一些思考才能得知如何是用单调栈。单调栈就是入栈的元素如果发现前面的元素与他构成的序型不是规定的排列的话（比如我们创建的单调栈要求递增或者递减时），那就一直弹出栈顶的元素，直到当前即将入栈的元素和栈顶的元素构成的有序性符合我们要求的排列性质。但是本题使用单调栈只能完成某一个价格的往日连续区间探测，正如上述所说，单调栈在使用的时候会把不符合序型的元素弹出队列，而这些弹出的元素却有可能是下一次查询的所需的数据，那怎么办呢？有没有办法能保存被弹出的元素的历史数据？目前来看这题就是在指引我们使用单调栈（单调队列），但是我们需要自己处理数据遗失的问题（比如
<code>[2,1,3]</code>，当 1
进行查询的时候会把前面的2也剔除掉，而这是最后的3的连续区间所能囊括的元素，因此这造成了元素的丢失）。</p>
<p>再进一步思考，可以发现，如果元素 <span
class="math inline">\(prices[i]\)</span> 在数组中的连续区间长度是 <span
class="math inline">\(x\)</span>，那么意味着这个元素加入单调队列之后将会弹出之前的
<span class="math inline">\(x-1\)</span> 个元素，如果下一个元素 <span
class="math inline">\(prices[i+1]\)</span> 是大于等于 <span
class="math inline">\(prices[i]\)</span> 的话，则 <span
class="math inline">\(prices[i]\)</span> 的跨度区间同样也是 <span
class="math inline">\(prices[i+1]\)</span> 的跨度区间，所以我们只需要在
<span class="math inline">\(prices[i]\)</span> 的跨度区间长度基础上计算
<span class="math inline">\(prices[i+1]\)</span> 元素到 <span
class="math inline">\(prices[i]\)</span>
元素的距离即可，也就是1。这样，我们把被弹出的元素的历史记录信息都记录在了最后入栈的栈顶的那个元素上。</p>
<p>可以使用 <code>vector&lt;pair&lt;int, int&gt;&gt;</code>
来作为我们的单调栈，其中 <code>pair&lt;int, int&gt;</code>
的第一个元素就存储价格，第二个元素存储这个价格的跨度区间长度，每当我们拿到一个新的价格并尝试将其加入单调队列的时候，我们维护单调队列的有序性，在弹出比当前价格小的价格时，累加被弹出价格对应的跨度区间长度即可。</p>
<p>总之，最重要的需要理解的一点就是，每个元素承载了它为了维护单调队列有序性而弹出的其他元素的历史数据，通过这种方式我们避免了为了维护单调队列而弹出元素导致的信息丢失。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StockSpanner <span class="keyword">struct</span> &#123;</span><br><span class="line">    stocks [][]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> StockSpanner &#123;</span><br><span class="line">    <span class="keyword">return</span> StockSpanner&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *StockSpanner)</span></span> Next(price <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    span := <span class="number">1</span></span><br><span class="line">    numStocks := <span class="built_in">len</span>(this.stocks)</span><br><span class="line">    <span class="keyword">for</span> numStocks != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &gt;= this.stocks[numStocks - <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            span  += this.stocks[numStocks - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            this.stocks = this.stocks[:numStocks - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        numStocks--</span><br><span class="line">    &#125;</span><br><span class="line">    this.stocks = <span class="built_in">append</span>(this.stocks, []<span class="type">int</span>&#123;price, span&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> span</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; stocks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockSpanner</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> span = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stocks.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (price &gt;= stocks.<span class="built_in">back</span>().first)</span><br><span class="line">            &#123;</span><br><span class="line">                span  += stocks.<span class="built_in">back</span>().second;</span><br><span class="line">                stocks.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stocks.<span class="built_in">emplace_back</span>(price, span);</span><br><span class="line">        <span class="keyword">return</span> span;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmn</category>
      </categories>
      <tags>
        <tag>algorithmn</tag>
        <tag>leetcode</tag>
        <tag>midium</tag>
      </tags>
  </entry>
  <entry>
    <title>C++17 template auto 显式实例化自动推导</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/C++17%20template%20auto%20%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<p>在C++11的时候，当声明函数模板时，通常不会使用auto作为函数模板声明的返回值以期编译器自动推导返回值，因为这样子写就等价于无法把函数模板的模板定义单独放到一个源文件来提升可读性了。</p>
<p>把模板定义放到单独的源文件，则其他用模板函数的源文件必须链接该模板定义所在的源文件的编译结果符号表才能查找实例化定义，而又由于模板定义自身不产生可链接的符号，因此这种模板函数的声明和定义分开存放的做法要求在定义所在的源文件中手动实现所有用到的参数类型的显式声明化，虽然提升了项目的可读性，但是本质上没有带来多少便捷。除非把模板定义和模板声明都放到同一个头文件中被其他源文件包含，这样用到模板函数的时候，就能直接发现头文件提供的模板定义，用来生成相应的实例化函数定义，而无需在链接阶段去查找其他源文件编译结果的符号表了。</p>
<h2 id="示例">示例</h2>
<p>templatetest.h<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEMPLATE_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMPLATE_TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span> -&gt; Type</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// templatetest.h</span></span></span><br></pre></td></tr></table></figure></p>
<p>templatetest.cpp<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatetest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span> -&gt; Type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> std::string&amp; a, <span class="type">const</span> std::string&amp; b)</span> -&gt; std::string</span>;</span><br></pre></td></tr></table></figure></p>
<p>auto.cpp<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatetest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mul</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objdump: _Z3addINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEDaRKT_S8_</span></span><br><span class="line"><span class="comment">// template&lt;typename Type&gt;</span></span><br><span class="line"><span class="comment">// auto add(const Type&amp; a, const Type&amp; b)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return a + b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result1 = <span class="built_in">mul</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// result 的类型将根据 mul 函数的返回值类型进行推导</span></span><br><span class="line">    <span class="comment">// auto result2 = add(2, 3);</span></span><br><span class="line">    <span class="keyword">auto</span> result3 = <span class="built_in">add</span>(std::<span class="built_in">string</span>(<span class="string">&quot;a&quot;</span>), std::<span class="built_in">string</span>(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; result1 &lt;&lt; std::endl; <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; result2 &lt;&lt; std::endl;</span></span><br><span class="line">    std::cout &lt;&lt; result3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，在C++17中，无需把每个版本的显式实例化定义都写出来，使用<code>template auto</code>关键字，编译器会自动在该源文件中生成对应返回值类型的显式实例化定义，并生成可供外部链接的符号。这样，在接收auto为返回值的函数的返回值时，也可以使用auto关键字自动推导类型了，因为编译器先计算右值的类型，而右值的类型通过<code>template auto</code>自动推导可以得到。</p>
<h2 id="template-auto-的缺点---错误发现推迟">template auto 的缺点 -
错误发现推迟</h2>
<p>因为template auto func(...) -&gt;
Type，实际上不会检查提供的模板定义中，return的值类别是否与Type一致，比如Type可能是指针，但是模板实际返回了一个值（整型、字符...），那么在编译期间由于编译器发现类型是匹配的，不会检查return值与
template auto
显式实例化要求假设的值的类别是否一致。因此这一错误会被推迟到运行时才能被发现。比如将
templatetest.cpp 中模板定义的 return 值写为整型，仍然能编译成功：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span> -&gt; Type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是运行时会报错：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bin/Debug/SHARED/auto</span> </span><br><span class="line">terminate called after throwing an instance of &#x27;std::logic_error&#x27;</span><br><span class="line">  what():  basic_string::_M_construct null not valid</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure> 也就是运行时，无法将整型值 0 隐式转换为 std::string
类型的值，因为std::string类并没有提供这样一个隐式转换的构造函数，其参数为只接收一个整型值。</p>
<p>但是某些值会在编译期就提示无法转换为 template auto
对应的假设返回值：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[  6%] Building CXX object src/CMakeFiles/insrc.dir/templatetest.cpp.o</span><br><span class="line">/home/fredom/workspace/temp/src/templatetest.cpp: In instantiation of ‘Type add(const Type&amp;, const Type&amp;) [with Type = std::__cxx11::basic_string&lt;char&gt;]’:</span><br><span class="line">/home/fredom/workspace/temp/src/templatetest.cpp:11:71:   required from here</span><br><span class="line">/home/fredom/workspace/temp/src/templatetest.cpp:7:12: error: could not convert ‘1’ from ‘int’ to ‘std::__cxx11::basic_string&lt;char&gt;’</span><br><span class="line">    7 |     return 1;</span><br><span class="line">      |            ^</span><br><span class="line">      |            |</span><br><span class="line">      |            int</span><br></pre></td></tr></table></figure></p>
<p>另外，如果使用了 <code>tempalte auto</code>
关键字，则不能再显式地提供它的定义了。如果希望显式实例化使用有别于模板定义的逻辑代码，则请使用空模板
<code>template &lt;&gt;</code>，再在下方写出所需要使用的函数定义实现。<br />
![[Pasted image 20230806132908.png]]</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode clang-tidy 使用入门</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/VScode%20clang-tidy%20%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Visual Studio
Code上的C++扩展迎来更新，这次带来的新功能是对静态分析框架clang-tidy的支持。clang-tidy是一个基于clang的C++静态分析工具，主要用来检测代码中的常见错误。通过对代码运行静态分析，可以找到潜在的Bug或者代码风格的不一致问题。对于clang-tidy的集成一直呼声较高，这次我们很高兴地宣布：clang-tidy它来了。</p>
<h2 id="我需要安装clang-tidy吗">我需要安装clang-tidy吗？</h2>
<p>不需要。clang-tidy直接集成在C++扩展中。但是如果你已经安装了clang-tidy(并且它位于你的环境变量路径中)，则C++扩展会转而使用已经安装好的版本。你可以通过修改C++扩展的”Clang
Tidy: Path”配置项来指定需要使用的clang-tidy执行文件。</p>
<h2 id="如何在vs-code中运行clang-tidy">如何在VS
Code中运行clang-tidy?</h2>
<p>如果需要手动运行clang-tidy，请打开”Command Palette (Ctrl + Shift +
P)”，并输入”Run Code
Analysis”。你可以直接在单个文件上执行clang-tidy，也可以在所有已打开的文件上执行，也可以在整个工作区上执行。如下图所示：</p>
<p><img
src="https://pic2.zhimg.com/80/v2-fce06d1dbe7b6af366a5d226cb6e9b91_720w.webp" /></p>
<p>如果有一些文件夹你不想在上面执行clang-tidy，则可以将它们的路径添加到”Clang
Tidy: Exclude”配置项中(位于配置文件settings.json中的<br />
C_Cpp.codeAnalysis.exclude)。</p>
<p>你也可以设置当打开或保存一个源文件时自动执行clang-tidy。可以在Command
Palette (Ctrl + Shift + P)中选择”Preferences: Open Settings
(UI)”进行相关设定，如下图所示：</p>
<p><img
src="https://pic3.zhimg.com/80/v2-66c6b7adefb2f328614fb576e1b60c6a_720w.webp" /></p>
<p>然后搜索”code
analysis”关键字来找到所有clang-tidy相关的设置项，然后将”Clang Tidy:
Enabled”设置为true。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-a9f8e38fac8aa889e49dd652cd7b3c6e_720w.webp" /></p>
<p>请注意，你可以在工作区级别或者解决方案级别上进行clang-tidy全局设置。</p>
<p>可以通过查看蓝色的状态栏中的”火”图标来判断clang-tidy是否正在运行，如下图所示：</p>
<p><img
src="https://pic2.zhimg.com/80/v2-d56adf0da99de9ecc255228001a7451d_720w.webp" /></p>
<p>如果需要暂停或取消clang-tidy执行，可以点击”火”图标并选择取消或暂停执行:</p>
<p><img
src="https://pic4.zhimg.com/80/v2-58c92325026b25a8cea78c0496735e6f_720w.webp" /></p>
<h2 id="如何配置clang-tidy检查规则">如何配置clang-tidy检查规则?</h2>
<p>如果你的项目目录中有 .clang-tidy 配置文件，C++
扩展将遵守该文件中定义的检查和选项。 如果你的工作区中有多个 .clang-tidy
配置文件，clang-tidy
将通过在它的上一级目录中搜索路径来使用最接近源文件的配置文件。
或者，你也可以使用 Clang Tidy: Config 设置指定 clang-tidy 配置。 Clang
Tidy：Config 接受检查和检查选项作为 YAML/JSON 格式的字符串。</p>
<p><img
src="https://pic1.zhimg.com/80/v2-40aae905ac42c6d92cd479015a95085c_720w.webp" /></p>
<p>如果源文件在其任何上一级目录中都没有 .clang-tidy 配置文件，并且 Clang
Tidy: Config
属性留空，则回退配置（在C_Cpp.codeAnalysis.clangTidy.fallbackConfig
中定义）将是 用于该文件。</p>
<p>你可以使用 Clang Tidy &gt; Checks: Enabled 和 Clang Tidy &gt; Checks:
Disabled 设置启用和禁用更多检查。 除了 .clang-tidy
文件中的检查外，还会运行这些设置中定义的检查。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-2700cd435c52f5e026c9430c962ce30e_720w.webp" /></p>
<p>选择添加项目会显示所有 clang-tidy 检查的列表。</p>
<p><img
src="https://pic3.zhimg.com/80/v2-e2612f96536a25982b91d2fe0e71c4ca_720w.webp" /></p>
<p>你可以向 Clang Tidy &gt; Checks: Enabled 和 Clang Tidy &gt; Checks:
Disabled 设置添加任意数量的检查。</p>
<p><img
src="https://pic1.zhimg.com/80/v2-90f7583f95e27be64cccc071c3c7a238_720w.webp" /></p>
<h2 id="如何将命令行参数传递给-clang-tidy">如何将命令行参数传递给
clang-tidy？</h2>
<p>如果你通过命令行选项传递给 clang-tidy，则可以在 Clang Tidy: Args
属性中指定这些选项。 Clang Tidy: Args 设置优先于编辑器中等效的 Clang
Tidy 设置（例如 Clang Tidy &gt; Checks: Enabled 和 Clang Tidy &gt;
Checks: Disabled）。</p>
<h2 id="在编辑器中查看检查结果">在编辑器中查看检查结果</h2>
<p>clang-tidy
检查的结果（警告和错误）显示在问题面板中，并在相关代码部分下方显示为波浪线。</p>
<p><img
src="https://pic2.zhimg.com/80/v2-945af2a4e5073aeba6484909aa3673dd_720w.webp" /></p>
<p>单击“问题”面板中的问题会将您带到源文件中的问题。
要清除代码分析波浪线，请单击快速操作灯泡，然后选择清除代码分析波浪线。</p>
<p><img
src="https://pic4.zhimg.com/80/v2-ef55b30608ad45e847004ca75b97318f_720w.webp" /></p>
<p>友情提示：如果你想取消对特定代码段的 clang-tidy
分析，可以在文件中添加 NOLINT、NOLINTNEXTLINE 和
NOLINTBEGIN至NOLINTEND之间的注释。</p>
<h2 id="clang-tidy设置">Clang-tidy设置</h2>
<p>最新的 VS Code
设置列表请参考原文，这里就不贴出来了。它帮助你为工作区配置
clang-tidy。</p>
<h2 id="总结">总结</h2>
<p>clang-tidy静态分析工具比我之前接触过的分析工具更加具有无缝使用体验，用来检查代码中的问题还是挺方便的。<br />
代码工作正常之后，如果还有闲暇时间，可以像打磨一件艺术品(例如，我一直在更新的拓扑梅尔智慧办公平台Topomel
Box)进行微小的优化，经过时间的积累，你得到的不只是一款能跑的软件，而更像一个可以放在玻璃后面的艺术品。<br />
有时候，做个写码匠人，不急不躁，挺好的。</p>
<p><img
src="https://pic2.zhimg.com/80/v2-6b38962ca714fcf67198ce848ee92a61_720w.webp" /></p>
<p>发布于 2021-12-16 12:40</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>clang-tidy介绍</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/clang-tidy%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="clang-tidy静态代码分析框架">clang-tidy——静态代码分析框架</h1>
<h2 id="clang-tidy介绍">clang-tidy介绍</h2>
<p><a
href="http://clang.llvm.org/extra/clang-tidy/">clang-tidy</a>是一个基于clang的静态代码分析框架，支持C++/C/Objective-C。</p>
<p>它是一个功能更强大的lint工具。绝大部分lint工具只能在出现问题的代码地方给出提示，之后需要人为修改，而clang-tidy则能够自动修复功能（当然这个如何修复需要该check作者提供）；并且clang-tidy采用模块化设计，非常容易扩展。如果用户想往clang-tidy添加一个新的检测功能，只需要编写一个clang-tidy
check实现（如何编写一个clang-tidy
check以后将会有一章详细介绍），每一个check检测一种问题，例如检测某个违反Code
style的模式，检测某些API不正确使用的方法等等。</p>
<p>clang-tidy check可以检测各式各样的问题：</p>
<ul>
<li>检测违反代码规范的代码模式（header
guard不满足，include头文件顺序错误)；<br />
</li>
<li>找出不容易在编译时发现的代码错误（把int赋值给std::string,
变量定义在头文件）；<br />
</li>
<li>把deprecated的API替换成新的API，modernize模块典型例子，把C++03的代码自动转换成C++11的代码（for-range-loop,
auto, nullptr, overriede, default）；</li>
</ul>
<p>Google code style提供了<a
href="https://github.com/google/styleguide/tree/gh-pages/cpplint">cpplint</a>脚本，用于检测代码中违反code
style的地方。clang-tidy也支持检测代码中违反Google code
style的地方(<code>google-*</code>check),
它们之间有什么区别？cpplint是一个python的脚本，它是采用正则表达式匹配出违反code
style的代码,
所以它能检测的功能会受限于正则表达式，它不能够检测所有的违反code
style的地方，并且还会有False positive和True
positive；而clang-tidy则是基于抽象语法树(AST)对源文件进行分析，相比之下，是在分析的结果更加准确，能检测的问题也更多。</p>
<p>这两者各有优缺点，clang-tidy需要对源代码进行语法分析（编译源文件），所以它需要知道源文件的编译命令，对于依赖较多较大的文件，花费时间会较长；cpplint则不需要源文件编译，对文件内容进行正则匹配，运行会更快。</p>
<p>clang-tidy每次只针对一个编译单元(TranslationUnit,
可简单理解成1个<code>.cpp</code>文件)进行静态分析，因此，它只能查找出一个编译单元里面的代码问题，对于那种只在跨编译单元出现的问题，就无能为力了。</p>
<p>现在clang-tidy实现有100+个check，请查看list列表。根据check不同种类(从check名字的前缀就能知道哪一类)，分为如下几大类：</p>
<ul>
<li>boost 检测boost库API使用问题<br />
</li>
<li>cert 检测<a
href="https://www.securecoding.cert.org/confluence/display/seccode/SEI+CERT+Coding+Standards">CERT</a>的代码规范<br />
</li>
<li>cpp-core-guidelines 检测是否违反cpp-core-guidelines<br />
</li>
<li>google 检测是否违反google code style<br />
</li>
<li>llvm 检测是否违反llvm code style<br />
</li>
<li>readability 检测代码上相关问题，但又不明确属于任何代码规范的<br />
</li>
<li>misc 其它一些零碎的check<br />
</li>
<li>mpi 检测MPI API问题<br />
</li>
<li>modernize 把C++03代码转换成C++11代码，使用C++11新特性<br />
</li>
<li>performance 检测performance相关问题</li>
</ul>
<h2 id="clang-tidy使用">clang-tidy使用</h2>
<p>clang-tidy是一个命令行工具，可以在官网下载编译好的二进制包。
我写了一个<a
href="https://www.npmjs.com/package/clang-tools-prebuilt">clang-tools-prebuilt</a>的npm包，可以通过<code>npm install clang-tools-prebuilt</code>的命令下载（仅支持MacOS,
Linux）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 列出所有的check</span><br><span class="line">$ clang-tidy -list-checks</span><br><span class="line">// 找出simple.cc中所有没有用到的using declarations. 后面的`--`表示这个文件不在compilation database里面，可以直接单独编译；</span><br><span class="line">$ clang-tidy -checks=&quot;-*,misc-unused-using-decls&quot; path/to/simple.cc --</span><br><span class="line"></span><br><span class="line">// 找出simple.cc中所有没有用到的using declarations并自动fix(删除掉)</span><br><span class="line">$ clang-tidy -checks=&quot;-*,misc-unused-using-decls&quot; -fix path/to/simple.cc --</span><br><span class="line"></span><br><span class="line">// 找出a.c中没有用到的using declarations. 这里需要path/to/project/compile_commands.json存在</span><br><span class="line">$ clang-tidy -checks=&quot;-*,misc-unused-using-decls&quot; path/to/project/a.cc</span><br></pre></td></tr></table></figure>
<p>分析项目中的y编译单元，clang-tidy首先要知道如何编译单元(该编译单元的编译命令)，它从目录下查找compliation
database，这个database就是<code>compile_commands.json</code>文件，里面包含该项目中所有的编译单元的编译命令。在使用之前要导出这个文件。目前已经有工具帮我们做了这项工作。</p>
<ul>
<li>如果是cmake的项目，通过<code>cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources</code>命令导出;<br />
</li>
<li>如果是GYP项目，通过<code>ninja -C out/D -t compdb cc cxx objc objcxx &gt; compile_commands.json</code>；<br />
</li>
<li>如果是make项目，使用<a
href="https://github.com/rizsotto/Bear">Bear</a>工具；</li>
</ul>
<p>一次命令只能分析一个文件太麻烦，要分析整个项目的所有文件？<a
href="https://github.com/llvm-mirror/clang-tools-extra/blob/master/clang-tidy/tool/run-clang-tidy.py">run_clang_tidy.py</a>脚本正是你想要的，通过多进程的方法对整个项目文件进行分析。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>const std map 不允许方括号操作符</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/const%20std%20map%20%E4%B8%8D%E5%85%81%E8%AE%B8%E6%96%B9%E6%8B%AC%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: no match for ‘operator[]’ (operand types are ‘const std::map&lt;char, std::shared_ptr&lt;const bustub::TrieNode&gt; &gt;’ and ‘char’) 26 | curr = curr-&gt;children_[c];</span><br></pre></td></tr></table></figure>
<p>2023/8/7 17:37:49</p>
<p>根据错误信息，问题出现在尝试使用 <code>operator[]</code> 访问一个
<code>const std::map</code> 对象的时候。 <code>operator[]</code>
操作符需要返回一个可修改的引用，但由于 <code>std::map</code>
对象是常量，因此不能使用 <code>operator[]</code>
直接进行访问和修改。</p>
<p>如果你想在一个 <code>const std::map</code>
对象中查找某个键对应的值，你可以使用 <code>find()</code>
函数来完成。<code>find()</code>
函数返回一个指向键所对应的迭代器，你可以通过迭代器来访问值。</p>
<p>以下是一个示例：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; myMap = &#123;&#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> key = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用find()函数查找键对应的值</span></span><br><span class="line">    std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::const_iterator iter = myMap.<span class="built_in">find</span>(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (iter != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> value = iter-&gt;second;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value of key &#x27;&quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27; is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key &#x27;&quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27; not found in the map.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述示例中，我们通过<code>find()</code>函数在<code>const std::map</code>中查找键<code>'b'</code>对应的值。如果键存在，我们通过迭代器访问这个值并打印输出；如果键不存在，我们打印相应的消息。</p>
<p>请根据你的具体需求，使用<code>find()</code>函数或其他适合的方法来访问一个<code>const std::map</code>对象的值。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>const限定符的作用起点</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/const%E9%99%90%E5%AE%9A%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<p>std::make_shared&lt;const class&gt;(arg1, arg2,
...)，这样能成功创建指向常量对象的shared_ptr吗？这样的shared_ptr指向的对象是不是由于const限定符而无法做出修改？</p>
<p>2023/8/8 15:38:35</p>
<p>是的，<code>std::make_shared</code> 可以创建指向常量对象的
<code>std::shared_ptr</code>。</p>
<p>在使用 <code>std::make_shared</code> 创建
<code>std::shared_ptr</code> 时，可以通过指定模板参数来使用 const
限定符，从而创建指向常量对象的智能指针。例如，你可以这样使用
<code>std::make_shared</code> 来创建一个指向常量对象的
<code>std::shared_ptr</code>：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">const</span> MyClass&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> MyClass&gt;(arg1, arg2, ...);</span><br></pre></td></tr></table></figure></p>
<p>这将创建一个指向类型为 <code>const MyClass</code> 的常量对象的
<code>std::shared_ptr</code>。由于对象被声明为常量，因此通过该指针是无法修改对象的状态的。任何试图通过指针对对象进行修改的操作都将导致编译错误。</p>
<p>这种方式可以确保对象不会在后续的代码中被修改，提供了更加严格的数据保护。使用
<code>std::shared_ptr&lt;const T&gt;</code>
可以很好地表示该指针所管理的对象是常量，并且即使在多个
<code>std::shared_ptr</code>
共享同一个对象的情况下，对象的状态也不会被修改。</p>
<p>2023/8/8 15:39:38</p>
<p>我想知道，一个对象声明创建的时候携带const限定符，是不会影响它的构造函数初始化所有成员变量的值的是吗？const限定符是在对象初始化创建完成之后才起作用？</p>
<p>2023/8/8 15:39:48</p>
<p>是的，当一个对象被声明为 const 时，const
限定符只会影响对象在初始化完成后的行为，而不会影响构造函数对成员变量的初始化过程。</p>
<p>在对象的构造函数中，无论是否将对象声明为
const，都可以对所有成员变量进行初始化。构造函数负责初始化对象的成员变量，而
const 限定符只是约束了对象在初始化完成后的行为。</p>
<p>一旦对象完成初始化，并且被声明为
const，那么就无法通过该对象来修改它的任何成员变量。对象的 const
限定性主要是适用于对象的使用部分，即在对象实例化完成后的代码中。通过将对象声明为
const，可以确保该对象的状态不会被修改，提供了额外的安全性。</p>
<p>总而言之，const
限定符是在对象初始化完成后才起作用的。构造函数和其他成员函数在对象初始化时不受
const
限定符的影响，并且可以正常地完成对象的成员变量初始化。一旦对象被声明为
const，它的状态就会被冻结，不允许修改。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>dynamic_cast和static_cast</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/dynamic_cast%E5%92%8Cstatic_cast/</url>
    <content><![CDATA[<p><code>dynamic_cast</code>和<code>static_cast</code>是C++中用于类型转换的两个关键字，它们有一些区别。</p>
<ol type="1">
<li><p><code>static_cast</code>：<code>static_cast</code>是一种编译时的类型转换，主要用于基本类型之间的转换、隐式转换、向上转型和进行无关类型指针的转换。它在编译时执行，没有运行时类型检查。<code>static_cast</code>可以将指针或引用转换为不同的静态类型，但它不能处理多态类型转换（即运行时类型的转换）。如果尝试在
<code>static_cast</code> 中进行错误的类型转换，会导致 undefined
behavior。</p>
<p>例如：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num); <span class="comment">// 基本类型之间的转换</span></span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 向上转型</span></span><br><span class="line">Derived* derivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr); <span class="comment">// 向下转型，需要保证 basePtr 指向的是 Derived 类型的对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* intPtr = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>))); <span class="comment">// 无关类型指针的转换，不推荐使用</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>dynamic_cast</code>：<code>dynamic_cast</code>是一种具有运行时类型检查的安全的类型转换操作符。它主要用于类层次结构中的多态类型转换。通过<code>dynamic_cast</code>可以在运行时判断指针或引用的实际类型，并进行相应的转换。如果转换失败，<code>dynamic_cast</code>会返回空指针（对于指针转换）或抛出<code>std::bad_cast</code>异常（对于引用转换）。</p>
<p>例如：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr); <span class="comment">// 多态类型转换，可以在运行时检查实际类型</span></span><br><span class="line">    <span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">        derivedPtr-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，<code>dynamic_cast</code>通过基类指针<code>basePtr</code>将其转换为派生类指针<code>derivedPtr</code>，并进行了实际类型的检查。如果转换成功，则可以调用派生类的成员函数。如果转换失败，<code>dynamic_cast</code>将返回空指针，因此需要检查结果以避免悬空指针的问题。</p></li>
</ol>
<p>总结起来，<code>static_cast</code>主要用于基本类型之间的转换和非多态类型的转换，是一种编译时类型转换；而<code>dynamic_cast</code>主要用于多态类型之间的转换，它支持运行时类型检查，转换失败时返回空指针或抛出异常。在使用时要根据具体情况选择合适的类型转换方式。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>multiple definition of 错误</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/multiple%20definition%20of%20%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="问题发现">问题发现</h1>
<h2 id="背景">背景</h2>
<p>在学习TCP/IP
socket编程的时候，照着书上的例子想照猫画虎写一个简易FTP程序，由于之前还有好几章的示例，每个程序都使用了一些相同的工具函数以及头文件和宏定义等，所以就想着希望能将相同的内容塞到一个头文件里面，其他示例文件include使用。下图左边红框是所有示例源文件，右边红框是所有源文件基本都会重复的部分。<br />
<img
src="https://img-blog.csdnimg.cn/15037965e5474c9aa4086994deda87ff.jpeg#pic_center"
alt="红框部分是每个源文件基本都有的部分" /> 于是我把这部分内容都扔到了
<strong>common.h</strong> 头文件里面：<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMON_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockaddr_in</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sockaddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nullptr NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETF  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTF  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CDIR  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERRO -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure> 我还很聪明地运用了从 <strong>《Effective C++》</strong>
中学到的，尽量把宏定义使用常量定义替换掉这条
<strong>“建议”</strong>，虽然我并不知道在这么一个小示例里面做有什么用，但是跟着
<strong>dalao</strong>
的做法做总让我以为可以避免一些坑和弯路，实际上就是这行宏定义替换导致了
<strong>多重定义</strong> 的错误。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE = <span class="number">256</span>; <span class="comment">// 这里应该写宏定义才对 #define BUF_SIZE 256</span></span><br></pre></td></tr></table></figure></p>
<h2 id="错误描述">错误描述</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/fredom/WorkSpace/cppPlayground/socket_programming/chapter1/build</span><br><span class="line">Consolidate compiler generated dependencies of target mysrc</span><br><span class="line">[  6%] Building C object src/CMakeFiles/mysrc.dir/common.c.o</span><br><span class="line">[ 12%] Linking C static library ../../runtimelib/libmysrc.a</span><br><span class="line">[ 12%] Built target mysrc</span><br><span class="line">Consolidate compiler generated dependencies of target calc_clnt</span><br><span class="line">[ 18%] Building C object app/CMakeFiles/calc_clnt.dir/calc_clnt.c.o</span><br><span class="line">[ 25%] Linking C executable ../../bin/calc_clnt</span><br><span class="line">/usr/bin/ld: ../../runtimelib/libmysrc.a(common.c.o):</span><br><span class="line">/home/fredom/WorkSpace/cppPlayground/socket_programming/chapter1/include/common.h:20: </span><br><span class="line">multiple definition of `BUF_SIZE`; </span><br><span class="line">CMakeFiles/calc_clnt.dir/calc_clnt.c.o:/home/fredom/WorkSpace/cppPlayground/socket_programming/chapter1/include/common.h:20: first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[2]: *** [app/CMakeFiles/calc_clnt.dir/build.make:98：../bin/calc_clnt] 错误 1</span><br><span class="line">make[1]: *** [CMakeFiles/Makefile2:154：app/CMakeFiles/calc_clnt.dir/all] 错误 2</span><br><span class="line">make: *** [Makefile:91：all] 错误 2</span><br></pre></td></tr></table></figure>
<p>从上面的错误输出可以看到，是常量 <strong>BUF_SIZE</strong>
存在重复定义，可是我就纳了闷了，我所有源文件相同的这部分代码都转移到
<strong>common.h</strong>
头文件里了啊，哪里来的第二个定义，而且从错误输出来看，确实没有报出第二个
<strong>BUF_SIZE</strong>
定义到底在哪里。我又里里外外的把所有源文件认真的检查了一遍，确信是绝对只有头文件中才有
<strong>BUF_SIZE</strong>的定义了，都排查到这里了，剩下只可能是链接的时候
<strong>BUF_SIZE</strong> 这个符号有什么猫腻。</p>
<h1 id="问题排查">问题排查</h1>
<p>我仔细想了一下，以前一直写的是 <strong>C++</strong> ，多个源文件
<strong>include</strong> 一个头文件从来没有遇到过
<code>multiple definition of</code> 这个错误，但是socket编程使用的是
<strong>C</strong>，说不定是两者的链接有什么差异造成的。我又想到，一般在头文件中都是声明而不会写定义，但是我从来没有细究过，为什么不能写定义？而且我在
<strong>C++</strong>
中，很多时候类的定义确实是直接内联写在声明上的。</p>
<p>所以我去 <strong>Google</strong>
了一下如何查看编译生成的文件的符号，得知可以使用
<strong>objdump</strong> 这样一个工具。以下截取了部分 <strong>Linux
manual page</strong> 关于 <strong>objdump</strong> 的使用方法。<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       objdump - display information from object files</span><br><span class="line">DESCRIPTION</span><br><span class="line">       objdump displays information about one or more object files.  The options control what particular information to display.  This information</span><br><span class="line">       is mostly useful to programmers who are working on the compilation tools, as opposed to programmers who just want their program to compile</span><br><span class="line">       and work.</span><br><span class="line"></span><br><span class="line">       objfile... are the object files to be examined.  When you specify archives, objdump shows information on each of the member object files.</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line">       The long and short forms of options, shown here as alternatives, are equivalent.  At least one option from the list</span><br><span class="line">       -a,-d,-D,-e,-f,-g,-G,-h,-H,-p,-P,-r,-R,-s,-S,-t,-T,-V,-x must be given.</span><br></pre></td></tr></table></figure> <strong>objdump</strong>
除了用来显示文件符号表，一般还用于显示生成对象的汇编指令（从二进制可执行文件反汇编？），显示文件的符号表需要使用
<strong>-t</strong> （给静态链接库 <strong>.a</strong>使用的）和
<strong>-T</strong> （给动态链接库 <strong>.so</strong>
使用的）。<strong>objdump</strong>
可以一次显示单个或多个文件的信息，上述选项控制特定信息的输出，使用时至少要指定一个选项。</p>
<p>下面的问题排查就使用能复现这个错误的最小工作区和文件来解释，不然以原来的文件解释有很多无关的代码干扰。实际用到的只有
<code>main.c</code>，<code>common.h</code>，<code>common.c</code>
三个文件。<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fredom@scut-lab-fgd:~/WorkSpace/cppPlayground/link_test$ tree -L 2</span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── main.c</span><br><span class="line">├── bin</span><br><span class="line">│   └── main</span><br><span class="line">├── build</span><br><span class="line">│   ├── app</span><br><span class="line">│   ├── CMakeCache.txt</span><br><span class="line">│   ├── CMakeFiles</span><br><span class="line">│   ├── cmake_install.cmake</span><br><span class="line">│   ├── compile_commands.json</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── src</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── common.h</span><br><span class="line">├── lib</span><br><span class="line">├── remake.sh</span><br><span class="line">├── runtimelib</span><br><span class="line">│   └── libmysrc.a</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── common.c</span><br><span class="line"></span><br><span class="line">10 directories, 13 files</span><br></pre></td></tr></table></figure> <img
src="https://img-blog.csdnimg.cn/7ff179dffb8045cc965afceb57eb6ac4.png#pic_center"
alt="在这里插入图片描述" />使用 <strong>objdump -t</strong> 看看
<strong>make</strong> 对两个源文件编译之后的 <strong>.o</strong>
输出文件都包含了什么。<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Consolidate compiler generated dependencies of target mysrc</span><br><span class="line">[ 25%] Building C object src/CMakeFiles/mysrc.dir/common.c.o</span><br><span class="line">[ 50%] Linking C static library ../../runtimelib/libmysrc.a</span><br><span class="line">[ 50%] Built target mysrc</span><br><span class="line">Consolidate compiler generated dependencies of target main</span><br><span class="line">[ 75%] Building C object app/CMakeFiles/main.dir/main.c.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking C executable ../../bin/main</span></span><br><span class="line">/usr/bin/ld: ../../runtimelib/libmysrc.a(common.c.o):/home/fredom/WorkSpace/cppPlayground/link_test/include/common.h:13: multiple definition of `BUF_SIZE`; CMakeFiles/main.dir/main.c.o:/home/fredom/WorkSpace/cppPlayground/link_test/include/common.h:13: first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[2]: *** [app/CMakeFiles/main.dir/build.make:98：../bin/main] 错误 1</span><br><span class="line">make[1]: *** [CMakeFiles/Makefile2:142：app/CMakeFiles/main.dir/all] 错误 2</span><br><span class="line">make: *** [Makefile:91：all] 错误 2</span><br><span class="line">/home/fredom/WorkSpace/cppPlayground/link_test</span><br></pre></td></tr></table></figure> 从上述 <strong>CMake</strong>
产生的信息可以看到，对单个文件的编译都是成功的，但是一到链接阶段，链接器
<strong>/usr/bin/ld</strong> 就会报错。两个源文件对应的编译产物分别是
<strong>common.c.o</strong> 和 <strong>main.c.o</strong>，对它们使用
<strong>objdump -t</strong>有如下结果：</p>
<p><strong>common.c.o</strong><br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~/WorkSpace/cppPlayground/link_test$ </span><span class="language-bash">objdump -t build/src/CMakeFiles/mysrc.dir/common.c.o</span></span><br><span class="line"></span><br><span class="line">build/src/CMakeFiles/mysrc.dir/common.c.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*  0000000000000000 common.c</span><br><span class="line">0000000000000000 l    d  .text  0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .debug_info    0000000000000000 .debug_info</span><br><span class="line">0000000000000000 l    d  .debug_abbrev  0000000000000000 .debug_abbrev</span><br><span class="line">0000000000000000 l    d  .debug_line    0000000000000000 .debug_line</span><br><span class="line">0000000000000000 l    d  .debug_str     0000000000000000 .debug_str</span><br><span class="line">0000000000000000 l    d  .debug_line_str        0000000000000000 .debug_line_str</span><br><span class="line">0000000000000000 g     O .bss   0000000000000004 BUF_SIZE</span><br><span class="line">0000000000000000 g     O .data  0000000000000004 num</span><br><span class="line">0000000000000000 g     F .text  0000000000000044 error_handling</span><br><span class="line">0000000000000000         *UND*  0000000000000000 stderr</span><br><span class="line">0000000000000000         *UND*  0000000000000000 fputs</span><br><span class="line">0000000000000000         *UND*  0000000000000000 fputc</span><br><span class="line">0000000000000000         *UND*  0000000000000000 exit</span><br></pre></td></tr></table></figure> <strong>main.c.o</strong><br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~/WorkSpace/cppPlayground/link_test$ </span><span class="language-bash">objdump -t build/app/CMakeFiles/main.dir/main.c.o</span></span><br><span class="line"></span><br><span class="line">build/app/CMakeFiles/main.dir/main.c.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*  0000000000000000 main.c</span><br><span class="line">0000000000000000 l    d  .text  0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .rodata        0000000000000000 .rodata</span><br><span class="line">0000000000000000 l    d  .debug_info    0000000000000000 .debug_info</span><br><span class="line">0000000000000000 l    d  .debug_abbrev  0000000000000000 .debug_abbrev</span><br><span class="line">0000000000000000 l    d  .debug_line    0000000000000000 .debug_line</span><br><span class="line">0000000000000000 l    d  .debug_str     0000000000000000 .debug_str</span><br><span class="line">0000000000000000 l    d  .debug_line_str        0000000000000000 .debug_line_str</span><br><span class="line">0000000000000000 g     O .bss   0000000000000004 BUF_SIZE</span><br><span class="line">0000000000000000 g     F .text  0000000000000045 main</span><br><span class="line">0000000000000000         *UND*  0000000000000000 error_handling</span><br><span class="line">0000000000000000         *UND*  0000000000000000 num</span><br><span class="line">0000000000000000         *UND*  0000000000000000 printf</span><br></pre></td></tr></table></figure> 但是平常没怎么用过 <code>objdump</code>
，这些输出的信息也没有表头，<code>man</code> 手册里好像也翻不到，只好再
<strong>Google</strong> 一下看看这些都是什么信息。在这个<a
href="https://stackoverflow.com/questions/6666805/what-does-each-column-of-objdumps-symbol-table-mean"><strong>StackOverflow</strong>
的帖子</a>里找到了一些相关的信息，不过没有科学工具的小伙伴有可能打不开链接的。</p>
<p><code>objdump -t</code> 的输出一共有五列：<br />
1. 符号symbol的值（或者说地址？）<br />
2. 由7个标志位表示的符号的属性<br />
3. 符号所属的段（section）<br />
4. 符号的大小或者说偏移（字节为单位）<br />
5. 符号的名称</p>
<p>一个程序（在Linux语境下）最基本的应该是
<strong>.text代码段</strong>，<strong>.data只读数据段（大概是const常量那些）</strong>，<strong>.bss全局未初始化数据段</strong>
三个段组成，在程序实际被运行成为进程之后还会有 <strong>.heap</strong> 和
<strong>.stack</strong> 堆栈区域。</p>
<p>而7个标志位的显示方式和Linux下使用 <code>ls</code>
命令显示的10个权限属性位很像，这7个位置每一列可能显示的值分组如下：</p>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">列值</th>
<th style="text-align: left;">值释义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>l</code>，<code>g</code>，<code></code>，<code>！</code></td>
<td
style="text-align: left;">内部链接性，外部连接性，都不是，同时具有外部和内部链接性</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>w</code>，<code></code></td>
<td style="text-align: left;">弱链接符号，强链接符号</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>C</code>，<code></code></td>
<td style="text-align: left;">构造函数的符号，普通符号</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>W</code>，<code></code></td>
<td
style="text-align: left;">警告⚠符号，普通符号（我去，警告符号是什么意思？？？）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>I</code>，<code></code></td>
<td
style="text-align: left;">该符号是对另一个符号的间接引用，普通符号</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>d</code>，<code>D</code>，<code></code></td>
<td style="text-align: left;">用于调试的符号，动态符号，普通符号</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>F</code>，<code>f</code>，<code>O</code>，<code></code></td>
<td
style="text-align: left;">函数名称的符号，文件的符号，对象的符号，普通符号</td>
</tr>
</tbody>
</table>
<p>说实话这里面有一大堆符号的类别我从来没听说过也不知道是用来做什么的，但是符号表的符号大概分为==导出符号==和==未知符号==，简单解释的话也可以看看<a
href="https://blog.csdn.net/qq_40399012/article/details/84069983">这篇博客</a>。那么刚才
<code>objdump -t</code> 输出的信息中，我只能猜测 <code>**UND**</code> 是
<code>undifine</code>
的缩写，也就是该符号未在本翻译单元内找到定义。在编译的初期阶段，会把宏定义字面量全部替换掉，展开<code>include</code>的内容，这里引用一下其他博客的话：<br />
&gt;预处理阶段是各个源文件独自进行的，每个源文件互不干扰，预处理的作用范围仅在本文件中，在预处理完成后，会生成一个<code>.i</code>文件，而这个<code>.i</code>文件就是下一阶段编译时的一个编译单元，在此之后头文件就已经没有任何的作用了</p>
<p>在 <strong>main.c</strong>
的符号表输出里有这样三个未定义的符号：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000000000000000         *UND*  0000000000000000 error_handling</span><br><span class="line">0000000000000000         *UND*  0000000000000000 num</span><br><span class="line">0000000000000000         *UND*  0000000000000000 printf</span><br></pre></td></tr></table></figure>
那么在后续的链接阶段就会去其他源文件的编译产物中的符号表去寻找这些<code>UND-undefine</code>
未定义符号的定义了。</p>
<p>以下是3个文件的内容：<br />
<strong>main.c</strong><br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    error_handling(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>common.c</strong><br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(msg, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>common.h</strong><br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nullptr NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> BUF_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure> 从 <strong>main.c</strong> 和 <strong>common.c</strong>
的符号表输出可以看到，<strong>common.c</strong> 刚好有
<strong>main.c</strong>
几个缺失定义的符号的入口（也就是没有显示<code>**UND**</code>啦）：<br />
<strong>main.c.o</strong><br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000000000000000 g     O .bss   0000000000000004 BUF_SIZE</span><br><span class="line">0000000000000000 g     F .text  0000000000000045 main</span><br><span class="line">0000000000000000         *UND*  0000000000000000 error_handling</span><br><span class="line">0000000000000000         *UND*  0000000000000000 num</span><br><span class="line">0000000000000000         *UND*  0000000000000000 printf</span><br></pre></td></tr></table></figure> <strong>common.c.o</strong><br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000000000000000 g     O .bss   0000000000000004 BUF_SIZE</span><br><span class="line">0000000000000000 g     O .data  0000000000000004 num</span><br><span class="line">0000000000000000 g     F .text  0000000000000044 error_handling</span><br><span class="line">0000000000000000         *UND*  0000000000000000 stderr</span><br><span class="line">0000000000000000         *UND*  0000000000000000 fputs</span><br><span class="line">0000000000000000         *UND*  0000000000000000 fputc</span><br><span class="line">0000000000000000         *UND*  0000000000000000 exit</span><br></pre></td></tr></table></figure>
至于<code>printf</code>，<code>stderr</code>，<code>fputs</code>这些声明在
<strong>stdio.h</strong>
的符号，他们的链接文件在<code>/usr/lib</code>等环境变量路径下，链接的时候应该能自动发现它们的定义并链接相关库的（这里有点勉强哈，但是我也不知道这里怎么解释了，先把眼下的这个问题解释清楚吧）。</p>
<p>从上述符号表输出还可以看到几个具有外部链接性的符号（也就是标志位修饰符带<code>g</code>的），其中
<strong>BUF_SIZE</strong>
这个符号在两个符号表中都显示已定义并且是导出符号，向其他源文件提供该符号的定义入口（因为
<strong>main.c</strong> 和 <strong>common.c</strong>
都<code>include</code>了头文件 <strong>common.h</strong>，而
<strong>BUF_SIZE</strong>
的声明在头文件里面），链接器在链接的时候发现了两个同样的符号，它很疑惑🤔，所以给报了<code>multiple definition</code>的错误。</p>
<p>这里的问题在于 <strong>main.c</strong>
中存在未定义的符号，所与需要向其他符号表查表。如果
<strong>main.c</strong>
没有向其他符号表查询的动作，其实编译时链接器是无法发现这个符号的重复定义的，比如我们在
<strong>main.c</strong>
把对函数<code>error_handling</code>和变量<code>num</code>的引用去掉，就不会引发
<strong>多重定义</strong> 错误。</p>
<h1 id="问题解决">问题解决</h1>
<h2 id="使之具有内部链接性">使之具有内部链接性</h2>
<p>要让符号具有内部链接性，那么可以用static来修饰，这样生成的符号表中，该符号属性是<code>l --local</code>，只限于本翻译单元使用。<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMON_H</span></span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> BUF_SIZE;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure> <strong>main.c.o</strong><br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">build/app/CMakeFiles/main.dir/main.c.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*  0000000000000000 main.c</span><br><span class="line">0000000000000000 l    d  .text  0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .bss   0000000000000000 .bss</span><br><span class="line">0000000000000000 l     O .bss   0000000000000004 BUF_SIZE</span><br></pre></td></tr></table></figure> <strong>common.c.o</strong><br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">build/src/CMakeFiles/mysrc.dir/common.c.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*  0000000000000000 common.c</span><br><span class="line">0000000000000000 l    d  .text  0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .bss   0000000000000000 .bss</span><br><span class="line">0000000000000000 l     O .bss   0000000000000004 BUF_SIZE</span><br></pre></td></tr></table></figure> 这样一来 <strong>CMake</strong> 就可以通过编译了。<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/fredom/WorkSpace/cppPlayground/link_test/build</span><br><span class="line">Consolidate compiler generated dependencies of target mysrc</span><br><span class="line">[ 25%] Building C object src/CMakeFiles/mysrc.dir/common.c.o</span><br><span class="line">[ 50%] Linking C static library ../../runtimelib/libmysrc.a</span><br><span class="line">[ 50%] Built target mysrc</span><br><span class="line">Consolidate compiler generated dependencies of target main</span><br><span class="line">[ 75%] Building C object app/CMakeFiles/main.dir/main.c.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking C executable ../../bin/main</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target main</span></span><br></pre></td></tr></table></figure> ## 使用宏定义<br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMON_H</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 256</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
这样该名称在预处理阶段就会被检测字面值并替换成相应的定义值，符号表中甚至不会有该符号。<br />
<strong>main.c.o</strong><br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">build/app/CMakeFiles/main.dir/main.c.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*  0000000000000000 main.c</span><br><span class="line">0000000000000000 l    d  .text  0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .rodata        0000000000000000 .rodata</span><br><span class="line">0000000000000000 l    d  .debug_info    0000000000000000 .debug_info</span><br><span class="line">0000000000000000 l    d  .debug_abbrev  0000000000000000 .debug_abbrev</span><br><span class="line">0000000000000000 l    d  .debug_line    0000000000000000 .debug_line</span><br><span class="line">0000000000000000 l    d  .debug_str     0000000000000000 .debug_str</span><br><span class="line">0000000000000000 l    d  .debug_line_str        0000000000000000 .debug_line_str</span><br><span class="line">0000000000000000 g     F .text  0000000000000045 main</span><br><span class="line">0000000000000000         *UND*  0000000000000000 error_handling</span><br><span class="line">0000000000000000         *UND*  0000000000000000 num</span><br><span class="line">0000000000000000         *UND*  0000000000000000 printf</span><br></pre></td></tr></table></figure></p>
<h1 id="其他探讨">其他探讨</h1>
<h2 id="c-的class默认是内部链接性">C++ 的class默认是内部链接性？</h2>
<p>如果使用以下的文件进行编译:<br />
<strong>main.cpp</strong><br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">foo <span class="title">a_foo</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;foo::static_member: &quot;</span> &lt;&lt; foo::static_member &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;foo.get() &quot;</span> &lt;&lt; a_foo.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;foo.set(100) &quot;</span>; a_foo.<span class="built_in">set</span>(<span class="number">100</span>); cout &lt;&lt; a_foo.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>common.cpp</strong><br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> foo::static_member = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure> <strong>common.h</strong><br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMON_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">foo</span>(<span class="type">int</span> x) : <span class="built_in">common_member</span>(x) &#123;&#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_member;</span><br><span class="line">    <span class="type">int</span> common_member;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> common_member; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; common_member = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>那么得到的符号表中，类的成员函数没有显示地指明内部还是外部链接性，但是会指明这是一个函数的符号。类定义本身确实是内部链接性的。<br />
<strong>main.c.o</strong><br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000000000000000 l    d  .text._ZN3fooC2Ei      0000000000000000 .text._ZN3fooC2Ei</span><br><span class="line">0000000000000000 l    d  .text._ZNK3foo3getEv   0000000000000000 .text._ZNK3foo3getEv</span><br><span class="line">0000000000000000 l    d  .text._ZN3foo3setEi    0000000000000000 .text._ZN3foo3setEi</span><br><span class="line">0000000000000000 l       .group 0000000000000000 _ZN3fooC5Ei</span><br><span class="line">0000000000000000  w    F .text._ZN3fooC2Ei      000000000000001b _ZN3fooC2Ei</span><br><span class="line">0000000000000000  w    F .text._ZN3fooC2Ei      000000000000001b _ZN3fooC1Ei</span><br><span class="line">0000000000000000  w    F .text._ZNK3foo3getEv   0000000000000014 _ZNK3foo3getEv</span><br><span class="line">0000000000000000  w    F .text._ZN3foo3setEi    000000000000001b _ZN3foo3setEi</span><br><span class="line">0000000000000000 g     F .text  000000000000016c main</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>引用<a
href="https://blog.csdn.net/M_jianjianjiao/article/details/84109955">这篇博客</a>作为总结吧。</p>
<p><strong>预处理阶段</strong><br />
&gt; 1. 执行预处理指令<br />
&gt; 2. 将头文件展开 即#include 所包含的内容<br />
&gt; 3. 进行宏替换<br />
&gt; 4. 删除注释<br />
&gt; 5. 添加行号和标识</p>
<p><strong>编译阶段</strong><br />
&gt; 1. 函数和变量声明的检查<br />
&gt; 2. 语法分析 语义分析 词法分析 符号汇总等<br />
&gt; 3. 将代码转换为汇编语言</p>
<p><strong>汇编阶段</strong><br />
&gt; 1. 转成机器指令<br />
&gt; 2. 生成符号表<br />
&gt; 3. 符号地址与地址重定位</p>
<p><strong>链接阶段</strong><br />
&gt; 1. 扫描符号表<br />
&gt; 2. 对未定义符号向其他符号表的导出符号查询定义<br />
&gt; 3. 链接对应文件对应位置的符号定义</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>noexcept成员函数限定符</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/noexcept%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
    <content><![CDATA[<p><code>noexcept</code> 是一个 C++11
引入的关键字，用于指定函数或表达式是否可能引发异常。它可以用在函数声明后面，表示该函数不会抛出异常。</p>
<p>当使用 <code>noexcept</code>
关键字声明一个函数时，我们向编译器表明该函数不会产生异常并且在调用过程中不会传播异常。这对于编写可靠的代码和进行优化非常有用。</p>
<p>以下是一个示例：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体，不会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Divide by zero exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">myFunction</span>(); <span class="comment">// 不会产生异常</span></span><br><span class="line">        <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述示例中，<code>myFunction()</code> 被声明为
<code>noexcept</code>，这表示该函数不会抛出任何异常。而
<code>divide()</code> 函数没有被声明为
<code>noexcept</code>，它可能会抛出 <code>std::runtime_error</code>
异常。</p>
<p>通过使用 <code>noexcept</code>
关键字，我们可以在编写代码时明确指定哪些函数是异常安全的，这有助于提高代码的可读性和可靠性。此外，编译器可以根据
<code>noexcept</code> 的信息进行一些优化，提高代码的性能和效率。</p>
<p>需要注意的是，如果在调用 <code>noexcept</code>
函数时发生了异常，不会触发默认的异常处理机制。相反，程序将直接终止（terminate），因此在使用
<code>noexcept</code> 时要确保函数内部不会抛出任何异常。</p>
<p>另外，类的成员函数也可以使用 <code>noexcept</code>
关键字进行声明，例如：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myMemberFunction</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，<code>noexcept</code>
关键字被放置在成员函数声明的末尾，表示该成员函数不会抛出异常。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>non-copyable type</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/non-copyable%20type/</url>
    <content><![CDATA[<p>在C++中，Non-Copyable类型是指不允许进行拷贝构造和拷贝赋值的类型。通常，我们可以通过将拷贝构造函数和拷贝赋值运算符声明为私有或删除来创建Non-Copyable类型。这样做可以防止对象的拷贝，以便更好地控制资源的管理和对象的行为。</p>
<p>以下是一个示例：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将拷贝构造函数声明为私有或删除</span></span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将拷贝赋值运算符声明为私有或删除</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NonCopyable obj1;</span><br><span class="line">    NonCopyable obj2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NonCopyable类型的对象无法进行拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="function">NonCopyable <span class="title">obj3</span><span class="params">(obj1)</span></span>; <span class="comment">// 编译错误！拷贝构造函数被删除</span></span><br><span class="line">    obj2 = obj1; <span class="comment">// 编译错误！拷贝赋值运算符被删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述示例中，<code>NonCopyable</code>类将拷贝构造函数和拷贝赋值运算符声明为删除的，这意味着我们无法对其对象进行拷贝操作。当我们尝试使用拷贝构造函数或拷贝赋值运算符来创建或赋值对象时，编译器会发出错误。</p>
<p>Non-Copyable类型常用于管理资源类（如文件句柄、网络连接等），以确保资源的唯一性和正确释放。通过禁止拷贝操作，可以避免资源被多个对象共享或意外释放，提高程序的安全性和可靠性。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>shared_ptr 引用计数与被放入容器关系</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/shared_ptr%20%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%8E%E8%A2%AB%E6%94%BE%E5%85%A5%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>先来看普通的计数规则：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出引用计数</span></span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出引用计数</span></span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出引用计数</span></span><br><span class="line"></span><br><span class="line">    ptr.<span class="built_in">reset</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是存在多少个shared_ptr对象使用了同一个地址，引用计数就是多少，当然，这要求用户必须严格使用shared_ptr来替代new指向对象，否则shared_ptr是无从得知有多少个指针变量使用了该地址的。</p>
<p>如果shared_ptr被放入容器，比如stack、vector，计数会如何变化呢？<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref cnt: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref cnt: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;<span class="type">int</span>&gt;&gt; spvec;</span><br><span class="line">    spvec.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref cnt: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    spvec.<span class="built_in">push_back</span>(ptr2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref cnt: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref cnt: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    spvec.<span class="built_in">pop_back</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref cnt: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    ptr.<span class="built_in">reset</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref cnt: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 输出：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ref cnt: 1</span><br><span class="line">ref cnt: 2</span><br><span class="line">ref cnt: 3</span><br><span class="line">ref cnt: 4</span><br><span class="line">ref cnt: 3</span><br><span class="line">ref cnt: 2</span><br><span class="line">ref cnt: 0</span><br></pre></td></tr></table></figure>
所以从容器弹出后，就变成了临时右值，如果没有对象接收（接过所有权）的话，这个临时右值会自动释放，导致引用计数减少。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>std upper_bound 二分查找上界</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/std%20upper_bound%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8A%E7%95%8C/</url>
    <content><![CDATA[<p>how to use C++ upper_bound()?</p>
<p>ChatGPT</p>
<p><code>std::upper_bound()</code> is a standard library function in C++
that is used with sorted ranges (like a sorted vector or array). It
returns an iterator pointing to the first element in the range
<code>[first, last)</code> that is greater than a given value. In other
words, it finds the upper boundary for a value in a sorted range.</p>
<p>Here's a step-by-step guide on how to use
<code>std::upper_bound()</code>:</p>
<ol type="1">
<li><p><strong>Include necessary headers</strong>:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Make sure the range is sorted</strong>.
<code>upper_bound()</code> assumes that the range is sorted in
non-decreasing order.</p></li>
<li><p><strong>Use the function</strong>: The function signature is as
follows:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">upper_bound</span> <span class="params">(iterator first, iterator last, <span class="type">const</span> val)</span></span>;</span><br></pre></td></tr></table></figure> Here:</p>
<ul>
<li><code>first</code> is the iterator pointing to the beginning of the
range.<br />
</li>
<li><code>last</code> is the iterator pointing to the end of the
range.<br />
</li>
<li><code>val</code> is the value for which you want to find the upper
bound.</li>
</ul>
<p>The function returns an iterator pointing to the first element that
is greater than <code>val</code>.</p></li>
<li><p><strong>Example</strong>:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find upper bound of 4</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Upper bound for 4 is &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element found greater than 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> This will output:<br />
<code>Upper bound for 4 is 6</code></p></li>
<li><p><strong>Custom Comparators</strong>: <code>upper_bound</code> can
also work with custom comparators. This is especially useful when
working with more complex data structures or custom sorting
criteria.</p>
<p>Here's an example with pairs sorted by the first element:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find upper bound of 4</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Upper bound for 4 is &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element found greater than 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Note</strong>: Remember, if the range is not sorted, the
results from <code>upper_bound</code> are undefined. Always ensure the
range is sorted according to the comparison function being
used.</p></li>
</ol>
<p>what could be the inner implementation of
<code>std::upper_bound()</code>? binary search?</p>
<p>ChatGPT</p>
<p>Yes, the inner implementation of <code>std::upper_bound()</code>
typically utilizes a binary search algorithm since the input range is
sorted. This ensures the operation runs in O(logn) time complexity,
which is the expected efficiency of <code>std::upper_bound()</code>.</p>
<p>Here's a simplified version of how <code>std::upper_bound()</code>
might be implemented using binary search:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIt, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Calculate the distance between first and last</span></span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step;</span><br><span class="line">    count = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ForwardIt it = first;</span><br><span class="line">        step = count / <span class="number">2</span>;</span><br><span class="line">        std::<span class="built_in">advance</span>(it, step); <span class="comment">// Move iterator by &#x27;step&#x27; positions</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(value &lt; *it)) &#123; <span class="comment">// If value is not less than the current element</span></span><br><span class="line">            first = ++it;    <span class="comment">// Move the starting point to the next element</span></span><br><span class="line">            count -= step + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = step;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Note that the actual implementation in the C++ Standard Library might
have various optimizations and variations to handle all possible cases
and types of iterators efficiently. The above code is a basic
illustration and might not cover all edge cases.</p>
<p>Always remember that binary search algorithms, like
<code>upper_bound()</code>, require that the input range be sorted
according to the comparison function being used. Otherwise, the results
will be undefined.</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>互相包含的头文件怎么处理？</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E4%BA%92%E7%9B%B8%E5%8C%85%E5%90%AB%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="需求场景">需求场景</h2>
<p>这是一个非常常见的需求，包括游戏设计中比较常见。比如游戏的对象可以拥有很多属性，类似位置属性，形状属性，颜色属性等等，我们希望拥有这些属性的对象能把属性的效果应用到其上，</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用delete来取消暴露继承的接口</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E4%BD%BF%E7%94%A8delete%E6%9D%A5%E5%8F%96%E6%B6%88%E6%9A%B4%E9%9C%B2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>之所以会去查找这个功能是因为在实现算法题OpenJudge.3750魔兽争霸时，我希望设计的一套类继承表示方法中，有一些静态方法只有基类可以来使用，这些静态方法会设置一些基本的类间共用信息，而子类应该专注于自身的接口，并不应该用于设置这些最基本的类间共用信息。</p>
<p>在子类中，使用 <strong>delete</strong>
关键字，显式地将从基类继承而来的某些接口标注为不可使用即可。这样在尝试使用子类调用这些方法的时候就会发生编译错误。</p>
<p>以下是GPT的回答：<br />
In C++, all base class public and protected member functions are always
inherited by derived classes. There's no direct mechanism to prevent a
derived class from inheriting a particular method. However, there are a
few workarounds depending on the exact use case.</p>
<ol type="1">
<li><strong>Using <code>private</code> Access Specifier</strong>: If a
base class method is made <code>private</code>, the derived class cannot
access it directly. But, this also means the method is not publicly
exposed from the base class as well.<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// someMethod is not accessible here.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>Hide the Method in Derived Class</strong>: While you can't
prevent inheritance, you can hide the base class method by defining a
method with the same name in the derived class. This method in the
derived class will hide the base class method.<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>= <span class="keyword">delete</span>; <span class="comment">// deletes the function and makes it inaccessible</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> In the above example, the derived class hides
<code>someMethod()</code> from the base class by declaring it with the
<code>delete</code> keyword. This ensures that <code>someMethod()</code>
cannot be called on the <code>Derived</code> class.</li>
</ol>
<p><strong>delete</strong>
关键字对于所有成员函数都是可用的，但是最常见的使用方法是用于屏蔽某个构造函数使之无法被显式地调用，比如一些默认构造函数并非是期望被用户所使用的，此时可以使用
<strong>delete</strong> 关键字标记该构造函数为禁止使用。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用shared_ptr指向值</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E4%BD%BF%E7%94%A8shared_ptr%E6%8C%87%E5%90%91%E5%80%BC/</url>
    <content><![CDATA[<p>要创建一个指向某个值的<code>shared_ptr</code>，你可以使用<code>std::make_shared</code>函数或直接使用<code>std::shared_ptr</code>的构造函数。</p>
<p>使用<code>std::make_shared</code>函数可以更方便地创建<code>shared_ptr</code>，它会在堆上分配内存，并返回一个指向该内存的<code>shared_ptr</code>对象。</p>
<p>下面是使用<code>std::make_shared</code>函数创建指向某个值的<code>shared_ptr</code>的示例代码：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 make_shared 创建 shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ptr 访问值</span></span><br><span class="line">    <span class="type">int</span> value = *ptr;  <span class="comment">// 解引用获取值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，<code>ptr</code>是一个指向<code>int</code>类型值<code>42</code>的<code>shared_ptr</code>。你可以通过解引用操作符<code>*</code>来访问指向的值。</p>
<p>另外，你也可以直接使用<code>std::shared_ptr</code>的构造函数来创建指向某个值的<code>shared_ptr</code>。下面是相应的示例代码：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 shared_ptr 构造函数创建 shared_ptr</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ptr 访问值</span></span><br><span class="line">    <span class="type">int</span> value = *ptr;  <span class="comment">// 解引用获取值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>new int(42)</code>会在堆上分配内存，并返回一个指向该内存的原始指针，然后将该指针传递给<code>std::shared_ptr</code>的构造函数以创建<code>shared_ptr</code>对象。</p>
<p>无论你选择使用<code>std::make_shared</code>函数还是直接使用<code>std::shared_ptr</code>的构造函数，都能够创建一个指向某个值的<code>shared_ptr</code>。它们的选择取决于个人偏好和具体的使用场景。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用基类容器存储不同模板参数的派生类对象</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E4%B8%8D%E5%90%8C%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>main.cpp：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class B&lt;&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;&gt; with data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* arr[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function">B&lt;<span class="type">int</span>&gt; <span class="title">b1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="function">B&lt;<span class="type">float</span>&gt; <span class="title">b2</span><span class="params">(<span class="number">3.14f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    arr[<span class="number">0</span>] = &amp;b1;</span><br><span class="line">    arr[<span class="number">1</span>] = &amp;b2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        arr[i]-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 输出：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Derived class B&lt;i&gt; with data: 42  </span><br><span class="line">Derived class B&lt;f&gt; with data: 3.14</span><br></pre></td></tr></table></figure></p>
<p>通过这种方式，我们可以实现类似于Python的序列存储不同类型的对象。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用尾置声明有什么好处？</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E4%BD%BF%E7%94%A8%E5%B0%BE%E7%BD%AE%E5%A3%B0%E6%98%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F/</url>
    <content><![CDATA[<p>There are certain cases where you must use a trailing return type.
Most notably, a lambda return type, if specified, must be specified via
a trailing return type. Also, if your return type utilizes
a <code>decltype</code> that requires that the argument names are in
scope, a trailing return type must be used (however, one can usually
use <code>declval&lt;T&gt;</code> to work around this latter issue).</p>
<p>The trailing return type does have some other minor advantages. For
example, consider a non-inline member function definition using the
traditional function syntax:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">my_awesome_type</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt; integer_sequence;</span><br><span class="line"></span><br><span class="line">    <span class="function">integer_sequence <span class="title">get_integers</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">my_awesome_type::integer_sequence <span class="title">my_awesome_type::get_integers</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Member typedefs are not in scope until after the name of the class
appears before <code>::get_integers</code>, so we have to repeat the
class qualification twice. If we use a trailing return type, we don't
need to repeat the name of the type:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">my_awesome_type::get_integers</span><span class="params">()</span> <span class="type">const</span> -&gt; integer_sequence</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this example, it's not such a big deal, but if you have long class
names or member functions of class templates that are not defined
inline, then it can make a big difference in readability.</p>
<p>In his <a
href="http://www.youtube.com/watch?v=ourmFvidEpk&amp;feature=plcp">"Fresh
Paint"</a> session at C++Now 2012, Alisdair Meredith pointed out that if
you use trailing return types consistently, the names of all of your
functions line up neatly:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span> -&gt; <span class="type">int</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bar</span><span class="params">()</span> -&gt; really_long_typedef_name</span>;</span><br></pre></td></tr></table></figure>
<p>I've used trailing return types everywhere in <a
href="https://github.com/dbremner/cxxreflect/">CxxReflect</a>, so if
you're looking for an example of how code looks using them consistently,
you can take a look there (e.g, <a
href="https://github.com/dbremner/cxxreflect/blob/master/cxxreflect/reflection/type.hpp">the <code>type</code> class</a>).</p>
<p>按照这篇StackOverflow的回答来讲，明显的好处是能简化成员函数返回值的书写。但是其他好处不明显。坏处就是函数声明前面永远带了一个意义不明的auto占位符。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>初始化 shared_ptr 的几种方式</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E5%88%9D%E5%A7%8B%E5%8C%96%20shared_ptr%20%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>A <code>shared_ptr</code> is a smart pointer in the C++ Standard
Library that retains shared ownership of an object through a pointer.
Multiple <code>shared_ptr</code> objects can own the same object, and
the object is destroyed when the last remaining <code>shared_ptr</code>
owning the object is destroyed or reset.</p>
<p>Here's how to initialize a <code>shared_ptr</code>:</p>
<ol type="1">
<li><p><strong>Direct Initialization with
<code>std::make_shared</code></strong> (Recommended)
<code>std::make_shared</code> is a utility function that creates a
<code>shared_ptr</code> that manages a new object of the type specified
as its template argument. This is the recommended way because it's more
efficient; it allocates memory for the control block and the object in
one allocation.<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Direct Initialization with Constructor</strong> This
involves using the <code>shared_ptr</code> constructor directly.
However, it uses two allocations, one for the control block and one for
the object.<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>Note: Avoid using raw pointers with <code>shared_ptr</code> this way.
If you forget to wrap a raw pointer with <code>shared_ptr</code>, it can
lead to memory leaks or double deletes.</p></li>
<li><p><strong>Copying Another <code>shared_ptr</code></strong> This
will share ownership of the managed object.<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = p1;  <span class="comment">// p3 now shares ownership with p1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Assignment</strong> Just like with copying, assignment
will share ownership.<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p4;</span><br><span class="line">p4 = p1;  <span class="comment">// p4 now shares ownership with p1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Initialization with <code>nullptr</code></strong> You can
initialize a <code>shared_ptr</code> with <code>nullptr</code> to
indicate it doesn't point to any object.<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Initialization with Custom Deleter</strong> Sometimes you
want to specify a custom deleter for the object managed by the
<code>shared_ptr</code>.<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>), fclose)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>When working with <code>shared_ptr</code>, it's a good idea to use
<code>std::make_shared</code> whenever possible due to its efficiency
benefits. If you need a custom deleter or are dealing with APIs that
return raw pointers, then you might need to use the
<code>shared_ptr</code> constructor directly, but always be cautious
about the ownership of the raw pointer.</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>只能指针shared_ptr的引用计数验证</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E5%8F%AA%E8%83%BD%E6%8C%87%E9%92%88shared_ptr%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>之前一直在想，如果放入容器的共享指针作为右值被返回但是没有使用变量接收这个值，这个对象的智能指针再也没有其他地方有引用的话，那么它真的会自动释放吗？</p>
<p>所以写了一个简单的demo来验证这个情况。分别是：<br />
1. 使用vector接收弹出的共享指针<br />
2. 不使用vector接收弹出的共享指针</p>
<p>对于第一种情况：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">C</span>() : <span class="built_in">data</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> _data) : <span class="built_in">data</span>(_data) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;C &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (<span class="type">int</span>*)<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; destructed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;C&gt;&gt; CSptrVec;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;C&gt;&gt; tempSptrVec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        CSptrVec.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">C</span>(i));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pop_back() begin\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tempSptrVec.<span class="built_in">emplace_back</span>(CSptrVec.<span class="built_in">back</span>());</span><br><span class="line">        CSptrVec.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pop_back() finish\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 实际的输出是：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pop_back() begin</span><br><span class="line">pop_back() finish</span><br><span class="line">C 4 0x1d089a341b0 destructed</span><br><span class="line">C 3 0x1d089a34000 destructed</span><br><span class="line">C 2 0x1d089a31a70 destructed</span><br><span class="line">C 1 0x1d089a33fc0 destructed</span><br><span class="line">C 0 0x1d089a31ea0 destructed</span><br></pre></td></tr></table></figure></p>
<p>对于后一种情况，也即不使用另外的容器接收弹出的共享指针的话，那么确实是在弹出后就直接自动释放了：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">C</span>() : <span class="built_in">data</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> _data) : <span class="built_in">data</span>(_data) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;C &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (<span class="type">int</span>*)<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; destructed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;C&gt;&gt; CSptrVec;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;C&gt;&gt; tempSptrVec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        CSptrVec.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">C</span>(i));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pop_back() begin\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// tempSptrVec.emplace_back(CSptrVec.back());</span></span><br><span class="line">        CSptrVec.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pop_back() finish\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 实际的输出是：<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pop_back() begin</span><br><span class="line">C 4 0x1b77dfe41b0 destructed</span><br><span class="line">C 3 0x1b77dfe4000 destructed</span><br><span class="line">C 2 0x1b77dfe1a70 destructed</span><br><span class="line">C 1 0x1b77dfe3fc0 destructed</span><br><span class="line">C 0 0x1b77dfe1ea0 destructed</span><br><span class="line">pop_back() finish</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>向上转换和向下转换</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E5%90%91%E4%B8%8A%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>向上转换是指子类指针向基类指针转换？</p>
<p>2023/8/6 13:56:49</p>
<p>是的，向上转换是指子类指针向基类指针的转换。在类的继承关系中，基类是父类，子类是派生类。向上转换允许将子类对象指针或引用转换为基类对象指针或引用。</p>
<p>由于子类对象继承了基类的属性和方法，因此可以将子类对象视为基类对象来操作，但是仅能访问基类中定义的成员，而无法访问子类新增的成员。</p>
<p>向上转换是安全的，不需要显式类型转换。编译器会自动进行这种转换，而且不会丢失任何信息。这是因为子类对象中包含了基类对象的部分，所以可以将子类对象指针或引用视为基类对象的指针或引用。</p>
<p>下面是一个示例：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal is eating.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog is barking.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog* dogPtr = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">    </span><br><span class="line">    Animal* animalPtr = dogPtr; <span class="comment">// 向上转换，将子类指针赋值给基类指针</span></span><br><span class="line">    </span><br><span class="line">    animalPtr-&gt;<span class="built_in">eat</span>(); <span class="comment">// 可以访问基类的成员函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// animalPtr-&gt;bark();  // 不可以访问子类新增的成员函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> dogPtr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，<code>Dog</code>类是<code>Animal</code>类的子类。通过向上转换，将<code>Dog</code>类的指针<code>dogPtr</code>赋值给了<code>Animal</code>类的指针<code>animalPtr</code>。然后，我们可以通过<code>animalPtr</code>访问<code>Animal</code>类中定义的成员函数<code>eat()</code>，但是无法访问<code>Dog</code>类中新增的成员函数<code>bark()</code>。</p>
<p>需要注意的是，当使用基类指针或引用操作子类对象时，如果想要调用子类新增的成员函数，可以使用向下转换（<code>dynamic_cast</code>）来恢复子类类型，前提是基类指针或引用确实指向了子类对象。</p>
<p>2023/8/6 13:57:03</p>
<p>只能转换指针是吗？不能够直接转换对象？</p>
<p>2023/8/6 13:57:17</p>
<p>是的，向上转换和向下转换通常用于指针或引用。在C++中，通过将子类对象指针或引用赋值给基类指针或引用来进行向上转换。这是因为向上转换是基于继承关系的，而对象之间没有直接的继承关系。</p>
<p>但是，如果你想要进行对象级别的转换，可以使用对象拷贝构造函数或赋值运算符来创建一个相应类型的新对象。这样可以实现对象级别的转换。</p>
<p>以下是一个示例：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal is eating.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog is barking.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    </span><br><span class="line">    Animal animal = <span class="built_in">static_cast</span>&lt;Animal&gt;(dog); <span class="comment">// 使用对象拷贝构造函数进行对象级别的转换</span></span><br><span class="line">    </span><br><span class="line">    animal.<span class="built_in">eat</span>(); <span class="comment">// 可以调用Animal类的成员函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// animal.bark();  // 不可以调用Dog类的成员函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，我们使用了<code>static_cast</code>来将<code>Dog</code>对象<code>dog</code>转换为<code>Animal</code>对象<code>animal</code>。这里使用的是对象级别的转换，通过对象拷贝构造函数进行转换。注意，这种转换只能获取到<code>Dog</code>对象中从<code>Animal</code>继承而来的部分，无法获得<code>Dog</code>对象中新增的部分。</p>
<p>需要注意的是，对象级别的转换会创建一个新对象，而不是直接在原始对象上进行转换。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>工作区.clang-tidy编写建议</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E5%B7%A5%E4%BD%9C%E5%8C%BA.clang-tidy%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>首先，一般是在VScode安装cpp-tools这个插件，已经集成了clang-tidy静态分析工具，但是cpp-tools的分析后端似乎不是clangd，而且clang本身虽然是LLVM工程的一部分，但是使用范围却比想象中的要广泛很多，原以为只是被Mac采用所以有一点占有量，没想到实际使用量还是很大的，很多公司都会使用clangd作为语法分析的后端，clang-tidy作为静态分析工具。</p>
<p>VScode的cpp-tools插件分析当前工作区的.c/.cpp源文件时（或者.h/.hpp头文件），会在当前目录下查找.clang-tidy文件，在.clang-tidy文件中可以使用yaml格式编写需要开启检查的条目。</p>
<p>如果某一个目录没有.clang-tidy文件指示检查项目，那么会沿用父目录的.clang-tidy，如果当前目录已有.clang-tidy那么不会使用父目录的.clang-tidy文件，但是可以在.clang-tidy文件中使用<code>InheritParen: True</code>属性来继承父目录的检查项。</p>
<p>一个常用的.clang-tidy检查项文件可能如下：<br />
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Checks:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  -*,</span></span><br><span class="line"><span class="string">  bugprone-unused-return-value,</span></span><br><span class="line"><span class="string">  google-readability-braces-around-statements,</span></span><br><span class="line"><span class="string">  readability-identifier-length,</span></span><br><span class="line"><span class="string">  -misc-unused-parameters,</span></span><br><span class="line"><span class="string">  -llvmlibc-*,</span></span><br><span class="line"><span class="string">  -modernize-use-trailing-return-type,</span></span><br><span class="line"><span class="string">  -cppcoreguidelines-owning-memory,</span></span><br><span class="line"><span class="string">  -misc-const-correctness,</span></span><br><span class="line"><span class="string">  -altera-unroll-loops,</span></span><br><span class="line"><span class="string">  -fuchsia-default-arguments-calls,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">InheritParentConfig:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CheckOptions:</span></span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.NamespaceCase</span>,                <span class="attr">value:</span> <span class="string">lower_case</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.ClassCase</span>,                    <span class="attr">value:</span> <span class="string">CamelCase</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.StructCase</span>,                   <span class="attr">value:</span> <span class="string">CamelCase</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.TemplateParameterCase</span>,        <span class="attr">value:</span> <span class="string">CamelCase</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.TemplateParameterSuffix</span>,      <span class="attr">value:</span> <span class="string">&#x27;T&#x27;</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.ValueTemplateParameterCase</span>,   <span class="attr">value:</span> <span class="string">CamelCase</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.ValueTemplateParameterPrefix</span>, <span class="attr">value:</span> <span class="string">&#x27;k&#x27;</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.ValueTemplateParameterSuffix</span>, <span class="attr">value:</span> <span class="string">&#x27;T&#x27;</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.TypedefCase</span>,                  <span class="attr">value:</span> <span class="string">CamelCase</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.TypeAliasCase</span>,                <span class="attr">value:</span> <span class="string">CamelCase</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.EnumCase</span>,                     <span class="attr">value:</span> <span class="string">CamelCase</span>  &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.VariableCase</span>,                 <span class="attr">value:</span> <span class="string">lower_case</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.ParameterCase</span>,                <span class="attr">value:</span> <span class="string">lower_case</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.PrivateMemberPrefix</span>,          <span class="attr">value:</span> <span class="string">&#x27;m_&#x27;</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.ProtectedMemberPrefix</span>,        <span class="attr">value:</span> <span class="string">&#x27;m_&#x27;</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.GlobalVariablePrefix</span>,         <span class="attr">value:</span> <span class="string">&#x27;g_&#x27;</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.StaticVariableCase</span>,           <span class="attr">value:</span> <span class="string">CamelCase</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.StaticVariablePrefix</span>,         <span class="attr">value:</span> <span class="string">&#x27;s_&#x27;</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.StaticConstantCase</span>,           <span class="attr">value:</span> <span class="string">CamelCase</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.StaticConstantPrefix</span>,         <span class="attr">value:</span> <span class="string">&#x27;k&#x27;</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.GlobalConstantCase</span>,           <span class="attr">value:</span> <span class="string">CamelCase</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.GlobalConstantPrefix</span>,         <span class="attr">value:</span> <span class="string">&#x27;k&#x27;</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.EnumConstantCase</span>,             <span class="attr">value:</span> <span class="string">CamelCase</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.EnumConstantPrefix</span>,           <span class="attr">value:</span> <span class="string">&#x27;k&#x27;</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.FunctionCase</span>,                 <span class="attr">value:</span> <span class="string">camelBack</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.TsmRotationCase</span>,              <span class="attr">value:</span> <span class="string">target_T_source</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.TsmIsometryCase</span>,              <span class="attr">value:</span> <span class="string">target_T_source</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.TsmJacobianCase</span>,              <span class="attr">value:</span> <span class="string">target_J_source</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">readability-identifier-naming.TsmIndexStructCase</span>,           <span class="attr">value:</span> <span class="string">UPPER_CASE</span> &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">misc-non-private-member-variables-in-classes.IgnoreClassesWithAllMemberVariablesBeingPublic</span>, <span class="attr">value:</span> <span class="number">1</span> &#125; <span class="comment"># structs are allowed</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">FormatStyle:</span> <span class="string">file</span> <span class="comment"># use .clang-format from the project dir for fixes</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<strong>Checks</strong>
字段下可以是一个yaml数组，也可以是一个yaml字符串值（用单引号或者双引号括起来），但是使用字符串值的话，所有检查项都放在一行，不便于查看，所以我还是采用了数组，每行单独放一个检查项的形式。</p>
<p>![[Pasted image 20230811211620.png]]<br />
在VScode中，可以手动执行clang-tidy静态分析，针对于当前打开的文件，或者工作区内所有文件，一般可以配置为当前文件改动后，只针对当前文件执行新的静态分析更新，这样子可以节省资源。如果开启的检查项特别多，那么分析工作区文件可能会很耗时，可能长达几十秒。</p>
<p>![[Pasted image 20230811211805.png]]</p>
<p>在工作区设置搜索clang可以显示出相关的选项配置，我选择配置成文件自动保存，并在cpp-tools检测到文件变更保存之后，对保存的文件使用clang-tidy静态分析（图中的选项提示我们记得把另一个选项
==Code Analysis: Run Automatically==
也设置为ture，就是去那个选项的框打上钩）：<br />
![[Pasted image 20230811212259.png]]</p>
<p>这样可以实现文件改动后自动更新静态分析。</p>
<p>使用clang-tidy静态分析的好处很多，可以自动检测出优化性能的地方，比如自动优化for-loop，有一些类型声明有更好的选择也会有提示。在VScode中，由clang-tidy静态分析提供的优化选项时蓝色灯泡，而cpp-tools自带的一些简单引用分析是黄色灯泡（比如类的成员函数没有在对应名称的源文件中找到实现又或者是头文件在给定的搜索路径下找不到就会在对应行有黄色灯泡）<br />
![[Pasted image 20230811212716.png]]</p>
<p>在.clang-tidy文件的Checks字段中，使用*通配符，表示开启所有检查选项，在检查选项前面添加短横杠<code>-</code>，表示禁用此检查选项，因此一般开头第一个检查选项是：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-*</span><br></pre></td></tr></table></figure> 表示禁用所有检查选项。<br />
* 开启所有检查选项将耗费很多资源用于静态分析<br />
* 有些检查并不适用于当前平台目标，比如__float128类型是x86
Linux下才支持的类型，但如果使用的是Windows下的MinGW，没有禁用此检查选项就会把标准头文件中使用了该类型的代码全部报错</p>
<p>一般是先禁用所有检查，然后根据项目要求开启相应的检查，一般是代码风格检查，还有一些容易出Bug的写法的检查，比如在Checks字段开启检查选项：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">misc-unused-parameters</span><br></pre></td></tr></table></figure> ![[Pasted image 20230811213145.png]]<br />
这通常就很没有必要，因为这两个进程入口参数确实不一定用得到，但是写上先也有可能是个人习惯。<br />
在关闭禁用这个检查选项后，已检查的源文件中这些警告和错误不会消失，通过再次手动保存文件触发当前文件的静态分析检查（即使没有任何改动，Ctrl+s也会被检测到保存操作）。</p>
<p>使用这样的一个.clang-tidy文件表示排除当前目录不使用clang-tidy的静态检查分析：<br />
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Checks:</span> <span class="string">&#x27;-*&#x27;</span></span><br><span class="line"><span class="attr">WarningsAsErrors:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">HeaderFilterRegex:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">AnalyzeTemporaryDtors:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">InheritParentConfig:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>clang-tidy静态检查是很有必要的，但是不会非常频繁的检查，一般可以考虑在编译前执行一次全局检查。因为VScode的cpp-tools插件自带的分析只有引用和简单的类型分析，稍微复杂一点的类型转换它是看不出来的，比如一些C++17以后的高级特性或者模板函数复杂的类型转换。cpp-tools的一般作用是根据所有文件以及CMake-tools配置好全局工作区之后生成好的compile-commands.json文件执行静态符号提取，然后给用户在编写代码时提供补全功能，但是分析功能比较弱。clang-tidy根据CMake-tools提供的compile-commands.json文件就能够把源文件的代码转为AST（Abstract
Syntax Tree，抽象语法树，编译原理课程的知识点）<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::get</span><span class="params">(<span class="type">const</span> std::string_view&amp; key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> Type*</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// throw std::runtime_error(&quot;Trie::get not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">const</span> Node&gt; curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; c : key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;sp_map.<span class="built_in">find</span>(c) == curr-&gt;sp_map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = curr-&gt;sp_map.<span class="built_in">find</span>(c)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!curr-&gt;has_value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>* curr_with_val = <span class="keyword">dynamic_cast</span>&lt;<span class="type">const</span> NodeWithValue&lt;Type&gt; *&gt;(curr.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">if</span> (curr_with_val == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr_with_val-&gt;data_sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">Trie::get</span><span class="params">(<span class="type">const</span> std::string_view&amp; key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> <span class="type">uint32_t</span>*</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">Trie::put</span><span class="params">(<span class="type">const</span> std::string_view&amp; key, <span class="type">uint32_t</span> val)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">Trie::get</span><span class="params">(<span class="type">const</span> std::string_view&amp; key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> <span class="type">uint64_t</span>*</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">Trie::put</span><span class="params">(<span class="type">const</span> std::string_view&amp; key, <span class="type">uint64_t</span> val)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">Trie::get</span><span class="params">(<span class="type">const</span> std::string_view&amp; key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> std::string*</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">Trie::put</span><span class="params">(<span class="type">const</span> std::string_view&amp; key, std::string val)</span> <span class="type">const</span> -&gt; Trie</span>;</span><br></pre></td></tr></table></figure>
在该源文件中，get模板方法要求返回的是存储字典树中键值的值的指针类型，但是如果我们尝试返回一个shared_ptr的话，clang-tidy静态检查就会发现这个错误，而cpp-tools无法发现。所以当项目很大时，因为编译时间很长，在编写完源文件之后，应该要进行静态分析检查，避免在编译时才发现错误，浪费大量时间。<br />
![[Pasted image 20230811215149.png]]</p>
<p>compile-commands.json是什么呢？截取工作区CMake-tools根据各个CMakeLists.txt文件生成的编译命令的一部分看看：<br />
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:/workspace/temp/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:\\allMinGW64\\x86_64-posix-seh-gcc-11.2.0-msvcrt\\bin\\g++.exe -DDEBUG -D__STRICT_ANSI__ -Dinner_EXPORTS @CMakeFiles/inner.dir/includes_CXX.rsp -g -std=gnu++17 -o CMakeFiles\\inner.dir\\dummy\\dummy.cpp.obj -c E:\\workspace\\temp\\src\\dummy\\dummy.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:/workspace/temp/src/dummy/dummy.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/inner.dir/dummy/dummy.cpp.obj&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:/workspace/temp/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:\\allMinGW64\\x86_64-posix-seh-gcc-11.2.0-msvcrt\\bin\\g++.exe -DDEBUG -D__STRICT_ANSI__ -Dinner_EXPORTS @CMakeFiles/inner.dir/includes_CXX.rsp -g -std=gnu++17 -o CMakeFiles\\inner.dir\\mathnipet.cpp.obj -c E:\\workspace\\temp\\src\\mathnipet.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:/workspace/temp/src/mathnipet.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/inner.dir/mathnipet.cpp.obj&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:/workspace/temp/build/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:\\allMinGW64\\x86_64-posix-seh-gcc-11.2.0-msvcrt\\bin\\g++.exe -DDEBUG -D__STRICT_ANSI__ -Dinner_EXPORTS @CMakeFiles/inner.dir/includes_CXX.rsp -g -std=gnu++17 -o CMakeFiles\\inner.dir\\trie.cpp.obj -c E:\\workspace\\temp\\src\\trie.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:/workspace/temp/src/trie.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/CMakeFiles/inner.dir/trie.cpp.obj&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，就是每个源文件作为翻译单元时，如何能正确编译出目标符号表文件的编译命令，但是这里面没有链接命令。-D参数就是源文件中的#ifdef和#ifndef这些宏用到的字面量。比如参数<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-DDEBUG -D__STRICT_ANSI__</span><br></pre></td></tr></table></figure> 和参数<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-std=gnu++17</span><br></pre></td></tr></table></figure> 都是在CMakeLists.txt文件中配置的：<br />
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SET(CMAKE_BUILD_TYPE &quot;Debug&quot;)</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_C_STANDARD   <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line">    <span class="comment"># clang does not support __float128 type, which is  supported</span></span><br><span class="line">    <span class="comment"># by GNU GCC/G++, to eliminate this lint error, an additional</span></span><br><span class="line">    <span class="comment"># define macro is needed.</span></span><br><span class="line">    <span class="keyword">ADD_DEFINITIONS</span>(-D__STRICT_ANSI__)</span><br><span class="line"><span class="keyword">ENDIF</span>()</span><br></pre></td></tr></table></figure></p>
<p>以上是普通小项目的一般使用方法，其他更多的clang-tidy操作可以参考阅读一下<a
href="%5BClang-Tidy%20—%20Extra%20Clang%20Tools%2018.0.0git%20documentation%20(llvm.org)%5D(https://clang.llvm.org/extra/clang-tidy/#suppressing-undesired-diagnostics)">LLVM项目官网</a></p>
<p>或者查看<a
href="%5Bclang-tidy——静态代码分析框架%20·%20Clang%20Tools入门教程%20(hokein.github.io)%5D(https://hokein.github.io/clang-tools-tutorial/clang-tidy.html)">这篇博客</a></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>指向容器的迭代器如果元素被删除则无效</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E6%8C%87%E5%90%91%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E8%A2%AB%E5%88%A0%E9%99%A4%E5%88%99%E6%97%A0%E6%95%88/</url>
    <content><![CDATA[<p>如果获取了一个指向容器内元素的迭代器，但是该容器执行了对该元素的删除操作，那么这个迭代器还有效吗？根据实际代码编译运行结果来看，是无效的；容器在使用迭代器的位置删除对应元素的时候，这块地址会被释放。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tp</span>(<span class="type">int</span> _data) : <span class="built_in">data</span>(_data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> tp&amp; rhs) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> data &lt; rhs.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;tp&gt; tset;</span><br><span class="line">    <span class="function">tp <span class="title">one</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    tset.<span class="built_in">insert</span>(one);</span><br><span class="line">    <span class="function">tp <span class="title">two</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    tset.<span class="built_in">insert</span>(two);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it1 = tset.<span class="built_in">find</span>(one);</span><br><span class="line">    <span class="keyword">auto</span> it2 = tset.<span class="built_in">find</span>(two);</span><br><span class="line">    tset.<span class="built_in">erase</span>(one);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; it1-&gt;data &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; it2-&gt;data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际输出：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-17891602</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数调用发生的过程</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8F%91%E7%94%9F%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>C++的构造函数的原理，是先产生一个空对象然后再使用构造函数的语句去初始化还是直接用构造函数的初始化列表的值在内存上构建了这个对象？</p>
<p>2023/8/18 17:26:40</p>
<p>在 C++
中，构造函数的原理是直接使用构造函数的初始化列表在内存上构建对象。构造函数的初始化列表允许在对象创建时同时初始化成员变量，而不是先创建一个空对象然后再使用构造函数的语句去逐个初始化成员变量。</p>
<p>构造函数的初始化列表位于构造函数的定义中，并在构造函数体之前。通过初始化列表，可以指定成员变量的初始值或调用其他构造函数来初始化基类或成员对象。这样可以避免在构造函数体内给成员变量赋值，提高了效率并确保了对象在创建时被正确地初始化。</p>
<p>因此，C++
中的构造函数在对象创建时会直接使用初始化列表的值在内存上构建对象，而不是先产生一个空对象再进行初始化。</p>
<p>2023/8/18 17:27:28</p>
<p>那如果构造函数没有初始化列表，所有的初始化放在函数体中，是不是就等于先创建所有值都是默认值的对象在内存上，然后再运行函数体的语句去对这个默认对象做各种修改操作完成初始化？</p>
<p>2023/8/18 17:28:04</p>
<p>是的，如果构造函数没有初始化列表，而是将所有的初始化操作放在函数体中，那么对象会先被默认地创建出来，其成员变量会被设置为默认值（例如数值类型为0，指针类型为nullptr，布尔类型为false等），然后在构造函数的函数体中进行进一步的修改和初始化操作。</p>
<p>当没有显式提供初始化列表时，编译器会自动调用默认构造函数或使用成员变量的默认初始化方式来创建对象。然后，在构造函数的函数体中，可以通过赋值操作、函数调用等方式对成员变量进行具体的初始化。</p>
<p>注意，这种方式可能导致对象在创建之后被默认初始化，然后再被修改的过程，相比于使用初始化列表来直接在创建时完成初始化，效率上可能会稍低。因此，在构造函数中使用初始化列表是一种更优雅和高效的方式，尤其在成员变量较多或需要复杂初始化逻辑的情况下。</p>
<p>2023/8/18 17:28:25</p>
<p>那构造函数可以是静态函数吗？</p>
<p>2023/8/18 17:28:41</p>
<p>构造函数不能是静态函数。构造函数是用于创建对象并初始化其成员变量的特殊成员函数，它们被自动调用当创建类的实例时。静态函数（也称为类函数或类方法）是与类关联而不依赖于具体对象的函数。静态函数不需要实例化对象就可以直接通过类名调用。</p>
<p>由于构造函数的主要目的是在创建对象时进行初始化，它们必须是非静态成员函数，因为它们需要通过对象实例来访问和操作对象的成员变量和成员函数。</p>
<p>总结起来，构造函数必须是非静态函数，用于创建对象并初始化其成员变量。静态函数与类关联，不依赖于具体对象的存在。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>模板元编程示例</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Box::str() is invoked.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bin</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">anotherStrName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bin::str() is invoked.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Outer&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">checker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type, std::<span class="built_in">string</span>(Type::*)() = &amp;Type::str&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="built_in">strCheck</span>(Type*) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">strCheck</span><span class="params">(...)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> validity = <span class="built_in">strCheck</span>(<span class="built_in">static_cast</span>&lt;Outer*&gt;(<span class="number">0</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定的类型要求必须有名称为&#x27;str&#x27;且参数列表为空，返回值类型为std::string的成员函数</span></span><br><span class="line"><span class="comment">// 并且这个类型Type本身不是std::string类型，以下模板函数才能实例化成功。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type,</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_class&lt;Type&gt;::value &amp;&amp; !std::is_same&lt;Type, std::string&gt;::value, Type&gt;::type* = <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;checker&lt;Type&gt;::validity, Type&gt;::type* = <span class="literal">nullptr</span></span><br><span class="line">&gt;</span><br><span class="line">std::string <span class="built_in">str</span>(Type&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Type[!std::string], Type::str()[enable]\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    Box box;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">str</span>(box) &lt;&lt; endl;</span><br><span class="line">    Bin bin;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">str</span>(bin) &lt;&lt; endl;  <span class="comment">// 此处将无法通过编译检查，因为没有匹配的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>![[meta_template_sample_err.png]]</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>模板函数的模板定义不是函数定义</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>对于模板函数一直存在一个疑问？为什么模板函数定义要和模板函数声明放在一起而且必须是头文件中？如果把模板函数定义放在单独分开的源文件中，则必须进行显式地实例化定义，否则链接阶段会报错==undefined
reference==，这次自己从编译链接项目的翻译单元去理解这样做的含义。</p>
<h2 id="函数定义和模板定义">函数定义和模板定义</h2>
<p>首先要消除一个理解误区，函数定义和模板定义不是一回事，模板定义是用来生成函数定义的模具，模板函数声明是告诉编译器在翻译本源文件时，存在这么一个模板可以使用，用来生成那些
编译器在后续翻译过程中遇到没有显式定义的、但可以通过参数列表和返回值推断的引用的函数定义，那么告诉了编译器有这样一个模板，实际的模具在哪里呢？就是一般博客提到的在头文件声明了模板函数后，紧接着在下方写出的模板定义。所以模板定义是用来生成函数定义的。</p>
<h2 id="查看编译出的符号表">查看编译出的符号表</h2>
<p>如果模板函数的模板定义和模板声明分开在不同的文件中（模板定义在.cpp源文件中，模板声明在.h头文件中）会怎样？一般情况下编译之前，IDE并不会提示任何错误，因为IDE只需要检测到声明，就可以使用这个符号，IDE一般是提示未声明的符号而不是未定义的符号。然而编译时大概率就是会在引用了模板函数的行报未定义错误。</p>
<p>使用三个简单的文件来查看编译时到底发生了什么，分别是存放模板函数声明的头文件，存放模板函数模板定义的源文件，和一个入口源文件main.cpp</p>
<p>templatetest.h<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEMPLATE_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMPLATE_TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// templatetest.h</span></span></span><br></pre></td></tr></table></figure></p>
<p>templatetest.cpp<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatetest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> std::string&amp; a, <span class="type">const</span> std::string&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main.cpp<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatetest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mul</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;typename Type&gt;</span></span><br><span class="line"><span class="comment">// auto add(const Type&amp; a, const Type&amp; b)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return a + b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result1 = <span class="built_in">mul</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// result 的类型将根据 mul 函数的返回值类型进行推导</span></span><br><span class="line">    <span class="comment">// auto result2 = add(2, 3);</span></span><br><span class="line">    <span class="keyword">auto</span> result3 = <span class="built_in">add</span>(std::<span class="built_in">string</span>(<span class="string">&quot;a&quot;</span>), std::<span class="built_in">string</span>(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; result1 &lt;&lt; std::endl; <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; result2 &lt;&lt; std::endl;</span></span><br><span class="line">    std::cout &lt;&lt; result3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述示例文件是一个最小可工作示例（Minimum Work
Example），使用g++编译这三个文件（是的，头文件也算是源文件的一种，毕竟
#include 只是把头文件的内容复制过来），查看它们的符号表（使用objdump -t
file.cpp.o），关于符号表如何查看，可以谷歌objdump输出结果的解析，也可以参考<a
href="%5BC%20multiple%20definition%20of%20报错_cmake出现multiple%20definition%20of%20%60err_ret&#39;的错误_sightONlast的博客-CSDN博客%5D(https://blog.csdn.net/Don_tknowwhat/article/details/128487954)">我的另一篇日志</a>。</p>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">列值</th>
<th style="text-align: left;">值释义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>l</code>，<code>g</code>，<code></code>，<code>！</code></td>
<td
style="text-align: left;">内部链接性，外部连接性，都不是，同时具有外部和内部链接性</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>w</code>，<code></code></td>
<td style="text-align: left;">弱链接符号，强链接符号</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>C</code>，<code></code></td>
<td style="text-align: left;">构造函数的符号，普通符号</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>W</code>，<code></code></td>
<td
style="text-align: left;">警告⚠符号，普通符号（警告符号是什么意思？？？）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>I</code>，<code></code></td>
<td
style="text-align: left;">该符号是对另一个符号的间接引用，普通符号</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>d</code>，<code>D</code>，<code></code></td>
<td style="text-align: left;">用于调试的符号，动态符号，普通符号</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>F</code>，<code>f</code>，<code>O</code>，<code></code></td>
<td
style="text-align: left;">函数名称的符号，文件的符号，对象的符号，普通符号</td>
</tr>
</tbody>
</table>
<p>先来看 templatetest.cpp 文件经过编译后在转换为机器码之前的符号表
templatetest.cpp.o：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -t build/src/CMakeFiles/insrc.dir/templatetest.cpp.o</span></span><br><span class="line"></span><br><span class="line">build/src/CMakeFiles/insrc.dir/templatetest.cpp.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*  0000000000000000 templatetest.cpp</span><br><span class="line">0000000000000000 l    d  .text  0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data  0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss   0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .text._ZStplIcSt11char_traitsIcESaIcEENSt7__cxx1112basic_stringIT_T0_T1_EERKS8_SA_     0000000000000000 .text._ZStplIcSt11char_traitsIcESaIcEENSt7__cxx1112basic_stringIT_T0_T1_EERKS8_SA_</span><br><span class="line">0000000000000000 l    d  .gcc_except_table._ZStplIcSt11char_traitsIcESaIcEENSt7__cxx1112basic_stringIT_T0_T1_EERKS8_SA_ 0000000000000000 .gcc_except_table._ZStplIcSt11char_traitsIcESaIcEENSt7__cxx1112basic_stringIT_T0_T1_EERKS8_SA_</span><br><span class="line">0000000000000000 l    d  .debug_info    0000000000000000 .debug_info</span><br><span class="line">0000000000000000 l    d  .debug_abbrev  0000000000000000 .debug_abbrev</span><br><span class="line">0000000000000000 l    d  .debug_aranges 0000000000000000 .debug_aranges</span><br><span class="line">0000000000000000 l    d  .debug_ranges  0000000000000000 .debug_ranges</span><br><span class="line">0000000000000000 l    d  .debug_line    0000000000000000 .debug_line</span><br><span class="line">0000000000000000 l    d  .debug_str     0000000000000000 .debug_str</span><br><span class="line">0000000000000000 l    d  .data.rel.local.DW.ref.__gxx_personality_v0    0000000000000000 .data.rel.local.DW.ref.__gxx_personality_v0</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack        0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame      0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment       0000000000000000 .comment</span><br><span class="line">0000000000000000 l    d  .group 0000000000000000 .group</span><br><span class="line">0000000000000000 l    d  .group 0000000000000000 .group</span><br><span class="line">0000000000000000 g     F .text  0000000000000031 _Z3addINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEDaRKT_S8_</span><br><span class="line">0000000000000000         *UND*  0000000000000000 _GLOBAL_OFFSET_TABLE_</span><br><span class="line">0000000000000000  w    F .text._ZStplIcSt11char_traitsIcESaIcEENSt7__cxx1112basic_stringIT_T0_T1_EERKS8_SA_     0000000000000061 _ZStplIcSt11char_traitsIcESaIcEENSt7__cxx1112basic_stringIT_T0_T1_EERKS8_SA_</span><br><span class="line">0000000000000000  w    O .data.rel.local.DW.ref.__gxx_personality_v0    0000000000000008 .hidden DW.ref.__gxx_personality_v0</span><br><span class="line">0000000000000000         *UND*  0000000000000000 _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ERKS4_</span><br><span class="line">0000000000000000         *UND*  0000000000000000 _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE6appendERKS4_</span><br><span class="line">0000000000000000         *UND*  0000000000000000 _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev</span><br><span class="line">0000000000000000         *UND*  0000000000000000 _Unwind_Resume</span><br><span class="line">0000000000000000         *UND*  0000000000000000 __gxx_personality_v0</span><br></pre></td></tr></table></figure>
因为开启了调试（g++编译时带-g参数的话），所以很多符号的属性中有
<strong>d</strong> 这个属性，代表debug调试符号，我们主要应该关注的是
.text
段的符号，至于.bss，.data这些数据段无需关心。关键的一行符号是这行：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000000000000000 g     F .text  0000000000000031 _Z3addINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEDaRKT_S8_</span><br></pre></td></tr></table></figure> 可以看到编译器重新命名的 <strong>add</strong>
函数名称是_Z3==add==INSt7_<em>cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEDaRKT_S8</em>，显然
<strong>basic_string</strong> 代指 std::string，也就是说，我们在
<strong>templatetest.cpp</strong>
中通过显式函数模板实例化的函数定义代码已经的符号已经在符号表中出现，并且具有属性
<strong>g</strong>，意味着这个符号在链接阶段是具有外部可见性的（global），那么
<strong>main.cpp</strong>
在编译后存在未定义符号时尝试去其他已被编译器翻译的单元（.c/.cpp源文件）的符号表查找导出符号时，这个符号：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_Z3addINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEDaRKT_S8_</span><br></pre></td></tr></table></figure> 是可以被发现并链接的，这个符号实际指向的内容在 .text
段的偏移量为<strong>0x0000000000000031</strong>
字节，编译器会去这里把被实例化的函数定义代码用于最终编译目标 main
的机器码。</p>
<p>注意：<br />
&gt;
#include预处理操作对于每个源文件（翻译单元）是独立的，就算源文件a和源文件b一起作为源文件列表参与编译同一个目标，它们仍然需要各自使用一次#include来包含所需的声明，因为每个源文件的翻译过程是独立进行的，并不会被其他源文件的翻译过程所影响。</p>
<h2 id="如果不显式实例化">如果不显式实例化</h2>
<p>接下来把 <strong>templatetest.cpp</strong>
中显式实例化的模板函数注释掉：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatetest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// template &lt;&gt;</span></span><br><span class="line"><span class="comment">// auto add(const std::string&amp; a, const std::string&amp; b)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return a + b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure> 然后重新编译，我发现 <code>auto</code>
关键字还会导致一个问题：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 68%] Building CXX object app/CMakeFiles/auto.dir/auto.cpp.o</span><br><span class="line">/home/guest/workspace/temp/app/auto.cpp: In function ‘int main()’:</span><br><span class="line">/home/guest/workspace/temp/app/auto.cpp:19:58: error: use of ‘auto add(const Type&amp;, const Type&amp;) [with Type = std::__cxx11::basic_string&lt;char&gt;]’ before deduction of ‘auto’</span><br><span class="line">   19 |     auto result3 = add(std::string(&quot;a&quot;), std::string(&quot;b&quot;));</span><br><span class="line">      |                                                          ^</span><br><span class="line">make[2]: *** [app/CMakeFiles/auto.dir/build.make:76: app/CMakeFiles/auto.dir/auto.cpp.o] Error 1</span><br><span class="line">make[2]: Leaving directory &#x27;/home/guest/workspace/temp/build&#x27;</span><br><span class="line">make[1]: *** [CMakeFiles/Makefile2:204: app/CMakeFiles/auto.dir/all] Error 2</span><br><span class="line">make[1]: Leaving directory &#x27;/home/guest/workspace/temp/build&#x27;</span><br><span class="line">make: *** [Makefile:136: all] Error 2</span><br><span class="line">make: Leaving directory &#x27;/home/guest/workspace/temp/build&#x27;</span><br></pre></td></tr></table></figure>
因为此时只有模板函数的声明，并且声明的返回值我们使用了auto希望在编译阶段自动推导，然而由于
<strong>templatetest.cpp</strong>
中显式实例化模板被注释，此时所有源文件并未提供用于生成兼容调用的实例化函数定义的模板定义，因此编译器只知道这行代码是：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> result3 = <span class="keyword">auto</span> <span class="built_in">add</span>(<span class="type">const</span> std::string&amp;, <span class="type">const</span> std::string&amp;)</span><br></pre></td></tr></table></figure> 而 <strong>auto</strong>
自动类型推导是需要右值的类型的，因此我们不能使用auto去推导auto。此时我们为了实验，先将模板函数声明修改为不使用auto推断返回值类型：</p>
<p>templatetest.h<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEMPLATE_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMPLATE_TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">Type <span class="title">add</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// templatetest.h</span></span></span><br></pre></td></tr></table></figure> 此时再执行编译链接，报错在源文件 <strong>main.cpp</strong>
中，模板函数的调用没有找到对应兼容的实例化函数定义：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 68%] Building CXX object app/CMakeFiles/auto.dir/auto.cpp.o</span><br><span class="line">[ 75%] Linking CXX executable /home/guest/workspace/temp/bin/Debug/SHARED/auto</span><br><span class="line">/usr/bin/ld: CMakeFiles/auto.dir/auto.cpp.o: in function `main&#x27;:</span><br><span class="line">/home/fredom/workspace/temp/app/auto.cpp:19: undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; add&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure> 注意，此时我们的 <strong>templatetest.cpp</strong>
源文件中是已经为头文件中的函数模板准备了模板定义的：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatetest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template &lt;&gt;</span></span><br><span class="line"><span class="comment">// auto add(const std::string&amp; a, const std::string&amp; b)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return a + b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
只是显式实例化定义被注释了，按道理来说不应该能使用该模板定义为
<strong>main.cpp</strong>
源文件的编译中未定义符号提供导出符号查找来链接吗？</p>
<p>看一下这次编译后，<strong>templatetest.cpp.o</strong> 符号表：<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -t ./build/src/CMakeFiles/insrc.dir/templatetest.cpp.o</span></span><br><span class="line"></span><br><span class="line">./build/src/CMakeFiles/insrc.dir/templatetest.cpp.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*  0000000000000000 templatetest.cpp</span><br><span class="line">0000000000000000 l    d  .text  0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data  0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss   0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .debug_info    0000000000000000 .debug_info</span><br><span class="line">0000000000000000 l    d  .debug_abbrev  0000000000000000 .debug_abbrev</span><br><span class="line">0000000000000000 l    d  .debug_aranges 0000000000000000 .debug_aranges</span><br><span class="line">0000000000000000 l    d  .debug_line    0000000000000000 .debug_line</span><br><span class="line">0000000000000000 l    d  .debug_str     0000000000000000 .debug_str</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack        0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .comment       0000000000000000 .comment</span><br></pre></td></tr></table></figure>
相比于第一次编译出来的符号表，干净了很多。但是太干净了，在这张符号表上没有任何具有属性g的可导出链接符号。也就是说，该源文件由于没有显式地使用模板函数，因此就算提供了模板定义，编译器也不会进行任何通过函数模板来生成函数定义代码的生成操作，自然最终的符号表就没有实例化的函数定义的符号了。而模板定义本身是用来生成其他各种版本的函数定义的，并不是某种具体的实现，其自身并不会生成可供链接的符号，只是一个模具，就算尝试转译到目标可执行文件的机器码，也没有对应的指令可以转译，因为缺少参数的类型（比如int或者double，但是模板给了一个typename
Type，编译器不知道Type是什么类型）。</p>
<h2 id="总结">总结</h2>
<p>这就是为什么一般情况下推荐大家在使用模板函数的时候，把模板的声明和定义放在一起（注意，是模板的定义，不要把模板定义和函数定义混淆了），因为编译的时候，每个源文件都是单独进行的（但是使用<code>make -j&lt;n&gt;</code>确实是并行编译，我并不了解并行编译目标文件时依赖关系如何解决），因此把模板定义放到单独的源文件中由于编译时模板定义没有生成导出符号，其他使用了模板函数的源文件只知道声明而找不到模板定义来生成合适的函数定义。</p>
<p>如果真的需要分开存放，比如为了可读性之类的需求，请在使用模板函数的源文件中进行显式模板实例化，或者把显式模板实例化函数定义和模板定义一起放在同一个源文件中，这样至少能提供导出符号供其他源文件链接，但是这样做似乎已经失去了模板函数的本意了，因为每个不同参数列表版本函数的调用都要用户手动实现其显式实例化函数定义，这和不使用模板函数而每个版本都实现一个重载好像也没有太大区别了。</p>
<blockquote>
<p>最后，记得显式模板实例化时，在函数前添加空模板 <strong>template
&lt;&gt;</strong>
，显式地告诉编译器，这是一个显式模板实例化，而不是一个普通的函数定义。因为我们声明的是一个模板，而不是函数，不要使用普通函数定义去匹配模板函数调用时实例化的函数定义！</p>
</blockquote>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>正确使用weak_ptr访问成员</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8weak_ptr%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<figure class="highlight plaintext"><figcaption><span>reference type 'std::weak_ptr<A>' is not a pointer; did you mean to use '.'? ``` 这是什么错误？weak_ptr居然不是指针吗？</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ChatGPT  </span><br><span class="line"></span><br><span class="line">这个错误消息表示编译器期望一个指针类型，但遇到了 `std::weak_ptr&lt;A&gt;` 类型。错误消息中的 &quot;did you mean to use &#x27;.&#x27;?&quot; 是编译器给出的建议，它提示您可能是使用了 `-&gt;` 操作符来访问 `std::weak_ptr` 的成员，而应该使用 `.` 操作符。  </span><br><span class="line"></span><br><span class="line">`std::weak_ptr` 不是传统意义上的指针，而是一个模板类，用于表示非拥有（non-owning）的对象引用。由于 `std::weak_ptr` 不是原始指针类型，您不能直接用 `-&gt;` 来访问其指向的对象的成员。相反，您需要先将 `std::weak_ptr` 提升（lock）成一个 `std::shared_ptr`，然后再用 `-&gt;` 访问指向的对象。  </span><br><span class="line"></span><br><span class="line">下面是一个例子，展示了如何正确使用 `std::weak_ptr`：  </span><br><span class="line">```cpp</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    void foo() &#123; std::cout &lt;&lt; &quot;A::foo\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; sharedPtr = std::make_shared&lt;A&gt;();</span><br><span class="line">    std::weak_ptr&lt;A&gt; weakPtr = sharedPtr;</span><br><span class="line"></span><br><span class="line">    // 错误的用法：weakPtr 不是一个原始指针，不能使用 -&gt; 操作符</span><br><span class="line">    // weakPtr-&gt;foo();</span><br><span class="line"></span><br><span class="line">    // 正确的用法：首先提升 weakPtr 到一个 shared_ptr</span><br><span class="line">    if (auto lockedPtr = weakPtr.lock()) &#123;</span><br><span class="line">        lockedPtr-&gt;foo();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Object has been destroyed\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用 <code>weakPtr.lock()</code> 将
<code>std::weak_ptr</code> 提升到 <code>std::shared_ptr</code>。如果
<code>weakPtr</code>
还有效（即指向的对象还未被销毁），<code>lock()</code> 会返回一个有效的
<code>std::shared_ptr</code>，然后我们就可以用 <code>-&gt;</code>
操作符来访问其成员函数了。如果 <code>weakPtr</code>
无效（即指向的对象已经被销毁），<code>lock()</code> 会返回一个空的
<code>std::shared_ptr</code>。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>生成随机数</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<p>使用 C++11 的特性来生成随机数是更好的选择，虽然也可以使用来自 C 的
<code>rand()/srand()</code> 来生成随机数，但是 C++11
提供的新随机数生成方法明显具有更小的伪随机特性。</p>
<h3 id="传统生成随机数方法">传统生成随机数方法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>)); </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = (<span class="built_in">rand</span>()%<span class="number">6</span>)+<span class="number">1</span>; </span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新式随机数生成方法">新式随机数生成方法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::random_device dev;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(dev())</span></span>;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;std::mt19937::result_type&gt; <span class="title">dist6</span><span class="params">(<span class="number">1</span>,<span class="number">6</span>)</span></span>; <span class="comment">// distribution in range [1, 6]</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">dist6</span>(rng) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于为什么用 C++11 的新随机数生成方法更好，可以参考 GPT
的回答：<br />
The code you provided makes use of the modern C++ random number
generation facilities. The difference between this and simply using
<code>rand()</code> from the C standard library is in precision,
predictability, and repeatability.</p>
<ol type="1">
<li><p><strong>Quality of Randomness</strong>: The traditional
<code>rand()</code> function and its seeding counterpart
<code>srand()</code> are often implemented using Linear Congruential
Generators (LCGs). LCGs are known for their periodicity and the fact
that they can produce sequences of numbers with easily discernible
patterns over time. The Mersenne Twister 19937 generator
(<code>std::mt19937</code>), on the other hand, is designed to have a
much longer period and produces numbers that are more uniformly
distributed.</p></li>
<li><p><strong>Seeding</strong>: The <code>std::random_device</code> is
a way to produce truly random numbers, typically sourced from hardware
randomness or some other entropy source. This makes it suitable for
seeding other random number generators like <code>std::mt19937</code>.
On the other hand, many beginners seed <code>rand()</code> with the
current time (<code>srand(time(NULL))</code>), which can be problematic,
especially when generating random numbers in quick succession (as the
seed doesn't change quickly enough).</p></li>
<li><p><strong>Distribution</strong>: The C++ Standard Library provides
a way to get numbers from various distributions easily – uniform,
normal, binomial, etc. In your code, you're using a uniform
distribution. This allows you to specify exactly how you want your
random numbers to behave. With <code>rand()</code>, you would often have
to use modulo arithmetic or other tricks to get numbers in a specific
range or distribution, which can introduce biases.</p></li>
<li><p><strong>Portability</strong>: The behavior of <code>rand()</code>
is implementation-defined, which means that the quality of randomness
and its characteristics can vary between different compilers and
platforms. The modern C++ random facilities, on the other hand, provide
more consistent behavior across platforms.</p></li>
<li><p><strong>Repeatability</strong>: For debugging purposes or
specific applications, you might want to produce the same sequence of
random numbers multiple times (for example, during testing). With
<code>std::mt19937</code> and other generators, you can seed the
generator with a known value to reproduce a sequence. This is also true
for <code>rand()</code> and <code>srand()</code>, but the modern C++
approach is more explicit and versatile.</p></li>
</ol>
<p>For these reasons, it's often recommended to use the modern C++
random facilities for new code, rather than relying on
<code>rand()</code>.</p>
<p>最后给出随机数生成的模板函数：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TOOLS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOOLS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">Type <span class="title">getRandom</span><span class="params">(Type min, Type max)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::random_device dev;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::mt19937 <span class="title">rng</span><span class="params">(dev())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;Type&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::uniform_int_distribution&lt;Type&gt; <span class="title">dist</span><span class="params">(min, max)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dist</span>(rng);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_floating_point_v&lt;Type&gt;) &#123;</span><br><span class="line">        std::uniform_real_distribution&lt;Type&gt; <span class="built_in">dist</span>(min, max);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dist</span>(rng);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This function doesn&#x27;t handle non-arithmetic types</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Unsupported type passed to getRandom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的计时器类</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8%E7%B1%BB/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//计时器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string title;</span><br><span class="line">    std::chrono::high_resolution_clock::time_point m_start, m_stop;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>(<span class="type">const</span> std::string&amp; title): <span class="built_in">title</span>(title)</span><br><span class="line">    &#123;</span><br><span class="line">        m_start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_stop = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        std::chrono::milliseconds ms = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(m_stop - m_start);</span><br><span class="line">        std::cout &lt;&lt; title &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (ms.<span class="built_in">count</span>()) * <span class="number">0.001</span> &lt;&lt; <span class="string">&quot;s\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类析构函数可以是内联的吗？</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E7%9A%84%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>答案是可以的。</p>
<p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</p>
<p>理由如下：内联是在发生在编译期间，编译器会自主选择内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline
virtual唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   	cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   	cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，</span></span><br><span class="line">   <span class="comment">// 编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">   Base b;</span><br><span class="line">   b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，</span></span><br><span class="line">   <span class="comment">// 所以不能为内联。  </span></span><br><span class="line">   Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">   ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），</span></span><br><span class="line">   <span class="comment">//所以 delete 时，会先调用派生类（Derived）析构函数，</span></span><br><span class="line">   <span class="comment">//再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">   <span class="keyword">delete</span> ptr;</span><br><span class="line">   ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>纯虚类</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E7%BA%AF%E8%99%9A%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>首先：强调一个概念</strong></p>
<p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p>
<p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现。</p>
<p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
<h3 id="简介">1、简介</h3>
<p>假设我们有下面的类层次：</p>
<h2 id="实例">实例</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">foo</span>();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓"推迟联编"或者"动态联编"上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为"虚"函数。</p>
<p><strong>虚函数只能借助于指针或者引用来达到多态的效果。</strong></p>
<hr />
<h2 id="c纯虚函数">C++纯虚函数</h2>
<p><strong>一、定义</strong></p>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:</p>
<p>virtual void funtion1()=0</p>
<p><strong>二、引入原因</strong></p>
<p>1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。<br />
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p>
<p>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual
ReturnType Function()=
0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。</p>
<p>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p>
<p><strong>纯虚函数最显著的特征是</strong>：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p>
<p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>
<p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。所以类纯虚函数的声明就是在告诉子类的设计者，"你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它"。</p>
<hr />
<h2 id="抽象类的介绍">抽象类的介绍</h2>
<p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p>
<p><strong>（1）抽象类的定义：</strong> 称带有纯虚函数的类为抽象类。</p>
<p><strong>（2）抽象类的作用：</strong> 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
<p><strong>（3）使用抽象类时注意：</strong></p>
<ul>
<li>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。<br />
抽象类是不能定义对象的。</li>
</ul>
<hr />
<h2 id="总结">总结：</h2>
<ul>
<li><p>1、纯虚函数声明如下： virtual void
funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</p></li>
<li><p>2、虚函数声明如下：virtual ReturnType
FunctionName(Parameter) 虚函数必须实现，如果不实现，编译器将报错，错误提示为：</p>
<p>error LNK****: unresolved external symbol "public: virtual void
__thiscall ClassName::virtualFunctionName(void)"</p></li>
<li><p>3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。</p></li>
<li><p>4、实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。</p></li>
<li><p>5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。</p></li>
<li><p>6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</p></li>
<li><p>7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</p></li>
<li><p>8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。</p></li>
</ul>
<p>有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。</p>
<p>定义纯虚函数就是为了让基类不可实例化化，因为实例化这样的抽象数据结构本身并没有意义，或者给出实现也没有意义。</p>
<p>实际上我个人认为纯虚函数的引入，是出于两个目的：</p>
<ul>
<li>1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。<br />
</li>
<li>2、为了效率，不是程序执行的效率，而是为了编码的效率。</li>
</ul>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器对inline内联修饰函数的处理</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9inline%E5%86%85%E8%81%94%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="处理步骤">处理步骤</h3>
<ul>
<li>将 inline 函数体复制到 inline 函数调用点处；<br />
</li>
<li>为所用 inline 函数中的局部变量分配内存空间；<br />
</li>
<li>将 inline
函数的的输入参数和返回值映射到调用方法的局部变量空间中；<br />
</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline
函数代码块末尾的分支（使用 GOTO）。<br />
### 优点<br />
</li>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。<br />
</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。<br />
</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。<br />
</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。<br />
</li>
<li>inline
函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像
non-inline 可以直接链接。<br />
解释一下这一句话：很容易被字面意思的链接带偏。这个链接不是编译链接。<br />
上面说的是如果一个函数位于程序库中且是非内联的，那么一旦它有修改，客户端程序只需要链接程序库就行，客户端程序不用重新编译了。客户端程序相当于main函数；程序库相当于自己写的库函数(include进来的)<br />
</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ul>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义排序时什么时候需要用decltype</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E6%97%B6%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E7%94%A8decltype/</url>
    <content><![CDATA[<p>C++的sort不可以用decltype和lambda函数自定义排序规则吗？</p>
<p>ChatGPT</p>
<p>在 C++ 中，使用 <code>&lt;algorithm&gt;</code> 头文件中的
<code>sort</code> 函数，你确实可以通过 <code>lambda</code>
函数来自定义排序规则。<code>decltype</code> 也可以用于定义 lambda
函数的类型。下面是一个使用 <code>decltype</code> 和 <code>lambda</code>
函数来自定义排序规则的例子：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> comp = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), comp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在这个例子中，<code>comp</code> 是一个 lambda
函数，用于定义排序规则，这里是降序排序。然后，这个 lambda 函数被传递给
<code>std::sort</code> 函数作为自定义排序规则。</p>
<p>你也可以使用 <code>decltype</code> 获取 <code>comp</code>
的类型，但这通常不是必需的，因为编译器可以自动推导 lambda
函数的类型：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(comp) anotherComp = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;; <span class="comment">// 升序排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), anotherComp);</span><br></pre></td></tr></table></figure> 这里，<code>decltype(comp)</code> 用于声明和
<code>comp</code> 具有相同类型的另一个 lambda 函数
<code>anotherComp</code>，并用它对向量 <code>v</code> 进行升序排序。</p>
<p>我的疑问在于，为什么sort可以直接用lambda函数对象，而set和map声明的时候使用模板类必须使用decltype对lambda对象作用</p>
<p>在 C++ 中，<code>std::sort</code> 函数可以直接接受 lambda
函数作为其比较函数，因为它是一个函数参数，编译器会自动推导其类型。</p>
<p>然而，对于 <code>std::set</code> 和 <code>std::map</code>
这样的容器，比较函数是作为模板参数传递的。模板参数在编译时需要确定类型，而
lambda
函数是匿名的，没有直接的类型名称，所以不能直接用作模板参数。这就是为什么需要使用
<code>decltype</code> 来推导 lambda
函数的类型，然后将这个类型用作模板参数。</p>
<p>下面是一个使用 <code>decltype</code> 和 lambda 函数为
<code>std::set</code> 自定义排序规则的例子：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> comp = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::set&lt;<span class="type">int</span>, <span class="title">decltype</span><span class="params">(comp)</span>&gt; <span class="title">s</span><span class="params">(comp)</span></span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : s) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在这个例子中，<code>decltype(comp)</code> 用于推导 lambda
函数 <code>comp</code> 的类型，然后这个类型被用作 <code>std::set</code>
的模板参数，以定义排序规则为降序。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>花括号用于成员变量值的缺省初始化</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E8%8A%B1%E6%8B%AC%E5%8F%B7%E7%94%A8%E4%BA%8E%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%80%BC%E7%9A%84%E7%BC%BA%E7%9C%81%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>成员变量能使用花括号初始化的话，这个初始值有什么用？比如当用户编写的构造函数忘记初始化这个成员变量了，那就默认花括号里的值？</p>
<p>2023/8/6 13:25:53</p>
<p>是的，当成员变量使用花括号初始化时，它会作为默认值，并在以下情况下起作用：</p>
<ol type="1">
<li>如果用户没有在构造函数中显式初始化该成员变量，那么它将会被默认初始化为花括号中指定的值。</li>
</ol>
<p>例如，假设有以下类定义：</p>
<p><code>class Example &#123; public:     int value&#123;42&#125;; &#125;;</code></p>
<p>如果用户没有提供构造函数并创建一个<code>Example</code>对象，<code>value</code>成员变量将自动初始化为<code>42</code>。</p>
<ol start="2" type="1">
<li>如果用户提供了构造函数，但没有在成员初始化列表中对该成员变量进行显式初始化，并且也没有在构造函数体内对其赋值，那么它将被默认初始化为花括号中指定的值。</li>
</ol>
<p>例如，假设有以下构造函数：</p>
<p><code>Example() &#123;&#125;</code></p>
<p>在这种情况下，由于没有在构造函数中对<code>value</code>进行初始化或赋值操作，<code>value</code>将被默认初始化为<code>42</code>。</p>
<p>注意，如果在构造函数的成员初始化列表中显式初始化了成员变量，那么花括号中指定的值将被忽略。</p>
<p>总而言之，通过在成员变量声明时使用花括号初始化，可以为成员变量提供一个默认值，以防止用户忘记初始化该成员变量或提供了一个无效的初始值。这样可以确保成员变量始终具有一个合理的默认值。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>通过虚函数表访问、调用虚函数</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/C++/%E9%80%9A%E8%BF%87%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E8%AE%BF%E9%97%AE%E3%80%81%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>为了完成说明，以下是样例代码：</p>
<p>头文件内容如下：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DUMMY_CLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUMMY_CLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">data</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;default constructor of A-&quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = obj.data;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;copy constructor of A-&quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;destructor of A-&quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s vfunc1 print &quot;</span> &lt;&lt; <span class="string">&quot;123&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc2</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s vfunc2 print &quot;</span> &lt;&lt; <span class="string">&quot;456&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;assign constructor of A&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data = obj.data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x) : <span class="built_in">A</span>(x), <span class="built_in">data</span>(x)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;default constructor of B-&quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; obj) : <span class="built_in">A</span>(obj.data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;copy constructor of B-&quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data = obj.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;destructor of B-&quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B&#x27;s vfunc1 print &quot;</span> &lt;&lt; <span class="string">&quot;abc&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc2</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B&#x27;s vfunc2 print &quot;</span> &lt;&lt; <span class="string">&quot;def&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    B&amp; <span class="keyword">operator</span>=(<span class="type">const</span> B&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;assign constructor of B&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data = obj.data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>测试程序如下：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dummy_class.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> llong;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    A c = <span class="built_in">B</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.cfunc1(): &quot;</span>; a.<span class="built_in">cfunc1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b.cfunc1(): &quot;</span>; b.<span class="built_in">cfunc1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.cfunc1(): &quot;</span>; c.<span class="built_in">cfunc1</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(a): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">sizeof</span>(&amp;a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(b): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">sizeof</span>(&amp;b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;b: &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;a.data &quot;</span> &lt;&lt; &amp;a.data &lt;&lt; <span class="string">&quot;, offset: &quot;</span> &lt;&lt; ((<span class="type">int</span>*)&amp;a.data - (<span class="type">int</span>*)&amp;a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;b.data &quot;</span> &lt;&lt; &amp;b.data &lt;&lt; <span class="string">&quot;, offset: &quot;</span> &lt;&lt; ((<span class="type">int</span>*)&amp;b.data - (<span class="type">int</span>*)&amp;b) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    A* pa = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">11</span>);</span><br><span class="line">    B* pb = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">22</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp; new A(): &quot;</span> &lt;&lt; pa &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;(*pa) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp; new B(): &quot;</span> &lt;&lt; pb &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;(*pb) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*funcptr)(<span class="type">void</span>) = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    llong* objvp = (llong*)&amp;a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start address of a: &quot;</span> &lt;&lt; objvp &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dereference value = virtual table address: &quot;</span> &lt;&lt; std::hex &lt;&lt; *objvp &lt;&lt; std::dec &lt;&lt; endl;</span><br><span class="line">    objvp = (llong*)(*objvp);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;objvp + 1: &quot;</span> &lt;&lt; objvp + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 一个指针的大小现在是8字节，那么虚函数表中由于存放的都是函数指针</span></span><br><span class="line">    <span class="comment">// 则一次偏移需要偏移8字节长度，普通的int指针运算只会偏移4字节，因</span></span><br><span class="line">    <span class="comment">// 此需要转换为long int型指针</span></span><br><span class="line">    <span class="comment">// funcptr = (void (*)(void))(*(objvp + 0));</span></span><br><span class="line">    <span class="comment">// funcptr(); </span></span><br><span class="line">    <span class="comment">// funcptr = (void (*)(void))(*(objvp + 1));</span></span><br><span class="line">    <span class="comment">// funcptr(); </span></span><br><span class="line">    funcptr = (<span class="built_in">void</span> (*)(<span class="type">void</span>))(*(objvp + <span class="number">2</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;objvp + 2: &quot;</span>; <span class="built_in">funcptr</span>();</span><br><span class="line">    funcptr = (<span class="built_in">void</span> (*)(<span class="type">void</span>))(*(objvp + <span class="number">3</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;objvp + 3: &quot;</span>; <span class="built_in">funcptr</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    A* morphsim = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">33</span>);</span><br><span class="line">    llong* morvp = (llong*)(&amp;(*morphsim));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start address of morphism: &quot;</span> &lt;&lt; morvp &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dereference value = virtual table address: &quot;</span> &lt;&lt; std::hex &lt;&lt; *morvp &lt;&lt; std::dec &lt;&lt; endl;</span><br><span class="line">    morvp = (llong*)(*morvp);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;morvp + 1: &quot;</span> &lt;&lt; morvp + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    funcptr = (<span class="built_in">void</span> (*)(<span class="type">void</span>))(*(morvp + <span class="number">2</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;morvp + 2: &quot;</span>; <span class="built_in">funcptr</span>();</span><br><span class="line">    funcptr = (<span class="built_in">void</span> (*)(<span class="type">void</span>))(*(morvp + <span class="number">3</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;morvp + 3: &quot;</span>; <span class="built_in">funcptr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.cfunc1(): A&#x27;s cfunc1 print aaa</span><br><span class="line">b.cfunc1(): B&#x27;s cfunc1 print bbb</span><br><span class="line">c.cfunc1(): A&#x27;s cfunc1 print aaa</span><br><span class="line"></span><br><span class="line">sizeof(a): 16 8</span><br><span class="line">sizeof(b): 16 8</span><br><span class="line">&amp;a: 0x61fdc0</span><br><span class="line">&amp;b: 0x61fdb0</span><br><span class="line">&amp;a.data 0x61fdc8, offset: 2</span><br><span class="line">&amp;b.data 0x61fdbc, offset: 3</span><br><span class="line">&amp; new A(): 0x6326b0 0x6326b0</span><br><span class="line">&amp; new B(): 0x6326f0 0x6326f0</span><br><span class="line"></span><br><span class="line">start address of a: 0x61fdc0</span><br><span class="line">dereference value = virtual table address: 4056c0</span><br><span class="line">objvp + 1: 0x4056c8</span><br><span class="line">objvp + 2: A&#x27;s vfunc1 print 123</span><br><span class="line">objvp + 3: A&#x27;s vfunc2 print 456</span><br><span class="line"></span><br><span class="line">start address of morphism: 0x6326b0</span><br><span class="line">dereference value = virtual table address: 4056f0</span><br><span class="line">morvp + 1: 0x4056f8</span><br><span class="line">morvp + 2: B&#x27;s vfunc1 print abc</span><br><span class="line">morvp + 3: B&#x27;s vfunc2 print def</span><br></pre></td></tr></table></figure></p>
<p>从中可以观察到的几个知识点：<br />
-
静态时期创建的对象在栈区上创建，所以地址由高到低（参考a和b的声明顺序以及他它的地址）<br />
-
动态时期创建的对象在堆区上创建，所以地址由低到高（参考申请的a和b的地址）<br />
-
存在virtual关键字声明虚函数的类型，其对象的内容中，首地址存放的是一个指向虚函数表vtable的指针，指针长度与架构的字长有关（我是64位机器，所以指针长8字节）<br />
-
若析构函数声明为了虚函数，则虚表第一项第二项都是析构函数指针（为什么？），后续是按声明顺序存放的其他虚函数指针<br />
-
基类指针指向派生类对象，可以通过指针访问到派生类的虚函数表，可以算是危险漏洞。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用VScode作为开发环境</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/CSharp/%E4%BD%BF%E7%94%A8VScode%E4%BD%9C%E4%B8%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>一般来说，C#
的项目开发会使用VisualStudio作为开发环境，但是平时使用其他语言的用户也许大部分时间使用的是VScode作为代码编辑器。这里简单记录一下使用VScode作为C#
的开发环境的准备工作</p>
<h3 id="下载.net运行时环境">1. 下载.NET运行时环境</h3>
<p>传统的高级语言以C/C++作为代表，是相对于汇编语言和机器码而言的，随着日益增长的业务开发需求，C/C++等语言作为开发操作系统的高级语言似乎又显得稍微有些靠近底层了，这里的底层指的是操作系统而不再是各个硬件平台了。</p>
<p>业务高级语言以 Golang/Java/C#
作为代表，它们通常能更快速地开发出互联网业务语言，但同时也能满足很多基础系统的开发，只不过没有
C/C++
面向的系统那么基础罢了。这些语言为了做到跨平台的体验，会先针对各个平台做适配，然后只要求用户撰写代码而无需关心跨平台部署的问题，Golang的做法是为每个平台开发不同的Golang版本，Java的做法是为每个平台开发适配的虚拟机，让虚拟机来实时的解释字节码到机器码（这个过程相当于拆分了编译过程的前端和后端，前端在各个不同的平台完成，后端在特定的平台完成）。C#
由于基本是针对 Windows 平台的，所以基本没有对其他平台做适配（不过由于
Java 的势头，微软也开始不限制 C# 的平台了，现在 .NetFramework
也可以在其他平台安装了）。C# 需要 .NetFramework
提供运行时所需的库以及相关的包，这就像 C/C++
开发需要先设置好头文件和标准库文件的位置一样，Java也需要先提前下载好JDK。</p>
<p>在<a
href="https://dotnet.microsoft.com/zh-cn/download">.NetFramework官网下载页面</a>下载.NetFramework，下载后是一个
exe 二进制可执行文件，运行直接安装 .NetFramework
到系统盘（官方似乎没有提供安装到其他位置的选择，这点感觉有点不友好，因为这会污染我的系统文件）<br />
![[Pasted image 20230905203124.png]]</p>
<h3 id="配置vscode以调试-c-程序">2. 配置VScode以调试 C# 程序</h3>
<p>![[Pasted image 20230905203345.png]]<br />
安装如图所示的插件包 <strong>C# Dev Kit</strong>
来自动安装所包括的三个插件，这三个插件提供了 C#
编写程序时的语法高亮以及一组相关的 .NetFramework 命令。</p>
<p>.NetFramework 一般还是被 VisualStudio
所调用形成自动化项目生成的，但是 VScode
插件也能做到这些功能，因此我不想使用 VS 这个重型IDE。</p>
<p>在命令行先检测 .NetFramework 是否已经正确安装，使用如下命令检测
.NetFramwork 的版本：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotnet --version</span><br></pre></td></tr></table></figure> ![[Pasted image 20230905204510.png]]</p>
<p>使用 <code>dotnet new</code> 创建 C# 应用，.NetFramework
包括了控制台应用，Web应用，2D/3D 图形应用等项目模板。这里，我们使用
<code>dotnet new console</code> 来创建控制台应用（使用
<code>dotnet new list</code> 来查看可用的项目模板）。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\fredom&gt;dotnet new list</span><br><span class="line">这些模板已匹配你的输入:</span><br><span class="line"></span><br><span class="line">模板名                  短名称               语言        标记</span><br><span class="line">----------------------  -------------------  ----------  --------------------------------</span><br><span class="line">ASP.NET Core gRPC 服务  grpc                 [C#]        Web/gRPC</span><br><span class="line">ASP.NET Core Web API    webapi               [C#],F#     Web/WebAPI</span><br><span class="line">ASP.NET Core Web 应用   webapp,razor         [C#]        Web/MVC/Razor Pages</span><br><span class="line">ASP.NET Core Web 应...  mvc                  [C#],F#     Web/MVC</span><br><span class="line">ASP.NET Core 与 Ang...  angular              [C#]        Web/MVC/SPA</span><br><span class="line">ASP.NET Core 与 Rea...  react                [C#]        Web/MVC/SPA</span><br><span class="line">ASP.NET Core 空         web                  [C#],F#     Web/Empty</span><br><span class="line">Blazor Server 应用      blazorserver         [C#]        Web/Blazor</span><br><span class="line">Blazor Server 应用空    blazorserver-empty   [C#]        Web/Blazor/Empty</span><br><span class="line">Blazor WebAssembly ...  blazorwasm           [C#]        Web/Blazor/WebAssembly/PWA</span><br><span class="line">Blazor WebAssembly ...  blazorwasm-empty     [C#]        Web/Blazor/WebAssembly/PWA/Empty</span><br><span class="line">dotnet gitignore 文件   gitignore                        Config</span><br><span class="line">Dotnet 本地工具清单...  tool-manifest                    Config</span><br><span class="line">EditorConfig 文件       editorconfig                     Config</span><br><span class="line">global.json file        globaljson                       Config</span><br><span class="line">MSBuild Directory.B...  buildprops                       MSBuild/props</span><br><span class="line">MSBuild Directory.B...  buildtargets                     MSBuild/props</span><br><span class="line">MSTest Test Project     mstest               [C#],F#,VB  Test/MSTest</span><br><span class="line">MVC ViewImports         viewimports          [C#]        Web/ASP.NET</span><br><span class="line">MVC ViewStart           viewstart            [C#]        Web/ASP.NET</span><br><span class="line">NuGet 配置              nugetconfig                      Config</span><br><span class="line">NUnit 3 Test Item       nunit-test           [C#],F#,VB  Test/NUnit</span><br><span class="line">NUnit 3 Test Project    nunit                [C#],F#,VB  Test/NUnit</span><br><span class="line">Razor 类库              razorclasslib        [C#]        Web/Razor/Library</span><br><span class="line">Razor 组件              razorcomponent       [C#]        Web/ASP.NET</span><br><span class="line">Razor 页面              page                 [C#]        Web/ASP.NET</span><br><span class="line">Web 配置                webconfig                        Config</span><br><span class="line">Windows 窗体应用        winforms             [C#],VB     Common/WinForms</span><br><span class="line">Windows 窗体控件库      winformscontrollib   [C#],VB     Common/WinForms</span><br><span class="line">Windows 窗体类库        winformslib          [C#],VB     Common/WinForms</span><br><span class="line">WPF 应用程序            wpf                  [C#],VB     Common/WPF</span><br><span class="line">WPF 用户控件库          wpfusercontrollib    [C#],VB     Common/WPF</span><br><span class="line">WPF 类库                wpflib               [C#],VB     Common/WPF</span><br><span class="line">WPF 自定义控件库        wpfcustomcontrollib  [C#],VB     Common/WPF</span><br><span class="line">xUnit Test Project      xunit                [C#],F#,VB  Test/xUnit</span><br><span class="line">协议缓冲区文件          proto                            Web/gRPC</span><br><span class="line">控制台应用              console              [C#],F#,VB  Common/Console</span><br><span class="line">类库                    classlib             [C#],F#,VB  Common/Library</span><br><span class="line">解决方案文件            sln,solution                     Solution</span><br><span class="line">辅助角色服务            worker               [C#],F#     Common/Worker/Web</span><br></pre></td></tr></table></figure></p>
<p>在自己需要创建 C#
项目的目录打开命令行，执行以下命令来创建项目目录：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotnet new console -o demo</span><br></pre></td></tr></table></figure> ![[Pasted image 20230905233605.png]]<br />
刚创建的目录没有执行过编译前，应该有一个obj目录和两个文件（以.net7.0来说）<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS F:\fredom\workspace\dotNet\demo&gt; dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: F:\fredom\workspace\dotNet\demo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----        2023/09/05     23:36                obj</span><br><span class="line">-a----        2023/09/05     23:36            249 demo.csproj</span><br><span class="line">-a----        2023/09/05     23:36            105 Program.cs</span><br></pre></td></tr></table></figure></p>
<p>然后我们需要在VScode中对该项目目录设置 .vscode
工作区配置json文件（其实也不用怎么设置，安装了插件之后，插件有自带的 C#
项目配置模板）。<br />
![[Pasted image 20230905234038.png]]<br />
然后就会在项目目录（或者说VScode工作区）下创建.vscode文件夹用于存放
launch.json 和 tasks.json，其内容如下：</p>
<p>launch.json<br />
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.NET Core Launch (console)&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;coreclr&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/bin/Debug/net7.0/demo.dll&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;console&quot;</span><span class="punctuation">:</span> <span class="string">&quot;internalConsole&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.NET Core Attach&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;coreclr&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;attach&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure> tasks.json<br />
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dotnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;process&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/demo.sln&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/property:GenerateFullPaths=true&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/consoleloggerparameters:NoSummary&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$msCompile&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dotnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;process&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/demo.sln&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/property:GenerateFullPaths=true&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/consoleloggerparameters:NoSummary&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$msCompile&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;watch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dotnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;process&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;watch&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;--project&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/demo.sln&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$msCompile&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，C# 项目还是要依赖于 .sln 文件中的一些信息，说明
VisualStudio 仍然是官方的 C# 项目IDE。</p>
<p>在模板生成的 <code>Program.cs</code> 文件中，替换如下测试代码：<br />
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
命名空间不一定和目录名称一样，但是常规情况下一般是和目录名相同的。按<code>F5</code>进行调试，会在底部的调试窗口中显式结果：<br />
![[Pasted image 20230905235300.png]]</p>
<h3 id="增强程序输入">3.增强程序输入</h3>
<p>但是使用 VScode
内置的调试控制台是只能显式标准输出的，但是无法接受标准输入，解决办法是使用外置的控制台作为调试终端，修改
launch.json 文件的对应属性来实现这一点：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console: &quot;externalTerminal&quot;</span><br></pre></td></tr></table></figure> <figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;What is your name?&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> name = Console.ReadLine();</span><br><span class="line">            <span class="keyword">var</span> currentDate = DateTime.Now;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Environment.NewLine&#125;</span>Hello, <span class="subst">&#123;name&#125;</span>, on <span class="subst">&#123;currentDate:d&#125;</span> at <span class="subst">&#123;currentDate:t&#125;</span>!&quot;</span>);</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123;Environment.NewLine&#125;</span>Press any key to exit...&quot;</span>);</span><br><span class="line">            Console.ReadKey(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述修改过后的程序要求用户输入自己的名字，之前的内置调试控制台是无法完成的，现在在外置控制台可以输入了：<br />
![[Pasted image 20230905235830.png]]</p>
<p>其他的类似断点调试的功能也支持的：<br />
![[Pasted image 20230906000057.png]]</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>bitset</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/STL/bitset/</url>
    <content><![CDATA[<p>bitset 就相当于一个 只能存储二进制，也就是 0 和 1 的 bool 数组<br />
但是可以直接当作一个数进行左移右移，取或取反等二进制操作,所以一般用二进制状态压缩时就会用
bitset。</p>
<p>一、定义：<br />
对于 bitset 的定义有四种方式：<br />
1、直接定义，每一位初始为0：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bitset&lt;N&gt; name; <span class="comment">// 定义长度为 N 的二进制数组，命名为 name；</span></span><br><span class="line">bitset&lt;8&gt; b1;</span><br><span class="line">cout &lt;&lt; b1 &lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>2、存储数字的二进制：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bitset&lt;N&gt; <span class="title">name</span><span class="params">(num)</span></span>; <span class="comment">// 定义长度为 N 的二进制数组，命名为 name，将数字 num 的二进制存到其中；</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">b2</span><span class="params">(<span class="number">12</span>)</span></span>; <span class="comment">//二进制长度8，将12转化为二进制存到其中。</span></span><br><span class="line">cout &lt;&lt; b2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>3、存储 01字符串 对应的二进制：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bitset&lt;N&gt; <span class="title">name</span><span class="params">(string)</span></span>; <span class="comment">// 定义长度为 N 的二进制数组，命名为 name，将01串 string 存到其中，长度不够前补 0，长度过长截断；</span></span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;10010&quot;</span>;</span><br><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">b3</span><span class="params">(s)</span></span>;</span><br><span class="line">cout &lt;&lt; b3 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>4、存储 01字符数组 中的二进制：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bitset&lt;N&gt; <span class="title">name</span><span class="params">(<span class="type">char</span>[])</span></span>; <span class="comment">// 定义长度为 N 的二进制数组，命名为 name，将 01字符数组存到其中，长度不够前补0，长度过长截断；</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> chs[<span class="number">10</span>] = <span class="string">&quot;10010&quot;</span>;</span><br><span class="line">bitset\&lt;<span class="number">8</span>&gt; <span class="built_in">b4</span>(chs);</span><br><span class="line">cout \&lt;&lt; b4 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>注意：<br />
直接输出 bitset
为正常的二进制，但是遍历所有位置来输出的话就是逆序的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="number">13</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; bs &lt;&lt;endl; <span class="comment">//00001101</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) cout&lt;&lt;bs[i]; <span class="comment">//10110000</span></span><br></pre></td></tr></table></figure>
<p>二、常用操作：<br />
像数字一样进行 取或 或者 左移右移：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b2 |= b3; <span class="comment">//两个二进制数取或操作； </span></span><br><span class="line">b2 &amp;= b3; <span class="comment">//两个二进制数取与操作； </span></span><br><span class="line">b2 ^= b3; <span class="comment">//取异或；</span></span><br><span class="line">b2 = ~b2; <span class="comment">//取反; </span></span><br><span class="line">b2 &lt;&lt;= <span class="number">2</span>; <span class="comment">//左移右移；</span></span><br></pre></td></tr></table></figure></p>
<p>自带函数：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt_1 = b2.<span class="built_in">count</span>(); <span class="comment">//查询二进制数组中，1的个数；</span></span><br><span class="line"><span class="type">int</span> len  = b2.<span class="built_in">size</span>(); <span class="comment">//二进制数组的长度，就是定义的长度； </span></span><br><span class="line"><span class="type">int</span> test = b2.<span class="built_in">test</span>(<span class="number">7</span>); <span class="comment">//判断第x个位置是0还是1，也就是输出第x个位置，注意逆序；</span></span><br><span class="line"></span><br><span class="line">b2.<span class="built_in">flip</span>(); <span class="comment">//将二进制每一位取反；</span></span><br><span class="line">b2.<span class="built_in">flip</span>(<span class="number">3</span>); <span class="comment">//将二进制第x位取反；</span></span><br><span class="line">b2.<span class="built_in">set</span>(); <span class="comment">//将二进制每一位置为1； reset置为0； </span></span><br><span class="line">b2.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//将第x个位置置为1；</span></span><br><span class="line">	</span><br><span class="line">string ss = b2.<span class="built_in">to_string</span>(); <span class="comment">//将二进制数组转化为字符串。 </span></span><br></pre></td></tr></table></figure> ————————————————<br />
版权声明：本文为CSDN博主「小酒窝.」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：https://blog.csdn.net/Mr_dimple/article/details/123478474</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>priority_queue</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/STL/priority_queue/</url>
    <content><![CDATA[<p>不出所料，priority_queue
容器适配器定义了一个元素有序排列的队列。默认队列头部的元素优先级最高。因为它是一个队列，所以只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。但是如何定义“优先级”完全取决于我们自己。如果一个优先级队列记录的是医院里等待接受急救的病人，那么病人病情的严重性就是优先级。如果队列元素是银行的借贷业务，那么借记可能会优先于信贷。</p>
<p>priority_queue 模板有 3
个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它定义了一个用来决定元素顺序的断言。因此模板类型是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container=std::vector&lt;T&gt;, <span class="keyword">typename</span> Compare=std::less&lt;T&gt;&gt; <span class="keyword">class</span> priority_queue</span><br></pre></td></tr></table></figure>
<p>如你所见，priority_queue 实例默认有一个 vector 容器。函数对象类型
less&lt;T&gt; 是一个默认的排序断言，定义在头文件 function
中，决定了容器中最大的元素会排在队列前面。fonction
中定义了 greater&lt;T&gt;，用来作为模板的最后一个参数对元素排序，最小元素会排在队列前面。当然，如果指定模板的最巵一个参数，就必须提供另外的两个模板类型参数。</p>
<figure>
<img
src="http://c.biancheng.net/uploads/allimg/180913/2-1P913134031947.jpg"
alt="优先队列示意图" />
<figcaption aria-hidden="true">优先队列示意图</figcaption>
</figure>
<p>图 1 中显示元素的方式反映了它们被检索的顺序。在 vector
中它们也可以不像这样排序。在讨论堆时，会解释原因。</p>
<h2 id="创建-priority_queue">创建 priority_queue</h2>
<p>可以如下所示生成一个空的优先级队列：</p>
<ol type="1">
<li>std::priority_queue<std::string> words;</li>
</ol>
<p>可以用适当类型的对象初始化一个优先级队列：</p>
<ol type="1">
<li>std::string wrds[] { "one", "two", "three", "four"};<br />
</li>
<li>std::priority_queue<std::string> words { std::begin(wrds),std::
end(wrds)}; // "two" "three" "one" "four"</li>
</ol>
<p>初始化列表中的序列可以来自于任何容器，并且不需要有序。优先级队列会对它们进行排序。</p>
<p>拷贝构造函数会生成一个和现有对象同类型的 priority_queue
对象，它是现有对象的一个副本。例如：</p>
<ol type="1">
<li>std::priority_queue<std::string> copy_words {words}; // copy of
words</li>
</ol>
<p>也有带右值引用参数的拷贝构造函数，它可以移动一个实参对象。</p>
<p>当对容器内容反向排序时，最小的元素会排在队列前面，这时候需要指定 3
个模板类型参数：</p>
<ol type="1">
<li>std:: string wrds[] {"one", "two", "three", "four"};<br />
</li>
<li>std::priority_queue&lt;std::string, std::vector<std::string>,std:
:greater<std::string>&gt; words1 {std::begin (wrds) , std:: end (wrds)
}; //"four" "one" "three" "two"</li>
</ol>
<p>这会通过使用 operator&gt;()
函数对字符串对象进行比较，进而生成一个优先级队列，因此这会和它们在队列中的顺序相反。</p>
<p>优先级队列可以使用任何容器来保存元素，只要容器有成员函数
front()、push_back()、pop_back()、size()、empty()。这显然包含了 deque
容器，因此这里也可以用 deque 来代替：</p>
<ol type="1">
<li>std::string wrds [] {"one", "two", "three", "four"};<br />
</li>
<li>std::priority_queue&lt;std::string, std::deque<std::string>&gt;
words {std::begin(wrds), std::end(wrds)};</li>
</ol>
<p>这个 words 优先级队列在 deque 容器中保存了一些 wrds
数组中的字符串，这里使用默认的比较断言，因此队列中的元素会和上面 word1
中元素的顺序相同。priority_queue
构造函数会生成一个和第二个类型参数同类型的容器来保存元素，这也是
priority_queue 对象的底层容器。</p>
<p>可以生成 vector 或 deque 容器，然后用它们来初始化
priority_queue。下面展示了如何以 vector 的元素作为初始值来生成
priority_queue 对象：</p>
<ol type="1">
<li>std::vector&lt;int&gt; values{21, 22, 12, 3, 24, 54, 56};<br />
</li>
<li>std::priority_queue&lt;int&gt; numbers
{std::less&lt;int&gt;(),values};</li>
</ol>
<p>priority_queue
构造函数的第一个参数是一个用来对元素排序的函数对象，第二个参数是一个提供初始元素的容器。在队列中用函数对象对
vector 元素的副本排序。values
中元素的顺序没有变，但是优先级队列中的元素顺序变为：56 54 24 22 21 12
3。优先级队列中用来保存元素的容器是私有的，因此只能通过调用
priority_queue
对象的成员函数来对容器进行操作。构造函数的第一个参数是函数对象类型，它必须和指定的比较模板类型参数相同，函数对象类型默认是
less&lt;T&gt;。如果想使用不同类型的函数，需要指定全部的模板类型参数。例如：</p>
<ol type="1">
<li>std::priority_queue&lt;int,
std::vector&lt;int&gt;,std::greater&lt;int&gt;&gt; numbersl
{std::greater&lt;int&gt;(), values};</li>
</ol>
<p>第三个类型参数是一个比较对象类型。如果要指定这个参数，必须指定前两个参数——元素类型和底层容器类型。</p>
<h2 id="priority_queue-操作">priority_queue 操作</h2>
<p>对 priority_queue 进行操作有一些限制：</p>
<ul>
<li>push(const T&amp;
obj)：将obj的副本放到容器的适当位置，这通常会包含一个排序操作。<br />
</li>
<li>push(T&amp;&amp;
obj)：将obj放到容器的适当位置，这通常会包含一个排序操作。<br />
</li>
<li>emplace(T constructor a
rgs...)：通过调用传入参数的构造函数，在序列的适当位置构造一个T对象。为了维持优先顺序，通常需要一个排序操作。<br />
</li>
<li>top()：返回优先级队列中第一个元素的引用。<br />
</li>
<li>pop()：移除第一个元素。<br />
</li>
<li>size()：返回队列中元素的个数。<br />
</li>
<li>empty()：如果队列为空的话，返回true。<br />
</li>
<li>swap(priority_queue&lt;T&gt;&amp;
other)：和参数的元素进行交换，所包含对象的类型必须相同。</li>
</ul>
<p>priority_queue
也实现了赋值运算，可以将右操作数的元素赋给左操作数；同时也定义了拷贝和移动版的赋值运算符。需要注意的是，priority_queue
容器并没有定义比较运算符。因为需要保持元素的顺序，所以添加元素通常会很慢。稍后会在堆(heaps)一节讨论
priority_queue 的内部操作。</p>
<p>以下展示了如何将键盘输入的数据记录到 priority_queue 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;std::string&gt; words;</span><br><span class="line">std::string word; std::cout &lt;&lt; <span class="string">&quot;Enter words separated by spaces, enter Ctrl+Z on a separate line to end:\n&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((std::cin &gt;&gt; word).<span class="built_in">eof</span>())</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    words.<span class="built_in">push</span>(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按下 Ctrl+Z
组合键会在输入流中设置文件结束状态，因此可以用来结束循环输入。istream
对象的成员函数 operator&gt;&gt;() 返回一个输入流对象，因此我们可以用 if
条件表达式来调用 eof() 以检查 cin
的状态。这里会对输入单词进行排序，所以最大的单词总在 words
队列的前面——自动对输入单词排序。</p>
<p>priority_queue
没有迭代器。如果想要访问全部的元素，比如说，列出或复制它们，会将队列清空；priority_queue
和 queue
有相同的限制。如果想在进行这样的操作后，还能保存它的元素，需要先把它复制一份，这里可以使用一个不同类型的容器。下面展示了如何列出优先级队列
words 的内容：</p>
<ol type="1">
<li>std::priority_queue<std::string> words_copy {words}; // A copy for
output<br />
</li>
<li>while (!words_copy.empty())<br />
</li>
<li>{<br />
</li>
<li><pre><code>std:: cout &lt;&lt; words_copy.top () &lt;&lt;&quot; &quot;;  </code></pre></li>
<li><pre><code>words_copy.pop();  </code></pre></li>
<li>}<br />
</li>
<li>std::cout &lt;&lt; std::endl;</li>
</ol>
<p>这里首先生成了一个 words 的副本，因为输出 words 会移除它的内容。输出
top() 返回的元素后，我们需要使用 pop()
来使下一个元素可访问。移除全部元素后，在循环条件中调用 empty()
以结束循环。也可以使用表达式 words_copy.size()
来控制循环，因为返回值会被隐式转换为布尔值，这样在 size() 返回 0
时，表达式的结果为 false。</p>
<p>如果为 words 输入：</p>
<p>one two three four five six seven</p>
<p>那么输出为：</p>
<p>two three six seven one four five</p>
<p>当然，如果需要多次输出 priority_queue
的内容，最好定义一个函数。这个函数应该是通用的，如下所示：</p>
<ol type="1">
<li><p>template&lt;typename T&gt;</p></li>
<li><p>void list_pq(std::priority_queue&lt;T&gt; pq, size_t count =
5)<br />
</p></li>
<li><p>{<br />
</p></li>
<li><pre><code>size_t n&#123;count&#125;;  </code></pre></li>
<li><pre><code>while (!pq. empty())  </code></pre></li>
<li><pre><code>&#123;  </code></pre></li>
<li><pre><code>    std::cout &lt;&lt; pq. top() &lt;&lt; &quot; &quot;;  </code></pre></li>
<li><pre><code>    pq.pop();  </code></pre></li>
<li><pre><code>    if (--n) continue;  </code></pre></li>
<li><pre><code>    std::cout &lt;&lt; std::endl;  </code></pre></li>
<li><pre><code>    n = count;  </code></pre></li>
<li><pre><code>&#125;  </code></pre></li>
<li><pre><code>std::cout &lt;&lt; std::endl;  </code></pre></li>
<li><p>}</p></li>
</ol>
<p>参数是以传值方式传入的，因此这里会处理一个优先级队列的副本。它是一个适用于任何类型容器的函数模板，只要容器实现了用于向
ostream 输出的 operator&lt;&lt;() 函数。如果没有设置第二个参数，默认每 5
个输出值一行。当然也可以定义一个适用于 queue
容器适配对象的函数模板。可以如下所示使用 priority_queue 的成员函数
emplace():</p>
<ol type="1">
<li>words.emplace("nine");</li>
</ol>
<p>以字符串为参数调用 string
类的构造函数会在容器的适当位置生成一个对象。这比下面的语句更有效率：</p>
<ol type="1">
<li>words.push("nine");</li>
</ol>
<p>这里编译器会在字符文字处插入一个 string 构造函数来生成 push()
的参数，然后以这个临时 string 对象作为参数调用 push()。push()
函数然后会调用 string
类的拷贝构造函数来将生成对象添加到容器中。我们把这些代码段组织成一个完整的程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment">// Exerci[sin](http://c.biancheng.net/ref/sin.html)g a priority queue container adapter</span></span><br><span class="line"><span class="number">2.</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// For s[tan](http://c.biancheng.net/ref/tan.html)dard streams</span></span></span><br><span class="line"><span class="number">3.</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">// For priority_queue&lt;T&gt;</span></span></span><br><span class="line"><span class="number">4.</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// For string class</span></span></span><br><span class="line"><span class="number">5.</span> <span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> <span class="comment">// List contents of a priority queue</span></span><br><span class="line"><span class="number">8.</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="number">9.</span> <span class="function"><span class="type">void</span> <span class="title">list_pq</span><span class="params">(std::priority_queue&lt;T&gt; pq, <span class="type">size_t</span> count = <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function">10. </span>&#123;</span><br><span class="line"><span class="number">11.</span>     <span class="type">size_t</span> n &#123;count&#125;;</span><br><span class="line"><span class="number">12.</span>     <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line"><span class="number">13.</span>     &#123;</span><br><span class="line"><span class="number">14.</span>         std::cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="number">15.</span>         pq.<span class="built_in">pop</span>();</span><br><span class="line"><span class="number">16.</span>         <span class="keyword">if</span> (--n) <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">17.</span>         std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="number">18.</span>         n = count;</span><br><span class="line"><span class="number">19.</span>     &#125;</span><br><span class="line"><span class="number">20.</span>     std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="number">21.</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">23.</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">24. </span>&#123;</span><br><span class="line"><span class="number">25.</span>     std::priority_queue&lt;std::string&gt; words;</span><br><span class="line"><span class="number">26.</span>     std::string word;</span><br><span class="line"><span class="number">27.</span>     std::cout &lt;&lt; <span class="string">&quot;Enter words separated by spaces, enter Ctrl+Z on a separate line to end:\n&quot;</span>;</span><br><span class="line"><span class="number">28.</span>     <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"><span class="number">29.</span>     &#123;</span><br><span class="line"><span class="number">30.</span>         <span class="keyword">if</span> ((std::cin &gt;&gt; word).<span class="built_in">eof</span>())</span><br><span class="line"><span class="number">31.</span>             <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32.</span>         words.<span class="built_in">push</span>(word);</span><br><span class="line"><span class="number">33.</span>     &#125;</span><br><span class="line"><span class="number">34.</span>     std::cout &lt;&lt; <span class="string">&quot;You entered &quot;</span> &lt;&lt; words.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; words:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="number">35.</span>     <span class="built_in">list_pq</span>(words);</span><br><span class="line"><span class="number">36.</span> &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<p>Enter words separated by spaces, enter Ctrl+Z on a separate line to
end:<br />
one two three four five six seven eight nine ten eleven twelve<br />
^Z<br />
You entered 12 words:<br />
two twelve three ten six<br />
seven one nine four five<br />
eleven eight</p>
<p>list_pq<T>() 函数模板实例的输出表明优先级队列对输出进行排序。</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>set</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/STL/set/</url>
    <content><![CDATA[<p>前面章节讲解了 map 容器和 multimap 容器的用法，类似地，<a
href="http://c.biancheng.net/cplus/">C++</a> <a
href="http://c.biancheng.net/stl/">STL</a> 标准库中还提供有 set 和
multiset 这 2 个容器，它们也属于关联式容器。不过，本节先讲解 set
容器，后续章节再讲解 multiset 容器。</p>
<p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key
和值 value 必须相等。</p>
<p>举个例子，如下有 2 组键值对数据：</p>
<p>{&lt;'a', 1&gt;, &lt;'b', 2&gt;, &lt;'c', 3&gt;}<br />
{&lt;'a', 'a'&gt;, &lt;'b', 'b'&gt;, &lt;'c', 'c'&gt;}</p>
<p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于
set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。</p>
<p>基于 set 容器的这种特性，当使用 set
容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key
的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供
{'a','b','c'} ，该容器即可成功将它们存储起来。</p>
<p>通过前面的学习我们知道，map、multimap
容器都会自行根据键的大小对存储的键值对进行排序，set 容器也会如此，只不过
set 容器中各键值对的键 key 和值 value 是相等的，根据 key
排序，也就等价为根据 value 排序。</p>
<p>另外，使用 set
容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set
容器并没有强制对存储元素的类型做 const 修饰，即 set
容器中存储的元素的值是可以修改的。但是，C++
标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改
set 容器中元素的值的。</p>
<blockquote>
<p>对于初学者来说，切勿尝试直接修改 set
容器中已存储元素的值，这很有可能破坏 set
容器中元素的有序性，最正确的修改 set
容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</p>
</blockquote>
<p>值得一提的是，set 容器定义于<code>&lt;set&gt;</code>头文件，并位于
std 命名空间中。因此如果想在程序中使用 set
容器，该程序代码应先包含如下语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="number">2.</span> u[sin](http:<span class="comment">//c.biancheng.net/ref/sin.html)g namespace std;</span></span><br></pre></td></tr></table></figure>
<p>注意，第二行代码不是必需的，如果不用，则后续程序中在使用 set
容器时，需手动注明 std 命名空间（强烈建议初学者使用）。</p>
<p>set 容器的类模板定义如下：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span>,                        <span class="comment">// 键 key 和值 value 的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;T&gt;,        <span class="comment">// 指定 set 容器内部的排序规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt;T&gt;      <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> set;</span><br></pre></td></tr></table></figure></p>
<p>注意，由于 set
容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此
set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。</p>
<blockquote>
<p>对于 set 类模板中的 3 个参数，后 2
个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3
个参数不会用到。</p>
</blockquote>
<h2 id="创建c-set容器的几种方法">创建C++ set容器的几种方法</h2>
<p>常见的创建 set 容器的方法，大致有以下 5 种。</p>
<ol type="1">
<li>调用默认构造函数，创建空的 set 容器。比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> std::set&lt;std::string&gt; myset;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。</p>
</blockquote>
<p>由此就创建好了一个 set
容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的
string 类型元素做升序排序。注意，由于 set
容器支持随时向内部添加新的元素，因此创建空 set
容器的方法是经常使用的。</p>
<ol start="2" type="1">
<li>除此之外，set 类模板还支持在创建 set
容器的同时，对其进行初始化。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> std::set&lt;std::string&gt; myset&#123;<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line"><span class="number">2.</span>                             <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line"><span class="number">3.</span>                             <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的
std::less&lt;T&gt; 规则，因此其内部存储 string
元素的顺序如下所示：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/java/&quot;  </span><br><span class="line">&quot;http://c.biancheng.net/python/&quot;  </span><br><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set
容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set
容器中。</li>
</ol>
<p>例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;</span><br><span class="line"><span class="number">2.</span> <span class="comment">//等同于</span></span><br><span class="line"><span class="number">3.</span> <span class="comment">//std::set&lt;std::string&gt; copyset = myset</span></span><br></pre></td></tr></table></figure>
<p>该行代码在创建 copyset 容器的基础上，还会将 myset
容器中存储的所有元素，全部复制给 copyset 容器一份。</p>
<p>另外，C++ 11 标准还为 set
类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的
set 容器为其初始化。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">set&lt;string&gt; <span class="title">retSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">2.</span>     std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line"><span class="number">3.</span>                             <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line"><span class="number">4.</span>                             <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br><span class="line"><span class="number">5.</span>     <span class="keyword">return</span> myset;</span><br><span class="line"><span class="number">6.</span> &#125;</span><br><span class="line"><span class="number">7.</span> <span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(retSet())</span></span>;</span><br><span class="line"><span class="number">8.</span> <span class="comment">//或者</span></span><br><span class="line"><span class="number">9.</span> <span class="comment">//std::set&lt;std::string&gt; copyset = retSet();</span></span><br></pre></td></tr></table></figure>
<p>注意，由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化
copyset 容器时，其内部调用的是 set
类模板中的移动构造函数，而非拷贝构造函数。</p>
<blockquote>
<p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2
个容器的类型完全一致。</p>
</blockquote>
<ol start="4" type="1">
<li>在第 3 种方式的基础上，set 类模板还支持取已有 set
容器中的部分元素，来初始化新 set 容器。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line"><span class="number">2.</span>                     <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line"><span class="number">3.</span>                     <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br><span class="line"><span class="number">4.</span> <span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(++myset.begin(), myset.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p>由此初始化的 copyset 容器，其内部仅存有如下 2 个 string
字符串：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/python/&quot;  </span><br><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br></pre></td></tr></table></figure></p>
<ol start="5" type="1">
<li>以上几种方式创建的 set
容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 set
类模板定义中第 2 个参数，我们完全可以手动修改 set
容器中的排序规则。比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> std::set&lt;std::string,std::greater&lt;string&gt; &gt; myset&#123;</span><br><span class="line"><span class="number">2.</span>     <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line"><span class="number">3.</span>     <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line"><span class="number">4.</span>     <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>通过选用 std::greater&lt;string&gt; 降序规则，myset
容器中元素的存储顺序为:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/stl/&quot;  </span><br><span class="line">&quot;http://c.biancheng.net/python/&quot;  </span><br><span class="line">&quot;http://c.biancheng.net/java/&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="c-stl-set容器包含的成员方法">C++ STL set容器包含的成员方法</h2>
<p>表 1 列出了 set 容器提供的常用成员方法以及各自的功能。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果
set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr class="even">
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和
begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const
类型的双向迭代器。</td>
</tr>
<tr class="odd">
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果
set 容器用 const 限定，则该方法返回的是 const
类型的反向双向迭代器。</td>
</tr>
<tr class="even">
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果
set 容器用 const 限定，则该方法返回的是 const
类型的反向双向迭代器。</td>
</tr>
<tr class="odd">
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const
属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr class="even">
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const
属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr class="odd">
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const
属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr class="even">
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const
属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr class="odd">
<td>find(val)</td>
<td>在 set 容器中查找值为 val
的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end()
方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是
const 类型的双向迭代器。</td>
</tr>
<tr class="even">
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val
的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const
类型的双向迭代器。</td>
</tr>
<tr class="odd">
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set
容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr class="even">
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和
lower_bound() 方法的返回值等价，pair.second 和 upper_bound()
方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val
的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
<tr class="odd">
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr class="even">
<td>size()</td>
<td>返回当前 set 容器中存有元素的个数。</td>
</tr>
<tr class="odd">
<td>max_size()</td>
<td>返回 set
容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr class="even">
<td>insert()</td>
<td>向 set 容器中插入元素。</td>
</tr>
<tr class="odd">
<td>erase()</td>
<td>删除 set 容器中存储的元素。</td>
</tr>
<tr class="even">
<td>swap()</td>
<td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set
容器的类型必须相同。</td>
</tr>
<tr class="odd">
<td>clear()</td>
<td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。</td>
</tr>
<tr class="even">
<td>emplace()</td>
<td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert()
一样，但效率更高。</td>
</tr>
<tr class="odd">
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 set
容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr class="even">
<td>count(val)</td>
<td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set
容器中各元素的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody>
</table>
<p>下面程序演示了表 1 中部分成员函数的用法：</p>
<ol type="1">
<li><p>#include <iostream><br />
</p></li>
<li><p>#include <set><br />
</p></li>
<li><p>#include <string><br />
</p></li>
<li><p>using namespace std;</p></li>
<li><p>int main()<br />
</p></li>
<li><p>{<br />
</p></li>
<li><pre><code>//创建空set容器  </code></pre></li>
<li><pre><code>std::set&lt;std::string&gt; myset;  </code></pre></li>
<li><pre><code>//空set容器不存储任何元素  </code></pre></li>
<li><pre><code>cout &lt;&lt; &quot;1、myset size = &quot; &lt;&lt; myset.size() &lt;&lt; endl;  </code></pre></li>
<li><pre><code>//向myset容器中插入新元素  </code></pre></li>
<li><pre><code>myset.insert(&quot;http://c.biancheng.net/java/&quot;);  </code></pre></li>
<li><pre><code>myset.insert(&quot;http://c.biancheng.net/stl/&quot;);  </code></pre></li>
<li><pre><code>myset.insert(&quot;http://c.biancheng.net/python/&quot;);  </code></pre></li>
<li><pre><code>cout &lt;&lt; &quot;2、myset size = &quot; &lt;&lt; myset.size() &lt;&lt; endl;  </code></pre></li>
<li><pre><code>//利用双向迭代器，遍历myset  </code></pre></li>
<li><pre><code>for (auto iter = myset.begin(); iter != myset.end(); ++iter) &#123;  </code></pre></li>
<li><pre><code>    cout &lt;&lt; *iter &lt;&lt; endl;  </code></pre></li>
<li><pre><code>&#125;  </code></pre></li>
<li><pre><code>return 0;  </code></pre></li>
<li><p>}</p></li>
</ol>
<p>程序执行结果为：</p>
<p>1、myset size = 0<br />
2、myset size = 3<br />
http://c.biancheng.net/java/<br />
http://c.biancheng.net/python/<br />
http://c.biancheng.net/stl/</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_map不能以pair作为键？</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/STL/unordered_map%E4%B8%8D%E8%83%BD%E4%BB%A5pair%E4%BD%9C%E4%B8%BA%E9%94%AE%EF%BC%9F/</url>
    <content><![CDATA[<p>C++ 报错<br />
如果用pair作为键初始化unordered_map，例如</p>
<p>unordered_map&lt;pair&lt;int, int&gt;, int&gt; m;<br />
会报下面的错误：</p>
<p>error: call to implicitly-deleted default constructor of
‘unordered_map&lt;pair&lt;int, int&gt;, int&gt;’ m;</p>
<p>分析<br />
unordered_map中用std::hash来计算key，但是C++中没有给pair做Hash的函数，所以不能用pair作为unordered_map的key。<br />
但是！map可以！<br />
map里面是通过操作符&lt;来比较大小，而pair是可以比较大小的。所以，map用在这里是可以的。</p>
<p>解决<br />
可以将unordered_map改为map，例如<br />
map&lt;pair&lt;int, int&gt;, int&gt; m;</p>
<p>编译通过！问题解决！！！<br />
————————————————<br />
版权声明：本文为CSDN博主「Zhihao杨」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：https://blog.csdn.net/weixin_42989041/article/details/113183015</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>vector bool 并未存储bool类型元素</title>
    <url>/blog/2023/10/11/data/languages/C%20&amp;%20C++%20&amp;%20CSharp/STL/vector%20bool%20%E5%B9%B6%E6%9C%AA%E5%AD%98%E5%82%A8bool%E7%B1%BB%E5%9E%8B%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>具体来讲，不推荐使用 vector&lt;bool&gt; 的原因有以下 2 个：</p>
<p>严格意义上讲，vector&lt;bool&gt; 并不是一个 STL 容器；<br />
vector&lt;bool&gt; 底层存储的并不是 bool 类型值。<br />
值得一提的是，对于是否为 STL 容器，C++
标准库中有明确的判断条件，其中一个条件是：如果 cont 是包含对象 T 的 STL
容器，且该容器中重载了 [ ] 运算符（即支持
operator[]），则以下代码必须能够被编译：</p>
<p>T *p = &amp;cont[0];<br />
此行代码的含义是，借助 operator[ ] 获取一个 cont&lt;T&gt; 容器中存储的 T
对象，同时将这个对象的地址赋予给一个 T 类型的指针。<br />
这就意味着，如果 vector&lt;bool&gt; 是一个 STL
容器，则下面这段代码是可以通过编译的：</p>
<p>//创建一个 vector&lt;bool&gt; 容器<br />
vector&lt;bool&gt;cont{0,1};<br />
//试图将指针 p 指向 cont 容器中第一个元素<br />
bool *p = &amp;cont[0];<br />
但不幸的是，此段代码不能通过编译。原因在于 vector&lt;bool&gt;
底层采用了独特的存储机制。</p>
<p>实际上，为了节省空间，vector&lt;bool&gt; 底层在存储各个 bool
类型值时，每个 bool 值都只使用一个比特位（二进制位）来存储。也就是说在
vector&lt;bool&gt; 底层，一个字节可以存储 8 个 bool
类型值。在这种存储机制的影响下，operator[ ]
势必就需要返回一个指向单个比特位的引用，但显然这样的引用是不存在的，等号左右两边出现冲突！</p>
<p>C++ 标准中解决这个问题的方案是，令 operator[] 返回一个代理对象（proxy
object）。有关代理对象，由于不是本节重点，这里不再做描述，有兴趣的读者可自行查阅相关资料。</p>
<p>同样对于指针来说，其指向的最小单位是字节，无法另其指向单个比特位。综上所述可以得出一个结论，即上面第
2 行代码中，用 = 赋值号连接 bool *p 和 &amp;cont[0] 是矛盾的。</p>
<p>由于 vector&lt;bool&gt; 并不完全满足 C++
标准中对容器的要求，所以严格意义上来说它并不是一个 STL
容器。可能有读者会问，既然 vector&lt;bool&gt;
不完全是一个容器，为什么还会出现在 C++ 标准中呢？</p>
<p>这和一个雄心勃勃的试验有关，还要从前面提到的代理对象开始说起。由于代理对象在
C++ 软件开发中很受欢迎，引起了 C++ 标准委员会的注意，他们决定以开发
vector&lt;bool&gt; 作为一个样例，来演示 STL
中的容器如何通过代理对象来存取元素，这样当用户想自己实现一个基于代理对象的容器时，就会有一个现成的参考模板。</p>
<p>然而开发人员在实现 vector&lt;bool&gt;
的过程中发现，既要创建一个基于代理对象的容器，同时还要求该容器满足 C++
标准中对容器的所有要求，是不可能的。由于种种原因，这个试验最终失败了，但是他们所做过的尝试（即开发失败的
vector&lt;bool&gt;）遗留在了 C++ 标准中。</p>
<p>至于将 vector&lt;bool&gt; 遗留到 C++
标准中，是无心之作，还是有意为之，这都无关紧要，重要的是让读者明白，vector&lt;bool&gt;
不完全满足 C++ 标准中对容器的要求，尽量避免在实际场景中使用它</p>
<p>那么，如果在实际场景中需要使用 vector&lt;bool&gt;
这样的存储结构，该怎么办呢？很简单，可以选择使用 deque&lt;bool&gt; 或者
bitset 来替代 vector&lt;bool&gt;。</p>
<p>要知道，deque 容器几乎具有 vecotr
容器全部的功能（拥有的成员方法也仅差 reserve() 和
capacity()），而且更重要的是，deque 容器可以正常存储 bool 类型元素。</p>
<p>还可以考虑用 bitset 代替
vector&lt;bool&gt;，其本质是一个模板类，可以看做是一种类似数组的存储结构。和后者一样，bitset
只能用来存储 bool 类型值，且底层存储机制也采用的是用一个比特位来存储一个
bool 值。</p>
<p>和 vector 容器不同的是，bitset
的大小在一开始就确定了，因此不支持插入和删除元素；另外 bitset
不是容器，所以不支持使用迭代器<br />
————————————————<br />
版权声明：本文为CSDN博主「Worthwhile_DUT」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：https://blog.csdn.net/Worthwhile_DUT/article/details/120854069</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>C &amp; C++ &amp; CSharp</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>np.array (x,) 转 np.ndarray (x,y)</title>
    <url>/blog/2023/10/11/data/languages/Python/deep%20learning/np.array%20(x,)%20%E8%BD%AC%20np.ndarray%20(x,y)/</url>
    <content><![CDATA[<p>To convert an array of shape <code>(3,)</code> to
<code>(1, 3)</code>, you can use the <code>reshape</code> method or the
<code>np.newaxis</code> indexing trick.</p>
<p>Here are a few ways to do it:</p>
<h3 id="using-reshape">1. Using <code>reshape</code>:</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">reshaped_arr = arr.reshape(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(reshaped_arr.shape)  <span class="comment"># Outputs: (1, 3)</span></span><br></pre></td></tr></table></figure>
<h3 id="using-np.newaxis">2. Using <code>np.newaxis</code>:</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">reshaped_arr = arr[np.newaxis, :]</span><br><span class="line"><span class="built_in">print</span>(reshaped_arr.shape)  <span class="comment"># Outputs: (1, 3)</span></span><br></pre></td></tr></table></figure>
<p>Either method will convert an array from shape <code>(3,)</code> to
<code>(1, 3)</code>.</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>pyplot的可选颜色映射</title>
    <url>/blog/2023/10/11/data/languages/Python/matplotlib/pyplot%E7%9A%84%E5%8F%AF%E9%80%89%E9%A2%9C%E8%89%B2%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="classes-of-colormaps">Classes of colormaps</h2>
<p>Colormaps are often split into several categories based on their
function (see, e.g., <a
href="https://matplotlib.org/stable/tutorials/colors/colormaps.html#moreland">[Moreland]</a>):</p>
<ol type="1">
<li>Sequential: change in lightness and often saturation of color
incrementally, often using a single hue; should be used for representing
information that has ordering.<br />
</li>
<li>Diverging: change in lightness and possibly saturation of two
different colors that meet in the middle at an unsaturated color; should
be used when the information being plotted has a critical middle value,
such as topography or when the data deviates around zero.<br />
</li>
<li>Cyclic: change in lightness of two different colors that meet in the
middle and beginning/end at an unsaturated color; should be used for
values that wrap around at the endpoints, such as phase angle, wind
direction, or time of day.<br />
</li>
<li>Qualitative: often are miscellaneous colors; should be used to
represent information which does not have ordering or
relationships.</li>
</ol>
<p>import numpy as np</p>
<p>import matplotlib as mpl</p>
<p>import matplotlib.pyplot as plt</p>
<p>from colorspacious import cspace_converter</p>
<p>First, we'll show the range of each colormap. Note that some seem to
change more "quickly" than others.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmaps = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">gradient = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">256</span>)</span><br><span class="line">gradient = np.vstack((gradient, gradient))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_color_gradients</span>(<span class="params">category, cmap_list</span>):</span><br><span class="line">    <span class="comment"># Create figure and adjust figure height to number of colormaps</span></span><br><span class="line">    nrows = <span class="built_in">len</span>(cmap_list)</span><br><span class="line">    figh = <span class="number">0.35</span> + <span class="number">0.15</span> + (nrows + (nrows - <span class="number">1</span>) * <span class="number">0.1</span>) * <span class="number">0.22</span></span><br><span class="line">    fig, axs = plt.subplots(nrows=nrows + <span class="number">1</span>, figsize=(<span class="number">6.4</span>, figh))</span><br><span class="line">    fig.subplots_adjust(top=<span class="number">1</span> - <span class="number">0.35</span> / figh, bottom=<span class="number">0.15</span> / figh,</span><br><span class="line">                        left=<span class="number">0.2</span>, right=<span class="number">0.99</span>)</span><br><span class="line">    axs[<span class="number">0</span>].set_title(<span class="string">f&#x27;<span class="subst">&#123;category&#125;</span> colormaps&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> ax, name <span class="keyword">in</span> <span class="built_in">zip</span>(axs, cmap_list):</span><br><span class="line">        ax.imshow(gradient, aspect=<span class="string">&#x27;auto&#x27;</span>, cmap=mpl.colormaps[name])</span><br><span class="line">        ax.text(-<span class="number">0.01</span>, <span class="number">0.5</span>, name, va=<span class="string">&#x27;center&#x27;</span>, ha=<span class="string">&#x27;right&#x27;</span>, fontsize=<span class="number">10</span>,</span><br><span class="line">                transform=ax.transAxes)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Turn off *all* ticks &amp; spines, not just the ones with colormaps.</span></span><br><span class="line">    <span class="keyword">for</span> ax <span class="keyword">in</span> axs:</span><br><span class="line">        ax.set_axis_off()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Save colormap list for later.</span></span><br><span class="line">    cmaps[category] = cmap_list</span><br></pre></td></tr></table></figure>
<p>使用上述代码来显示所有的映射的模式图</p>
<h3 id="sequential">Sequential</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_color_gradients(<span class="string">&#x27;Perceptually Uniform Sequential&#x27;</span>,</span><br><span class="line">                     [<span class="string">&#x27;viridis&#x27;</span>, <span class="string">&#x27;plasma&#x27;</span>, <span class="string">&#x27;inferno&#x27;</span>, <span class="string">&#x27;magma&#x27;</span>, <span class="string">&#x27;cividis&#x27;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="sequential1">Sequential1</h3>
<p>For the Sequential plots, the lightness value increases monotonically
through the colormaps. This is good. Some of the  values in the
colormaps span from 0 to 100 (binary and the other grayscale), and
others start around . Those that have a smaller range of  will
accordingly have a smaller perceptual range. Note also that the
 function varies amongst the colormaps: some are approximately linear in
 and others are more curved.<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_color_gradients(<span class="string">&#x27;Sequential&#x27;</span>,</span><br><span class="line">                     [<span class="string">&#x27;Greys&#x27;</span>, <span class="string">&#x27;Purples&#x27;</span>, <span class="string">&#x27;Blues&#x27;</span>, <span class="string">&#x27;Greens&#x27;</span>, <span class="string">&#x27;Oranges&#x27;</span>, <span class="string">&#x27;Reds&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;YlOrBr&#x27;</span>, <span class="string">&#x27;YlOrRd&#x27;</span>, <span class="string">&#x27;OrRd&#x27;</span>, <span class="string">&#x27;PuRd&#x27;</span>, <span class="string">&#x27;RdPu&#x27;</span>, <span class="string">&#x27;BuPu&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;GnBu&#x27;</span>, <span class="string">&#x27;PuBu&#x27;</span>, <span class="string">&#x27;YlGnBu&#x27;</span>, <span class="string">&#x27;PuBuGn&#x27;</span>, <span class="string">&#x27;BuGn&#x27;</span>, <span class="string">&#x27;YlGn&#x27;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="sequential2">Sequential2</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_color_gradients(<span class="string">&#x27;Sequential (2)&#x27;</span>,</span><br><span class="line">                     [<span class="string">&#x27;binary&#x27;</span>, <span class="string">&#x27;gist_yarg&#x27;</span>, <span class="string">&#x27;gist_gray&#x27;</span>, <span class="string">&#x27;gray&#x27;</span>, <span class="string">&#x27;bone&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;spring&#x27;</span>, <span class="string">&#x27;summer&#x27;</span>, <span class="string">&#x27;autumn&#x27;</span>, <span class="string">&#x27;winter&#x27;</span>, <span class="string">&#x27;cool&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;Wistia&#x27;</span>, <span class="string">&#x27;hot&#x27;</span>, <span class="string">&#x27;afmhot&#x27;</span>, <span class="string">&#x27;gist_heat&#x27;</span>, <span class="string">&#x27;copper&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="diverging">Diverging</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_color_gradients(<span class="string">&#x27;Diverging&#x27;</span>,</span><br><span class="line">                     [<span class="string">&#x27;PiYG&#x27;</span>, <span class="string">&#x27;PRGn&#x27;</span>, <span class="string">&#x27;BrBG&#x27;</span>, <span class="string">&#x27;PuOr&#x27;</span>, <span class="string">&#x27;RdGy&#x27;</span>, <span class="string">&#x27;RdBu&#x27;</span>, <span class="string">&#x27;RdYlBu&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;RdYlGn&#x27;</span>, <span class="string">&#x27;Spectral&#x27;</span>, <span class="string">&#x27;coolwarm&#x27;</span>, <span class="string">&#x27;bwr&#x27;</span>, <span class="string">&#x27;seismic&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="cyclic">Cyclic</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_color_gradients(<span class="string">&#x27;Cyclic&#x27;</span>, [<span class="string">&#x27;twilight&#x27;</span>, <span class="string">&#x27;twilight_shifted&#x27;</span>, <span class="string">&#x27;hsv&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="qualitative">Qualitative</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_color_gradients(<span class="string">&#x27;Qualitative&#x27;</span>,</span><br><span class="line">                     [<span class="string">&#x27;Pastel1&#x27;</span>, <span class="string">&#x27;Pastel2&#x27;</span>, <span class="string">&#x27;Paired&#x27;</span>, <span class="string">&#x27;Accent&#x27;</span>, <span class="string">&#x27;Dark2&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;Set1&#x27;</span>, <span class="string">&#x27;Set2&#x27;</span>, <span class="string">&#x27;Set3&#x27;</span>, <span class="string">&#x27;tab10&#x27;</span>, <span class="string">&#x27;tab20&#x27;</span>, <span class="string">&#x27;tab20b&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;tab20c&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="miscellaneous">### Miscellaneous</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_color_gradients(<span class="string">&#x27;Miscellaneous&#x27;</span>,</span><br><span class="line">                     [<span class="string">&#x27;flag&#x27;</span>, <span class="string">&#x27;prism&#x27;</span>, <span class="string">&#x27;ocean&#x27;</span>, <span class="string">&#x27;gist_earth&#x27;</span>, <span class="string">&#x27;terrain&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;gist_stern&#x27;</span>, <span class="string">&#x27;gnuplot&#x27;</span>, <span class="string">&#x27;gnuplot2&#x27;</span>, <span class="string">&#x27;CMRmap&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;cubehelix&#x27;</span>, <span class="string">&#x27;brg&#x27;</span>, <span class="string">&#x27;gist_rainbow&#x27;</span>, <span class="string">&#x27;rainbow&#x27;</span>, <span class="string">&#x27;jet&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;turbo&#x27;</span>, <span class="string">&#x27;nipy_spectral&#x27;</span>, <span class="string">&#x27;gist_ncar&#x27;</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>创建多幅子图</title>
    <url>/blog/2023/10/11/data/languages/Python/matplotlib/%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B9%85%E5%AD%90%E5%9B%BE/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">pd.options.display.notebook_repr_html=<span class="literal">False</span>  <span class="comment"># 表格显示</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;figure.dpi&#x27;</span>] = <span class="number">75</span>  <span class="comment"># 图形分辨率</span></span><br><span class="line">sns.set_theme(style=<span class="string">&#x27;darkgrid&#x27;</span>)  <span class="comment"># 图形主题</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(samples) <span class="comment"># &#x27;samples&#x27; type is dict</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, nrows=<span class="number">1</span>, figsize=(<span class="number">12</span>, <span class="number">3</span>)) </span><br><span class="line">sns.lineplot(data=df, x=<span class="string">&quot;overlap&quot;</span>, y=<span class="string">&quot;success&quot;</span>, hue=<span class="string">&quot;method&quot;</span>, ax=axs[<span class="number">0</span>])</span><br><span class="line">sns.lineplot(data=df, x=<span class="string">&quot;overlap&quot;</span>, y=<span class="string">&quot;raxis&quot;</span>, hue=<span class="string">&quot;method&quot;</span>, ax=axs[<span class="number">1</span>])</span><br><span class="line">sns.lineplot(data=df, x=<span class="string">&quot;overlap&quot;</span>, y=<span class="string">&quot;rdegr&quot;</span>, hue=<span class="string">&quot;method&quot;</span>, ax=axs[<span class="number">2</span>])</span><br><span class="line">axs[<span class="number">0</span>].legend_.remove()</span><br><span class="line">axs[<span class="number">1</span>].legend_.remove()</span><br><span class="line">plt.legend(loc=<span class="number">2</span>, bbox_to_anchor=(<span class="number">1.025</span>,<span class="number">1.0</span>),borderaxespad = <span class="number">0.</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>通过移除子图1和子图2的图例，并重新设置图例相对于画布框的位置使其在外部而不是在图像上，使得整幅图像美观。</p>
<p>需要注意的是，seaborn的画图一般是和pd.DataFrame紧耦合的，pd.DataFrame完全可以看作是Excel这种表头+数据列的数据表存储，而matplotlib往往是和多维序列紧耦合的。使用seaborn画图时，需要注意将样本数据转化为Excel数据表的思维模式：一排表头代表了数据中样本会含有的属性，接下来每一行代表一个样本数据（其实和SQL的表概念也是相同的）。seaborn的画图一般要指定横轴是来自于哪个数据，纵轴是来自于哪个数据，除了着两个必要的特征外，还可以使用其他数据添加新的特征，比如散点图除了横纵坐标数据外，可以用其他数据描述点的大小（size参数），可以用其他数据描述点的分类颜色（hue参数）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m, n = [(ss-<span class="number">1.</span>)/<span class="number">2.</span> <span class="keyword">for</span> ss <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">3</span>)]</span><br><span class="line">y, x = np.ogrid[-m:m+<span class="number">1</span>,-n:n+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">sns.reset_defaults()</span><br><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">3</span>, figsize=(<span class="number">9</span>, <span class="number">6</span>))</span><br><span class="line">axes = axes.flatten()</span><br><span class="line"><span class="keyword">for</span> ax, sigma <span class="keyword">in</span> <span class="built_in">zip</span>(axes, [<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2</span>, <span class="number">2.5</span>, <span class="number">3</span>]):</span><br><span class="line">    z = gaussian_2d(x, y, <span class="number">0.0</span>, sigma, <span class="number">0.0</span>, sigma)</span><br><span class="line">    z_normed = (z - z.<span class="built_in">min</span>()) / z.<span class="built_in">max</span>()</span><br><span class="line">    z_normed[z_normed &lt; np.finfo(z_normed.dtype).eps * z.<span class="built_in">max</span>()] = <span class="number">0.0</span></span><br><span class="line">    im = ax.imshow(z_normed, cmap=<span class="string">&quot;viridis&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;sigma = <span class="subst">&#123;sigma&#125;</span>&quot;</span>)</span><br><span class="line">    fig.colorbar(im, ax=ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20231003193048.png]]</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>boot 引导程序实验记录</title>
    <url>/blog/2023/10/11/data/CSAPP/os/The%20Design%20And%20Implementation%20Of%20A%2064-bit%20OS/ch3/3-1/boot%20%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>![[Pasted image 20230817143521.png]]</p>
<p>![[Pasted image 20230817143707.png]]</p>
<p>然后发现折腾了大半天，其实Xshell自带的XManager可以直接转发基于X
11制作的窗口，所以直接在XShell中执行bochs虚拟机程序，也可以在Windows下弹出Bochs虚拟机界面，无需开启远程桌面登录功能。不过也算是多学习了一项技能吧？</p>
<p>注释版本代码：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORG 0x7c00</span><br><span class="line"></span><br><span class="line">stack_base EQU 0x7c00</span><br><span class="line"></span><br><span class="line">label_start:</span><br><span class="line">	MOV ax, cs ; copy the start address of the sector</span><br><span class="line">	MOV ds, ax</span><br><span class="line">	MOV es, ax</span><br><span class="line">	MOV ss, ax</span><br><span class="line">	MOV sp, stack_base ; set stack pointer to stack_base</span><br><span class="line"></span><br><span class="line">	; suffix &#x27;h&#x27; of a number means hexadecimal</span><br><span class="line"></span><br><span class="line">	; suffix &#x27;l&#x27; of a register means low byte of it</span><br><span class="line">	; suffix &#x27;h&#x27; of a register means high byte of it</span><br><span class="line"></span><br><span class="line">	; clear screen</span><br><span class="line">	MOV ax, 0600h</span><br><span class="line">	MOV bx, 0700h</span><br><span class="line">	MOV cx, 0</span><br><span class="line">	MOV dx, 0184fh</span><br><span class="line">	; no value is set to register ah, so INT instruction will</span><br><span class="line">	; clear the screen</span><br><span class="line">	INT 10h ; 0x10 + ah=0x06 -&gt; clear screen</span><br><span class="line"></span><br><span class="line">	; interrupt vector code:</span><br><span class="line">	; 0x10 - BIOS VEDIO SERVICE</span><br><span class="line">	; 0x13 - BIOS DISK  SERVICE</span><br><span class="line">	; 0x16 - BIOS IO    SERVICE</span><br><span class="line">	; 0x21 - DOS FUNCITON</span><br><span class="line"></span><br><span class="line">	; set focus</span><br><span class="line">	MOV ax, 0200h</span><br><span class="line">	MOV bx, 0000h ; console x = 0, console y = 0</span><br><span class="line">	MOV dx, 0000h</span><br><span class="line">	INT 10h		  ; 0x10 + ah=0x02 -&gt; set console pos</span><br><span class="line"></span><br><span class="line">	; display message</span><br><span class="line">	MOV ax, 1301h  ; set ah=0x13 and al=0x10</span><br><span class="line">	MOV bx, 000Fh  ; bx controls display mode</span><br><span class="line">	MOV cx, 10	   ; cx controls display length</span><br><span class="line">	MOV dx, 0000h  ; dx controls console position</span><br><span class="line">	PUSH ax</span><br><span class="line">	MOV ax, ds</span><br><span class="line">	MOV es, ax</span><br><span class="line">	POP ax</span><br><span class="line">	MOV bp, ud_msg ; set the address of string</span><br><span class="line">	INT 10h		   ; invoke BIOS display service</span><br><span class="line"></span><br><span class="line">	; BIOS has finished display the message</span><br><span class="line">	; now reset the disk head  of  floppy A</span><br><span class="line">	; to mask the first section as  a  boot</span><br><span class="line">	; sector</span><br><span class="line">	XOR ah, ah</span><br><span class="line">	XOR dl, dl</span><br><span class="line">	INT 13h ; 0x13 + ah=0x00 -&gt; reset disk head</span><br><span class="line"></span><br><span class="line">	; let&#x27;s stuck at this place first as our</span><br><span class="line">	; loader code is not finished,.. </span><br><span class="line">	JMP $</span><br><span class="line"></span><br><span class="line">	; store data to other sector</span><br><span class="line">ud_msg: DB &quot;hello world&quot;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	; mask the whole sector</span><br><span class="line">	TIMES 510 - ($ - $$) DB 0</span><br><span class="line">	DW 0xAA55 ; low byte &#x27;0x55&#x27; will be write to sector first</span><br><span class="line">			  ; then high byte &#x27;0xAA&#x27;.</span><br></pre></td></tr></table></figure></p>
<p>一开始还想了半天，这个<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp $</span><br></pre></td></tr></table></figure>
到底有什么作用，因为这种代码实际意义就是不断地跳转回这条指令的地址，那么就是一个死循环。后来才发觉，作者应该是想着，后面的loader代码还没有讲解展示，因此我们这里的boot代码运行到此处即可，直接死循环等于暂停功能......</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>The Design And Implementation Of A 64-bit OS</tag>
        <tag>ch3</tag>
        <tag>3-1</tag>
      </tags>
  </entry>
  <entry>
    <title>如何从颜色映射中获取单个RGB值</title>
    <url>/blog/2023/10/11/data/languages/Python/matplotlib/%E5%A6%82%E4%BD%95%E4%BB%8E%E9%A2%9C%E8%89%B2%E6%98%A0%E5%B0%84%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AARGB%E5%80%BC/</url>
    <content><![CDATA[<p>有时候我们希望使用的映射能给我们提供用于着色的RGB值以便于我们做其他操作，这种反向数据映射是可行的。</p>
<p>You can do this with the code below, and the code in your question
was actually very close to what you needed, all you have to do is call
the cmap object you have.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib  </span><br><span class="line">cmap = matplotlib.cm.get_cmap(<span class="string">&#x27;Spectral&#x27;</span>)</span><br><span class="line">rgba = cmap(<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(rgba) <span class="comment"># (0.99807766255210428, 0.99923106502084169, 0.74602077638401709, 1.0)</span></span><br></pre></td></tr></table></figure>
<p>For values outside of the range <code>[0.0, 1.0]</code> it will
return the under and over colour (respectively). This, by default, is
the minimum and maximum colour within the range (so 0.0 and 1.0). This
default can be changed with cmap.set_under() and cmap.set_over().</p>
<p>For "special" numbers such as np.nan and np.inf the default is to use
the 0.0 value, this can be changed using cmap.set_bad() similarly to
under and over as above.</p>
<p>Finally it may be necessary for you to normalize your data such that
it conforms to the range <code>[0.0, 1.0]</code>. This can be done using
<a
href="http://matplotlib.org/api/colors_api.html#matplotlib.colors.Normalize">matplotlib.colors.Normalize</a>
simply as shown in the small example below where the arguments vmin and
vmax describe what numbers should be mapped to 0.0 and 1.0
respectively.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">norm = matplotlib.colors.Normalize(vmin=<span class="number">10.0</span>, vmax=<span class="number">20.0</span>)  </span><br><span class="line"><span class="built_in">print</span>(norm(<span class="number">15.0</span>)) <span class="comment"># 0.5</span></span><br></pre></td></tr></table></figure>
<p>A logarithmic normaliser (<a
href="http://matplotlib.org/api/colors_api.html#matplotlib.colors.LogNorm">matplotlib.colors.LogNorm</a>)
is also available for data ranges with a large range of values.</p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>languages</tag>
        <tag>Python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>引导签名0x55 0xAA是什么时候被写入扇区末尾的？</title>
    <url>/blog/2023/10/11/data/CSAPP/os/The%20Design%20And%20Implementation%20Of%20A%2064-bit%20OS/ch3/3-1/%E5%BC%95%E5%AF%BC%E7%AD%BE%E5%90%8D0x55%200xAA%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E5%86%99%E5%85%A5%E6%89%87%E5%8C%BA%E6%9C%AB%E5%B0%BE%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<p>因为BIOS要求上电完成硬件存储设备检查之后，读取引导扇区，而辨别第一扇区是否是引导扇区的标志是扇区最后两个字节是否是
0x55 和
0xAA，如果不是，则根据规范可能不会将扇区数据加载到主内存0x7C00位置处并转移CPU执行权。</p>
<p>书中给的示例代码有dw伪指令，最开始以为这种指令也会被编译为可执行的机器指令，但实际上，这些伪指令只是共汇编器分配常量数据空间的提示，最终不会生成可被执行的机器码。</p>
<p>所以，一个产生最小可被识别的引导扇区的汇编代码如下：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 引导代码</span><br><span class="line"></span><br><span class="line">[org 0x7C00]  ; 设置代码加载地址</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    ; 引导代码的入口点</span><br><span class="line"></span><br><span class="line">    ; 此处是引导代码的实际逻辑</span><br><span class="line"></span><br><span class="line">    ; 结尾处写入0xAA55标识符</span><br><span class="line">    times 510-($-$$) db 0  ; 填充剩余空间为0</span><br><span class="line">    dw 0xAA55             ; 写入0xAA55标识符</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>os</tag>
        <tag>The Design And Implementation Of A 64-bit OS</tag>
        <tag>ch3</tag>
        <tag>3-1</tag>
      </tags>
  </entry>
</search>
